<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Thu, 22 Dec 2022 10:24:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>커맨드와 액티브 오브젝트 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/21/java/design-pattern/commandAndActiveObjectPattern/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/21/java/design-pattern/commandAndActiveObjectPattern/</guid>
      <pubDate>Wed, 21 Dec 2022 05:02:25 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;커맨드-패턴&quot;&gt;&lt;a href=&quot;#커맨드-패턴&quot; class=&quot;headerlink&quot; title=&quot;커맨드 패턴&quot;&gt;&lt;/a&gt;커맨드 패턴&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="커맨드-패턴"><a href="#커맨드-패턴" class="headerlink" title="커맨드 패턴"></a>커맨드 패턴</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/commandPatternUML.png"><br>여러 행동을 호출해야 하는 경우 여러 행동을 커맨드로 추상화하여 사용하는 쪽에서는 커맨드가 어떻게 행동하는 지 관심없이 사용하기만 하도록 구현하는 패턴이다.<br>이 패턴은 커맨드를 사용하는 쪽에서 커맨드를 실행하기 위해서 어떤 객체가 사용되는지 알아지 않아도 되는 장점이 있다. 커맨드 패턴은 명령의 개념을 캡슐화해서 시스템과 연결된 장치의 논리적인 상호 연결을 분리해낼 수 있다.</p><h2 id="물리적-분리"><a href="#물리적-분리" class="headerlink" title="물리적 분리"></a>물리적 분리</h2><p><img src="/img/commandPatternUML2.png"><br>커맨드 패턴을 사용하면 사용자에게서 데이터를 받는 코드와 그 데이터를 검증하고 작업을 하는 코드, 도메인 객체를 분리할 수 있다. 데이터를 받는 코드에서 커맨드의 실행 코드와 검증 코드와 물리적으로 분리 된다.</p><h2 id="시간적-분리"><a href="#시간적-분리" class="headerlink" title="시간적 분리"></a>시간적 분리</h2><p>사용자에게서 데이터를 입력받는 역할과 그 데이터를 검증하고 작업을 하는 코드를 물리적으로 분리할 수 있다고 했다. 이를 다르게 생각해보면 데이터를 입력받았다고 바로 검증과 실행을 하지 않아도 된다는 의미다. 즉 명령을 일단 다 생성해서 모아놓고 특정 시점에 몰아서 명령을 검증하고 실행할 수 있다는 의미이다.</p><h2 id="되돌리기"><a href="#되돌리기" class="headerlink" title="되돌리기"></a>되돌리기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>커맨드에 실행하는 메서드말고 되돌리기 메서드를 선언해놓으면 롤백 기능도 구현할 수 있다. 위처럼 인터페이스로 실행과 실행 취소 메서드를 선언해놓고 각 명령마다 실행과 실행 취소 로직을 구현해놓으면 된다.<br>직원 임금 관리 서비스에서 직원을 추가하는 명령이 있다고 할 때 실행시키는 메서드는 직원 객체를 생성하고 저장소에 저장하는 방식으로 구현된다. 실행 취소 메서드는 저장소에 해당 직원의 데이터를 제거하는 방식으로 구현할 수 있을 것이다.</p><h1 id="액티브-오브젝트-패턴"><a href="#액티브-오브젝트-패턴" class="headerlink" title="액티브 오브젝트 패턴"></a>액티브 오브젝트 패턴</h1><p>액티브 오브젝트 패턴은 커맨드 패턴의 응용된 버전으로 다중 제어 스레드 구현을 위해 등장했다.<br>액티브 오브젝트 패턴은 하나의 스레드로 멀티 스레드가 이벤트 방식으로 작동하는 것처럼 구현할 수 있어서 런타임 스택을 여러개 만들지 않아도 된다. 즉 멀티 스레드를 활용하고 메모리가 부족한 상황에서 사용할 만한 대안이다.</p><p>액티브 오브젝트 패턴은 커맨드를 모아두고 꺼내서 실행하는 엔진과 실행 시킬 커맨드, 마지막으로 실행 시킬 조건을 다루는 커맨드 이렇게 세가지로 구성된다.</p><h2 id="엔진"><a href="#엔진" class="headerlink" title="엔진"></a>엔진</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveObjectEngine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Command&gt; commands = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Command c)</span> </span>&#123;</span><br><span class="line">        commands.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!commands.isEmpty()) &#123;</span><br><span class="line">            commands.pop()</span><br><span class="line">                    .execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔진을 실행시키면 자신이 가진 모든 커맨드를 순차적으로 실행한다.</p><h2 id="실행-조건을-다루는-커맨드"><a href="#실행-조건을-다루는-커맨드" class="headerlink" title="실행 조건을 다루는 커맨드"></a>실행 조건을 다루는 커맨드</h2><p><code>특정 시간만큼 sleep하고 커맨드를 실행</code> 이라는 조건을 달성하기 위해 커맨드를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sleepMilliSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActiveObjectEngine engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Command wakeUpCommand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startedTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepCommand</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> sleepMilliSeconds, <span class="keyword">final</span> ActiveObjectEngine engine, <span class="keyword">final</span> Command wakeUpCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sleepMilliSeconds = sleepMilliSeconds;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.wakeUpCommand = wakeUpCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            startedTime = currentTime;</span><br><span class="line">            engine.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTime - startedTime &lt; sleepMilliSeconds) &#123;</span><br><span class="line">            engine.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        engine.add(wakeUpCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자신이 엔진에 의해 실행된 경우가 없다면 현재 시간을 시작 시각으로 기록하고 다시 엔진에 자신을 집어넣는다.<br>자신이 엔진에 의해 실행된 경우가 있으면 현재 시각과 시작 시각을 비교해서 커맨드 실행 조건에 달성했는 지 체크한다.<br>조건에 달성했다면 <code>wakeUpCommand</code> 즉 우리가 원래 실행하려고 했던 커맨드를 실핸한다.</p><h2 id="실행하려는-커맨드"><a href="#실행하려는-커맨드" class="headerlink" title="실행하려는 커맨드"></a>실행하려는 커맨드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTyper</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActiveObjectEngine engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> itsDelay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> itsChar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTyper</span><span class="params">(<span class="keyword">final</span> ActiveObjectEngine engine, <span class="keyword">final</span> <span class="keyword">long</span> itsDelay, <span class="keyword">final</span> <span class="keyword">char</span> itsChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.itsDelay = itsDelay;</span><br><span class="line">        <span class="keyword">this</span>.itsChar = itsChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.print(itsChar);</span><br><span class="line">        delayAndRepeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayAndRepeat</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        engine.add(<span class="keyword">new</span> SleepCommand(itsDelay, engine, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주어진 글자를 출력하고 특정 시간만큼 sleep 이후 다시 출력하는 커맨드이다.</p><p>마지막으로 이를 실행하는 코드를 통해 실제 결과물을 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ActiveObjectEngine ENGINE = <span class="keyword">new</span> ActiveObjectEngine();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">100</span>, <span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">500</span>, <span class="string">&#x27;5&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">700</span>, <span class="string">&#x27;7&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> SleepCommand(<span class="number">20000</span>, ENGINE, () -&gt; System.exit(<span class="number">0</span>)));</span><br><span class="line">        ENGINE.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/design-pattern/">Design Pattern</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/21/java/design-pattern/commandAndActiveObjectPattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Elastic Beanstalk와 Github Actions를 활용해서 CICD 무중단 배포 구현하기</title>
      <link>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/</guid>
      <pubDate>Wed, 14 Dec 2022 03:45:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Elastic-Beanstalk란&quot;&gt;&lt;a href=&quot;#Elastic-Beanstalk란&quot; class=&quot;headerlink&quot; title=&quot;Elastic Beanstalk란&quot;&gt;&lt;/a&gt;Elastic Beanstalk란&lt;/h1&gt;&lt;p&gt;AWS에서는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Elastic-Beanstalk란"><a href="#Elastic-Beanstalk란" class="headerlink" title="Elastic Beanstalk란"></a>Elastic Beanstalk란</h1><p>AWS에서는 인프라에 대한 지식이 없어도 배포 환경을 구축할 수 있는 Elastic Beanstalk(EB)를 제공한다. EB에 어플리케이션을 전달하면 EB에서 용량 프로비저닝, 로드 밸런싱, 조정, 어플리케이션 상태 모니터링을 자동으로 처리한다.</p><p>다음은 EB가 어떻게 어플리케이션을 관리하는 지 보여주는 워크플로우다.<br><img src="/img/EBflow.png" alt="EB workflow"></p><h2 id="Elastic-Beanstalk-구조"><a href="#Elastic-Beanstalk-구조" class="headerlink" title="Elastic Beanstalk 구조"></a>Elastic Beanstalk 구조</h2><p>EB는 여러 종류의 환경을 제공할 수 있다. 웹 서버 환경을 중점적으로 살펴보자.<br><img src="/img/ebWebServerEnv.png" alt="EB web server Env"><br>Auto Scaling Group에 여러 EC2 인스턴스들이 존재한다. 이 인스턴스에서 어플리케이션이 실행되는데 여기서 <code>HM</code>(호스트 매니저) 이라는 개념이 있다. <code>HM</code>는 어플리케이션의 로그를 S3에 개시하거나 서버 인스턴스의 상태를 보고하는 역할을 한다.</p><p>Auto Scaling Group의 EC2들 앞에는 Elastic Load Balancer가 로드 밸런싱을 한다. EB의 ELB는 CNAME(URL)을 가진다. 그리고 EB 환경도 CNAME을 가진다. 이때 환경의 CNAME은 ELB의 CNAME의 별칭으로 지정된다.</p><h1 id="Elastic-Beanstalk-직접-구성해보기"><a href="#Elastic-Beanstalk-직접-구성해보기" class="headerlink" title="Elastic Beanstalk 직접 구성해보기"></a>Elastic Beanstalk 직접 구성해보기</h1><p>EB를 생성할 때 중요한 몇가지 위주로 설명하겠다.</p><h2 id="플랫폼-설정하기-및-추가-옵션-구성"><a href="#플랫폼-설정하기-및-추가-옵션-구성" class="headerlink" title="플랫폼 설정하기 및 추가 옵션 구성"></a>플랫폼 설정하기 및 추가 옵션 구성</h2><p>AWS EB 콘솔에서 새 어플리케이션 만들기를 선택하면 어플리케이션이 어떤 플랫폼인지 그리고 그 플랫폼을 어떤 운영체제에서 실행할지를 정해야 한다.<br>필자의 경우는 Spring Boot 어플리케이션이므로 Java 플랫폼에 Linux 2를 설정했다. 즉 EB 환경의 EC2가 Linux 2 기반으로 생성된다는 의미이다.</p><p>그리고 이때 중요한 건 바로 애플리케이션 생성을 누르지 말고 무중단 배포를 위해 <strong>추가 옵션 구성</strong>을 선택한다.<br><img src="/img/EBPlatformSetting.png" alt="플랫폼 설정화면"></p><p>추가 옵션 구성을 클릭하면 여러가지 설정 가능한 옵션이 나온다. 이때 사전 설정에서 <code>사용자 지정 구성</code>으로 우리 상황에 맞도록 구성할 수 있도록 해보자.<br><img src="/img/EBPreSetting.png" alt="추가 옵션 구성 - 사전 설정"></p><h2 id="인스턴스-보안그룹-설정하기"><a href="#인스턴스-보안그룹-설정하기" class="headerlink" title="인스턴스 보안그룹 설정하기"></a>인스턴스 보안그룹 설정하기</h2><p>Auto Scaling Group의 인스턴스들이 적용되는 보안그룹을 반드시 설정해줘야 한다. 그렇지 않으면 외부에서 인스턴스에 SSH로 접근해서 의도하지 않은 작업을 진행할 수 있다.<br><img src="/img/EBInstanceSG.png" alt="인스턴스 - EC2 인스턴스 보안 그룹"><br>F12-PROD 보안그룹은 80 포트와 8080 포트를 모든 IP가 접근할 수 있도록 했고, SSH는 개발자 IP만 접근 가능하도록 인바운드 규칙을 적용했다.<br>ec2-rds-1 보안그룹은 mysql 포트인 3306 포트를 아웃바운드 규칙으로 적용되어 있다.</p><h2 id="Auto-Scaling-Group-및-로드-밸런싱-설정하기"><a href="#Auto-Scaling-Group-및-로드-밸런싱-설정하기" class="headerlink" title="Auto Scaling Group 및 로드 밸런싱 설정하기"></a>Auto Scaling Group 및 로드 밸런싱 설정하기</h2><p>먼저 Auto Scaling Group에 어떤 인스턴스를 몇 개나 수용할 지를 정해야 한다. 우리는 프리티어 한도 내에서 인프라를 구축해야 하기 때문에 인스턴스를 한 개만 사용하도록 했다.<br><img src="/img/EBAutoScalingGroupSetting.png" alt="용량 - Auto Scaling 그룹"></p><p>다음으로 로드 밸런서를 설정해야 한다. 로드 밸런서는 크게 Classic Load Balancer(ELB)와 Application Load Balancer(ALB)를 선택할 수 있다. ELB가 먼저 출시되어 많은 참고 자료가 존재하지만 갑작스러운 트래픽이 발생할 경우에 대응이 좋지 않다고 한다. 그래서 우리는 ALB를 선택했다.</p><p>그리고 추가로 프론트엔드에서 8080포트로 요청하는 상황이라 로드 밸런서의 리스너를 8080포트도 열어줬다.<br><img src="/img/EBALBSetting.png" alt="로드 밸런서"></p><h2 id="무중단-배포-설정"><a href="#무중단-배포-설정" class="headerlink" title="무중단 배포 설정"></a>무중단 배포 설정</h2><p>이제 EB에서 새 버전을 배포하려고 할 때 무중단 배포가 되도록 설정해야 한다. 롤링 업데이트와 배포 수정에 가서 애플리케이션 배포 방식을 정할 수 있다. 우리는 추가 배치를 사용한 롤링 방식을 선택했다. 만약 새 버전이 배포되면 새 EC2 하나를 만들어서 새 버전을 배포하고 배포가 완료되면 로드 밸런서 설정을 바꾸고 기존의 Auto Scaling은 폐기하는 방식으로 운영된다. 다만 이 방식은 배포가 되고나면 롤백하지 못한다.<br><img src="/img/EBDeploySetting.png" alt="롤링 업데이트와 배포 수정"></p><h2 id="EC2-키-페어-설정"><a href="#EC2-키-페어-설정" class="headerlink" title="EC2 키 페어 설정"></a>EC2 키 페어 설정</h2><p>EB에서 생성된 EC2 인스턴스에 접근할  수 있는 PEM 키를 설정해 줄 수 있다. 우리는 기존에 만들어놨던 PEM 키를 활용했다.<br><img src="/img/EBSecuritySetting.png" alt="보안 수정"></p><p>이제 EB 설정은 어느정도 끝났으니 EB를 생성하면 된다.</p><h1 id="EB-어플리케이션-구성"><a href="#EB-어플리케이션-구성" class="headerlink" title="EB 어플리케이션 구성"></a>EB 어플리케이션 구성</h1><p>EB 어플리케이션을 실행할 때 인스턴스에서 설정해줘야 하는 것들이 있을 수 있다. 예를 들어 EC2의 타임존 설정이나 리버스 프록시 설정이 필요할 수 있다. 그 설정을 EB에서는 <code>.ebextensions</code> 디렉토리, <code>.platform</code> 디렉토리로 설정해줄 수 있다.</p><h2 id="EC2-리버스-프록시-설정하기"><a href="#EC2-리버스-프록시-설정하기" class="headerlink" title="EC2 리버스 프록시 설정하기"></a>EC2 리버스 프록시 설정하기</h2><p>로드 밸런서가 보내는 트래픽을 EC2에서 애플리케이션으로 전달 할 때 리버시 프록시를 설정해줄 수 있다. 우리가 사용하는 Linux 2 플랫폼은 Nginx로 리버스 프록시를 구현할 수 있다. 이때 <code>.platform/nginx/nginx.conf</code> 파일을 통해서 EC2의 Nginx의 설정을 오버라이딩 할 수 있다. <code>.platform/nginx/conf.d/&#123;설정파일이름&#125;.conf</code>에 파일을 만들면 기존의 Nginx 설정 파일에 설정을 추가하는 방식으로 구현할 수 있다.</p><p>우리는 <code>.platform/nginx/nginx.conf</code> 파일을 프로젝트에 추가해서 Nginx 설정을 오버라이딩 하는 방식으로 구현했다. <code>/</code>로 오는 모든 요청은 로컬의 8080포트로 보내도록 구현했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user                    nginx;</span><br><span class="line">error_log               /var/log/nginx/error.log warn;</span><br><span class="line">pid                     /var/run/nginx.pid;</span><br><span class="line">worker_processes        auto;</span><br><span class="line">worker_rlimit_nofile    33282;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">  log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">  include       conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">  map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">      default     &quot;upgrade&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  upstream springboot &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    keepalive 1024;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">      listen        80 default_server;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          proxy_pass          http://springboot;</span><br><span class="line">          proxy_http_version  1.1;</span><br><span class="line">          proxy_set_header    Connection          $connection_upgrade;</span><br><span class="line">          proxy_set_header    Upgrade             $http_upgrade;</span><br><span class="line"></span><br><span class="line">          proxy_set_header    Host                $host;</span><br><span class="line">          proxy_set_header    X-Real-IP           $remote_addr;</span><br><span class="line">          proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      access_log    /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">      client_header_timeout 60;</span><br><span class="line">      client_body_timeout   60;</span><br><span class="line">      keepalive_timeout     60;</span><br><span class="line">      gzip                  off;</span><br><span class="line">      gzip_comp_level       4;</span><br><span class="line"></span><br><span class="line">      # Include the Elastic Beanstalk generated locations</span><br><span class="line">      include conf.d/elasticbeanstalk/healthd.conf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EB-환경-커스텀하기"><a href="#EB-환경-커스텀하기" class="headerlink" title="EB 환경 커스텀하기"></a>EB 환경 커스텀하기</h2><p>EB에서 가동 중인 EC2에 파일을 추가한다던지 커맨드를 실행하고 싶은 경우 <code>.ebextensions</code> 디렉토리에 config 확장자로 파일을 추가하면 된다.</p><p>우리는 JAR 배포 스크립트와 로깅 설정파일을 생성하고 EC2 타임존 설정 커맨드를 실행하도록 구현해보자<br><code>.ebextension/00-makeFiles.config</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">files:</span></span><br><span class="line">    <span class="string">&quot;/sbin/appstart&quot;</span> <span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            #!/usr/bin/env bash</span></span><br><span class="line"><span class="string">            JAR_PATH=/var/app/current/application.jar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="comment"># run app</span></span><br><span class="line">            <span class="string">killall</span> <span class="string">java</span></span><br><span class="line">            <span class="string">java</span> <span class="string">-Dfile.encoding=UTF-8</span> <span class="string">-Dspring.profiles.active=main</span> <span class="string">-jar</span> <span class="string">$JAR_PATH</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/taillogs.d/applogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          /var/app/current/logs/log/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/applogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        /var/app/current/logs/log/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/taillogs.d/dblogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          /var/app/current/logs/db/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/dblogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">/var/app/current/logs/db/*.log</span></span><br></pre></td></tr></table></figure><p><code>.ebextension/01-setupKSTTimezone.config</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">commands:</span></span><br><span class="line">  <span class="attr">set_time_zone:</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">ln</span> <span class="string">-f</span> <span class="string">-s</span> <span class="string">/usr/share/zoneinfo/Asia/Seoul</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure><h2 id="Procfile을-사용해서-애플리케이션-프로세스-구성"><a href="#Procfile을-사용해서-애플리케이션-프로세스-구성" class="headerlink" title="Procfile을 사용해서 애플리케이션 프로세스 구성"></a>Procfile을 사용해서 애플리케이션 프로세스 구성</h2><p>애플리케이션이 실행하기 위한 커맨드를 모은 파일이다. Procfile의 프로세스는 계속 실행 될 것으로 기대하고 EB에서 해당 프로세스를 모니터링하고 종료된 프로세스는 재시작한다.</p><p><code>Procfile</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span> <span class="string">appstart</span></span><br></pre></td></tr></table></figure><h1 id="Github-Actions로-CICD-구축하기"><a href="#Github-Actions로-CICD-구축하기" class="headerlink" title="Github Actions로 CICD 구축하기"></a>Github Actions로 CICD 구축하기</h1><h2 id="CI-스크립트-작성"><a href="#CI-스크립트-작성" class="headerlink" title="CI 스크립트 작성"></a>CI 스크립트 작성</h2><p>사실 CI 스크립트는 매우 간단하다. Github Actions에 대한 지식이 있으면 구현할 수 있다.</p><p><code>.github/workflows/backend.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;backend/**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">run:</span></span><br><span class="line">    <span class="attr">working-directory:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gradle</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">comments</span> <span class="string">to</span> <span class="string">a</span> <span class="string">pull</span> <span class="string">request</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">mikepenz/action-junit-report@v3</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">always()</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">report_paths:</span> <span class="string">backend/build/test-results/test/TEST-*.xml</span></span><br></pre></td></tr></table></figure><h2 id="IAM-인증키-발급받아-Github-Actions에서-사용하기"><a href="#IAM-인증키-발급받아-Github-Actions에서-사용하기" class="headerlink" title="IAM 인증키 발급받아 Github Actions에서 사용하기"></a>IAM 인증키 발급받아 Github Actions에서 사용하기</h2><p>외부에서 AWS 리소스에 접근하려면 IAM을 통해 액세스 키가 필요하다. AWS IAM에 가서 사용자를 추가해주자.<br><img src="/img/IAMAddUser.png" alt="IAM 사용자 추가"></p><p>해당 IAM 사용자에게 EB에 접근할 수 있는 권한을 설정해주면 된다.<br><img src="/img/IAMAuthority.png" alt="IAM 권한 추가"></p><p>이렇게 IAM 사용자를 만들면 액세스 키와 시크릿키가 생성된다. 이 두 키를 깃허브 레포지토리에 액션 시크릿으로 추가해준다. 필자는 액세스 키는 <code>AWS_ACCESS_KEY_ID</code>, 시크릿 키는 <code>AWS_SECRET_ACCESS_KEY</code>로 설정했다.<br><img src="/img/githubActionSecret.png" alt="github Action secrets"></p><h2 id="CD-스크립트-작성"><a href="#CD-스크립트-작성" class="headerlink" title="CD 스크립트 작성"></a>CD 스크립트 작성</h2><p>우리는 beanstalk-deploy라는 Github Actions 플러그인을 사용해서 배포 스크립트를 작성해본다.<br>스크립트에 주석으로 각 단계가 어떤 의미 인지 기록해두었다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span> <span class="string">eb</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">run:</span></span><br><span class="line">    <span class="attr">working-directory:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">        <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="string">&#x27;true&#x27;</span> <span class="comment"># 서브 모듈이 존재하는 경우 반드시 넣어준다.</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Gradle</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">gradle/gradle-build-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">cache-read-only:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="type">!=</span> <span class="string">&#x27;refs/heads/main&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Execute</span> <span class="string">Gradle</span> <span class="string">build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">bootJar</span></span><br><span class="line">          </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">current</span> <span class="string">time</span> <span class="comment"># 현재 시각을 기록해둔다.</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="number">1466587594</span><span class="string">/get-current-time@v2.0.2</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">current-time</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">YYYY-MM-DDTHH-mm-ss</span></span><br><span class="line">        <span class="attr">utcOffset:</span> <span class="string">&quot;+09:00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">deployment</span> <span class="string">package</span> <span class="comment"># JAR 파일과 함께 이전에 만들었던 설정파일을 함께 zip파일로 압축한다.</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p deploy</span></span><br><span class="line"><span class="string">        cp build/libs/f12-0.0.1-SNAPSHOT.jar deploy/application.jar</span></span><br><span class="line"><span class="string">        cp Procfile deploy/Procfile</span></span><br><span class="line"><span class="string">        cp -r .ebextensions deploy/.ebextensions</span></span><br><span class="line"><span class="string">        cp -r .platform deploy/.platform</span></span><br><span class="line"><span class="string">        cd deploy &amp;&amp; zip -r deploy.zip .</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">EB</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">einaregilsson/beanstalk-deploy@v21</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">aws_access_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.AWS_ACCESS_KEY_ID</span> <span class="string">&#125;&#125;</span> <span class="comment"># IAM</span></span><br><span class="line">        <span class="attr">aws_secret_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.AWS_SECRET_ACCESS_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># IAM</span></span><br><span class="line">        <span class="attr">application_name:</span> <span class="string">f12-prod-backend</span></span><br><span class="line">        <span class="attr">environment_name:</span> <span class="string">F12prodbackend-env-2</span></span><br><span class="line">        <span class="attr">version_label:</span> <span class="string">github-action-$&#123;&#123;steps.current-time.outputs.formattedTime&#125;&#125;</span> <span class="comment"># 버전명을 아까 기록한 시간을 토대로 구분하게 했다.</span></span><br><span class="line">        <span class="attr">region:</span> <span class="string">ap-northeast-2</span></span><br><span class="line">        <span class="attr">deployment_package:</span> <span class="string">backend/deploy/deploy.zip</span></span><br><span class="line">        <span class="attr">wait_for_environment_recovery:</span> <span class="number">180</span> <span class="comment"># 배포가 Green으로 돌아오는 시간을 고려해 환경 회복 시간을 180초로 하였다.</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">comments</span> <span class="string">to</span> <span class="string">a</span> <span class="string">pull</span> <span class="string">request</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">mikepenz/action-junit-report@v3</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">always()</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">          <span class="attr">report_paths:</span> <span class="string">backend/build/test-results/test/TEST-*.xml</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html</a><br><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts-webserver.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts-webserver.html</a><br><a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/platforms-linux-extend.html">https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/platforms-linux-extend.html</a><br><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.html</a><br><a href="https://techblog.woowahan.com/2539/">https://techblog.woowahan.com/2539/</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS의 Blue-Green 배포 구현 방법 알아보기</title>
      <link>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/</guid>
      <pubDate>Tue, 13 Dec 2022 09:55:21 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제-배경&quot;&gt;&lt;a href=&quot;#문제-배경&quot; class=&quot;headerlink&quot; title=&quot;문제 배경&quot;&gt;&lt;/a&gt;문제 배경&lt;/h1&gt;&lt;p&gt;우아한테크코스에서 프로젝트를 진행할 때는 우아한테크코스에 AWS 계정을 제공해줘서 EC2를 비용 걱정없이</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제-배경"><a href="#문제-배경" class="headerlink" title="문제 배경"></a>문제 배경</h1><p>우아한테크코스에서 프로젝트를 진행할 때는 우아한테크코스에 AWS 계정을 제공해줘서 EC2를 비용 걱정없이 갯수 상관없이 사용할 수 있었다. 하지만 우아한테크코스를 수료하고 나서는 AWS 계정 제공이 되지 않아서 팀원들이 자체 AWS 계정을 만들어서 인프라를 구축해야 했다.</p><p>이때 AWS에서는 프리티어로 RDS 인스턴스 한 개와 EC2 인스턴스 한 개를 제공해주는 점을 활용해서 최대한 비용을 줄일 수 있다.<br>하지만 기존 프로젝트는 CD와 무중단 배포를 위해 젠킨스를 EC2로 띄워서 구현했다. 그리고 Nginx를 따로 EC2로 띄워서 리버스 프록시 및 로드밸런싱 기능을 할 수 있도록 구축했다. 그래서 하나의 EC2로는 기존의 인프라 구조를 구현하기 어렵다.</p><h1 id="AWS-무중단-배포를-구현하는-여러-방법들"><a href="#AWS-무중단-배포를-구현하는-여러-방법들" class="headerlink" title="AWS 무중단 배포를 구현하는 여러 방법들"></a>AWS 무중단 배포를 구현하는 여러 방법들</h1><p>기존에는 젠킨스의 스크립트로 Nginx를 조절하는 방식으로 우리가 직접 Blue-Green 무중단 배포를 구현하는 방식이었다.<br>하지만 EC2 사용 갯수가 제한된 상황이기 때문에 AWS에서 제공하는 Blue-Green 무중단 배포 방법들을 참고해서 문제를 해결해보자.</p><h2 id="Route-53으로-DNS-라우팅-업데이트"><a href="#Route-53으로-DNS-라우팅-업데이트" class="headerlink" title="Route 53으로 DNS 라우팅 업데이트"></a>Route 53으로 DNS 라우팅 업데이트</h2><p>AWS의 DNS 서비스인 Route 53을 활용해서 무중단 배포를 구현할 수 있다.</p><p><img src="/img/EBGADeploy-1.png" alt="클래식DNS패턴"></p><p>다음과 같은 가중분포의 경우는 점진적으로 Green 환경으로 트래픽을 분산시킬 수 있다. 트래픽의 일부를 새로운 환경에서 처리해보도록 하는 카나리아 배포를 구현할 수 있다. ELB를 사용하면 Green 환경이 점차적으로 전체 프로덕션 부하를 감당하도록 점진적으로 스케일 아웃 할 수 있다. 다만 ELB에서 스케일 아웃은 즉시 이뤄지지 않으니 스케일 아웃이 잘 작동하는 지 모니터링하고 문제를 감지할 수 있도록 구현하는 게 중요하다.</p><p><img src="/img/EBGADeploy-2.png" alt="클래식DNS패턴"></p><p>Green 환경에서 문제가 발견되면 Route 53의 DNS 레코드를 롤백하는 방식으로 Blue 환경으로 롤백시킨다. 하지만 DNS 라우팅은 DNS TTL(클라이언트가 DNS 쿼리를 어느 시간만큼 캐시)를 고려해야 하고,  심지어는 클라이언트에 따라서는 특정 세션이 이전 환경에 연결되어 있는 경우가 존재할 수 있다.</p><h2 id="Elastic-Load-Balancer-뒤에서-Auto-Scaling-그룹-교체"><a href="#Elastic-Load-Balancer-뒤에서-Auto-Scaling-그룹-교체" class="headerlink" title="Elastic Load Balancer 뒤에서 Auto Scaling 그룹 교체"></a>Elastic Load Balancer 뒤에서 Auto Scaling 그룹 교체</h2><p>DNS 라우팅 업데이트를 활용한 방법이 복잡하다면 ELB와 Auto Scaling 그룹을 활용해서 Blue-Green 배포를 구현할 수 있다.</p><p><img src="/img/EBGADeploy-3.png" alt="Auto Scaling 그룹 바꾸기"></p><p>다음과 같이 Blue 환경을 대기 상태로 만들어 놓고 유사 시에 빠르게 이전 버전으로 롤백할 수 있게 구현할 수도 있다. 만약 그럴 필요가 없는 경우는 이전 Auto Scaling 그룹을 폐기하면 된다.</p><p><img src="/img/EBDGDeploy-4.png" alt="Auto Scaling 그룹 대기 및 폐기"></p><p>이 방식은 DNS 방식만큼 세분하게 구현할 수는 없지만 DNS가 복잡하다면 도입해볼만 하다.</p><h2 id="Elastic-Beanstalk-애플리케이션-환경-교체"><a href="#Elastic-Beanstalk-애플리케이션-환경-교체" class="headerlink" title="Elastic Beanstalk 애플리케이션 환경 교체"></a>Elastic Beanstalk 애플리케이션 환경 교체</h2><p>EB를 활용하면 인프라에 대한 지식이 많지 않아도 쉽게 애플리케이션을 배포할 수 있다. 배포하려는 어플리케이션 번들과 어플리케이션 버전, 멏 가지 정보를 제공하면 EB가 해당 정보를 기반으로 어플리케이션을 배포하고 어플리케이션에 액세스할 수 있는 URL을 제공한다.</p><p><img src="/img/EBGADeploy-5.png" alt="EB 배포 환경"></p><p>EB는 Auto Scaling 그룹을 추가하는 방식이나 일부 인스턴스를 업데이트하는 방식으로 하나의 환경 안에서 롤링 방식으로 무중단 배포를 구현할 수 있다.</p><p><img src="/img/prepare-green-elastic.png" alt="EB Blue-Green 배포"><br>EB를 활용해서 Blue-Green 배포를 할 수도 있다. 배포되고 있던 환경과 동일한 환경을 만들고 해당 환경을 새 버전 어플리케이션으로 교체한 다음 새로운 환경의 URL을 DNS에서 업데이트 하는 방식으로 설계할 수 있다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://docs.aws.amazon.com/whitepapers/latest/blue-green-deployments/implementation-techniques.html">https://docs.aws.amazon.com/whitepapers/latest/blue-green-deployments/implementation-techniques.html</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/infra/">Infra</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java11의 HttpClient로 서버에서 다른 API로 요청 보내기</title>
      <link>https://yangdongjue5510.github.io/2022/10/26/howToUseHttpClient/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/26/howToUseHttpClient/</guid>
      <pubDate>Wed, 26 Oct 2022 14:47:05 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;도입-배경&quot;&gt;&lt;a href=&quot;#도입-배경&quot; class=&quot;headerlink&quot; title=&quot;도입 배경&quot;&gt;&lt;/a&gt;도입 배경&lt;/h2&gt;&lt;p&gt;Github Oauth를 통해 인증인가를 구현하던 과정에서 깃허브에서 발급된 코드를 통해 Github A</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h2><p>Github Oauth를 통해 인증인가를 구현하던 과정에서 깃허브에서 발급된 코드를 통해 Github API에 Github Access Token을 발급 요청을 보내야했다. 그리고 발급된 Github Access Token을 통해 해당 사용자의 정보를 요청해야 했다.</p><h2 id="선택-가능한-방법들"><a href="#선택-가능한-방법들" class="headerlink" title="선택 가능한 방법들"></a>선택 가능한 방법들</h2><p>서버에서 HTTP 요청을 보낼 수 있는 방법은 여러가지가 있다.</p><ol><li>HTTPClient</li><li>RestTemplate</li><li>WebClient</li></ol><p>간단하게 세가지 방법을 비교하자면 다음과 같다.</p><table><thead><tr><th></th><th>HttpClient</th><th>RestTemplate</th><th>WebClient</th></tr></thead><tbody><tr><td>논블락킹 방식 제공 여부</td><td>제공</td><td>X (블락킹 방식)</td><td>제공</td></tr><tr><td>비동기 방식 제공 여부</td><td>제공</td><td>X (동기 방식)</td><td>제공</td></tr><tr><td>필요한 의존성</td><td>없음(Java 11에 포함)</td><td>spring-boot-starter-web에 포함</td><td>webFlux에 포함</td></tr></tbody></table><p>스프링 부트를 활용해서 프로젝트를 하는 경우 RestTemplate를 사용하는 경우가 많다.</p><p>하지만 스프링 공식문서의 RestTemplate 설명을 보면 작은 버그 수정만 앞으로 진행되고 큰 개선은 진행되지 않을 것이니 WebClient를 사용할 것을 권장한다.<br>(<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html</a>)</p><p>하지만 WebClient를 사용하기 위해서는 webFlux를 의존성에 추가해줘야 한다.</p><p>webFlux는 리액티브 프로그래밍을 스프링에서 제공하기 위한 모듈이다.</p><p>현재 우리 프로젝트는 스프링 MVC 기반 블락킹 동기 기반 어플리케이션인데 WebClient를 사용하기 위해 리액티브 프로그래밍을 지원하는 모듈을 추가해주는 것은 지나치다고 생각했다.</p><p>반면 HttpClient는 Java 11에 포함되어 있기 때문에 자바 버전만 지원된다면 다른 의존성을 추가해주지 않아도 된다.</p><p>그래서 우리 프로젝트에는 HttpClient를 사용하기로 했다.</p><h2 id="HttpClient-간단한-사용법"><a href="#HttpClient-간단한-사용법" class="headerlink" title="HttpClient 간단한 사용법"></a>HttpClient 간단한 사용법</h2><h3 id="동기-방식으로-GET-POST-요청-보내는-예시"><a href="#동기-방식으로-GET-POST-요청-보내는-예시" class="headerlink" title="동기 방식으로 GET, POST 요청 보내는 예시"></a>동기 방식으로 GET, POST 요청 보내는 예시</h3><p>먼저 외부 API 역할을 하게 될 컨트롤러를 간단하게 구현해보자.</p><p>이를 위해서는 HttpCliet를 실행하는 프로젝트와 외부 API 역할을 할 스프링 부트 프로그램을 서로 다른 프로젝트로 분리해서 구현하기로 한다.</p><h4 id="초간단-컨트롤러"><a href="#초간단-컨트롤러" class="headerlink" title="초간단 컨트롤러"></a>초간단 컨트롤러</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sync&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">syncGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;동기 GET 요청 처리 성공!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sync&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">syncPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;동기 POST 요청 처리 성공!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 초간단 컨트롤러의 프로젝트를 로컬에서 구동시킨다.<br>이제 <a href="http://localhost:8080을">http://localhost:8080을</a> 기본으로 작동한다.</p><h4 id="HttpClient를-활용한-HttpClientExample-구현"><a href="#HttpClient를-활용한-HttpClientExample-구현" class="headerlink" title="HttpClient를 활용한 HttpClientExample 구현"></a>HttpClient를 활용한 HttpClientExample 구현</h4><p>이제 외부 API에 요청을 보내는 HttpClient를 구현해보자.<br>일단 동기 방식으로 요청을 처리하는 간단한 예시를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientSyncExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HttpClientSyncExample.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">            .version(Version.HTTP_2)</span><br><span class="line">            .followRedirects(Redirect.NORMAL)</span><br><span class="line">            .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse&lt;String&gt; <span class="title">requestSyncGetApi</span><span class="params">(<span class="keyword">final</span> String uri)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = HttpRequest.newBuilder(URI.create(uri))</span><br><span class="line">                .GET()</span><br><span class="line">                .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString());</span><br><span class="line">        validateSuccess(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">validateSuccess</span><span class="params">(<span class="keyword">final</span> HttpResponse&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HttpStatus status = HttpStatus.resolve(response.statusCode());</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span> || status.isError()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;URI: &#123;&#125;, STATUS: &#123;&#125;&quot;</span>, response.uri(), response.statusCode());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;요청 처리 실패&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;URI: &#123;&#125;, STATUS: &#123;&#125;, BODY : &#123;&#125;, &quot;</span>, response.uri(), response.statusCode(), response.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse&lt;String&gt; <span class="title">requestSyncPostApi</span><span class="params">(<span class="keyword">final</span> String uri, <span class="keyword">final</span> Object requestBody)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String requestBodyString = objectMapper.writeValueAsString(requestBody);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = HttpRequest.newBuilder(URI.create(uri))</span><br><span class="line">                .POST(BodyPublishers.ofString(requestBodyString))</span><br><span class="line">                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString());</span><br><span class="line">        validateSuccess(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpClient 객체를 만들어 놓고, 필요할 때마다 HttpRequest를 만들어서 HttpClient 객체에 send 메서드를 통해 요청을 보낸다.</p><p>그리고 POST 요청을 보낼 때는 Body 값을 Object Mapper로 객체를 문자열로 만들어서 보내줘야 한다.</p><h4 id="테스트-코드로-작동-확인하기"><a href="#테스트-코드로-작동-확인하기" class="headerlink" title="테스트 코드로 작동 확인하기"></a>테스트 코드로 작동 확인하기</h4><p>이제 테스트 메서드 몇 개를 만들어서 동작을 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpClientSyncExample httpClientSyncExample = <span class="keyword">new</span> HttpClientSyncExample();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;동기 방식으로 GET 요청을 보낸다.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">final</span> String uri = <span class="string">&quot;http://localhost:8080/test/sync&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncGetApi(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(response.statusCode()).isEqualTo(<span class="number">200</span>),</span><br><span class="line">                () -&gt; assertThat(response.body()).isEqualTo(<span class="string">&quot;동기 GET 요청 처리 성공!&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;동기 방식으로 POST 요청을 보낸다.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncPost</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">final</span> String uri = <span class="string">&quot;http://localhost:8080/test/sync&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String requestBody = <span class="string">&quot;bodyValue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncPostApi(uri, requestBody);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(response.statusCode()).isEqualTo(<span class="number">200</span>),</span><br><span class="line">                () -&gt; assertThat(response.body()).isEqualTo(<span class="string">&quot;동기 POST 요청 처리 성공!&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 실행해보면 다음과 같이 모두 잘 작동하는 것을 볼 수 있다.</p><p><img src="/img/howToUseHttpClient-1.png"></p><p>참고</p><p><a href="https://www.baeldung.com/java-9-http-client">https://www.baeldung.com/java-9-http-client</a><br><a href="https://golb.hplar.ch/2019/01/java-11-http-client.html">https://golb.hplar.ch/2019/01/java-11-http-client.html</a><br><a href="https://github.com/yangdongjue5510/http-client">https://github.com/yangdongjue5510/http-client</a></p><p>Java 11의 HttpClient 사용법을 배울 수 있는 레포지토리.<br>동기 방식 뿐만 아니라 비동기 방식도 학습 테스트를 통해 배울 수 있도록 구현해놨다.<br>github.com](<a href="https://github.com/yangdongjue5510/http-client">https://github.com/yangdongjue5510/http-client</a>)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/26/howToUseHttpClient/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RestDocs의 Custom Snippet으로 에러코드 쉽게 문서화하기</title>
      <link>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</guid>
      <pubDate>Tue, 25 Oct 2022 08:21:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h1&gt;&lt;p&gt;RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.&lt;br&gt;우리 프로젝트에서는 정상 요청 흐름을 중점으로 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.<br>우리 프로젝트에서는 정상 요청 흐름을 중점으로 API 문서화했다.<br>하지만 해당 API에서 발생 가능한 애외 상황에 대한 응답도 정리해줘야 했다.<br>그래서 우리는 백엔드 단에서 발생하는 예외에 매핑되는 예외 코드를 만들어서 예외 상황 발생 시 해당 예외 코드를 바디에 담아서 반환하도록 해서 대해 API 사용자들이 어떤 문제가 발생해는 지 알 수 있도록 했다.<br>문제는 특정 API에 해당하는 예외 코드들을 어떻게 문서화하는 지 였다.</p><h2 id="코드-예시"><a href="#코드-예시" class="headerlink" title="코드 예시"></a>코드 예시</h2><p>restDocs 환경 설정은 생략했다.</p><h3 id="예시-컨트롤러"><a href="#예시-컨트롤러" class="headerlink" title="예시 컨트롤러"></a>예시 컨트롤러</h3><p>만약 id값이 1보다 작으면 예외를 반환하는 아주 간단한 예시 컨트롤러이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/simple/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">getSimple</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;id값은 무조건 1보다 커야 합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String body = String.format(<span class="string">&quot;simple id is %d&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-에러코드"><a href="#예시-에러코드" class="headerlink" title="예시 에러코드"></a>예시 에러코드</h3><p>사용자에게 알려줄 예외 코드를 enum으로 관리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ILLEGAL_ARGUMENT(<span class="string">&quot;40000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    ErrorCode(<span class="keyword">final</span> String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="예시-테스트"><a href="#예시-테스트" class="headerlink" title="예시 테스트"></a>예시 테스트</h3><p>성공 사례를 확인하는 예시 테스트이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-adoc-파일"><a href="#예시-adoc-파일" class="headerlink" title="예시 adoc 파일"></a>예시 adoc 파일</h3><p>새로운 adoc 파일을 만들어서 다음과 같이 생성된 스니펫을 넣어주고 테스트를 실행시켜서 성공하면 스니펫이 적용된 html을 얻을 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="/img/restDocsErrorCode-1.png"></p><h2 id="에러-코드를-어떻게-문서화할까"><a href="#에러-코드를-어떻게-문서화할까" class="headerlink" title="에러 코드를 어떻게 문서화할까?"></a>에러 코드를 어떻게 문서화할까?</h2><p>초창기 프로젝트에서 각 API에 에러코드를 명시했던 방법은 매우 간단하다.<br>그냥 adoc파일에 에러코드를 같이 적어주는 것이다.(…)</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>40000 (예시)</span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 그대로 API 예시 요청과 응답에 해당하는 예시코드를 문서화 할 수는 있다. 문제는 API를 추가로 개발하거나 에러 상황이 바뀌게 되면 일일히 adoc 파일에 들어가서 해당 에러코드를 수정해줘야 한다. 그리고 예외 코드를 직접 적어줘야 하니 헷갈리는 여지가 많았다.</p><h2 id="RestDocs의-커스텀-스니펫을-활용해보기"><a href="#RestDocs의-커스텀-스니펫을-활용해보기" class="headerlink" title="RestDocs의 커스텀 스니펫을 활용해보기"></a>RestDocs의 커스텀 스니펫을 활용해보기</h2><p>커스텀 스니펫은 사용자가 특정한 데이터를 전달받아서 restDocs에 사용되는 스니펫의 형태를 직접 정해서 렌더링할 수 있게 하는 방법이다.</p><h3 id="스니펫-형식-만들기"><a href="#스니펫-형식-만들기" class="headerlink" title="스니펫 형식 만들기"></a>스니펫 형식 만들기</h3><p>우리가 문서화할 형식을 먼저 만들어보자. 문서에서 에러코드를 어떤 식으로 표현할지를 만들어주면 된다. 우리는 표 형식으로 에러코드를 만들고자 한다.</p><p>이때 mustache 문법을 활용해서 전달받은 error-codes를 순회하면서 표를 만들도록 작성했다.<br>그리고 이 내용을 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor</code> 이 경로에 저장해주면 된다. 우리는 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor/error-code-table.snippet</code> 으로 저장했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|===</span><br><span class="line">|분류|코드</span><br><span class="line">&#123;&#123;#error-codes&#125;&#125;</span><br><span class="line">|&#123;&#123;name&#125;&#125;</span><br><span class="line">|&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;&#123;/error-codes&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><h3 id="TemplateSnippet-정의하기"><a href="#TemplateSnippet-정의하기" class="headerlink" title="TemplateSnippet 정의하기"></a>TemplateSnippet 정의하기</h3><p>이제 커스텀 스니펫에 어떤 데이터를 넣어서 만들 것인지 정의해보자.</p><p>spring framework의 RestDocs에는 TemplatedSnippet이라는 추상 클래스를 지원한다.<br>RestDocs는 TemplatedSnippet을 기본으로 다양한 스니펫을 만들어서 문서화 한다.</p><p>위에서 예시로 봤던 요청 스니펫과 응답 스니펫도 TemplatedSnippet을 상속받은 HttpRequestSnippet이나 HttpResponseSnippet을 통해서 스니펫을 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatedSnippet</span> <span class="keyword">implements</span> <span class="title">Snippet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String snippetName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(snippetName, snippetName, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, String templateName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">        <span class="keyword">this</span>.snippetName = snippetName;</span><br><span class="line">         <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">this</span>.attributes.putAll(attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 우리가 원하는 스니펫을 정의해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCodeSnippet</span> <span class="keyword">extends</span> <span class="title">TemplatedSnippet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorCodeSnippet</span><span class="params">(ErrorCode... errorCodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;error-code-table&quot;</span>, Map.of(<span class="string">&quot;error-codes&quot;</span>, errorCodes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">createModel</span><span class="params">(<span class="keyword">final</span> Operation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation.getAttributes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스니펫을 생성할 때 에러 코드를 가변 인자로 전달해주면 그 가변인자를 생성자를 통해 전달해주고 TemplateSinppet의 생성자를 호출해서 스니펫을 생성한다. 이때 우리가 스니펫의 이름을 전달해주고 해당 스니펫 속성에 해당하는 Map에 담아 전달해준다.</p><h3 id="커스텀-스니펫-적용해보기"><a href="#커스텀-스니펫-적용해보기" class="headerlink" title="커스텀 스니펫 적용해보기"></a>커스텀 스니펫 적용해보기</h3><p>이제 adoc 파일에 직접 에러 코드를 적는 방식을 우리의 커스텀 스니펫으로 개선해보자!</p><p>먼저 기존의 테스트 코드에 우리의 커스텀 스니펫을 생성해서 문서화할 에러 코드를 생성자의 인자로 전달해준다!</p><p>이때 실제 코드가 아닌 자바 enum을 전달해주면 되고 테스트 코드 안에서 문서화 할 내용을 관리해 줄 수 있어서 더 간편한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>, <span class="keyword">new</span> ErrorCodeSnippet(ErrorCode.ILLEGAL_ARGUMENT)));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 adoc에도 우리가 만든 커스텀 스니펫을 쓰겠다고 적어줘야 한다!</p><p>스니펫에 error-code-table이 추가됐음을 확인할 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;error-code-table,http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 해놓고 테스트를 성공시키면 다음과 같이 문서화가 된다.<br><img src="/img/restDocsErrorCode-2.png"></p><h1 id="참고문서"><a href="#참고문서" class="headerlink" title="참고문서"></a><em>참고문서</em></h1><p><a href="https://techblog.woowahan.com/2597/">https://techblog.woowahan.com/2597/</a></p><p><a href="https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing">https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing</a></p><p><a href="https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29">https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/project/">Project</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인증 인가에 사용되는 토큰을 어디에서 관리할까? (이론 편)</title>
      <link>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/</guid>
      <pubDate>Wed, 19 Oct 2022 15:07:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번 포스트에서는 우아한테크코스 팀 프로젝트에서 리프레시 토큰을 적용하게 된 계기를 정리해본다.&lt;/p&gt;
&lt;h1 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h1&gt;&lt;p&gt;우아한기크코스 팀</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 우아한테크코스 팀 프로젝트에서 리프레시 토큰을 적용하게 된 계기를 정리해본다.</p><h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>우아한기크코스 팀 프로젝트 회의 중 현재 우리가 사용하고 있는 인증 인가 방식을 현업에서도 유효한가에 대해 의논한 적이 있다.<br>당시 팀 프로젝트의 인증 인가는 JWT 액세스 토큰을 세션 스토리지에 저장해놓는 방식으로 운영하고 있었다.</p><h2 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h2><p>이 방식에는 크게 두가지 문제가 있다고 생각했다.<br>먼저 세션 스토리지에 저장할 경우 브라우저를 닫으면 저장된 토큰 정보가 날아간다.<br>대부분의 서비스는 탭이나 브라우저를 닫는다고 로그아웃되지 않는다.<br>우리는 세션 스토리지에 사용자 인증 정보를 담아서는 안되겠다고 판단했다.</p><h2 id="대안-비교하기"><a href="#대안-비교하기" class="headerlink" title="대안 비교하기"></a>대안 비교하기</h2><p>브라우저를 닫아도 사용자가 로그인 한 상태가 유지되려면 사용자 인증 정보를 세션 스토리지가 아닌 다른 곳에 저장해야 했다.<br>쿠키나 로컬 스토리지가 가능한 선택지였다</p><h3 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a>쿠키</h3><p>먼저 쿠키에 대해 고민해보자.<br>쿠키의 가장 큰 문제점은 CSRF 공격이 위험하다는 점이다.<br>쿠키는 매번 HTTP 요청에 같이 포함되서 가기 때문에 공격자가 <code>[POST] /review/1</code> 이런 URL을 실행시키도록 유도해서 사용자가 의도하지 않은 행동을 실행시킬 수 있다.<br>서버에서는 같이 온 쿠키로 사용자 정보를 확인에 성공했으니 더 의심하지 않고 요청을 수행하게 되서 문제가 된다.</p><p>반면 쿠키는 <code>httpOnly</code> 속성을 활용하면 xss 공격을 막을 수 있다.<br><code>httpOnly</code> 속성을 사용하면 자바스크립트로 접근이 불가능하기 때문에 xss 공격으로 스크립트를 실행해도 쿠키의 내용을 알지 못한다.</p><h3 id="로컬-스토리지"><a href="#로컬-스토리지" class="headerlink" title="로컬 스토리지"></a>로컬 스토리지</h3><p>반면 로컬 스토리지는 어떨까?<br>로컬 스토리지는 세션 스토리지와 함께 HTML5 스토리지라고 불린다.<br>로컬 스토리지를 사용하게 되면 세션 스토리지와는 다르게 브라우저를 닫아도 정보가 사라지지 않는다.<br>프론트엔드는 로컬 스토리지에 담겨있는 토큰을 꺼내서 <code>Authorization</code> 헤더에 담아 요청을 보낸다.</p><p>이 방법은 CSRF 공격에 비교적 안전하다.<br>왜냐면 쿠키와 다르게 자동으로 요청에 함께 포함되지 않고 자바스크립트로 로컬 스토리지로 꺼내서 <code>Authorization</code> 헤더에 담는 추가적인 행위가 필요하므로 CSRF 공격으로는 하기 어렵다.</p><p>하지만 로컬 스토리지(뿐만 아니라 HTML5 스토리지 모두) XSS 공격에 취약하다는 문제가 있다.<br>쿠키와 다르게 로컬 스토리지는 애초에 자바스크립트에서 사용하기 위해 등장한 개념이라 <code>httpOnly</code>를 적용한 쿠키처럼 자바스크립트의 접근을 막을 수 없다.</p><p>그래서 다음과 같은 HTML 코드를 삽입하는 XSS 공격에 취약할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;access-token&#x27;</span>))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>지금까지 대안을 정리하면 다음과 같다.</p><table><thead><tr><th><strong>비교</strong></th><th><strong>세션 스토리지</strong></th><th><strong>로컬 스토리지</strong></th><th><strong>쿠키</strong></th></tr></thead><tbody><tr><td><strong>회원 정보 유지</strong></td><td>불가능</td><td>가능</td><td>가능</td></tr><tr><td><strong>CSRF 공격</strong></td><td>방어</td><td>방어</td><td>취약</td></tr><tr><td><strong>XSS 공격</strong></td><td>취약</td><td>취약</td><td>httpOnly 사용시 방어</td></tr></tbody></table><h2 id="대안-선택-기준"><a href="#대안-선택-기준" class="headerlink" title="대안 선택 기준"></a>대안 선택 기준</h2><p>우리는 대안을 선택할 때 다음과 같은 기준을 정해두고 생각했다.</p><ol><li>브라우저를 닫아도 회원 정보가 유지될 것</li><li>CSRF 공격과 XSS 공격을 최대한 막아볼 것</li><li>만에 하나 액세스 토큰이 탈취되었더라도 피해를 최소화 할 것</li><li>인증 인가를 통한 DB 부하를 줄일 수 있을 것</li></ol><p>먼저 1번을 고려했을 때 세션 스토리지(기존 방식)은 제외해야 했다.</p><p>2번을 고려하면 로컬 스토리지와 쿠키 모두 각자 다른 곳에서 취약함을 알 수 있었다.<br>다만 로컬 스토리지 XSS 공격은 리액트에서 어느정도 막아줄 수 있다. 하지만 리액트에 의존해서 XSS 공격을 막는 것은 부족하다고 생각했다.</p><p>반면 쿠키의 CSRF 공격은 추가적인 방어 수단을 고려해야 한다.<br>쿠키의 CSRF 공격 취약성은 CSRF 토큰을 도입해서 해결할 수 있다고 한다.<br>CSRF 토큰은 난수를 서버에서 저장하고 매 요청마다 클라이언트가 난수를 같이 보내서 서버에서 난수가 일치하는 지 확인하는 방식이다.<br>문제는 난수를 서버에서 관리하는 비용이 있고 만약 난수를 DB에서 관리할 경우 매 요청마다 DB에 접근해서 난수를 비교해야하는 비용도 존재했다.</p><p>또한 CSRF 공격을 referer 헤더를 체크하는 방식으로 막을 수도 있다.<br>referer는 공격자가 위조할 수 있는 요소라서 referer 체크로는 CSRF 공격을 막기 힘들다고 생각했다.</p><p>3번은 우리가 예상하지 못한 경우를 대비한다.<br>즉 어찌됐건 토큰이 유출됐을 경우 피해를 최소화하기 위해서는 액세스 토큰의 유효 시간을 짧게 설정할 필요가 있었다.<br>하지만 액세스 토큰 유효시간을 짧게 설정하면 너무 빠르게 로그아웃되어버리는 현상이 발생할 수 있었다.</p><p>이럴 때 사용되는 것이 리프레시 토큰이다. 리프레시 토큰은 다른 포스트로 이어서 설명해보겠다.</p><p>4번은 간단하다 보안을 생각하는 것은 좋으나 그렇다고 지나치게 DB 서버에 부하를 주는 방식은 곤란하다. 왜냐면 우리 프로젝트의 서비스가 금융과 관련된 보안에 민감한 서비스는 아니기 때문에 보안 때문에 성능을 포기하면 안된다고 생각했다.</p><p>4번 관점에서는 CSRF 토큰을 사용하기는 어려웠다.</p><h2 id="대안-선택-하기"><a href="#대안-선택-하기" class="headerlink" title="대안 선택 하기"></a>대안 선택 하기</h2><p>우리가 선택한 방법은 리프레시 토큰을 httpOnly 쿠키에 담고 액세스 토큰을 자바스크립트 변수로 관리하는 방식이었다.</p><p>이렇게 하면 우리의 선택 기준을 충족할 수 있었다.</p><ol><li>브라우저를 닫아도 쿠키에 저장된 리프레시 토큰으로 다시 액세스 토큰을 발급받으면 되니 회원 정보를 유지할 수 있었다.</li><li>XSS 공격은 <code>httpOnly</code> 속성으로 방지하고 CSRF 공격은 리프레시 토큰만으로는 액세스 토큰 발급을 제외한 다른 행위를 할 수 없으니 해커의 공격 가능한 범위를 줄이는 방식으로 대응했다.<br>만약 액세스 토큰을 발급하는 데 성공해도 해커는 이 응답값에 접근할 수 없으므로 큰 위협이 되지 않는다.</li><li>액세스 토큰이 만에 하나 갈취되어도 짧은 유효시간을 적용하면 해커가 공격 가능한 시간이 적어져 대응 가능하다고 판단했다.<br>만약 유효시간이 훨씬 긴 리프레시 토큰이 갈취 되었을 경우에는 액세스 토큰을 발급하면 만료시키는 방식으로 대응했다.<br>이렇게 하면 리프레시 토큰이 갈취되어도 액세스 토큰 한 개의 시간 만큼만 공격에 노출된다.</li><li>리프레시 토큰을 통해 액세스 토큰을 발급받을 때 추가적인 DB 접근 비용이 필요했다.<br>하지만 CSRF 토큰을 도입했을 경우처럼 매 요청마다 DB를 접근하는 것이 아닌 액세스 토큰을 발급할 때만 DB에 접근해서 감당 가능하다고 봤다.</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring boot에서 JWT 토큰 발급 구현하기</title>
      <link>https://yangdongjue5510.github.io/2022/09/26/springBootJwt/</link>
      <guid>https://yangdongjue5510.github.io/2022/09/26/springBootJwt/</guid>
      <pubDate>Mon, 26 Sep 2022 14:28:39 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;도입-배경&quot;&gt;&lt;a href=&quot;#도입-배경&quot; class=&quot;headerlink&quot; title=&quot;도입 배경&quot;&gt;&lt;/a&gt;도입 배경&lt;/h2&gt;&lt;p&gt;우아한테크코스에 프로젝트를 진행하는데 사용자의 정보를 기억해야 하는 상황이 필요한 경우가 있다.&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h2><p>우아한테크코스에 프로젝트를 진행하는데 사용자의 정보를 기억해야 하는 상황이 필요한 경우가 있다.</p><p>예를 들면 사용자가 작성한 리뷰를 삭제하거나 수정할 수 있어야 한다. 그러려면 현재 접속한 사용자가 이전에 리뷰를 작성한 사용자임을 알아낼 수 있어야 한다.</p><p>일단 사용자를 구분하기 위해서 로그인을 해서 사용자를 구분해서 관리할 수 있도록 했다.</p><p>이때 사용자 인증하는 역할은 깃허브Oauth를 활용해서 깃허브에서 사용자를 인증하고 사용자의 정보를 반환한다.</p><p>이제 사용자에 대한 정보를 우리 프로젝트 서버로 가져왔다. 이 정보를 어딘가에 기억해놔야 사용자가 다음에 요청을 했을 때 같은 사용자임을 알 수 있다.</p><h2 id="세션-JWT-토큰"><a href="#세션-JWT-토큰" class="headerlink" title="세션, JWT 토큰"></a>세션, JWT 토큰</h2><p>정보를 어디에 저장할 지, 어떻게 저장할 지에 따라 세션, JWT 토큰을 활용하는 방법이 있다.<br>(쿠키에 사용자 정보를 그대로 저장하는 방법도 있지만 보안에 취약해서 제외했다.)</p><h3 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h3><p>세션 방식은 서버의 세션에 사용자의 정보를 저장하고 해당 세션에 저장할 때 발급되는 JSESSIONID를 클라이언트에게 전달해서 클라이언트는 JSESSIONID를 요청 보낼 때 같이 보낸다. 서버는 요청과 함께 온 JSESSIONID를 통해 서버의 세션에 저장된 정보를 찾아 사용자를 식별한다.즉 세션 방식은 사용자의 정보를 서버에 저장하는 방식이다.</p><p>문제는 만약 서버가 다중화가 되는 경우다.</p><p>필자가 사용하는 Spring의 경우 세션을 톰캣 내부에 저장하는 게 기본이다. 그럴 경우 사용자가 다른 서버로 요청을 보내게 되면 해당 서버의 세션에는 사용자 정보가 저장된 적 없으니 문제가 생긴다. 즉 여러 서버의 세션이 동기화를 해줘야 한다.</p><p>그래서 세션을 사용하는 실 서비스에서는 세션을 위한 DB 서버를 따로 관리한다. 세션을 위한 저장소를 따로 관리하는 경우 기존의 API 서버와 IO 비용을 생각해야 한다. 특히 여러 API 서버가 한 세션 서버에 요청을 보낼 경우 세션 서버에 지나친 부하가 생길 수 있다.</p><h3 id="JWT-토큰"><a href="#JWT-토큰" class="headerlink" title="JWT 토큰"></a>JWT 토큰</h3><p>JWT 토큰은 JWT 토큰이라는 것에 사용자의 정보를 인코딩하여 담고 서버가 가진 시크릿키로 서명해서 만든 다음 클라이언트 쪽에서 저장하는 방법이다.</p><p>클라이언트는 자신이 가진 JWT 토큰을 요청을 보낼 때 같이 보내서 서버가 이를 받아 디코딩해서 사용하는 방식이다.</p><p>문제는 JWT 토큰에 담긴 정보는 누구나 디코딩 할 수 있다는 점이다.</p><p>JWT 토큰의 페이로드에 담긴 값은 애초에 암호화한 값을 집어넣는 것이 아니라면 누구나 그 값이 어떤 값인지 디코딩 해서 볼 수 있다.</p><p>그래서 보안에 민감한 값은 JWT 토큰에 담지 않도록 한다.</p><p>더 큰 문제는 시크릿키가 노출되면 공격자가 JWT 토큰을 얼마든지 만들 수 있다는 점이다.</p><p>그래서 JWT 토큰을 사용할 때는 시크릿키를 깃허브같은 곳에 노출되지 않도록 주의해야 한다.</p><h3 id="쿠키에-사용자-정보-그대로-저장-비추천"><a href="#쿠키에-사용자-정보-그대로-저장-비추천" class="headerlink" title="쿠키에 사용자 정보 그대로 저장 (비추천)"></a>쿠키에 사용자 정보 그대로 저장 (비추천)</h3><p>쿠키에 사용자의 정보를 그대로 저장하는 방법은 추천하지 않는다.</p><p>일반적인 쿠키는 JS로 접근해서 내용을 볼 수 있기 때문에 XSS(Cross Site Scripting)을 통해 탈취 될 수 있다.</p><p>또한 스니핑(Sniffing, 서버와 클라이언트의 네트워크 중간에서 패킷을 탈취해서 도청) 공격을 통해 탈취 될 수 있다.</p><p>위 두 문제점은 막으려면</p><p>1. 쿠키의 Http-Only 옵션을 켜서 JS가 접근할 수 없도록 해야 한다.</p><p>2. 서버와 클라이언트의 통신을 HTTPS로 설정해서 중간에 도청해도 알 수 없도록 해야 한다.</p><h2 id="JWT-토큰을-고른-이유"><a href="#JWT-토큰을-고른-이유" class="headerlink" title="JWT 토큰을 고른 이유"></a>JWT 토큰을 고른 이유</h2><p>JWT 토큰은 서버에서 토큰을 어떻게 저장할 지 고민하지 않아도 되는 점이 컸다.</p><p>특히 서비스의 특성에 따라 달라지는데, 우리 서비스는 단순 리뷰 서비스이기 때문에 지금 단계에서는 JWT 토큰으로 간단하게 사용자를 식별해도 괜찮다고 판단했다.</p><p>JWT 토큰에 사용되는 시크릿키는 서브 모듈로 따로 Private 레포지토리를 만들어서 관리하면 해결된다고 판단했다. </p><h2 id="Spring-Boot에서-JWT-토큰-발급하기"><a href="#Spring-Boot에서-JWT-토큰-발급하기" class="headerlink" title="Spring Boot에서 JWT 토큰 발급하기"></a>Spring Boot에서 JWT 토큰 발급하기</h2><p>일단 JWT 토큰에 어떤 값을 저장해서 서버와 클라이언트가 주고 받을 것인지 결정해야 한다.</p><p>우리 서비스는 사용자의 정보를 DB에 저장할 때 생성된 MemberID를 페이로드에 담았다.</p><p>로그인을 할 때 인증 인가 로직 흐름은 다음과 같다.</p><ol><li>클라이언트에서 깃허브에 코드를 요청한다.</li><li>깃허브는 해당 클라이언트가 깃허브의 사용자인지 확인하고 코드를 반환한다.</li><li>클라이언트는 서버에 깃허브에서 받은 코드를 넘겨서 로그인 요청을 날린다.</li><li>서버는 코드를 통해 깃허브 API용 access token을 요청한다.</li><li>깃허브는 코드를 확인하고 깃허브 API에 접근할 수 있는 access token을 발급한다.</li><li>서버는  깃허브 API access token을 통해 사용자의 정보를 요청한다.</li><li>깃허브는 access token을 확인하고 해당 사용자의 정보를 반환한다.</li><li>서버는 사용자의 정보를 받고 이를 DB에 최신화한다. (만약 깃허브 이름이 변했을 경우 반영해주기 위함)</li><li>서버는 DB에 저장된 사용자의 ID를 통해 JWT 토큰을 만들어서 클라이언트에게 반환한다.</li><li>이제 클라이언트는 인가가 필요한 요청에 받은 JWT 토큰을 요청 헤더(Authorization)에 담아서 보낸다.</li><li>서버는 클라이언트의 Authorization 헤더에 저장된 JWT 토큰이 우리 서버가 발급한 것인지, 유효한 것인지 확인하고 요청을 수행한다.</li></ol><p>서버 입장에서는 3, 4, 6, 8, 9, 11을 처리해주면 된다.</p><h2 id="AuthController"><a href="#AuthController" class="headerlink" title="AuthController"></a>AuthController</h2><p>먼저 3번 먼저 구현해보자. 로그인 요청을 받는 AuthController 예시이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v1&quot;)</span><br><span class="line">public class AuthController &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthService authService;</span><br><span class="line"></span><br><span class="line">    public AuthController(final AuthService authService) &#123;</span><br><span class="line">        this.authService = authService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/login&quot;)</span><br><span class="line">    public ResponseEntity&lt;LoginResponse&gt; login(@RequestParam final String code) &#123;</span><br><span class="line">        final LoginResult loginResult = authService.login(code);</span><br><span class="line">        return ResponseEntity.ok(LoginResponse.from(loginResult));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 파라미터로 오는 코드는 깃허브에서 사용자 인증에 성공했을 경우 돌려받는 코드이다.</p><p>AuthService에서 코드를 전달해서 로그인 처리를 위임하고 있다.</p><h2 id="AuthService"><a href="#AuthService" class="headerlink" title="AuthService"></a>AuthService</h2><p>AuthService에서 logIn을 어떻게 처리하는 지 살펴보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional(readOnly = true)</span><br><span class="line">public class AuthService &#123;</span><br><span class="line"></span><br><span class="line">    private final GitHubOauthClient gitHubOauthClient;</span><br><span class="line">    private final MemberRepository memberRepository;</span><br><span class="line">    private final JwtProvider jwtProvider;</span><br><span class="line"></span><br><span class="line">    public AuthService(final GitHubOauthClient gitHubOauthClient, final MemberRepository memberRepository,</span><br><span class="line">                       final JwtProvider jwtProvider) &#123;</span><br><span class="line">        this.gitHubOauthClient = gitHubOauthClient;</span><br><span class="line">        this.memberRepository = memberRepository;</span><br><span class="line">        this.jwtProvider = jwtProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public LoginResult login(final String code) &#123;</span><br><span class="line">        final GitHubProfileResponse gitHubProfileResponse = getGitHubProfileResponse(code);</span><br><span class="line">        final Member member = addOrUpdateMember(gitHubProfileResponse);</span><br><span class="line">        final Long memberId = member.getId();</span><br><span class="line">        final String applicationAccessToken = jwtProvider.createAccessToken(memberId);</span><br><span class="line">        return new LoginResult(applicationAccessToken, member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GitHubProfileResponse getGitHubProfileResponse(final String code) &#123;</span><br><span class="line">        final String gitHubAccessToken = gitHubOauthClient.getAccessToken(code);</span><br><span class="line">        return gitHubOauthClient.getProfile(gitHubAccessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Member addOrUpdateMember(final GitHubProfileResponse gitHubProfileResponse) &#123;</span><br><span class="line">        final Member requestedMember = gitHubProfileResponse.toMember();</span><br><span class="line">        final Member member = memberRepository.findByGitHubId(gitHubProfileResponse.getGitHubId())</span><br><span class="line">                .orElseGet(() -&gt; memberRepository.save(requestedMember));</span><br><span class="line">        member.update(requestedMember);</span><br><span class="line">        return member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthService의 getGitHubProfileResponse 메서드는 4번과 6번을 GithubOauthClient에게 위임하고 있다.</p><p>(GithubOauthClient는 다른 포스트로 더 설명해보고자 한다.)</p><p>AuthService의 addOrUpdateMember 메서드는 8번을 수행하고 있다.</p><p>AuthService의 login 메서드에서 JwtProvider를 통해 9번을 수행하고 있다.</p><p>그리고 LoginResult라는 DTO에 결과를 담아서 컨트롤러로 반환하고 있다.</p><h2 id="JwtProvider"><a href="#JwtProvider" class="headerlink" title="JwtProvider"></a>JwtProvider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_TYPE = <span class="string">&quot;Bearer&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_TOKEN_SUBJECT = <span class="string">&quot;AccessToken&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthTokenExtractor authTokenExtractor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Key secretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> validityInMilliseconds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtProvider</span><span class="params">(<span class="keyword">final</span> AuthTokenExtractor authTokenExtractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@Value(&quot;$&#123;security.jwt.secret-key&#125;&quot;)</span> <span class="keyword">final</span> String secretKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@Value(&quot;$&#123;security.jwt.expire-length&#125;&quot;)</span> <span class="keyword">final</span> <span class="keyword">long</span> validityInMilliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authTokenExtractor = authTokenExtractor;</span><br><span class="line">        <span class="keyword">this</span>.secretKey = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">this</span>.validityInMilliseconds = validityInMilliseconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createAccessToken</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Role role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">final</span> Date validity = <span class="keyword">new</span> Date(now.getTime() + validityInMilliseconds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(ACCESS_TOKEN_SUBJECT)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(validity)</span><br><span class="line">                .claim(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">                .claim(<span class="string">&quot;role&quot;</span>, role)</span><br><span class="line">                .signWith(secretKey, SignatureAlgorithm.HS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidToken</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Jws&lt;Claims&gt; claims = getClaimsJws(token);</span><br><span class="line">            <span class="keyword">return</span> isAccessToken(claims) &amp;&amp; isNotExpired(claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Jws&lt;Claims&gt; <span class="title">getClaimsJws</span><span class="params">(<span class="keyword">final</span> String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parserBuilder()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .build()</span><br><span class="line">                .parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccessToken</span><span class="params">(<span class="keyword">final</span> Jws&lt;Claims&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getSubject()</span><br><span class="line">                .equals(ACCESS_TOKEN_SUBJECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotExpired</span><span class="params">(<span class="keyword">final</span> Jws&lt;Claims&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getExpiration()</span><br><span class="line">                .after(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemberPayload <span class="title">getPayload</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        Claims body = getClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long id = body.get(<span class="string">&quot;id&quot;</span>, Long.class);</span><br><span class="line">            Role role = Role.valueOf(body.get(<span class="string">&quot;role&quot;</span>, String.class));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MemberPayload(id, role);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getExpiration()</span><br><span class="line">                .after(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemberPayload <span class="title">getPayload</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        Claims body = getClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long id = body.get(<span class="string">&quot;id&quot;</span>, Long.class);</span><br><span class="line">            Role role = Role.valueOf(body.get(<span class="string">&quot;role&quot;</span>, String.class));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MemberPayload(id, role);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtProvider는 Jwt 토큰을 만들고, 검증하는 역할을 한다.</p><p>이때 JwtProvider에는 io.jsonwebtoken 라이브러리를 사용한다.</p><p>이를 위해서는 build.gradle에 다음과 같이 의존성을 추가해주자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">// 생략...</span><br><span class="line"></span><br><span class="line">    // jwt</span><br><span class="line">    implementation &#x27;io.jsonwebtoken:jjwt-api:0.11.5&#x27;</span><br><span class="line">    runtimeOnly &#x27;io.jsonwebtoken:jjwt-impl:0.11.5&#x27;</span><br><span class="line">    runtimeOnly &#x27;io.jsonwebtoken:jjwt-jackson:0.11.5&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtProvider는 생성자로 시크릿키, 만료 시간, AuthTokenExtractor를 주입받는다.</p><p>AuthTokenExtractor는 Authorization 헤더 형식에서 토큰값만 추출하는 책임을 진다.</p><p>(<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization" title="Authorization 헤더에 대하여">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization</a>)</p><p>만료시간은 변경해줘야 할 경우 JwtProvider의 코드를 살펴보면서 바꾸면 위험하기 때문에 따로 주입해주는 방식을 썼다.</p><p>문제는 시크릿키이다.</p><p>시크릿키는 한번 유출되면 누구나 서버가 만든 JWT 토큰과 동일한 서명을 가진 JWT 토큰을 만들어 낼 수 있다.</p><p>그래서 따로 설정파일 (yaml)을 만들어서 보안이 중요한 내용을 관리하도록 했다.</p><p>이런 보안이 중요한 파일들은 .gitignore로 깃에 등록되지 않도록 관리하거나, 서브 모듈을 활용해서 private repository에서 버전 관리를 할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">security:</span><br><span class="line">  jwt:</span><br><span class="line">    secret-key: secretKeyExample</span><br><span class="line">    expire-length: 3600000</span><br></pre></td></tr></table></figure><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a><em>참고</em></h2><p><a href="https://github.com/woowacourse-teams/2022-f12">https://github.com/woowacourse-teams/2022-f12</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/09/26/springBootJwt/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA를 왜 쓰나요?</title>
      <link>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</link>
      <guid>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</guid>
      <pubDate>Wed, 29 Jun 2022 10:21:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.&lt;br&gt;객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.<br>객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스는 데이터 중심으로 설계된다.<br>객체지향은 참조의 방향이 정해져있지만, 데이터베이스는 하나의 외래키로 양쪽 모두 참조 가능하다.<br>동일성 비교를 객체는 인스턴스의 주소값으로 하고 데이터베이스는 기본키로 한다.<br>JPA는 이런 차이를 개발자가 신경쓰지 않게 해준다.<br>JPA는 반복적인 SQL 작성을 줄여준다.</p><h1 id="반복적인-SQL-작성"><a href="#반복적인-SQL-작성" class="headerlink" title="반복적인 SQL 작성"></a>반복적인 SQL 작성</h1><p>JDBC API로 Member 객체를 저장하거나 조회해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">        <span class="keyword">final</span> String sql = <span class="string">&quot;insert into member (id, name) values (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, member.getId());</span><br><span class="line">            statement.setString(<span class="number">2</span>, member.getName());</span><br><span class="line">            statement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Member 객체를 저장하는 데 정말 많은 코드가 많이 필요하다.<br>만약 테이블이 100개이면 저장하는 메서드 100개를 반복해서 만들어줘야 한다.</p><p>만약 데이터베이스를 컬렉션이라고 상상해보면 다음과 같지 않을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">members.add(member);</span><br></pre></td></tr></table></figure><p>JPA를 사용하면 컬렉션처럼 객체를 데이터베이스에 저장시킬 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entityManager.persist(member);</span><br></pre></td></tr></table></figure><p>JPA는 객체와 매핑 정보를 보고 적절한 SQL을 알아서 실행시킨다.<br>개발자는 반복적인 SQL 작성을 하지 않아도 된다.</p><h1 id="상속-구조-구현-문제"><a href="#상속-구조-구현-문제" class="headerlink" title="상속 구조 구현 문제"></a>상속 구조 구현 문제</h1><p><img src="/img/whyUseJpa-1.png"></p><p>데이터베이스는 객체 지향 상속을 지원하지 않으니 위 그림처럼 DTYPE 칼럼을 추가해서 어떤 자식 테이블과 관계가 있는지 확인할 수 있어야 한다.</p><p>문제는 이런 경우 개발자가 Keyboard 객체를 저장하려면</p><ol><li>ITEM 테이블에 insert 하는 쿼리</li><li>KEYBOARD 테이블에 insert 하는 쿼리</li></ol><p>두 개의 쿼리를 작성해야 한다.</p><p>데이터베이스에서 객체를 가져올 때는 ITEM과 KEYBOARD을 조인해서 데이터를 가져온 다음, Keyboard 객체를 생성해야 한다.</p><p>JPA의 경우 그냥 해당 객체를 저장(혹은 조회)하면 적절한 SQL을 실행해서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 저장</span></span><br><span class="line">entityManager.persist(keyboard);</span><br><span class="line"><span class="comment">// 조회</span></span><br><span class="line">Keyboard keyboard = entityManager.find(Keyboard.class, keyboardId);</span><br></pre></td></tr></table></figure><h1 id="연관-관계-문제"><a href="#연관-관계-문제" class="headerlink" title="연관 관계 문제"></a>연관 관계 문제</h1><p>Member 클래스가 Team과 연관 관계가 있다고 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Team team;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 Member를 조회하는 두 개의 SQL이 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> u.id, u.name, t.id, t.name </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">member</span> u </span><br><span class="line"><span class="keyword">JOIN</span> team t <span class="keyword">ON</span> member.team_id <span class="operator">=</span> team.id </span><br><span class="line"><span class="keyword">WHERE</span> u.id <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure><p>만약 굳이 Team 객체를 사용하지 않는 경우에는 첫번째 쿼리를 사용해서 Member 객체를 만드는게 낫다.<br>Team 객체를 사용해야 하는 경우는 두번째 쿼리로 Team 객체를 만들어서 Member 객체를 만들어야 한다.</p><p>문제는 개발자가 Member객체가 Team 객체에 값이 들어와 있는지를 확신할 수 없다는 점이다.</p><p>첫번째 쿼리로 만들어진 Member객체에게 getTeam()을 할 경우 Id만 채워진 객체가 반환되서 문제를 일으키게 된다.</p><p>그리고 만약 Team 객체에도 연관되는 객체가 있으면 쿼리는 더 복잡해질 가능성이 있다.<br>이 경우에도 Team 객체의 연관 객체의 데이터를 채워서 만들어 줄 것인지에 따라 SQL을 다르게 작성해야 한다.<br>다양한 연관관계를 상황에 따라 맞는 쿼리를 작성하는 건 상당히 힘든 작업이다.</p><p>반면 JPA에서는 연관 관계의 객체의 프로퍼티에 접근할 때 쿼리를 실행시켜서 해당 객체를 초기화한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 Team 객체는 id값만 채워져있다.</span></span><br><span class="line">Member member = entityManager.find(Member.class, memberId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이때 Team 객체의 데이터가 채워진다.</span></span><br><span class="line">member.getTeam().getName();</span><br></pre></td></tr></table></figure><h1 id="동일성-보장-문제"><a href="#동일성-보장-문제" class="headerlink" title="동일성 보장 문제"></a>동일성 보장 문제</h1><p>자바는 인스턴스의 주소값이 같으면 같은 객체로 분류하고, 데이터베이스는 기본키 값이 같으면 동일하다고 인식한다.<br>자바 객체를 저장하고 다시 조회했을 때 같은 객체를 반환하기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 Member 객체를 조회하려면 DB에서 조회한 데이터로 새로운 객체를 만들어서 반환하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">    <span class="keyword">final</span> String sql = <span class="string">&quot;select id, name from member where id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        ResultSet resultSet = statement.executeQuery();</span><br><span class="line">        <span class="keyword">if</span> (!resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Member(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 이렇게 되면 객체를 저장하고 해당 객체를 다시 조회했을 때 같은 객체가 반환되지 않는다는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">memberDao.save(member);</span><br><span class="line">Member foundMember = memberDao.findById(<span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//실패!!</span></span><br></pre></td></tr></table></figure><p>분명 논리적으로는 같은 객체인데 DB에 저장하고 찾아온 객체가 자바에서는 다른 객체로 인식하게 된다.</p><p>JPA에서는 객체를 DB에 저장하고 조회해도 같은 객체(인스턴스 주소값이 같은)를 반환해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">entityManager.persist(member);</span><br><span class="line">Member foundMember = entityManager.find(Member.class, <span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//성공!!</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바 ORM 표준 JPA 프로그래밍</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Transactional 어노테이션</title>
      <link>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</guid>
      <pubDate>Mon, 16 May 2022 08:35:14 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;트랜잭션이 무엇인지 알아본다.&lt;br&gt;@Transactional의 Propagation 옵션을 알아본다.&lt;br&gt;@Transactional의 롤백 기준을 알아본다.&lt;br&gt;@Transa</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>트랜잭션이 무엇인지 알아본다.<br>@Transactional의 Propagation 옵션을 알아본다.<br>@Transactional의 롤백 기준을 알아본다.<br>@Transactional 적용 실패하는 경우를 알아본다.</p><h1 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션?"></a>트랜잭션?</h1><p>모두 반드시 성공해야 하는 연속된 작업들을 트랜잭션이라 한다.<br>만약 작업들 중 하나만 실패해도 모든 작업들이 어플리케이션의 상태를 변경시키지 않은 상태로 돌려놔야 한다.</p><p>만약 하나의 지하철 노선에 등록할 때 구간도 같이 저장해야 한다고 가정하자.<br>이때 INSERT 문이 두 번 사용될 것이다.<br>개발자는 이를 하나의 작업 단위로 인식해서 하나의 트랜잭션으로 관리할 수 있다.<br>노선을 등록하는데 성공했더라도 구간이 저장안되면 노선도 저장되서는 안되기 때문이다.</p><p>트랜잭션 진행 중에 문제가 생길 경우 그 작업을 진행하기 이전으로 DB를 롤백시킨다.</p><h1 id="JDBC의-트랜잭션"><a href="#JDBC의-트랜잭션" class="headerlink" title="JDBC의 트랜잭션"></a>JDBC의 트랜잭션</h1><p>JDBC는 statement를 트랜잭션에서 진행할 수 있게한다.<br>JDBC의 한 Connection의 수행마다 auto-commit한다.<br>즉 모든 statement를 하나의 트랜잭션이라 생각하고 수행 이후 자동으로 반영한다.</p><p>만약 여러 statement를 하나의 트랜잭션에서 진행하고 싶다면 connection의 autoCommit을 꺼놓고 트랜잭션을 종료하고 싶을 때 명시적으로 커밋해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// auto-commit 꺼놓음.</span></span><br><span class="line"><span class="comment">// ... 작업들...</span></span><br><span class="line">connection.commit(); <span class="comment">//명시적으로 커밋.</span></span><br></pre></td></tr></table></figure><h1 id="스프링의-트랜잭션"><a href="#스프링의-트랜잭션" class="headerlink" title="스프링의 트랜잭션"></a>스프링의 트랜잭션</h1><p>스프링에서는 여러가지 트랜잭션 관리 기능을 제공한다.</p><h2 id="명시적-트랜잭션"><a href="#명시적-트랜잭션" class="headerlink" title="명시적 트랜잭션"></a>명시적 트랜잭션</h2><p>트랜잭션의 범위를 자세하게 정하고 싶을 땐 명시적 트랜잭션을 사용한다.</p><p>Transaction Template는 개발자가 직접 트랜잭션 범위를 명시적으로 결정할 수 있다.</p><h2 id="선언적-트랜잭션-Transactional"><a href="#선언적-트랜잭션-Transactional" class="headerlink" title="선언적 트랜잭션 @Transactional"></a>선언적 트랜잭션 @Transactional</h2><p>클래스나 메서드에 @Transactional 어노테이션을 붙이면 글로벌 트랜잭션을 정해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 메서드 위에 두면 메서드 실행 중 예외가 발생하면 롤백한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 위에 두면 클래스에 해당하는 메서드들을 @Transactional을 붙인 셈이 된다.</p><h3 id="Transactional의-여러가지-속성"><a href="#Transactional의-여러가지-속성" class="headerlink" title="@Transactional의 여러가지 속성"></a>@Transactional의 여러가지 속성</h3><p>트랜잭션에는 여러가지 속성을 설정해줄 수 있다. 예시코드를 통해 이해해보자.</p><p>일단 하나의 서비스에서 방을 DB에 저장하고 예외를 일으키는 메서드를 트랜잭션으로 처리하고자 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionalService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;other&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>그리고 다른 서비스에서 아까 만든 서비스를 주입받아 예외를 만드는 메서드를 호출하는 메서드를 트랜잭션 처리해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionalService.throwSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 OuterService의 메서드를 실행하기 위한 Runner 클래스를 만들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OuterService outerService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(OuterService outerService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outerService = outerService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        outerService.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 어플리케이션을 실행하면 외부 트랜잭션 메서드가 실행될 것이다.</p><h3 id="1-전파-옵션"><a href="#1-전파-옵션" class="headerlink" title="1. 전파 옵션"></a>1. 전파 옵션</h3><p>트랜잭션 수행 중 다른 트랜잭션을 호출하는 상황에서 어떻게 처리하는지 다루는 옵션.</p><ul><li><p><strong>REQUIRED</strong> : 트랜잭션 수행 중 다른 트랜잭션 호출되면 먼저 수행되던 거에 합쳐서 수행. propagation 기본 설정값.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>다른 설정을 안하면 REQUIRED 옵션으로 설정된다.<br>이 상태로 실행시키면 DB에는 아무 일도 일어나지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>UnexpectedRollbackException은 외부 트랜잭션이 내부 트랜잭션이 롤백됐음을 예상하지 못했다는 의미다.</p><p>외부 트랜잭션은 내부에서 다른 트랜잭션의 성공 여부 상관없이 커밋하려 한다.<br>중간에 내부 트랜잭션이 실패해서 롤백됐으면 이를 외부 트랜잭션에게 알려줘야 해서 생긴 예외다.</p><p>REQUIRED 옵션은 내부 트랜잭션과 외부 트랜잭션의 범위가 논리적으로는 분리되지만 물리적으로는 각 스코프가 같은 물리적 트랜잭션을 갖게 된다. 그래서 외부 트랜잭션은 내부의 트랜잭션의 rollback-only에 따라 영향을 받는다.</p></li><li><p><strong>SUPPORTS</strong> : 만약 트랜잭션이 진행되고 있는 상태에서 호출 시 해당 트랜잭션에 참여, 아닐 경우 트랜잭션 하지 않고 진행.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//외부 메서드가 트랜잭션이 아니면</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 어떻게 될까?</p><p>그 결과 두 메서드의 DB 업데이트가 모두 이뤄진다.(예외를 일으켜도 DB 업데이트가 이뤄졌다.)<br>사실 두 메서드 모두 트랜잭션 처리 되지 않았다.</p></li><li><p><strong>REQUIRED_NEW</strong> : 이미 진행 중인 트랜잭션이 있어도 새로운 트랜잭션 생성해서 진행. 서로 물리적으로 독립된 트랜잭션을 생성.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 외부 트랜잭션만 커밋된다.<br>내부 트랜잭션은 따로 트랜잭션으로 생성되서 예외 탐지하고 롤백됐고 외부 트랜잭션은 내부 트랜잭션의 실패 여부와 상관없이 트랜잭션을 진행해서 커밋했다.</p></li><li><p><strong>NESTED</strong> : 이미 진행 중인 트랜잭션의 중첩된 트랜잭션을 생성. 물리적으로는 하나의 트랜잭션인데 저장점을 추가하는 방식. 중첩된 트랜잭션은 외부 트랜잭션에 영향을 끼치지 못하지만 내부 트랜잭션은 외부 트랜잭션의 롤백에 영향 받는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이러면 내부 트랜잭션은 롤백되지만 외부 트랜잭션은 잘 실행된다.</p><p>반면 내부 트랜잭션은 예외를 던지지 않는데 외부 트랜잭션에서 예외가 발생한 경우는 어떨까?<br>모든 트랜잭션이 롤백된다! 내부가 성공해도 외부가 롤백되면 모두 롤백된다.</p></li></ul><h3 id="2-롤백-조건-옵션"><a href="#2-롤백-조건-옵션" class="headerlink" title="2. 롤백 조건 옵션"></a>2. 롤백 조건 옵션</h3><p>트랜잭션이 롤백되는 조건을 다룬다.<br>선언적 트랜잭션은 기본적으로 <strong>unchecked exception와 Error</strong>가 발생하면 롤백한다.<br>Checked exception은 개발자가 반드시 처리한 예외이니 예상하지 못한 예외인 unchecked exception과 Error가 발생하면 롤백한다.</p><p>@Transactional 어노테이션의 속성을 통해 롤백조건을 다르게 할 수 있다.<br>관련 속성은 다음과 같다.</p><ul><li><strong>rollbackFor</strong> : 추가로 롤백되어야 할 예외를 추가할 수 있다.</li><li><strong>rollbackForClassName</strong> : 추가로 롤백되어야 할 예외 클래스의 이름을 배열로 받아 추가할 수 있다.</li><li><strong>noRollbackFor</strong> : 롤백하지 않으려는 예외를 정할 수 있다.</li><li><strong>noRollbackForClassName</strong> : 롤백하지 않으려는 예외 클래스으 이름을 배열로 받아 정할 수 있다.</li></ul><h3 id="3-readOnly"><a href="#3-readOnly" class="headerlink" title="3. readOnly"></a>3. readOnly</h3><p>데이터를 수정하지 않는 트랜잭션을 데이터를 수정하려고 하는 경우를 막고 싶을 수 있다.<br>이럴 때 사용되는게 readOnly 속성이다.</p><p>readOnly는 읽기 전용일 경우 true로 세팅해주면 읽기 위한 트랜잭션임을 암시한다.<br>다만 readOnly가 붙은 트랜잭션에서 데이터를 수정하려고 할 때 반드시 실패한다는 의미는 아니다.<br>트랜잭션 매니저에 따라 readOnly를 지원하지 않는 경우 readOnly 설정은 무시된다.</p><h3 id="4-그-외-속성들"><a href="#4-그-외-속성들" class="headerlink" title="4. 그 외 속성들"></a>4. 그 외 속성들</h3><p>트랜잭션의 격리 수준을 결정하는 isolation이나 트랜잭션의 제한 시간을 정하는 timeout 속성들도 존재한다.</p><h2 id="Transation과-AOP"><a href="#Transation과-AOP" class="headerlink" title="@Transation과 AOP"></a>@Transation과 AOP</h2><p>선언적 트랜잭션은 AOP 프록시를 통해 활성화 된다.<br>프록시로 구현되다보니 트랜잭션에 수행하는 프록시 객체와 진짜 객체가 서로 다를 수 있다.<br>간략하게 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        transactionalService.throwSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;done! with throw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 예시로 사용했던 서비스는 사실 AOP 프록시를 사용하면 다음과 같이 된다.<br>외부에서 doSomething 메서드를 호출 -&gt; (프록시)트랜잭션 시작! -&gt; (진짜) doSomething 수행! -&gt; (프록시)트랜잭션 끝!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 프록시객체 </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> 진짜객체;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 트랜잭션_붙은_메서드() &#123;</span><br><span class="line">        트랜잭션_시작;</span><br><span class="line">        진짜객체.트랜잭션_붙은_메서드();</span><br><span class="line">        트랜잭션_끝;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 다음과 같은 경우는 어떻게 될까??</p><p>트랜잭션이 적용되지 않은 public 메서드를 통해서 트랜잭션 붙은 메서드를 호출해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 doSomething은 롤백될까? 답은 아니다!!!!</p><p>왜냐면 프록시 객체는 execute 메서드를 실행시킬 때 내부에서 어떤 메서드를 부르는지 모른다. 그래서 트랜잭션을 적용시켜주지 못한다.</p><p>그래서 <strong>private 메서드는 @Transactional을 붙이는 건 의미 없다.</strong> 트랜잭션 처리 해줄 프록시 객체가 해당 메서드에 접근할 수 없기 때문이다.</p><p>그리고 <strong>public이 붙었더라도 트랜잭션이 붙지 않은 메서드를 통해서 호출하면 트랜잭션이 적용되지 않는다</strong>!!!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Bean Validation으로 검증하기</title>
      <link>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</guid>
      <pubDate>Thu, 12 May 2022 11:41:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Bean-Validation&quot;&gt;&lt;a href=&quot;#Bean-Validation&quot; class=&quot;headerlink&quot; title=&quot;Bean Validation&quot;&gt;&lt;/a&gt;Bean Validation&lt;/h1&gt;&lt;h2 id=&quot;일반적인-유효성-검사-로</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h1><h2 id="일반적인-유효성-검사-로직"><a href="#일반적인-유효성-검사-로직" class="headerlink" title="일반적인 유효성 검사 로직"></a>일반적인 유효성 검사 로직</h2><p>지켜져야 할 조건에 맞지 않은 상황에 로직을 진행하려는 경우  예외를 터트려서 의도하지 않은 진행을 막을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.isBlank()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ExceptionMessage.BLANK_LINE_NAME.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자로 전달받은 문자열이 빈값이면 예외를 터지도록 해서 Name 객체는 반드시 이름을 가지도록 만들 수 있다.</p><p>하지만 이런 로직이 비슷하게 여러 클래스에 흩어져 있다면 중복이 많아지고 관리하기도 힘들어진다.</p><p>이런 검증을 각 </p><blockquote><p>Bean Validation과 Hibernate Validator</p></blockquote><p>Bean Validation은 일종의 명세이지 실제 작동하는 코드는 아니다.<br>이 명세를 구현한 것 중 하나가 Hibernate Validator이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/12/spring/validation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring IoC 컨테이너, 컴포넌트 스캔, 빈 생명주기</title>
      <link>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/</guid>
      <pubDate>Thu, 05 May 2022 12:21:02 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약 (다음 질문의 정답을 안다면 이 포스트를 읽지 않아도 된다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;IoC 컨테이너와 ApplicationContext는 완전히 같은 개념인가?&lt;/li&gt;
&lt;li&gt;IoC 컨테이</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약 (다음 질문의 정답을 안다면 이 포스트를 읽지 않아도 된다.)</p></blockquote><ol><li>IoC 컨테이너와 ApplicationContext는 완전히 같은 개념인가?</li><li>IoC 컨테이너를 구성하는 방법은 어떤 것이 있는가?</li><li>BeanFactory와 ApplicationContext의 차이를 알고 있는가?</li></ol><h1 id="IoC-컨테이너"><a href="#IoC-컨테이너" class="headerlink" title="IoC 컨테이너"></a>IoC 컨테이너</h1><p>스프링의 IoC 컨테이너는 객체를 인스턴스화하고 구성 및 조합하고 수명주기를 관리하는 역할을 한다.</p><h2 id="스프링이-제공하는-IoC-컨테이너"><a href="#스프링이-제공하는-IoC-컨테이너" class="headerlink" title="스프링이 제공하는 IoC 컨테이너"></a>스프링이 제공하는 IoC 컨테이너</h2><p>스프링의 IoC 컨테이너는 두 가지 유형의 컨테이너를 제공한다.</p><ol><li><strong>BeanFactory 기반 컨테이너</strong></li><li><strong>ApplicationContext 기반 컨테이너</strong></li></ol><p>우리가 가장 흔히 아는 <strong>ApplicationContext는 IoC 컨테이너 중 하나</strong>이다.</p><p>BeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.<br>ApplicationContext는 BeanFactory의 기능을 확장한 버전이다.</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.<br>BeanFactory는 메타데이터를 기반으로 빈 객체를 생성하고 구성한다.</p><p>이때 BeanFactory는 XML 기반으로 메타데이터를 사용한다.<br>BeanFactory는 Lazy Loadaing으로 빈 객체를 등록한다.</p><h4 id="코드로-이해하기"><a href="#코드로-이해하기" class="headerlink" title="코드로 이해하기"></a>코드로 이해하기</h4><p>User라는 POJO 클래스가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 클래스를 XML을 통해 Bean 등록해보자.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>config.xml에 user라는 이름으로 빈 등록을 해줬다.<br>init-method를 통해 빈 객체가 생성될 때 User#setIsBeanInitialized를 실행하도록 했다.</p><p>만약 User가 빈 객체로 생성되면 IS_BEAN_INITIALIZED가 true가 될 것 이다.</p><p>테스트 코드로 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;XML 기반으로 BeanFactory 레이지 로딩 확인하기&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beanFactoryLazyLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        Resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line">        BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">boolean</span> isCreated = User.IS_BEAN_INITIALIZED;</span><br><span class="line">        User user = (User) factory.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(isCreated).isFalse();</span><br><span class="line">        assertThat(isCreatedAfterGetBean).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 Lazy Loading을 확인할 수 있다.<br>Lazy Loading은 BeanFactory에서 빈 객체를 가져올 때 해당 객체를 생성한다는 의미다.</p><p>그래서 User.IS_BEAN_INITIALIZED가 빈 객체를 가져올 때 true가 됨을 확인 할 수 있다.</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext는 BeanFactory의 하위 인터페이스다.<br>따라서 BeanFactory의 모든 기능을 제공한다.</p><p>다만 ApplicationContext는 웹 어플리케이션, AOP에 필요한 더 많은 기능을 제공한다.</p><p>ApplicationContext의 선언부를 통해 어떤 기능을 추가로 제공하는 지 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>EnvironmentCapable</strong> 인터페이스 : 프로파일과 프로퍼티를 다루는 Environment를 접근할 수 있게 한다.</li><li><strong>ListableBeanFactory</strong> 인터페이스 : BeanFactory의 기능을 지원하기 위한 인터페이스. 빈 객체를 생성 관리한다.</li><li><strong>HierarachicalBeanFactory</strong> 인터페이스 : BeanFactory 구현체 사이의 계층 구조를 확인할 수 있게 한다.</li><li><strong>MessageSource</strong> 인터페이스 : 국제화(i18n)을 제공하는 인터페이스</li><li><strong>ApplicationEventPublisher</strong> 인터페이스 : 이벤트를 발생시키는 기능을 제공한다.</li><li><strong>ResourcePatternResolver</strong> 인터페이스 : 리소스를 읽어오는 기능을 제공한다.</li></ol><h4 id="ApplicationContext의-메타데이터-설정-방법들"><a href="#ApplicationContext의-메타데이터-설정-방법들" class="headerlink" title="ApplicationContext의 메타데이터 설정 방법들"></a>ApplicationContext의 메타데이터 설정 방법들</h4><p>BeanFactory와 달리 ApplicationContext의 중요한 기능 중 하나는 메타데이터를 다양한 방식으로 할 수 있다.</p><p>BeanFactory는 XML 외부 파일로 컨테이너를 설정해줘야 했다.<br>ApplicationContext는 어노테이션 기반 설정도 지원한다!</p><p>아까 사용했던 User POJO 클래스를 다시 사용하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 @Configuration 어노테이션을 붙인 설정 파일로 Bean 등록해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationUserBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setIsBeanInitialized();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Bean 어노테이션이 붙은 메서드가 실행되면 반환되는 객체를 빈 객체로 컨테이너에 등록한다.<br>그리고 XML의 init-method 대신 메서드 안에 setIsBeanInitialized 메서드를 호출했다.</p><p>테스트로 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@DisplayName(&quot;어노테이션 기반(설정 파일)로 빈 객체 생성 확인하기&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">applicationContextBeanCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// given</span></span><br><span class="line">       ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// when</span></span><br><span class="line">       <span class="keyword">boolean</span> isCreated = User.IS_BEAN_INITIALIZED;</span><br><span class="line">       User user = (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       <span class="keyword">boolean</span> isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// then</span></span><br><span class="line">       assertThat(isCreated).isTrue();</span><br><span class="line">       assertThat(isCreatedAfterGetBean).isTrue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>설정 클래스를 전달해서 ApplicationContext를 생성했다.<br>ApplicationContext는 eager-loading이라 컨테이너가 생성됐을 때 빈 객체를 생성한다!</p><p>그래서 빈 객체를 호출하기 전에도 이미 빈 객체가 생성되어 있다는 의미다!<br>(결국 모든 빈객체를 eager-loading하기 때문에 ApplicationContext는 비교적 무거운 IoC container이다.)</p><h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h1><p>ComponentScan은 특정 패키지에서 @Component가 붙은 클래스를 빈 객체 등록하는 방법이다.<br>일일히 빈 객체를 메서드로 작성하지 않아도 된다는 장점이 있다.</p><p>이전에 @Bean 어노테이션으로 등록했던 방식 대신 ComponentScan을 활용해보자.</p><p>먼저 빈등록하고 싶은 클래스에 @Component 어노테이션을 달아주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        setIsBeanInitialized();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitializeBean 인터페이스로 해당 클래스가 빈 객체로 만들어지고 나서 setIsBeanInitialized()를 실행하도록 했다.</p><p>이제 설정 파일에 @ComponentScan 어노테이션을 붙여주자!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;nextstep.helloworld.core.componentscan.user&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationUserBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@ComponentScan은 특정 패키지를 기준으로 해당 패키지와 하위 패키지의 @Component 어노테이션이 붙은 클래스를 빈등록한다. (위 예시는 User클래스가 있는 패키지를 기준으로 잡았다.)</p><p>@Bean을 붙여서 빈객체를 생성해줬던 메서드를 제거할 수 있게됐다!</p><blockquote><p>그렇다면 스프링 부트에서는 어떻게 ComponentScan을 하는 걸까??</p></blockquote><p>스프링 부트를 사용하면 @Configuration을 붙인 설정파일 없이도 @Component를 붙인 클래스를 빈등록 해준다.<br>왜 그렇게 되는 건지 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스프링 부트 프로젝트를 만들면 먼저 @SpringBootApplication이 붙은 클래스가 프로젝트 패키지에 생성된다.<br>@SpringBootApplication에 들어가보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 @SpringBootApplication 어노테이션에는 @ComponentScan 어노테이션이 포함되어 있다.<br>basePackages가 따로 설정하지 않았으니 해당 클래스가 속한 패키지를 기준으로 컴포넌트 스캔을 진행하게 된다.<br>그리고 @Filter 어노테이션으로 특정 클래스들을 컴포넌트 스캔에서 제외할 수 있다.</p><h1 id="Bean-생명주기"><a href="#Bean-생명주기" class="headerlink" title="Bean 생명주기"></a>Bean 생명주기</h1><p>Bean 객체의 생명 주기를 이해하기 위해서는 Bean을 생성하고 관리하는 스프링 컨테이너의 생명주기를 이해해야 한다.</p><h2 id="스프링-컨테이너의-생명주기"><a href="#스프링-컨테이너의-생명주기" class="headerlink" title="스프링 컨테이너의 생명주기"></a>스프링 컨테이너의 생명주기</h2><ul><li>컨테이너 초기화</li><li>컨테이너 종료</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@DisplayName(&quot;컨테이너 생명주기&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">applicationContextLifeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 초기화</span></span><br><span class="line">       AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 사용</span></span><br><span class="line">       User user = (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 종료</span></span><br><span class="line">       applicationContext.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="컨테이너-초기화"><a href="#컨테이너-초기화" class="headerlink" title="컨테이너 초기화"></a>컨테이너 초기화</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br></pre></td></tr></table></figure><p>AppliactionContext 객체를 생성하면 스프링 컨테이너를 초기화한다.<br>이 과정에서 메타데이터를 읽어서 알맞은 빈 객체를 생성하고 각 빈을 연결(주입)하게 된다.</p><h3 id="컨테이너-종료"><a href="#컨테이너-종료" class="headerlink" title="컨테이너 종료"></a>컨테이너 종료</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.close();</span><br></pre></td></tr></table></figure><p>컨테이너를 close 메서드를 통해 종료하면 컨테이너가 관리하던 빈 객체들도 모두 소멸된다.<br>(이때 프로퍼티 스코프인 객체들은 소멸되지 않는다. )</p><h2 id="빈-객체의-생명-주기"><a href="#빈-객체의-생명-주기" class="headerlink" title="빈 객체의 생명 주기"></a>빈 객체의 생명 주기</h2><p>스프링 컨테이너의 생명주기를 보면 짐작할 수 있듯이 일반적인 빈 객체는 컨테이너의 통제에 따라 생명 주기를 진행한다.</p><ul><li><strong>객체 생성</strong> -&gt; ApplicationContext가 생성되면서 빈 객체 생성</li><li><strong>의존 설정</strong> -&gt; ApplicationContext가 메타데이터를 기반으로 의존 주입</li><li><strong>초기화</strong> -&gt; 의존관계가 모두 설정하고 나면 빈 객체의 초기화에 해당하는 메서드를 수행</li><li><strong>소멸</strong> -&gt; ApplicationContext를 종료하면 빈 객체 소멸에 해당하는 메서드를 수행</li></ul><h3 id="초기화와-소멸"><a href="#초기화와-소멸" class="headerlink" title="초기화와 소멸"></a>초기화와 소멸</h3><p>의존관계까지 모두 주입되고 나면 빈 객체가 등록될 때 어떤 행위를 하도록 하고싶거나,<br>특정 빈 객체가 소멸 될 때 어떤 행위를 하기 원할 때가 있다.</p><p>이런 의도를 빈 생명 주기 중 초기화와 소멸에서 수행할 수 있다.</p><h4 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h4><p>빈 객체가 생성되고 나서 어떤 메서드를 실행시키고 싶은 경우 초기화 단계에서 수행한다.<br>이를 설정하기 위해서는 여러가지 방법이 있다.</p><ol><li><strong>@PostConstruct</strong></li><li><strong>InitializingBean</strong> 인터페이스</li><li><strong>init-method</strong></li></ol><p>코드로 이해해보자.<br>User 클래스가 빈 객체로 등록될 때 특정 메서드를 실행하게 만들자.</p><p>먼저 <strong>@PostConstruct</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 빈 객체가 등록되고 나서 수행됐으면 하는 메서드에 @PostConstruct를 붙여주면 된다.</p><p><strong>InitializingBean 인터페이스</strong>를 구현하는 방법도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        setIsBeanInitialized();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterPropertiesSet() 메서드 안에 빈 객체가 등록될 때 수행할 행동을 적어놓으면 된다.</p><p>마지막으로 <strong>xml init-method</strong>를 사용하는 방법이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean 태그 안에 init-method 속성에 빈 객체 생성 될 때 수행될 메서드 이름을 적어주면 된다.</p><h4 id="소멸"><a href="#소멸" class="headerlink" title="소멸"></a>소멸</h4><p>빈 객체가 사라질 때 특정 행동을 하라고 설정할 수 있다.<br>소멸을 구현하는 데에도 여러 방법이 있다.</p><ol><li><strong>@PreDestroy</strong></li><li><strong>DisposableBean</strong> 인터페이스</li><li><strong>destroy-method</strong></li></ol><p>코드로 이해해보자.<br>User 클래스의 빈 객체가 폐기될 때 특정 메서드를 실행하게 만들자.</p><p><strong>@PreDestory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DisposableBean 인터페이스</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XML destroy-method</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.componentscan.user.User&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 빈 객체가 제거 될 때(컨테이너가 종료될 때) 해당 메서드를 실행시킬 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>왜 스프링을 쓰는 걸까??(IoC, DI)</title>
      <link>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/</guid>
      <pubDate>Tue, 26 Apr 2022 10:34:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;의존 역전과 유연함을 위해서 DI하도록 객체를 설계하는 경우,&lt;br&gt;매번 해당 객체를 사용할 때마다 필요한 객체를 찾아서 주입해줘야 한다.&lt;br&gt;스프링 프레임워크는 DI를 대신해주</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>의존 역전과 유연함을 위해서 DI하도록 객체를 설계하는 경우,<br>매번 해당 객체를 사용할 때마다 필요한 객체를 찾아서 주입해줘야 한다.<br>스프링 프레임워크는 DI를 대신해주는 역할을 한다.</p><h1 id="유연한-설계를-위해서"><a href="#유연한-설계를-위해서" class="headerlink" title="유연한 설계를 위해서"></a>유연한 설계를 위해서</h1><p>객체지향 설계 원칙 중 SOLID 원칙이 있다.<br>그 중 D에 해당하는 의존 역전 원칙은 상위 모듈이 하위 모듈의 구현에 의존하지 말고, 상위 모듈이 정한 추상 타입에 하위 모듈들이 의존해야 한다는 규칙이다.</p><p>쉽게 말하면 상위 기능에서 정한 인터페이스나 추상 클래스 타입으로 하위 클래스들이 협력해야 한다는 의미이다.<br>이렇게 하면 상위 모듈은 하위 모듈의 내부 구현이 달라져도 상관하지 않게 되고 기능이 확장에 열리게 된다.</p><h2 id="예시로-좀-더-알아보자"><a href="#예시로-좀-더-알아보자" class="headerlink" title="예시로 좀 더 알아보자."></a>예시로 좀 더 알아보자.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReader에서 파일을 읽어서 문자열을 반환하는 책임을 한다고 하자.<br>이 클래스와 협력하는 NamePrinter를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        System.out.println(fileReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReader 객체를 만들어서 readName을 호출해서 출력한다!</p><blockquote><p>그런데 이름을 읽어오는 방법이 파일만 있을까?</p></blockquote><p>그렇다. 파일만 이름을 저장하라는 법은 없다.<br>이번엔 DBReader를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBReader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DB에서 이름을 읽어오는 로직이 존재한다고 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Names From DB...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 DBReader를 만들었어도 아직 DB에서 읽은 이름을 출력할 수 없다.<br>왜냐면 NamePrinter는 FileReader에 의존하고 있어서 파일에서 읽어온 이름만 출력할 수 있다.<br>그러면 NamePrinter의 FileReader를 DBReader로 바꾸면?<br>읽는 방식이 바뀌었다고 상위 기능인 출력 기능을 담당하는 NamePrinter를 수정해야 되면 문제가 있다.</p><h3 id="변경이-많은-곳을-추상화"><a href="#변경이-많은-곳을-추상화" class="headerlink" title="변경이 많은 곳을 추상화"></a>변경이 많은 곳을 추상화</h3><p>이름을 읽어오는 곳이 경우의 수가 다양하니까 인터페이스로 추상화하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">readNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 FileReader와 DBReader가 해당 인터페이스를 구현해서 의존하도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DB에서 이름을 읽어오는 로직이 존재한다고 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Names From DB...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아직 할 일이 남았다.<br>상위 모듈인 NamePrinter도 추상타입인 NameReader에 의존하도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamePrinter</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 생상자의 인자로 의존하도록 했다.<br>인자로 구현체를 전달해주어서 원하는 방식으로 이름을 읽어들이면 된다!</p><p>물론 의존성 주입은 생성자로만 하는 건 아니다. Setter 메서드로도 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameReader</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dependencyInjection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter();</span><br><span class="line">    namePrinter.setNameReader(<span class="keyword">new</span> FileReader());</span><br><span class="line">    namePrinter.printNames(); <span class="comment">//File에서 읽은 이름 출력</span></span><br><span class="line"></span><br><span class="line">    namePrinter.setNameReader(<span class="keyword">new</span> DBReader());</span><br><span class="line">    namePrinter.printNames(); <span class="comment">//DB에서 읽은 이름 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>의존성을 주입하는 방식으로 변경하니, NamePrinter는 어떤 곳에서 이름을 읽어오던 이름을 출력할 수 있게 됐다!</p><h1 id="좋은-설계를-쉽게-사용하기-위해서"><a href="#좋은-설계를-쉽게-사용하기-위해서" class="headerlink" title="좋은 설계를 쉽게 사용하기 위해서"></a>좋은 설계를 쉽게 사용하기 위해서</h1><p>DI를 활용해서 유연하고 확장하기 좋은 설계를 만들었다.<br>그런데 조금 걸리는게 있다.</p><p>클라이언트가 PrintName을 통해 이름을 출력하고 싶으면 의존성을 주입해줘야 한다.<br>setter를 쓰던 생성자를 통해 주입을 해주던 매번 해줘야 된다는 의미다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자 주입을 하는 경우</span></span><br><span class="line">NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter(<span class="keyword">new</span> DBReader());</span><br><span class="line">namePrinter.readNames();</span><br><span class="line"><span class="comment">//세터 주입을 하는 경우</span></span><br><span class="line">NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter();</span><br><span class="line">namePrinter.setNameReader(<span class="keyword">new</span> FileReader());</span><br><span class="line">nameReader.readNames();</span><br></pre></td></tr></table></figure><p>흠. 꽤 번거롭다. 지금은 두개의 객체가 협력하는 책임이라 그나마 봐줄만 하지만,<br>만약 추상화 수준이 높은 객체의 책임을 실행하려면 수많은 객체를 주입해줘야 할 것이다.</p><p>이 문제를 스프링이 해결해줄 수 있다.<br>스프링은 객체를 생성하는 과정을 프로그래머가 아닌 자신이 한다.<br>그리고 만들어진 객체를 스프링이 관리한다.</p><h2 id="예제를-통해-확인하기"><a href="#예제를-통해-확인하기" class="headerlink" title="예제를 통해 확인하기"></a>예제를 통해 확인하기</h2><p>스프링을 통해 객체를 관리하려면 스프링에게 어떤 객체를 관리할 것인지 알려줘야 한다.<br>자세히보면 @Component 어노테이션을 붙였다.<br>이 객체를 만들고 관리하는 일은 스프링이 해달라는 표시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamePrinter</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameReader</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>근데 잠깐만, 스프링이 객체를 생성하려면 NameReader 객체가 필요하다.(생성자가 그것 뿐이니,,)<br>그러면 NameReader 객체는 어디서 가져오는건가?!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 필요했던 NameReader의 구현체에도 @Component 어노테이션을 붙여서 스프링이 이 객체를 생성해서 관리하게 하면 된다!</p><p>즉!</p><p>일단 스프링 어플리케이션을 실행하면 먼저 컴포넌트 스캔을 실행한다.<br>컴포넌트 스캔은 @Component가 붙은 클래스를 객체로 만들어 IoC 컨테이너에 올려둔다.<br>이때 중요한 건! 만약 DI 받는 객체가 있는 경우, 스프링이 IoC 컨테이너에 있는 객체일 경우 자동으로 주입해준다!!</p><p>반면 생성자로 주입받으려는 객체가 IoC 컨테이너에 없는 경우 컴파일에러를 일으킨다.</p><blockquote><p> 한 가지 궁금한 점!</p></blockquote><p>아까 DI를 활용하면 유연하고 확장 가능한 구조를 얻을 수 있다고 했다.<br>하지만 스프링을 통해 아까 예제에 있던 NameReader의 두 구현체 모두에게 @Component를 붙여 관리하도록 하면,<br>컴파일 에러가 생긴다. 즉 NamePrinter가 어떤 구현체를 주입해서 객체를 생성해야 할 지 결정내리지 못하는 문제가 생긴다.</p><p>이 문제는 추후 더 알아보도록 하자!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>불필요한 객체 생성을 피해라</title>
      <link>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/</guid>
      <pubDate>Fri, 08 Apr 2022 15:29:09 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;변경되지 않는 객체를 사용할 때마다 새로운 객체를 만들지 말자.&lt;/p&gt;
&lt;h1 id=&quot;불필요한-객체-생성을-하는-예시&quot;&gt;&lt;a href=&quot;#불필요한-객체-생성을-하는-예시&quot; clas</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>변경되지 않는 객체를 사용할 때마다 새로운 객체를 만들지 말자.</p><h1 id="불필요한-객체-생성을-하는-예시"><a href="#불필요한-객체-생성을-하는-예시" class="headerlink" title="불필요한 객체 생성을 하는 예시"></a>불필요한 객체 생성을 하는 예시</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String bad = <span class="keyword">new</span> String(<span class="string">&quot;bikini&quot;</span>); <span class="comment">//안좋은 예시</span></span><br><span class="line">String good = <span class="string">&quot;bikini&quot;</span>; <span class="comment">//무난한 예시</span></span><br></pre></td></tr></table></figure><p>new String(“bikini”)로 문자열을 만드는 경우 불필요한 문자열 객체를 만든다.<br>왜? “bikini”라는 코드 자체가 문자열 객체를 만들기 때문이다.</p><p>문자열 객체를 만들고  다시 새로운 객체로 만드는 코드인 셈이다.</p><p>반면 두번째 줄 코드는 가상 머신에서 문자열 리터럴을 하나 만들어서 재사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> String(<span class="string">&quot;bikini&quot;</span>); <span class="comment">//얼마나 많은 문자열 객체가 만들어질까?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반복문에 위처럼 문자열 객체를 만들면 불필요한 객체가 생기게 된다.</p><h2 id="정적-팩터리-메서드로-불변-클래스-효율적으로-만들기"><a href="#정적-팩터리-메서드로-불변-클래스-효율적으로-만들기" class="headerlink" title="정적 팩터리 메서드로 불변 클래스 효율적으로 만들기"></a>정적 팩터리 메서드로 불변 클래스 효율적으로 만들기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean trueBoolean = <span class="keyword">new</span> Boolean(<span class="string">&quot;true&quot;</span>); <span class="comment">//안좋은 예시</span></span><br><span class="line">Boolean falseBoolean = Boolean.of(<span class="string">&quot;false&quot;</span>); <span class="comment">//좋은 예시</span></span><br></pre></td></tr></table></figure><p>Boolean 클래스는 객체 내부가 변경되지 않는 불변 객체이다.<br>불변 객체는 굳이 사용할 때마다 객체를 만들어주지 않아도 된다.</p><p>새로운 객체를 만들기보다는 만들어진 객체를 반환하는 기능을 정적 팩터리 메서드로 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;, <span class="title">Constable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Boolean&gt; TYPE = (Class&lt;Boolean&gt;) Class.getPrimitiveClass(<span class="string">&quot;boolean&quot;</span>);</span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3665804199014368530L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">    &#125;</span><br><span class="line">                                          </span><br><span class="line">     <span class="comment">//생략   </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseBoolean(s) ? TRUE : FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Boolean 객체 내부를 보면 자신의 인스턴스들을 내부에서 클래스 변수로 가지고 있다.<br>정적 팩터리 메서드로 전달받은 인수에 맞는 인스턴스를 반환해주면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>조합으로 체스 말 이동 범위 검사하기!</title>
      <link>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</guid>
      <pubDate>Fri, 08 Apr 2022 00:31:53 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.&lt;br&gt;이를 따로 분리해서 중복을 제거하고자 했다.&lt;/p&gt;
&lt;h1 id=&quot;도입-배경&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.<br>이를 따로 분리해서 중복을 제거하고자 했다.</p><h1 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h1><h2 id="체스-말-종류-구현하기"><a href="#체스-말-종류-구현하기" class="headerlink" title="체스 말 종류 구현하기"></a>체스 말 종류 구현하기</h2><p>체스 말 객체(Piece)는 자신의 위치와 이동할 위치를 전달받아서 이동할 위치로 이동할 수 있는지 확인한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> MovableStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Piece</span><span class="params">(<span class="keyword">final</span> Color color, <span class="keyword">final</span> MovableStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPointValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;같은 위치로는 이동 불가능합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.movable(source, target, moveType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>체스 말 객체는 여러가지 종류가 있다. (퀸, 킹, 폰, 비숍, 룩, 나이트)<br>Piece를 상속받아서 다양한 종류를 구현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> <span class="keyword">extends</span> <span class="title">Piece</span></span></span><br></pre></td></tr></table></figure><h2 id="체스-말-종류에-따라-달라지는-이동-범위"><a href="#체스-말-종류에-따라-달라지는-이동-범위" class="headerlink" title="체스 말 종류에 따라 달라지는 이동 범위"></a>체스 말 종류에 따라 달라지는 이동 범위</h2><p>체스 말 객체는 종류에 따라 이동 범위가 다르다.</p><p>문제는 각 클래스마다 이동 검증 로직이 중복되는 게 많다는 점이다!</p><h3 id="중복되는-코드"><a href="#중복되는-코드" class="headerlink" title="중복되는 코드"></a>중복되는 코드</h3><p>퀸 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen</span> <span class="keyword">extends</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; QUEEN_DIRECTION</span><br><span class="line">            = List.of(EAST, WEST, SOUTH, NORTH, SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> QUEEN_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반면 이건 룩 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bishop</span> <span class="keyword">extends</span> <span class="title">Piece</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; BISHOP_DIRECTION = List.of(SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bishop</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> BISHOP_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 잘 보면 movable 메서드 안에 로직이 중복됨을 알 수 있다. 이를 해결해보자.</p><h1 id="조합으로-중복-제거하기"><a href="#조합으로-중복-제거하기" class="headerlink" title="조합으로 중복 제거하기"></a>조합으로 중복 제거하기</h1><p>이때 체스 말 객체를 두가지로 나눠서 생각한다.</p><p><strong>이동하는 거리가 제한 없는 경우 VS 이동하는 거리가 제한 있는 경우</strong></p><p>전자는 퀸, 비숍, 룩이 해당한다.<br>후자는 폰, 킹, 나이트가 해당한다.</p><p>그렇다면 거리 제한 없이 이동하는 전략과 거리 제한이 있는 전략을 구분해서 추상화할 수 있지 않을까?</p><h2 id="인터페이스로-전략을-추상화해서-만들기"><a href="#인터페이스로-전략을-추상화해서-만들기" class="headerlink" title="인터페이스로 전략을 추상화해서 만들기"></a>인터페이스로 전략을 추상화해서 만들기</h2><p>모든 종류의 체스 말들이 자신의 이동여부를 확인할 수 있도록하는 인터페이스를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>자신의 위치, 목표 위치, 움직임이 공격인지를 전달받아 해당 목표로 갈 수 있는지 판단한다.</p><h2 id="이동하는-거리가-제한-없는-경우"><a href="#이동하는-거리가-제한-없는-경우" class="headerlink" title="이동하는 거리가 제한 없는 경우"></a>이동하는 거리가 제한 없는 경우</h2><p>인터페이스를 구현해서 먼저 이동하는 거리가 제한이 없는 경우의 전략을 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnlimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnlimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하는 거리가 제한이 없는 전략은 가려는 목표지점의 방향이 내가 갈 수 있는 방향인지만 검사하면 된다.</p><p>즉 룩의 경우 상하좌우로 거리제한없이 이동할 수 있다.<br>룩이 가려는 목표 지점이 상하좌우 방향 중 하나에 있다면, 룩은 그 목표로 갈 수 있다.<br>(이동 경로에 다른 누군가 있는 경우나 목표 지점이 같은 편이 있는 경우는 다른 곳에서 검증한다.)</p><h2 id="이동하는-거리가-제한된-경우"><a href="#이동하는-거리가-제한된-경우" class="headerlink" title="이동하는 거리가 제한된 경우"></a>이동하는 거리가 제한된 경우</h2><p>이동하는 거리가 제한된 경우의 전략을 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> moveLimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections, <span class="keyword">int</span> moveLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">        <span class="keyword">this</span>.moveLimit = moveLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Distance distance = source.getDistance(target);</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction) &amp;&amp; distance.isInRange(moveLimit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하려는 거리 제한이 있으면 두 위치간에 거리를 추가로 확인해주면 된다.</p><h2 id="폰의-이동-전략"><a href="#폰의-이동-전략" class="headerlink" title="폰의 이동 전략"></a>폰의 이동 전략</h2><p>폰의 이동 전략은 꽤 까다롭다.</p><p>첫 위치에서 움직이는 경우 전진을 두칸까지 할 수 있다.<br>공격은 반드시 전진 방향 대각선으로 할 수 있다.</p><p>이를 위해서는 MoveType에 따라 다른 전략을 만들어서 실행해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PawnMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_MOVE_LIMIT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOT_FIRST_MOVE_LIMIT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACK_LIMIT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; nonAttackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; attackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Rank startRank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PawnMovableStrategy</span><span class="params">(List&lt;Direction&gt; nonAttackDirection, List&lt;Direction&gt; attackDirection, Rank startRank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nonAttackDirection = nonAttackDirection;</span><br><span class="line">        <span class="keyword">this</span>.attackDirection = attackDirection;</span><br><span class="line">        <span class="keyword">this</span>.startRank = startRank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (moveType.isAttack()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(attackDirection, ATTACK_LIMIT).movable(source, target, moveType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nonAttackMovable(source, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonAttackMovable</span><span class="params">(Square source, Square target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.isSameRank(startRank)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                    MoveType.MOVE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, NOT_FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                MoveType.MOVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>폰의 이동전략을 수행하기 위해서는 자신의 첫 위치 시점(starkRank), 공격가능 방향(attckDirection), 이동 가능 방향(nonAttackDirection)을 주입받는다.</p><p>현재 이동하려는 것이 공격이면 공격에 맞는 방향과 거리로 검증한다.<br>반면 그냥 이동하려는 경우는 이동에 맞는 방향과 거리로 검증한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java의 Call by Value</title>
      <link>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</guid>
      <pubDate>Sat, 02 Apr 2022 09:11:48 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바에는 Call by Value만 존재한다.&lt;br&gt;Call by Value는 함수의 인자에 값을 전달하는 방식이고,&lt;br&gt;Call by Reference는 함수의 인자에 주소를 </description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>자바에는 Call by Value만 존재한다.<br>Call by Value는 함수의 인자에 값을 전달하는 방식이고,<br>Call by Reference는 함수의 인자에 주소를 전달하는 방식이다.</p><h1 id="Call-by-Value-vs-Call-by-Reference"><a href="#Call-by-Value-vs-Call-by-Reference" class="headerlink" title="Call by Value vs Call by Reference"></a>Call by Value vs Call by Reference</h1><p>프로그래밍 언어에서 함수에 인자로 전달하는 방식에 따라 나뉜다.</p><h2 id="Call-by-Value"><a href="#Call-by-Value" class="headerlink" title="Call by Value"></a>Call by Value</h2><p>Call by Value는 함수 호출시 전달되는 변수의 값을 복사해서 전달한다.<br>이렇게 전달된 인자는 외부에서 있었던 변수와는 달리 함수 내부의 지역 변수로 활용된다.<br>즉 함수 안에서 인자를 변경해도 외부 변수 값은 변경되지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드를 살펴보자.<br>swap 함수는 두 int형 변수의 값을 바꾸는 함수다. 그런데 테스트 결과는 맞지 않게 나온다.<br>원인은 swap 함수에서 변수를 가져오는 과정이 Call by Value이기 때문이다.</p><p>테스트 코드에서 전달한 a와 swap 내부에서의 a는 서로 영향을 주지 않는다.<br>테스트 코드의 a에 저장된 1이라는 값을 복사해서 메서드의 a에 저장한 것일 뿐이다.</p><h2 id="Call-by-Reference"><a href="#Call-by-Reference" class="headerlink" title="Call by Reference"></a>Call by Reference</h2><p>Call by Reference는 함수 호출 시 전달되는 변수의 참조값을 전달하는 방식이다.<br>함수가 인자로 주소값을 전달받고나서 이를 함수 내부에서 접근하여 수정하면,<br>함수 외부의 변수도 변화가 생길 수 있다.</p><h1 id="Java의-Call-by-Value"><a href="#Java의-Call-by-Value" class="headerlink" title="Java의 Call by Value"></a>Java의 Call by Value</h1><blockquote><p>Java는 전달되는 인자의 타입에 따라 약간 다르게 보인다.</p></blockquote><h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2><p>자바는 8가지 원시 타입이 있다.<br>(byte, short, int, long, float, double, char, boolean)</p><p>원시 타입 변수들은 스택 메모리에 그대로 저장된다.<br>그래서 원시 타입이 인자로 전달될 때는 스택에 저장된 값 그대로 복사되어서 전달된다.</p><p>전달된 값은 원래 변수와는 다른 별개의 변수. 즉 Call by Value 방식으로 전달된다.<br>전달된 갑쇼은 해당 메서드가 종료되면 스택에서 제거된다. </p><h4 id="예시로-이해하기"><a href="#예시로-이해하기" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//1단계</span></span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//2단계</span></span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c;</span><br><span class="line">        c = d;</span><br><span class="line">        d = tmp; <span class="comment">//3단계</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까 본 예시로 다시 이해해보자.</p><p>1단계까지 실행하고 나면 스택에는 a &#x3D; 1, b &#x3D; 2 라는 정보를 저장하게 된다.<br>2단계를 실행하고 나면 a &#x3D; 1, b &#x3D; 2 라는 정보에 새로운 스택 프레임이 생기고 그곳에 c &#x3D; 1, d &#x3D; 2가 생긴다.<br>즉 (a &#x3D;1 , b &#x3D; 2), (c &#x3D; 1, d &#x3D; 2) 이런 식으로 스택에 저장된다.</p><p>이제 3단계까지 실행하면 스택은 (a &#x3D; 1, b &#x3D;2), (c &#x3D; 2, d &#x3D; 1, tmp &#x3D; 1) 이렇게 저장된다.<br>swap 메서드가 종료되면 swap 메서드의 프레임이 종료되므로 결국 (a &#x3D; 1, b &#x3D; 2)만 스택에 남는다.</p><h2 id="참조-타입"><a href="#참조-타입" class="headerlink" title="참조 타입"></a>참조 타입</h2><p>참조 타입은 쉽게 말해서 객체의 주소를 저장하는 타입이다.<br>보통 기본 타입을 제외한 모든 것을 의미한다.</p><p>참조 타입은 기본 타입과 다르게 값 그 자체를 저장하지 않는다.<br>대신 그 값의 주소 값을 저장한다.</p><p>그렇다면 그 값의 주소는 어디의 주소를 의미하는 걸까?<br>그 주소는 바로 힙 영역에 있는 인스턴스의 주소를 의미한다.</p><p>즉 참조 타입은 객체의 주소를 가지고 스택에 저장되고,<br>그 주소는 힙 영역에 있는 인스턴스의 주소다.</p><p>앞서서 자바는 Call by Value라고 했다.<br>참조 타입도 예외는 아니다. Call by Value다.<br>다만 전달되는 Value가 주소값이라서 기본 타입과는 다르게 작동한다.</p><h4 id="예시로-이해하기-1"><a href="#예시로-이해하기-1" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callByValueObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserAge a = <span class="keyword">new</span> UserAge();</span><br><span class="line">        a.value = <span class="number">1</span>;</span><br><span class="line">        UserAge b = <span class="keyword">new</span> UserAge();</span><br><span class="line">        b.value = <span class="number">2</span>;<span class="comment">//1단계</span></span><br><span class="line">        swap(a, b);<span class="comment">//2단계</span></span><br><span class="line">        assertThat(a.value == <span class="number">2</span> &amp;&amp; b.value == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(UserAge c, UserAge d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c.value;</span><br><span class="line">        c.value = d.value;</span><br><span class="line">        d.value = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAge는 int 형 데이터를 저장하는 클래스다.<br>이제 두개의 UserAge를 만들어서 값을 변경하는 swap 메서드에 전달해보자.</p><p>1단계까지 오면 스택에 a &#x3D; UserAge 주소값1, b &#x3D; UserAge 주소값2 이 오게된다.<br>우리가 만든 실제 객체는 힙 영역에 있고 스택의 주소값은 힙 영역을 가르키는 값이다.</p><p>2단계까지 오면 이제 새로운 스택 프레임이 생긴다.<br>c와 d에 a, b가 가진 값(즉 주소값)을 복사해서 넣어준다. 즉 Call by Value 방식으로 전달한다.</p><p>스택에는 (a &#x3D; UserAge주소1, b &#x3D; UserAge주소2), (c &#x3D; UserAge주소1, d &#x3D; UserAge주소2) 이렇게 저장된다.</p><p>이때 주목할 점은 a와 c가 같은 주소값을 저장하고 있고, b와 d가 같은 값을 저장하고 있다는 점이다.<br>이제 c를 통해 힙에 있는 인스턴스를 변경하면 나중에 a를 통해 인스턴스에 접근했을 때 값이 변경되어 있게 된다.<br>(b와 d도 같은 관계다.)</p><blockquote><p>정리</p></blockquote><p>자바는 모두 Call by Value이다.<br>다만 원시 타입은 값 자체를 복사해서 전달하고,<br>참조 타입은 참조하는 객체의 주소를 복사해서 전달한다.</p><p><em>참고</em></p><p><a href="https://deveric.tistory.com/92">https://deveric.tistory.com/92</a><br><a href="https://www.baeldung.com/java-pass-by-value-or-pass-by-reference">https://www.baeldung.com/java-pass-by-value-or-pass-by-reference</a><br><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a><br><a href="https://kingpodo.tistory.com/54">https://kingpodo.tistory.com/54</a><br><a href="https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame">https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame</a><br><a href="https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference">https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>상속과 조합</title>
      <link>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</guid>
      <pubDate>Sat, 12 Mar 2022 04:28:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;상속의-위험성&quot;&gt;&lt;a href=&quot;#상속의-위험성&quot; class=&quot;headerlink&quot; title=&quot;상속의 위험성&quot;&gt;&lt;/a&gt;상속의 위험성&lt;/h1&gt;&lt;p&gt;상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.&lt;br&gt;내가 필요로 하는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="상속의-위험성"><a href="#상속의-위험성" class="headerlink" title="상속의 위험성"></a>상속의 위험성</h1><p>상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.<br>내가 필요로 하는 클래스와 매우 유사한 클래스가 있다면 해당 클래스를 상속하면 같은 코드를 여러번 쓸 필요가 줄어든다.</p><p>상속은 코드 재사용을 위해 캡슐화를 희생시킨다. 부모 클래스의 코드를 재활용하기 위해 자식 클래스도 재활용할 코드를 모두 공개되기 때문이다.</p><blockquote><p>경고 1. 자식 클래스 메서드 안에서 super 참조로 부모 클래스의 메서드를 직접 호출하면 두 클래스의 결합도가 높아진다. (super 참조를 제거하라.)</p></blockquote><p>상속을 염두해두고 설계하지 않은 클래스를 상속하기 어렵다.<br>기존의 코드를 다른 상황에 재사용하기 위해서는 개발자가 나름의 해석을 하고 가정한다.<br>그러나 개발자의 가정을 이해해야 하는 코드는 읽기가 어려워진다.</p><p>실제 요구사항과 구현이 다르면 우리는 기존의 구현을 요구사항과 같은 결과를 나타내도록 많은 가정을 하게된다.</p><p>상속을 하려면 부모 클래스의 가정과 추론 과정을 정확하게 이해해야 한다.<br>상속은 부모 클래스의 구체적인 구현을 이해해야 할 가능성이 높다. 그래서 결합도(다른 모듈에 대해 알고 있어야할 지식의 수준)가 높다.</p><p>자식 클래스가 부모 클래스의 변경이 취약해진다. 취약한 기반 클래스 문제.<br>만약 부모 클래스의 변경된 부분이 자식 클래스에 파생되는 행동이라면, 자식 클래스의 행동이 예상과 다르게 작동 될 수 있다. </p><p>상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만든다.<br>상속은 부모 클래스의 퍼블릭 인터페이스가 아닌 다른 곳을 고쳐도 영향을 받는다. 이게 캡슐화를 약화시킨다는 증거다.</p><blockquote><p>경고 2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.</p></blockquote><p>코드 재활용을 하기 위해 부모 클래스를 상속 할 경우, 부모에서 공개 됐던 메서드들이 자식 클래스의 내부 규칙을 깨트릴 수 있다.</p><p>오브젝트에서 제시한 예시는 Vector를 상속받는 Stack이다.<br>Stack은 push와 pop으로만 데이터를 수정할 수 있다. 그러나 Vector는 퍼블릭 인터페이스로 다양한 인덱스에 add할 수 있게한다. 이는 Stack의 규칙을 깨트리는 방식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line"></span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>); <span class="comment">//이건 Vector의 퍼블릭 인터페이스. 스택의 규칙에 어긋난 행동</span></span><br></pre></td></tr></table></figure><blockquote><p>경고 3. 자식이 부모의 메서드를 오버라이딩하면 부모의 다른 메서드가 자식의 메서드를 결합하게 될 수 있다.</p></blockquote><p>부모 클래스의 특정 메서드를 자식 클래스가 오버라이딩 하게 되면, 부모 클래스에서 해당 클래스를 원래의 메서드(즉 오버라이딩 되기 전 메서드)를 예상하고 사용했던 부분에서 예기치 못한 작동(오버라이딩 된 메서드)를 수행할 수 있다.</p><blockquote><p> 경고 4. 부모 클래스에 변화가 생기면 자식도 같이 변해야 되는 일이 생길 수 있다. 상속은 결합도가 높아서, 부모와 자식이 같이 변하거나, 자식과 부모를 변경하지 않거나 두가지 선택지 밖에 없다.</p></blockquote><p>부모 클래스를 오버라이딩 하지 않고 불필요한 퍼블릭 인터페이스를 상속받지 않아도 부모의 중요한 부분이 변경되면 자식 클래스도 같이 변경될 수 밖에 없다.</p><h1 id="상속을-보다-안전하게-사용하기"><a href="#상속을-보다-안전하게-사용하기" class="headerlink" title="상속을 보다 안전하게 사용하기"></a>상속을 보다 안전하게 사용하기</h1><h2 id="추상화에-의존"><a href="#추상화에-의존" class="headerlink" title="추상화에 의존"></a>추상화에 의존</h2><p>자식 클래스가 부모 클래스의 구현이 아닌 부모 클래스의 추상화에 의존해야 한다.<br>더 정확하게 말하면 부모와 자식 모두 추상화에 의존해야 한다.</p><h3 id="달라지는-부분을-찾아-메서드로-분리"><a href="#달라지는-부분을-찾아-메서드로-분리" class="headerlink" title="달라지는 부분을 찾아 메서드로 분리"></a>달라지는 부분을 찾아 메서드로 분리</h3><p>비슷해보이는 클래스 간에 서로 다른 부분을 메서드를 추출한다.<br>그러면 다른 부분을 제외하면 나머지 메서드들은 동일하게 된다.<br>그러면 이제 중복 코드를 부모 클래스로 올린다.<br>그리고 달라지는 부분은 부모의 추상 메서드로, 각 클래스들이 구현하도록 하면 된다.</p><p>이제 자식 클래스들은 부모의 추상 메서드에만 의존하게 되므로 느슨하게 결합된다.</p><p>하지만 이런 추상 클래스를 활용한 추상화에 의존하는 방법도 문제가 있다.<br>객체 행동만 변하면 각 클래스를 독립적으로 변경시키면 되겠지만, 인스턴스 변수가 추가되는 경우는 다르다.<br>부모 클래스에 인스턴스 변수가 추가되어 객체 생성때 초기화해줘야 하는 경우, 상속되는 모든 클래스는 수정을 해줘야 한다.</p><h1 id="합성을-활용하기"><a href="#합성을-활용하기" class="headerlink" title="합성을 활용하기"></a>합성을 활용하기</h1><p>상속은 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 방법.<br>합성은 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.</p><p>합성은 구현에 의존하지 않는다.<br>합성은 내부 부분 객체의 퍼블릭 인터페이스에 의존한다. 즉 구현에 의존하는 것이 아닌 인터페이스에 의존하도록 할 수 있다.<br>합성은 내부 부분 객체의 구현 방식이 변경되어도 전체 객체는 영향이 적다.</p><p>상속은 정적인 관계인데 합성은 동적인 관계이다.<br>코드 작성 때 정해진 상속 관계를 실행 시점에서 변경이 불가능하다.<br>반면 합성 관계는 코드 작성 때 정해진 관계를 실행 시점에서 변경이 가능하다.</p><p>상속을 합성으로 바꾸는 방법은 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p><h2 id="합성의-안전성"><a href="#합성의-안전성" class="headerlink" title="합성의 안전성"></a>합성의 안전성</h2><p>불필요한 인터페이스 상속 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 규칙에 맞게 인스턴스의 퍼블릭 인터페이스를 활용하면 된다.</p><p>메서드 오버라이딩 오작동 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 메서드가 부모 인스턴스의 메서드를 오버라이딩해서 부모 인스턴스의 퍼블릭 인터페이스와 협력하면 된다.<br>(이때 오버라이딩한 인스턴스 메서드가 인스턴스에게 동일한 메서드 호출을 전달하는 메서드를 포워딩 메서드라고 한다.)</p><p>부모 클래스와 자식 클래스의 동시 수정 문제<br>합성이 이 문제를 완전히 해결하지는 못한다. 하지만 조합된 내부 인스턴스의 변경사항을 최대한 캡슐화 시킬 수 있다.</p><h2 id="합성의-유연성"><a href="#합성의-유연성" class="headerlink" title="합성의 유연성"></a>합성의 유연성</h2><p>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함.</p><p>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많이 늘어날 수 있다.</p><p>추상 메서드와 훅 메서드<br>추상 메서드 : 개방 - 폐쇄 원칙을 만족하기 위한 설계. 하위 계층이 오버라이딩해서 구현<br>훅 메서드 : 추상 메서드는 반드시 모두가 구현해야 해서 불편하다. 대부분의 하위 계층이 똑같이 구현하면 중복 코드가 많이 생기기 때문에 기본 구현을 해놓고 달라지는 경우에만 오버라이딩하는 메서드</p><p>기능 추가를 할 때 상속을 남용하면 필요 이상으로 클래스가 만들어진다.(클래스 폭발, 조합의 폭발)<br>이런 문제는 자식 클래스와 부모 클래스의 다양한 조합이 필요한데 상속은 컴파일 타임에 관계가 결정되어 버려서 모든 조합을 미리 만들어놓으면서 생기는 문제다.</p><p>합성을 사용하면 컴파일 타임에서 정한 관계를 런타임에서 수정할 수 있다.<br>상속은 조합의 결과를 개별의 클래스에 밀어넣는 방법이고, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 다음 런타임에서 인스턴스를 조립하는 방식이다.</p><h1 id="그러면-상속은-언제-사용하는가"><a href="#그러면-상속은-언제-사용하는가" class="headerlink" title="그러면 상속은 언제 사용하는가"></a>그러면 상속은 언제 사용하는가</h1><p>코드 재활용을 목적으로 상속하면 변경하기 어렵고 유연하지 못하게 된다.<br>만약 상속을 사용하려고 할 때 스스로에게 물어보자.<br>내가 상속을 이용하는게 코드 재사용을 위한 것인가? 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위한 것인가? (코드 재사용을 위한 것이면 상속을 피해야 한다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 함수</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</guid>
      <pubDate>Fri, 04 Mar 2022 08:37:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;함수는-한-가지만-해라&quot;&gt;&lt;a href=&quot;#함수는-한-가지만-해라&quot; class=&quot;headerlink&quot; title=&quot;함수는 한 가지만 해라!&quot;&gt;&lt;/a&gt;함수는 한 가지만 해라!&lt;/h3&gt;&lt;p&gt;함수에 적힌 코드들의 추상화 수준이 같은 단계로 통</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="함수는-한-가지만-해라"><a href="#함수는-한-가지만-해라" class="headerlink" title="함수는 한 가지만 해라!"></a>함수는 한 가지만 해라!</h3><p>함수에 적힌 코드들의 추상화 수준이 같은 단계로 통일시켜라는 의미다.<br>혹은 함수 내에서 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 셈이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parseInt(token));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">        lottoNumbers.add(<span class="keyword">new</span> LottoNumber(number));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(lottoNumbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 크게 추상화 단계가 두가지이다.</p><ul><li>문자열을 숫자로 바꾸는 단계 (추상화 단계 낮음)</li><li>숫자를 LottoNumber로 바꾸는 단계 (추상화 단계 중간)</li><li>LottoNumber를 Lotto로 바꾸는 단계 (추상화 단계 높음)</li></ul><p>이제 이 작업들을 나눠서 리팩토링 해보자.<br>자연스럽게 내려가기 규칙이 적용되서 다음에 오는 함수는 추상화 단계가 하나씩 줄어드는 걸 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(createLottoNumbers(tokens));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;LottoNumber&gt; <span class="title">createLottoNumbers</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : parseAll(tokens)) &#123;</span><br><span class="line">        lottoNumbers.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lottoNumbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">parseAll</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parse(token));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="함수-인수"><a href="#함수-인수" class="headerlink" title="함수 인수"></a>함수 인수</h3><p>함수에 전달되는 인수는 0개가 제일 좋다.<br>3개 이상은 되도록 피해야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 의미 있는 이름</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</guid>
      <pubDate>Fri, 04 Mar 2022 05:44:23 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;의도를-분명히-밝혀라&quot;&gt;&lt;a href=&quot;#의도를-분명히-밝혀라&quot; class=&quot;headerlink&quot; title=&quot;의도를 분명히 밝혀라&quot;&gt;&lt;/a&gt;의도를 분명히 밝혀라&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="의도를-분명히-밝혀라"><a href="#의도를-분명히-밝혀라" class="headerlink" title="의도를 분명히 밝혀라"></a>의도를 분명히 밝혀라</h3><ol><li>변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</li><li>어떤 일을 수행하는가?</li><li>어떻게 사용하는가?</li></ol><p>이름으로 위 세가지가 표현이 안된다면 문제가 있다.</p><h4 id="변수의-이름은-범위-크기에-비례해야-한다"><a href="#변수의-이름은-범위-크기에-비례해야-한다" class="headerlink" title="변수의 이름은 범위 크기에 비례해야 한다."></a>변수의 이름은 범위 크기에 비례해야 한다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pricePerLotto = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> Prizesum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Lotto lotto : lottos) &#123;</span><br><span class="line">    prizeSum += pricePerLotto * lotto.getPrize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이름이 길수록 사용되는 범위가 넓다고 생각하자.<br>예를 들면 for 문의 i는 해당 루프에서만 사용되서 짧아도 된다.<br>이름이 길수록 검색도 용이하다.</p><h4 id="맥락을-추가하라"><a href="#맥락을-추가하라" class="headerlink" title="맥락을 추가하라"></a>맥락을 추가하라</h4><p>이름 그 자체로 의미를 분명히 보여주는 변수는 없다.<br>함수나 클래스에서 맥락을 부여하면 이름을 더 자연스럽게 읽힐 수 있다.<br>이마저도 힘들면 접두사를 붙일 수 있다. (stateName, 이런 식으로..)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">(String name, String position)</span> </span>&#123;</span><br><span class="line">    System.out.println(name + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name는 어떤 이름을 의미하고, positon는 어떤 위치를 표시하는 건지 도저히 알 수 없다.</p><p>이름과 포지션은 사실 자동차의 이름과 자동차의 위치를 말해주는 변수들이다.<br>그럼 이를 더 잘 알려주기 위해 맥락을 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Car라는 맥락 안에서 이름과 위치를 파악하면 좀 더 의미있게 파악할 수 있다.</p><h4 id="불필요한-맥락-제거"><a href="#불필요한-맥락-제거" class="headerlink" title="불필요한 맥락 제거"></a>불필요한 맥락 제거</h4><p>그렇다고 불필요하게 맥락을 이름에 붙여주는건 불필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carPosition;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 Car라는 맥락 안에서 쓰이는 이름에 굳이 car를 붙이지 않아도 되지않을까?</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</guid>
      <pubDate>Thu, 03 Mar 2022 15:47:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.&lt;br&gt;이런 영향력이 있는 자원을</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.<br>이런 영향력이 있는 자원을 클래스 내부에서 만들면 안된다.<br>대신 이 자원(혹은 자원을 만드는 팩토리)을 해당 클래스를 인스턴스화 할 때 넘겨주자.</p><h3 id="자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴"><a href="#자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴" class="headerlink" title="자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴"></a>자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴</h3><p>맞춤법 검사기가 사전을 자원으로 가진다고 가정하자.<br>만약 사전을 직접 명시한다는 건 어떤 얘기일까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정적 유틸리티를 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 방지</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//싱글톤을 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SpellChecker INSTANCE = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두 예시 모두 자원인 사전을  final로 직접 명시하고 있다. </p><ul><li>나중에 다른 사전을 사용하고 싶을 때 변경이 힘들어진다.</li><li>final을 제거하고 사전을 교체하는 메서드를 추가하는 방식은 멀티스레드 환경에 쓸 수 없음.</li></ul><p><strong>즉 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식을 사용하면 안된다!</strong></p><h3 id="의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기"><a href="#의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기" class="headerlink" title="의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기"></a>의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Dictionary dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>자원이 많거나 의존 관계가 어떻든 잘 작동</li><li>불변성을 지원</li><li>생성자, 정적 팩터리, 빌더 모두에 적용 가능</li></ul><h3 id="자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt"><a href="#자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt" class="headerlink" title="자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;"></a>자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Supplier&lt;? extends Dictionary&gt; dictionaryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionaryFactory.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자원 팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.<br>자바에서는 Supplier&lt;T&gt;가 해당한다.</p><p>위처럼 생성자(정적 팩토리 메서드나 빌더)에 팩토리를 넘겨받으면 다음같이 활용 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpellChecker englishChecker = <span class="keyword">new</span> SpellChecker(() -&gt; <span class="keyword">new</span> Dictionary(Language.ENGLISH));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인스턴스화를 막으려거든 private 생성자를 사용해라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</guid>
      <pubDate>Thu, 03 Mar 2022 15:04:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;인스턴스화하지-않으려는-클래스&quot;&gt;&lt;a href=&quot;#인스턴스화하지-않으려는-클래스&quot; class=&quot;headerlink&quot; title=&quot;인스턴스화하지 않으려는 클래스?&quot;&gt;&lt;/a&gt;인스턴스화하지 않으려는 클래스?&lt;/h3&gt;&lt;p&gt;객체지향적이지 않지만 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="인스턴스화하지-않으려는-클래스"><a href="#인스턴스화하지-않으려는-클래스" class="headerlink" title="인스턴스화하지 않으려는 클래스?"></a>인스턴스화하지 않으려는 클래스?</h3><p>객체지향적이지 않지만 필요할 때가 있다.<br>java.lang.Math, java.util.Array 같이 기본 타입 값이나 배열 관련 메서드를 모아둔 곳<br>java.util.Collections와 같이 특정 인터페이스를 구현한 객체를 생성하는 정적 메서드를 모아둔 곳.<br>final 클래스와 관련된 메서드를 모아놓을 때. (final 클래스를 상속해서 하위 클래스에 메서드를 못넣음)</p><h3 id="인스턴스화-하지-않으려면-private-생성자를-사용"><a href="#인스턴스화-하지-않으려면-private-생성자를-사용" class="headerlink" title="인스턴스화 하지 않으려면 private 생성자를 사용"></a>인스턴스화 하지 않으려면 private 생성자를 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NotInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private로 기본 생성자를 해놓으면 외부에서 인스턴스화를 막을 수 있다.<br>Private 기본 생성자를 해놓으면 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문이다.</p><p>Private 기본 생성자는 상속도 못하게 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super(); 가 생략되어 있음. </span></span><br><span class="line"><span class="comment">//부모 객체의 생성자가 private면 이 과정이 안되니 상속이 안된다.      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>추상 클래스의 위험성</p></blockquote><p>추상 클래스 그 자체는 인스턴스화할 수 없다.</p><p>하지만, 추상 클래스는 상속한 클래스를 통해 인스턴스화 할 수 있다.<br>게다가 사용자가 추상 클래스를 보면 인스턴스화 하지 말라고 이해하지 않고, 상속받아서 사용하라고 이해하기 때문에 더 위험하다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
