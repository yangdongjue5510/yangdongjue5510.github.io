<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Sat, 11 Feb 2023 14:02:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>우테코 수료 이후 새로운 프로젝트 준비까지 회고</title>
      <link>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/</guid>
      <pubDate>Sat, 11 Feb 2023 12:43:04 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;실패-그리고-반성&quot;&gt;&lt;a href=&quot;#실패-그리고-반성&quot; class=&quot;headerlink&quot; title=&quot;실패 그리고 반성&quot;&gt;&lt;/a&gt;실패 그리고 반성&lt;/h1&gt;&lt;p&gt;우아한테크코스가 끝난 뒤 본 면접들에서 모두 떨어졌다. 이유를 정확히 알 수</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="실패-그리고-반성"><a href="#실패-그리고-반성" class="headerlink" title="실패 그리고 반성"></a>실패 그리고 반성</h1><p>우아한테크코스가 끝난 뒤 본 면접들에서 모두 떨어졌다. 이유를 정확히 알 수 없지만 내가 느끼기에는 여러가지 아쉬움이 있었다. 먼저 빠르고 정확하게 학습하는 습관을 만들지 못했다. 우아한테크코스를 하면서 주위 사람들이 공부하는 내용을 따라가기 급급했다. 원하는 지식이 무엇인지 차분히 고민하고, 집중해서 빠르고 정확하게 학습해야 하지 않았나 싶다. 시간 관리도 부족했다. 우아한테크코스에서 팀 프로젝트를 할 때 내 일정을 팀에서 주어지는 업무에 맞춰서 수동적으로 그리고 아무 시간 관리 전략 없이 막무가내로 시간을 보냈다.</p><h1 id="시간-관리하기"><a href="#시간-관리하기" class="headerlink" title="시간 관리하기"></a>시간 관리하기</h1><p>떨어지고 나서 먼저 나만의 시간 관리 시스템을 만들었다. 우아한테크코스 특강 중 칸반으로 자신의 일정을 관리하는 현업자 분의 이야기가 떠올랐다. 그 특강을 들을 당시 잠깐 해볼까 했지만 공부하느라 정신이 없어서 포기했었다. 새로 처음부터 다시 시작하려는 지금이 이런 시간 관리 방법을 고민하기 적절하다고 생각했다.</p><p>시간 관리는 노션의 칸반 보드로 구현했다. 대략 <code>백로그</code>-<code>이번주 할 일</code>-<code>오늘 할 일</code>-<code>하고 있는 일</code>-<code>대기 중인 일</code>-<code>다한 일</code> 이렇게 나눴다. 처음에는 매우 간단하게 시작했는데 시간 관리를 해보면서 내 목표와 맞게 추가하다 보니 단계가 늘었다.</p><p>칸반을 하면서 좋았던 점은 칸반에 할 일을 추가하는 과정에서 계획이 들어가고 그 계획이 시각화되어서 체감이 잘된다. 그리고 하나하나 일을 완료로 옮길 때마다 성취감을 느낄 수 있었다.</p><h2 id="단계-별로-계획하기"><a href="#단계-별로-계획하기" class="headerlink" title="단계 별로 계획하기"></a>단계 별로 계획하기</h2><p>나는 6개월 이후 취업을 목표로 칸반으로 시간 관리를 한다. 그렇기에 정해진 기간 안에 목표를 이루기 위해 남은 시간을 쪼개서 각 목표를 두고 학습해야 했다. 일단 6개월은 각 6개의 달로 나눌 수 있고, 하나의 달은 여러 주로 나눌 수 있다. 나는 먼저 내가 가고 싶은 기업의 2~3년차 경력직의 필요요건을 찾아서 대략 각 달마다 나눠서 할당했다. 물론 나에게 벅찰 수 있지만, 높은 목표를 설정하고 실행하는 과정에서 조정하면 된다고 판단했다. 그리고 각 달의 목표를 이루기 위해서 그 목표를 구체적인 여러 행동으로 나눠서 매 주마다 할당했다. 그래서 이번 주에 할당된 일은 칸반에서 <code>이번주 할 일</code>에서 시각화 된다. 마지막으로 한 주의 할일은 하루씩 나눠져서 실행된다. 이 내용은 칸반에서 <code>오늘 할 일</code>에서 시각화된다.</p><h1 id="새로운-프로젝트"><a href="#새로운-프로젝트" class="headerlink" title="새로운 프로젝트"></a>새로운 프로젝트</h1><p>나는 면접 탈락 이후 갈 곳이 있다. 썩 달갑지는 않지만 아직 학교를 한 학기를 다녀야 한다. 그래서 학교에서 어떤 수업을 들어야 하나 고민했다. CS 과목을 들을까? 사실 우아한테크코스 이전엔 네트워크와 데이터베이스 수업을 들었다. 학점도 각각 A+를 받았다. 그러나 이 경험이 취업에 큰 도움이 되지는 않았다. 차라리 혼자 공부하거나 스터디를 하는 게 더 유익하다고 판단했다. 그러면 비대면 꿀강의를 찾아서 신청할까? 일단 꿀강의 수강 신청에 실패하면 리스크가 크다. 그리고 꿀강의라고 해서 레포트나 퀴즈같은 성가신 일을 피할 순 없다.<br>마지막으로 남은 선택지는 프로젝트. 우리 학교는 참빛 설계학기라는 제도를 운영한다. 이 제도는 학생들이 주제를 자유롭게 정해서 지도 교수를 섭외해서 한 학기동안 진행하는 제도이다. 학점도 유연하게 받을 수 있고 지원금이 100만원(!)이나 된다! 프로젝트를 하기로 했다!</p><h2 id="프로젝트를-하면서-어려웠던-점"><a href="#프로젝트를-하면서-어려웠던-점" class="headerlink" title="프로젝트를 하면서 어려웠던 점"></a>프로젝트를 하면서 어려웠던 점</h2><p>프로젝트 주제는 학교 기자재 대여 웹 서비스 만들기이다. 대여 내역을 수기로 써서 관리하고 이 내용을 네이버 카페에 관리자들이 다시 전산화하는 불편한 방식을 개선하고자 한다.<br>애자일 방식으로 개발을 진행하려 할 때 어려운 점이 드러났다. 먼저 2주를 스프린트 기간이라고 하면, 그 주간안에 의미있는 소프트웨어 결과물이 나와야 한다. 우리팀은 기획 1명 프론트 2, 백엔드 1로 구성됐다. 한 스프린트 안에서 기능 계획, UX 레이아웃, API 설계 등 각자 작업을 하기전에 먼저 선행되어야 하는 작업이 있다. 그래서 그 작업이 되기 전까지는 개발이 되지 못한다. 이 경우 실질적인 개발 기간이 줄어드는데 이런 상황이 괜찮은 건지 고민된다.<br>그리고 기능을 계획하는 과정에서도 어려움이 있었다. 에픽을 선정하는 과정이 어려웠다. 스토리는 직관적이라 가능했는데, 이를 에픽으로 어떤 기준으로 묶어야 하는지가 어려웠다. 그래서 일단 첫 스프린트는 스토리의 동사에서 에픽을 추출해서 묶기로 했다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링과 JPA 환경에서 동시성 문제 해결하기</title>
      <link>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/</guid>
      <pubDate>Fri, 10 Feb 2023 12:50:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;동시성-문제&quot;&gt;&lt;a href=&quot;#동시성-문제&quot; class=&quot;headerlink&quot; title=&quot;동시성 문제&quot;&gt;&lt;/a&gt;동시성 문제&lt;/h1&gt;&lt;p&gt;동시성 문제는 공유 자원을 여러 스레드가 수정할 때 공유 자원의 일관성이 깨지는 상황을 말한다. </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="동시성-문제"><a href="#동시성-문제" class="headerlink" title="동시성 문제"></a>동시성 문제</h1><p>동시성 문제는 공유 자원을 여러 스레드가 수정할 때 공유 자원의 일관성이 깨지는 상황을 말한다. 예를 들어 내 계좌에 1000원을 두 스레드가 동시에 입금하려고 한다고 가정해보자.</p><p>병렬로 스레드가 작업을 수행하고 위에서 부터 시간순으로 진행됨을 나타낸다.<br>스레드 A가 남은 금액 조회 : 0원<br>스레드 B가 남은 금액 조회 : 0원<br>스레드 A가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)<br>스레드 B가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)<br>스레드 A가 커밋하면서 금액을 1000원으로 업데이트 : 1000원<br>스레드 B가 커밋하면서 금액을 1000원으로 업데이트 : 1000원(어라? 1000원을 두 스레드가 입금하면 2000원이 되어야 한다!!!!)</p><p>위 예시를 보면 알 수 있듯이 공유 자원드 아무 제약 없이 조회(획득)해서 각자 작업을 하고 업데이트 하는 경우 예상하지 못한 결과가 나올 수 있다.</p><h1 id="예시-코드"><a href="#예시-코드" class="headerlink" title="예시 코드"></a>예시 코드</h1><p>먼저 도메인 엔티티는 간략하게 포인트 하나만 둔다. 이 포인트 객체는 사용자의 포인트 누적액과 포인트 적립과 사용에 쓰이는 바코드를 포함한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">val</span> barcode: String,</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그리고 바코드에 해당하는 포인트 객체를 조회하는 메서드를 포함한 레포지토리 코드이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcode</span><span class="params">(barcode: <span class="type">String</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 서비스 코드이다. (주입받는 부분은 생략하고 메서드만 표기했다.)<br>이해를 위해 매우 간략하게 구현된 점을 이해하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUp</span><span class="params">(shopId: <span class="type">Long</span>, barcode: <span class="type">String</span>, amount: <span class="type">Long</span>)</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">val</span> point = pointRepository.findByBarcode(barcode)</span><br><span class="line">        .orElseGet &#123; pointRepository.save(Point(<span class="number">0</span>, barcode)) &#125; <span class="comment">// 기존의 바코드가 존재하지 않으면 새 객체를 만들어서 영속화한다.</span></span><br><span class="line">    point.amount += amount</span><br><span class="line">    <span class="keyword">return</span> point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이를 테스트 하기 위해 테스트 메서드를 만들어보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="string">&quot;포인트 적립 동시성 문제 검증&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUp_concurrency</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> threadCount = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> executorService = Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> countDownLatch = CountDownLatch(threadCount)</span><br><span class="line">    <span class="keyword">val</span> barcodeValue = <span class="string">&quot;1234567890&quot;</span></span><br><span class="line">    callSaveUp(<span class="number">1</span>, barcodeValue) <span class="comment">//적립할 양과 바코드를 받아 적립하는 메서드이다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.threadCount) &#123;</span><br><span class="line">        executorService.submit &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callSaveUpAPI( <span class="number">1</span>, barcodeValue)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await()</span><br><span class="line">    <span class="keyword">val</span> point = pointRepository.findByBarcode(barcodeValue)</span><br><span class="line">        .orElseThrow()</span><br><span class="line">    assertThat(point.amount).isEqualTo((threadCount + <span class="number">1</span>).toLong())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CountDownRatch?<br>CountDownRatch는 어떤 스레드가 다른 스레드에서 작업이 완료될 때까지 기다릴 수 있도록 해주는 클래스다. 위 예시에서는 작업을 하는 스레드들이 완료될 때마다 countDown을 해서 모든 스레드들이 작업을 마칠 때까지 await하도록 구현했다.</p></blockquote><h1 id="synchronized-키워드"><a href="#synchronized-키워드" class="headerlink" title="synchronized 키워드"></a>synchronized 키워드</h1><p>먼저 자바 및 코틀린에서 쉽게 생각할 수 있는 synchronized 키워드를 사용할 수 있다. 미리 말하자면, 이 방법은 확장성에 좋지않고 스프링에서는 고려해야할 부분이 있다.</p><ol><li>확정성에 좋지 않은 이유.<br>synchronized는 해당 어플리케이션 안에서만 유효하다. 즉 여러 서버를 운영하게 되면 여러 어플리케이션이 요청을 처리하게 되는데, 자신이 아닌 다른 어플리케이션의 요청은 제어할 수 없게된다.</li><li>스프링에서 고려해야 하는 부분. <code>@Transactional</code><br>일반적으로 서비스 계층에서 <code>@Transactional</code>을 사용해서 각 요청에 트랜잭션을 적용한다. 하지만 스프링은 트랜잭션을 프록시로 처리하게 된다. 즉 원래 메서드를 감싼 외부 메서드가 존재하게 된다. 업데이트는 트랜잭션 종료 시 실행되는데 스프링에서는 원래 메서드가 종료되면 외부 메서드에서 트랜잭션 종료 처리릃 하게 된다. 즉 값의 반영이 되지 않은 시점에서 다른 스레드가 원래 메서드를 통해 반영되지 않은 값을 조회할 수 있다.</li></ol><h1 id="Database에서-해결하기"><a href="#Database에서-해결하기" class="headerlink" title="Database에서 해결하기"></a>Database에서 해결하기</h1><p>데이터베이스의 Lock을 활용해서 해결할 수 있다.</p><h2 id="낙관적-락"><a href="#낙관적-락" class="headerlink" title="낙관적 락"></a>낙관적 락</h2><p>낙관적 락은 서비스 특성 상 동시성 문제가 발생할 경우가 적은 상황에서 사용한다. 실제로는 락을 사용한다기 보다는 수정 시점을 기록하는 칼럼(버전)을 통해 동시성 문제를 일으키는 쿼리를 감지하는 방식이다.</p><p>엔티티에 버전을 기록하는 칼럼을 추가하고, 조회했을 때 버전과 값을 변경해서 반영할 때의 버전이 같아야 반영하고 버전을 +1하는 방식이다. </p><p>가령 여러 스레드가 동시에 하나의 데이터를 조회해서 값을 변경하고 반영하려고 한다면, 모두 다 버전이 1인 상황에서 값을 반영하려고 할 것이고, 먼저 하나의 스레드가 반영이 되어서 버전이 2가 되어버리면 그 외 버전 1인 업데이트 쿼리가 모두 반영되지 않도록 막는다.</p><h3 id="코드로-살펴보기"><a href="#코드로-살펴보기" class="headerlink" title="코드로 살펴보기"></a>코드로 살펴보기</h3><p>먼저 도메인 엔티티에 버전을 추가해주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">val</span> barcode: String,</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그리고 레포지토리 메서드에서 <code>@Lock</code> 어노테이션만 추가해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Lock(LockModeType.OPTIMISTIC)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcodeAndShopSector</span><span class="params">(barcode: <span class="type">String</span>, shopSector: <span class="type">ShopSector</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 추가로 낙관적 락은 동시성이 우려된 경우 예외를 발생한다는 사실을 알아두자. 즉 서비스 단에서 예외가 발생한 경우 재시도하는 코드를 추가해야 테스트 코드가 통과 될 것이다!</p><h2 id="비관적-락"><a href="#비관적-락" class="headerlink" title="비관적 락"></a>비관적 락</h2><p>비관적 락은 모든 시도가 동시성 문제를 일으킬 수 있을 경우 사용한다. DB에서 락을 획득해서 다른 스레드가 자원을 접근하지 못하거나 수정을 막는 방식이다. 구현하는 방법은 매우 간단하다. 레포지토리에서 <code>@Lock</code>의 인자를 다르게 해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Lock(LockModeType.PESSIMISTIC_WRITE)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcode</span><span class="params">(barcode: <span class="type">String</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>락과 트랜잭션<br>락은 반드시 트랜잭션이 존재할 때만 가능하다. 만약 레포지토리 메서드를 트랜잭션이 아닌 환경에서 실행하면 예외가 발생한다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서로 연관관계가 없는 엔티티를 DTO로 조회하기</title>
      <link>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/</guid>
      <pubDate>Thu, 09 Feb 2023 07:32:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제-상황&quot;&gt;&lt;a href=&quot;#문제-상황&quot; class=&quot;headerlink&quot; title=&quot;문제 상황&quot;&gt;&lt;/a&gt;문제 상황&lt;/h1&gt;&lt;p&gt;전세계의 프로 축구 선수를 관리하는 시스템을 만든다고 가정하자. 이 시스템에는 나라, 리그, 선수 이렇게</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h1><p>전세계의 프로 축구 선수를 관리하는 시스템을 만든다고 가정하자. 이 시스템에는 나라, 리그, 선수 이렇게 세가지 엔티티가 있다. 이 세 엔티티 모두 직접 참조는 되어 있지 않은 상태로 모두 물리적인 연관관계는 없다. 다만 리그가 나라를 id로 간접 참조하고, 선수가 리그를 id로 간접 참조하고 있다고 하자. 그렇다면 코드는 다음과 같을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Nation</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Nation</span><span class="params">(<span class="keyword">final</span> String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">League</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Long nationId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">League</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">League</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Long nationId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nationId = nationId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long leagueId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Player</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티가 이런 상황에서 특정 국가에서 뛰고 있는 모든 선수의 이름, 그 선수의 소속 리그 이름, 그 선수 소속 리그의 국가 이름을 조회하려고 한다. 물리적인 관계가 있다면 JPQL fetch join으로 모든 엔티티의 정보를 가져와서 DTO에 매핑하는 방법을 사용할 수 있다. 하지만 간접 참조로 fetch join으로 최적화가 안된다. 이 문제를 해결하기 위해서는 일단 두 단계로 문제를 쪼개보자.</p><ol><li>일단 원하는 정보가 여러 테이블에 흩어져 있기 때문에 이를 모아서 조회해야 한다. 즉 조인을 활용해야 한다.</li><li>조인 한 결과물을 담을 수 있는 객체가 필요하다. 우리의 문제 상황에서는 조회된 결과물이 한 엔티티에 담을 수 없기 때문에 DTO를 만들어서 담을 것이다.</li></ol><h1 id="JPQL에서-연관-관계가-없는-엔티티-조인하기"><a href="#JPQL에서-연관-관계가-없는-엔티티-조인하기" class="headerlink" title="JPQL에서 연관 관계가 없는 엔티티 조인하기"></a>JPQL에서 연관 관계가 없는 엔티티 조인하기</h1><p>사실 SQL과 매우 비슷하다. <code>join &#123;엔티티&#125; on &#123;조건&#125;</code> 이런 형태로 조인을 해주면 된다. 우리의 사레를 JQPL로 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select &#123;나중에 만들 DTO&#125;</span></span><br><span class="line"><span class="meta">                 from Player p</span></span><br><span class="line"><span class="meta">                 join League l on p.leagueId = l.id</span></span><br><span class="line"><span class="meta">                 join Nation n on n.id = l.nationId</span></span><br><span class="line"><span class="meta">                 where n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p>위의 예시는 각 조인을 명시적으로 표현해줬다. 하지만 조인을 명시적으로 표현하지 않아도 from 절에 명시하고 where 절에서 조인 조건을 명시해도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select &#123;나중에 만들 DTO&#125;</span></span><br><span class="line"><span class="meta">                 from Player p, League l, Nation n</span></span><br><span class="line"><span class="meta">                 where p.leagueId = l.id and n.id = l.nationId and n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><h2 id="조인-종류"><a href="#조인-종류" class="headerlink" title="조인 종류"></a>조인 종류</h2><p>여기서 잠깐 JPQL의 조인 종류에 대해서 알아보자. 왜냐면 LEFT JOIN에 대해 잘 모르고 사용했다가 잘못된 테스트임에도 테스트가 통과되고 있었다.<br>일단 조인은 여러 테이블을 하나의 테이블로 합치는 행동이다. 이때 합칠 때 특정 조건을 걸어서 우리가 원하는 결과물만 받을 수 있게 된다.<br>조인의 종류는 이때 중요해지는데, 조인의 종류에 따라 결과물이 달라지기 때문이다.</p><p>먼저 INNER JOIN. 이 경우 두 테이블을 합칠 때 조인 조건이 맞는 데이터만 가져와서 합친다.<br>INNER JOIN이 아닌 LEFT JOIN, RIGHT JOIN, OUTER JOIN은 조인 조건을 만족하지 않는 데이터도 결과에 포함된다.<br>LEFT JOIN은 조인 조건에 맞는 데이터 + 왼쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 왼쪽 테이블의 모든 데이터가 결과값으로 반환된다.)<br>RIGHT JOIN은 조인 조건에 맞는 데이터 + 오른쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 오른쪽 테이블의 모든 데이터가 결과값에 포함된다.)<br>OUTER JOIN은 조인 조건에 맞는 데이터를 제외한 왼쪽 테이블과 오른쪽 테이블의 모든 데이터를 결과값을 보여준다. (즉 INNER JOIN의 여집합이겠다.)</p><h3 id="JPQL에서-조인"><a href="#JPQL에서-조인" class="headerlink" title="JPQL에서 조인"></a>JPQL에서 조인</h3><p>JPQL에서는 위에서 언급한 INNER, LEFT JOIN을 지원한다. (RIGHT JOIN은 지원하지 않으므로 두 테이블의 적용 위치를 바꿔서 LEFT JOIN으로 하면 동일한 결과를 얻을 수 있다.)<br>그리고 FETCH JOIN이라는 것을 지원한다. FETCH JOIN은 연관관계가 있는 엔티티가 Lazy Loading일 때 쿼리 한번에 연관된 객체를 같이 조회해서 가져오는 방법이다. 연관관계가 있는 엔티티를 조회하는 경우 매우 중요한 개념이지만 현재는 연관관계가 없는 엔티티 조회하는 상황이므로 넘어가겠다.</p><h1 id="결과값을-DTO로-받기"><a href="#결과값을-DTO로-받기" class="headerlink" title="결과값을 DTO로 받기"></a>결과값을 DTO로 받기</h1><p>JQPL에서 결과값을 DTO로 받으려면 다음과 같다. <code>SELECT new &#123;패키지&#125;.&#123;DTO 클래스&#125;(...생성자...)</code> 이를 적용한 코드는 다음과 같다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select new com.example.jointest.blogging.PlayerDto(p.id, p.name, l.name, n.name)</span></span><br><span class="line"><span class="meta">                 from Player p, League l, Nation n</span></span><br><span class="line"><span class="meta">                 where p.leagueId = l.id and n.id = l.nationId </span></span><br><span class="line"><span class="meta">                 and n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p>JPQL에서 엔티티나 값 객체가 아닌 (<code>@Entity</code>나 <code>@Embeddable</code>이 안붙은 클래스) 경우는 이렇게 패키지 명을 써줘야 해서 매우 코드가 불편한 게 단점이다.<br>그래서 QueryDSL을 활용하면 더 깔끔한 코드를 작성할 수 있게 된다!!! 나중에 QueryDSL로 더 개선해보자!!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>애노테이션과 리플렉션</title>
      <link>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/</guid>
      <pubDate>Sun, 05 Feb 2023 06:51:34 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;애노테이션-선언과-사용&quot;&gt;&lt;a href=&quot;#애노테이션-선언과-사용&quot; class=&quot;headerlink&quot; title=&quot;애노테이션 선언과 사용&quot;&gt;&lt;/a&gt;애노테이션 선언과 사용&lt;/h1&gt;&lt;h2 id=&quot;애노테이션-적용&quot;&gt;&lt;a href=&quot;#애노테이션</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="애노테이션-선언과-사용"><a href="#애노테이션-선언과-사용" class="headerlink" title="애노테이션 선언과 사용"></a>애노테이션 선언과 사용</h1><h2 id="애노테이션-적용"><a href="#애노테이션-적용" class="headerlink" title="애노테이션 적용"></a>애노테이션 적용</h2><p>코틀린 애노테이션 적용은 자바와 매우 비슷하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated(<span class="meta-string">&quot;Use removeAt(index) instead&quot;</span>, ReplaceWith(<span class="meta-string">&quot;removeAt(index)&quot;</span>)</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>애노테이션에 인자로는 원시 타입 값, 문자열, enum, 클래스 참조, 다른 어노테이션 클래스, 마지막으로 앞서 말한 요소의 배열을 전달해줄 수 있다.<br>다만 인자를 전달할 때는 자바와 다른 점이 있다.</p><ul><li>클래스를 인자로 전달할 때 <code>::class</code>로 전달한다</li><li>어노테이션 인자로 다른 어노테이션을 전달할 때는 <code>@</code>를 빼고 전달한다.</li><li>배열을 인자로 전달하려면 <code>arrayOf</code> 함수를 사용한다. 다만 가변인자로 전달할 때는 그러지 않아도 된다.</li></ul><p>어노테이션 인자를 컴파일 시점에서 알아야 한다. 따라서 어노테이션 인자로 프로퍼티를 전달할 때 임시 프로퍼티나 일반 프로퍼티는 사용하지 못한다. const가 붙은 프로퍼티를 인자로 전달할 수 있다.</p><h2 id="어노테이션-대상"><a href="#어노테이션-대상" class="headerlink" title="어노테이션 대상"></a>어노테이션 대상</h2><p>사용 지점 대상 선언으로 어노테이션을 붙일 요소를 정할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Rule</span></span><br></pre></td></tr></table></figure><p>위 예시를 보면 앞에 사용 지점 대상을 적고 콜론으로 어노테이션 이름적는다. 이런 방식으로 getter 메서드에 어노테이션을 적용해야 되는 경우를 프로퍼티를 통해 적용할 수 있다.</p><h3 id="사용-지점-대상-목록"><a href="#사용-지점-대상-목록" class="headerlink" title="사용 지점 대상 목록"></a>사용 지점 대상 목록</h3><ul><li>property : 프로퍼티 전체.</li><li>field ; 프로퍼티에 생성되는 필드(뒷받침하는 경우도 포함)</li><li>get : 프로퍼티 게터</li><li>set : 프로퍼티 세터</li><li>receiver : 확장 함수나 프로퍼티의 수신 객체 파라미터</li><li>param : 생성자 파라미터</li><li>setparam : 세터 파라미터</li><li>delegate : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드</li><li>file : 파일 안에 선언된 최상위 함수와 프로퍼티를 담아둔 클래스</li></ul><h2 id="어노테이션-선언"><a href="#어노테이션-선언" class="headerlink" title="어노테이션 선언"></a>어노테이션 선언</h2><p>객체를 직렬화하는 제이키드 라이브러리의 어노테이션을 예제로 어노테이션 선언에 대해 알아본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExclude</span></span></span><br></pre></td></tr></table></figure><p>어노테이션 클래스는 오직 메타데이터의 구조를 정의하기 때문에 내부에 아무 코드도 들어있을 수 없다.</p><p>파라미터가 있는 어노테이션은 주 생성자를 통해 파라미터를 정의한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonName</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>이를 자바 어노테이션 선언과 비교하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메타어노테이션-어노테이션을-처리하는-방법-제어"><a href="#메타어노테이션-어노테이션을-처리하는-방법-제어" class="headerlink" title="메타어노테이션: 어노테이션을 처리하는 방법 제어"></a>메타어노테이션: 어노테이션을 처리하는 방법 제어</h2><p>어노테이션 클래스에 적용할 수 있는 어노테이션을 메타어노테이션이라고 부른다.<br>표준 라이브러리에 있는 메타어노테이션 중 가장 흔히 쓰이는 메타어노테이션은 <code>@Target</code>이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.PROPERTY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExclude</span></span></span><br></pre></td></tr></table></figure><p><code>@Target</code> 메타어노테이션은 어노테이션을 적용할 수 있는 요소 유형을 지정한다.</p><p>메타어노테이션을 직접 만들어야 한다면 다음과 같이 구현한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingAnnotation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//사용</span></span><br><span class="line"><span class="meta">@BindingAnnotation</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinding</span></span></span><br></pre></td></tr></table></figure><h2 id="어노테이션-파라미터로-클래스-사용"><a href="#어노테이션-파라미터로-클래스-사용" class="headerlink" title="어노테이션 파라미터로 클래스 사용"></a>어노테이션 파라미터로 클래스 사용</h2><p>어떤 클래스를 선언 메타데이터로 참조할 수 있는 기능이 필요한 때가 있다. 클래스 참조를 파라미터로 하는 어노테이션 클래스를 선언하면 그런 기능을 사용할 수 있다.<br>제이키드 라이브러리의 <code>@DeserializeInterface</code>를 통해 이해해보자. 이 어노테이션은 인터페이스 타입인 프로퍼티를 역직렬화할 때 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@DeserailizeInterface(CompanyImpl::class)</span> <span class="keyword">val</span> company: Company</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이제 이 어노테이션의 정의를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeInterface</span></span>(<span class="keyword">val</span> targetClass: KClass&lt;<span class="keyword">out</span> Any&gt;)</span><br></pre></td></tr></table></figure><p>KClass는 java.lang.Class 타입과 같은 역할을 하는 코틀린 타입이다. 여기서 제네릭 타입에 out이 붙었다. out이 붙지 않고 KClass&lt;Any&gt;로 하면 해당 어노테이션에 CompanyImpl::class를 인자로 넘기지 못하고 Any::class만 인자로 넘길 수 있다. out이 없으면 하위타입이 되지 못하기 때문이다!</p><h2 id="어노테이션-파라미터로-제네릭-클래스-받기"><a href="#어노테이션-파라미터로-제네릭-클래스-받기" class="headerlink" title="어노테이션 파라미터로 제네릭 클래스 받기"></a>어노테이션 파라미터로 제네릭 클래스 받기</h2><p>파라미터로 제네릭 클래스를 받는 어노테이션을 정의해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">foo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> barClass: KClass&lt;<span class="keyword">out</span> SomeClass&lt;*&gt;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>제네릭 클래스인 SomeClass를 구현한 클래스만 파라미터로 받을 수 있게 구현된 예시이다.<br>여기서 아직 어떤 타입이 인자로 올 지 확정할 수 없기 때문에 스타 프로젝션이 적용됐다.</p><h1 id="리플렉션-실행-시점에-코틀린-객체-내부-관찰"><a href="#리플렉션-실행-시점에-코틀린-객체-내부-관찰" class="headerlink" title="리플렉션: 실행 시점에 코틀린 객체 내부 관찰"></a>리플렉션: 실행 시점에 코틀린 객체 내부 관찰</h1><p>리플렉션은 실행 시점에 동적으로 객체의 프로퍼티와 메서드에 접근할 수 있게 해주는 방법이다.<br>리플렉션은 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메서드나 프로퍼티 이름을 오직 실행 시점에서 알 수 있는 경우(JSON 직렬화)에 리플렉션이 필요하다.<br>코틀린에서는 java.lang.reflect 패키지를 통해 제공되는 표준 자바 리플렉션과 kotlin.reflect 패키지를 통해 제공되는 코틀린 리플렉션 API를 다룬다. 코틀린 리플렉션은 자바 리플렉션의 복잡한 기능을 아직 지원하지 않는 경우가 있어서 아직 자바 리플렉션을 필요로 한다. 다만 코틀린 리플렉션이 자바 클래스도 다룰 수 있다.</p><h2 id="코틀린-리플렉션-API-KClass-KCallable-KFunction-KProperty"><a href="#코틀린-리플렉션-API-KClass-KCallable-KFunction-KProperty" class="headerlink" title="코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty"></a>코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty</h2><h3 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h3><p>KClass는 java.lang.class에 해당하며 클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등 작업이 가능하다. 특정 인스턴스의 KClass를 얻기 위해서는 <code>&#123;instance&#125;.javaClass.kotlin</code>으로 얻을 수 있다.</p><h3 id="KCallable"><a href="#KCallable" class="headerlink" title="KCallable"></a>KCallable</h3><p>KCallable은 함수와 프로퍼트를 아우르는 공통 상위 인터페이스다. 그 안에는 call 메서드가 있다. call 메서드를 호출하면 함수나 프로퍼티의 게터를 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KCallable</span>&lt;<span class="type">out R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: R</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KFunction"><a href="#KFunction" class="headerlink" title="KFunction"></a>KFunction</h3><p>KFunction는 함수의 상위 인터페이스이다. call로 메서드를 호출할 수 있는데 이때 매개변수 갯수가 안맞으면 예외가 발생한다. 이를 방지 하기위해 KFunctionN&lt;…&gt;을 사용할 수 있다. 이 인터페이스는 invoke함수를 통해 정해진 매개변수를 받도록 제한한다. 다만 이런 경우 적용가능한 메서드가 적다.</p><h3 id="KProperty-KMutableProperty"><a href="#KProperty-KMutableProperty" class="headerlink" title="KProperty, KMutableProperty"></a>KProperty, KMutableProperty</h3><p>KProperty는 call로 프로퍼티의 게터를 호출한다. 하지만 프로퍼티 인터페이스는 더 좋은 방법으로 게터를 호출할 수 있다.<br>KProperty0은 최상위 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 이 인터페이스에 get메서드가 정의되어 있다.<br>KProperty1은 멤버 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 멤버 프로퍼티는 객체가 있어야 가능하므로, 인자가 하나인 get 메서드가 정의되어 있다. 그리고 제네릭 클래스이기 때문에 수신 객체의 타입을 검증할 수 있다.<br>KMutableProperty0, KMutableProperty1은 각 KProperty0, KProperty1를 확장한 인터페이스로 세터를 제공한다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린의 제네릭스</title>
      <link>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/</guid>
      <pubDate>Fri, 03 Feb 2023 04:23:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;코틀린의 제네릭스는 자바와 비슷한 점이 많다. 자바와 다른 부분도 많으니 이 점을 살펴보자!&lt;/p&gt;
&lt;h1 id=&quot;제네릭-타입-파라미터&quot;&gt;&lt;a href=&quot;#제네릭-타입-파라미터&quot; class=&quot;headerlink&quot; title=&quot;제네릭 타입 파라미터</description>
        
      
      
      
      <content:encoded><![CDATA[<p>코틀린의 제네릭스는 자바와 비슷한 점이 많다. 자바와 다른 부분도 많으니 이 점을 살펴보자!</p><h1 id="제네릭-타입-파라미터"><a href="#제네릭-타입-파라미터" class="headerlink" title="제네릭 타입 파라미터"></a>제네릭 타입 파라미터</h1><p>코틀린의 제네릭 타입 파라미터는 자바와 매우 비슷하지만 몇 가지 새로운 기능에 대해 배워보자.</p><h2 id="타입-파라미터-제약"><a href="#타입-파라미터-제약" class="headerlink" title="타입 파라미터 제약"></a>타입 파라미터 제약</h2><p>코틀린은 타입 파라미터 제한으로 클래스나 함수에 사용할 수 있는 타입 인자를 제한할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">sum</span><span class="params">()</span></span>: T</span><br></pre></td></tr></table></figure><p>이렇게 함수를 선언하면 숫자를 원소로 갖는 리스트 객체만 <code>sum</code> 함수를 호출할 수 있게 된다!! 와우~</p><p>타입 파라미터 제약을 사용한 예시를 살펴보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Person&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.forEach &#123;println(<span class="string">&quot;<span class="subst">$&#123;it.name&#125;</span> hello~&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Bob&quot;</span>), Person(<span class="string">&quot;Tom&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// numbers.hello() 컴파일 에러</span></span><br><span class="line">people.hello()</span><br></pre></td></tr></table></figure><p>타입 파라미터 제한에 따라 함수도 제한한 예시이다.</p><p>여기서 더 실전적인 예시를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(first: <span class="type">T</span>, second: <span class="type">T</span>)</span></span> : T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (first &gt; second) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(max(<span class="string">&quot;airplane&quot;</span>, <span class="string">&quot;zebra&quot;</span>))</span><br></pre></td></tr></table></figure><p>Comparable을 구현한 타입, 즉 원소 간 비교가 가능한 타입 파라미터만 사용할 수 있는 함수를 구현했다.</p><h3 id="타입-파라미터에-여러-제약-걸기"><a href="#타입-파라미터에-여러-제약-걸기" class="headerlink" title="타입 파라미터에 여러 제약 걸기"></a>타입 파라미터에 여러 제약 걸기</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">ensureTrailingPeriod</span><span class="params">(seq: <span class="type">T</span>)</span></span></span><br><span class="line">        <span class="keyword">where</span> T : CharSequence, T : Appendable &#123;</span><br><span class="line">    <span class="keyword">if</span> (!seq.endsWith(<span class="string">&#x27;.&#x27;</span>)) seq.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 시그니처 뒷 쪽에 where 절로 타입 파라미터가 여러 조건을 만족하도록 제한을 걸 수 있다. 위 예시에서는 T가 CharSequence와 Appendable의 하위 타입이어야 가능함을 의미한다.</p><h2 id="타입-파라미터를-널이-될-수-없는-타입으로-한정"><a href="#타입-파라미터를-널이-될-수-없는-타입으로-한정" class="headerlink" title="타입 파라미터를 널이 될 수 없는 타입으로 한정"></a>타입 파라미터를 널이 될 수 없는 타입으로 한정</h2><p>타입 파라미터에 아무런 제약 없이 사용하면 <code>Any?</code>를 상한으로 하는 것과 마찬가지다. 만약 널을 허용하지 않는 타입으로 제한하고 싶으면 <code>&lt;T: Any&gt;</code>로 상한을 걸어주자.<br>터</p><h1 id="실행-시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터"><a href="#실행-시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터" class="headerlink" title="실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터"></a>실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터</h1><p>JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다. 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다. </p><h2 id="실행-시점의-제네릭-타입-검사와-캐스트"><a href="#실행-시점의-제네릭-타입-검사와-캐스트" class="headerlink" title="실행 시점의 제네릭: 타입 검사와 캐스트"></a>실행 시점의 제네릭: 타입 검사와 캐스트</h2><p>코틀린도 자바와 마찬가지로 제네틱 타입 인자 정보는 런타임에 지워진다. 타입 소거는 저장해야 하는 타입 정보의 크기가 줄어들어서 메모리 사용량이 줄어드는 장점은 있다.<br>하지만 타입 소거 때문에 실행 시점에 타입 인자를 검사할 수 없다. 예를 들면 다음과 같은 코드는 컴파일 에러가 발생한다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;String&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>왜냐면 실행 시점에서 value가 List인지 아닌지는 명확히 판별할 수 있지만, List&lt;String&gt;인지, List&lt;Long&gt;인지는 확인할 수 없기 때문이다.</p><p>하지만 방법은 있다. 스타 프로젝션을 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;*&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>인자를 알 수 없는 제네릭 타입을 표현할 때 스타 프로젝션을 사용한다.(자바의 와일드카드와 비슷)<br>스타 프로젝션을 사용하면 as나 as? 캐스팅도 가능하다. 문제는 타입 파라미터를 정확히 모르니 컴파일은 가능해도 런타임에 캐스팅 에러가 발생할 수 있다.</p><h2 id="실체화한-타입-파라미터를-사용한-함수-선언"><a href="#실체화한-타입-파라미터를-사용한-함수-선언" class="headerlink" title="실체화한 타입 파라미터를 사용한 함수 선언"></a>실체화한 타입 파라미터를 사용한 함수 선언</h2><p>타입 소거에 의해 런타임에는 타입 인자 정보를 알 수 없다. 하지만 코틀린 인라인 함수의 타입 인자는 알 수 있다!!!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isA</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T</span><br><span class="line"></span><br><span class="line">println(isA&lt;String&gt;(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>인라인 함수의 타입 파라미터 앞에 reified로 지정하면 실행 시점에서 타입 파라미터를 사용할 수 있다. 이때 파라미터에 람다를 받지 않는데도 타입 파라미터를 실체화 하기 위해서 inline 했읆을 주목하자. 즉 성능을 위해 inline 한 게 아니라 타입 파라미터 사용을 위해서 inline 선언한 것이다. 이때 해당 함수의 길이에 따라 성능 문제가 발생할 수 있다. 그럴 경우 반드시 필요한 부분을 분리해서 성능을 최적화 할 수 있다.</p><blockquote><p>왜 inline은 타입 파라미터를 실체화 할 수 있나?</p></blockquote><p>컴파일러가 인라인 함수의 본문을 바이트코드로 호출한 곳에 집어 넣을 때, 호출 할 때 제네릭 타입에 전달된 클래스를 알 수 있어서 타입 파라미터 자리에 정확한 클래스를 넣을 수 있다.<br>위 예시의 경우 다음과 같이 인라이닝된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;hello&quot;</span> <span class="keyword">is</span> String)</span><br></pre></td></tr></table></figure><blockquote><p>자바에서는 실체화한 타입 파라미터를 가진 inline 함수를 호출할 수 없다.</p></blockquote><p>자바에서 인라인 함수를 호출할 수 있다. 이 경우 일반 함수처럼 사용되서 인라이닝 되지 않는다. 실체화 된 타입 파라미터가 있는 inline 함수의 경우 반드시 인라이닝이 되어야 하기 때문에 자바에서는 해당 함수를 호출하지 못하도록 했다.</p><h2 id="실체화한-타입-파라미터의-제약"><a href="#실체화한-타입-파라미터의-제약" class="headerlink" title="실체화한 타입 파라미터의 제약"></a>실체화한 타입 파라미터의 제약</h2><p>실체화한 타입 파라미터는 몇가지 제약이 있다. 실체화한 타입 파라미터 개념 자체에서 오는 제약과 코틀린에서 실체화한 타입 파라미터를 구현하는 과정에서 오는 제약이 있다. 따라서 구현이 달라지면 나중에 완화될 제약이 있다.</p><p>가능한 것</p><ul><li>타임 검사와 캐스틍 (is, as 등)</li><li>코틀린 리플렉션 API (::class 등)</li><li>코틀린 타입에 대응하는 java.lang.Class 얻기 (::class.java)</li><li>다른 함수를 호출할 때 타입 인자로 사용</li></ul><p>불가능한 것</p><ul><li>타입 파라미터 클래스의 인스턴스 생성</li><li>타입 파라미터 클래스의 동반 객체 메서드 호출</li><li>실체화된 타입 파라미터 자리에 실체화 되지 않은 타입 파라미터로 받은 타입을 넘기기</li><li>클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기</li></ul><h1 id="변성-제네릭과-하위-타입"><a href="#변성-제네릭과-하위-타입" class="headerlink" title="변성: 제네릭과 하위 타입"></a>변성: 제네릭과 하위 타입</h1><p>변성 개념은 <code>List&lt;Any&gt;</code>와 <code>List&lt;String&gt;</code>과 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.</p><h2 id="변성이-있는-이유-인자를-함수에-넘기기"><a href="#변성이-있는-이유-인자를-함수에-넘기기" class="headerlink" title="변성이 있는 이유: 인자를 함수에 넘기기"></a>변성이 있는 이유: 인자를 함수에 넘기기</h2><p><code>List&lt;Any&gt;</code>를 인자로 받는 함수에 <code>List&lt;String&gt;</code> 객체를 전달해도 괜찮을까?<br>보통 <code>Any</code>가 더 상위 객체이니 별 문제 없을 것 같다. 하지만 경우에 따라 컴파일 에러가 발생한다. (책에서는 경우에 따라 런타임에서 문제가 될 수 있다고 했지만 실제로는 아예 컴파일이 되지 않는다.)</p><h3 id="문제가-되는-경우-원소-추가-변경하는-경우"><a href="#문제가-되는-경우-원소-추가-변경하는-경우" class="headerlink" title="문제가 되는 경우: 원소 추가, 변경하는 경우"></a>문제가 되는 경우: 원소 추가, 변경하는 경우</h3><p>아래 코드를 보면 리스트의 원소를 추가, 변경 가능한 MutableList를 매개변수로 갖는 함수에게 타입 인자가 하위 계층인 리스트를 전달하면 컴파일 자체가 되지 않는다.</p><p>그렇지 않은 함수는 별 문제 없이 잘된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addContent</span><span class="params">(contents: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">   contents.add(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printContents</span><span class="params">(contents: <span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(contents.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strings = mutableListOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">printContents(strings)</span><br><span class="line">addContent(strings) <span class="comment">// 컴파일 에러!</span></span><br></pre></td></tr></table></figure><h2 id="클래스-타입-하위-타입"><a href="#클래스-타입-하위-타입" class="headerlink" title="클래스, 타입, 하위 타입"></a>클래스, 타입, 하위 타입</h2><h3 id="클래스와-티입의-구분"><a href="#클래스와-티입의-구분" class="headerlink" title="클래스와 티입의 구분"></a>클래스와 티입의 구분</h3><p>타입과 클래스는 다른 개념이다. 예를 들어 String이라는 클래스는 코틀린에서 <code>String</code>과 <code>String?</code>두가지 타입을 만들어낸다. 즉 하나의 클래스에서 두가지의 타입이 나온다.<br>그렇다면 List는 어떨까? List는 하나의 클래스이다. 다만 타입 매개변수에 따라 수많은 타입이 가능하다. (List&lt;String&gt;, List&lt;Int&gt; 등…) 이제 타입과 클래스가 구분된다는 의미가 와닿는다.</p><h3 id="하위-타입-상위-타입"><a href="#하위-타입-상위-타입" class="headerlink" title="하위 타입, 상위 타입"></a>하위 타입, 상위 타입</h3><p>타입 A 자리에 타입 B가 와도 문제가 없을 때 B가 A의 하입 타입이다 라고 말한다. 반면 A는 B의 상위 타입이라고 한다. 컴파일러는 변수에 값을 대입할 때 변수의 타입이 값의 타입보다 상위 타입인지 확인한다.</p><p>간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다. 하지만 널 가능성과 제네릭 클래스의 경우 하위 타입과 하위 클래스의 차이가 두드러진다.<br>Int는 Int?의 하위 타입이라고 볼 수 있다. 하지만 두 타입 모두 같은 클래스를 기반으로 한 타입이다.</p><p>제네릭 클래스의 경우 List&lt;Any&gt;는 List&lt;String&gt;의 상위 타입이라고 볼 수 있다. 하지만 MutableList&lt;Any&gt;는 MutableList&lt;String&gt;의 상위 타입이라고 볼 수 없다. (이유는 문제가 되는 이유라는 소제목을 보자.)<br>즉 타입 인자가 서로 다른 타입이 들어갔을 경우 두 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않는 상황을 무공변이라고 한다! (참고로 자바에서는 모든 클래스가 무공변이라 한다.)<br>지</p><h2 id="공변성-하위-타입-관계를-유지"><a href="#공변성-하위-타입-관계를-유지" class="headerlink" title="공변성: 하위 타입 관계를 유지"></a>공변성: 하위 타입 관계를 유지</h2><p>같은 제네릭 클래스 기반의 서로 다른 타입 인자를 가진 두 인스턴스의 하위 타입 관계가 유지되면 공변이라고 얘기한다.</p><p>코틀린에서 공변한 클래스를 선언하는 방법을 소개한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out 키워드를 타입 파라미터 앞에 붙여주자. 공변인 타입 파라미터는 함수 정의에 사용된 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다. 즉 하위 관계인 타입 인자가 함수에 사용되어도 된다는 의미다.</p><h3 id="아웃-인-생산-소비"><a href="#아웃-인-생산-소비" class="headerlink" title="아웃, 인, 생산, 소비"></a>아웃, 인, 생산, 소비</h3><p>모든 클래스를 공변으로 만들면 안된다. 타입 안정성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에 있어야 한다.이는 클래스가 타입의 값을 생산(반환)할 수는 있지만, 타입 값을 소비(파라미터 타입 선언)할 수 없다는 의미다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transformIn</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123; ... &#125; <span class="comment">// 타입을 소비 (in)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transformOut</span><span class="params">()</span></span> : T &#123; ... &#125; <span class="comment">// 타입을 생산 (out)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정리하자면 공변성은 타입 인자를 아웃(생산, 반환) 위치에만 사용하는 클래스만 가능하다.</p><blockquote><p>공변의 규칙에서 자유로운 생성자 &amp; private 메서드<br>공변은 인스턴스가 생성되고 나서 하위 타입 관계를 유지할 수 있도록 하는 규칙이므로 생성자는 관련없다. 그리고 인, 아웃 규칙은 외부에서 볼 수 있는 클래스 API 관점에서 정의이다. private 메서드는 인, 아웃 둘 다 해당하지 않는다.</p></blockquote><h2 id="반공변성-뒤집힌-하위-타입-관계"><a href="#반공변성-뒤집힌-하위-타입-관계" class="headerlink" title="반공변성: 뒤집힌 하위 타입 관계"></a>반공변성: 뒤집힌 하위 타입 관계</h2><p>반공변성은 공변성의 반대다. 즉 타입 A가 타입 B의 하위 타입인데, Consumer&lt;B&gt;가 Consumer&lt;A&gt;의 하위 타입이 될 때 반공변성이라고 한다. 인 아웃 규칙도 반대다. 인 위치에서만 타입이 사용되어야 반공변성이 성립한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용-지점-변성-타입이-언급되는-지점에서-변성-지정"><a href="#사용-지점-변성-타입이-언급되는-지점에서-변성-지정" class="headerlink" title="사용 지점 변성: 타입이 언급되는 지점에서 변성 지정"></a>사용 지점 변성: 타입이 언급되는 지점에서 변성 지정</h2><p>클래스에서 in과 out으로 타입 매개변수에 변성을 지정해주지 않고 타입이 언급되는 곳마다 변성을 적용하는 방법이 사용 지점 변성이다. 자바에서 와일드카드 기능을 통해 <code>? extends String</code> 이런 식으로 사용 지점 변성을 사용한다. (물론 기존의 선언 지점 변성이 코드 중복을 줄여주는 장점이 있어 더 간결하다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) destination.add(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무공변인 MutableList를 인자로 받아 인과 아웃에서 모두 사용하고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) destination.add(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in, out 키워드를 통해 적절한 변성을 적용했다. 이때 in, out 키워드를 붙인 타입에서는 타입 프로젝션이 일어난다. 일반적인 MutableList가 아닌 변성이 적용된 MutableList 타입으로 만들어서, 해당 변성에 맞는 메서드만 호출할 수 있게 된다.</p><h2 id="스타-프로젝션-타입-인자-대신-사용"><a href="#스타-프로젝션-타입-인자-대신-사용" class="headerlink" title="스타 프로젝션: 타입 인자 대신 * 사용"></a>스타 프로젝션: 타입 인자 대신 * 사용</h2><p>스타 프로젝션은 어떤 구체적인 타입이 타입 인자로 정해졌는데, 정확히 어떤 타입인지 추론할 수 없을 때 사용한다. 일반적으로 타입 인자가 중요하지 않은 경우 주로 사용한다. <code>MutableList&lt;*&gt;</code>를 통해 스타 프로젝션에 대해 이해해보자.</p><h3 id="Any-와-차이"><a href="#Any-와-차이" class="headerlink" title="Any?와 차이"></a>Any?와 차이</h3><p><code>MutableList&lt;*&gt;</code>와 <code>MutableList&lt;Any?&gt;</code>는 의미가 다르다. 후자는 어떤 객체든 담을 수 있는 리스트이다. 전자는 구체적인 타입 인자가 정해졌는데 추론할 수 없는 상황이므로 아무 객체나 담으면 안된다. 반면 전자에서 값을 꺼낼 때는 타입을 정확히 추론할 수는 없지만 Any?의 하위타입일 것은 명확하므로 반환하는 타입은 Any?가 된다. 따라서 <code>MutableList&lt;*&gt;</code>는 아웃 프로젝션 타입이 된다. 즉 생성(반환)만 되고 소비(인자로 사용)은 안되는 타입이다!</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>고차 함수(파라미터와 반환 값으로 람다 사용)</title>
      <link>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/</guid>
      <pubDate>Tue, 31 Jan 2023 07:41:02 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;고차-함수&quot;&gt;&lt;a href=&quot;#고차-함수&quot; class=&quot;headerlink&quot; title=&quot;고차 함수&quot;&gt;&lt;/a&gt;고차 함수&lt;/h1&gt;&lt;p&gt;고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다. 코틀린의 고차 함수가 인자나 반환값으로 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h1><p>고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다. 코틀린의 고차 함수가 인자나 반환값으로 함수를 사용하기 위해서는 함수 타입이 필요하다.</p><h2 id="함수-타입"><a href="#함수-타입" class="headerlink" title="함수 타입"></a>함수 타입</h2><p>자바에서 람다 식을 매개변수나 반환값으로 사용하기 위해서는 함수형 인터페이스를 사용했다. 코틀린에서는 함수 타입이 존재한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x + y&#125;</span><br><span class="line"><span class="keyword">val</span> action: () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="number">42</span>) &#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 함수 타입에 대해 알 수 있다. 마치 람다 식처럼 생겼다.</p><p>널을 반환하거나 함수 타입 자체가 널이 될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> canReturnNull: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>? = &#123; <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">val</span> funOrNull: ((<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>)? = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>함수 타입이 파라미터로 활용될 때 함수 타입의 파라미터에 이름을 정해줄 수 있다.<br>고차 함수에서 함수 타입 호출은 일반 함수 호출처럼 괄호 안에 인자를 넣어서 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(callback: (<span class="type">code</span>:<span class="type">Int</span>, <span class="type">content</span>:<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    callback(<span class="number">1</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething &#123; code, content -&gt; println(<span class="string">&quot;code = <span class="variable">$code</span>, content = <span class="variable">$content</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="자바에서-코틀린-함수-타입-사용"><a href="#자바에서-코틀린-함수-타입-사용" class="headerlink" title="자바에서 코틀린 함수 타입 사용"></a>자바에서 코틀린 함수 타입 사용</h3><p>코틀린의 함수 타입은 자바에서 <code>FunctionN</code>이라는 인터페이스로 바뀐다. 매개 변수 갯수에 따라 <code>FunctionN&lt;R&gt;</code>, <code>Function&lt;R, P1&gt;</code> 등으로 바뀐다. 이렇게 바뀐 인터페이스 안에는 <code>invoke</code> 메서드가 정의되어 있다. <code>invoke</code>를 통해 함수를 실행시킬 수 있다.</p><p>이때 Unit을 반환하는 함수 타입을 자바에서도 사용할 수 있으나 자바에서 void를 반환하는 람다를 Unit을 반환하는 함수 타입에 전달해줄 수 없다. 코틀린의 Unit은 값이 있지만 자바의 void는 값이 없기 때문이다.</p><h2 id="디폴트-값을-지정한-파라미터와-널이-될수-있는-함수-타입-파라미터-활용"><a href="#디폴트-값을-지정한-파라미터와-널이-될수-있는-함수-타입-파라미터-활용" class="headerlink" title="디폴트 값을 지정한 파라미터와 널이 될수 있는 함수 타입 파라미터 활용"></a>디폴트 값을 지정한 파라미터와 널이 될수 있는 함수 타입 파라미터 활용</h2><p>고차 함수에 함수 타입 파라미터에 디폴트 값을 넣어줄 수 있다. 또한 널이 될 수 있도록 타입을 정할 수 있다. 다만 이런 경우 고차 함수에서 함수 타입에 해당하는 객체를 바로 호출할 수 없고 안전하게 호출해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomethingWithDefault</span><span class="params">(callback: ((<span class="type">code</span>: <span class="type">Int</span>, <span class="type">content</span>: <span class="type">String</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    callback?.invoke(<span class="number">1</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">        ?: run &#123; println(<span class="string">&quot;input null&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomethingWithDefault() <span class="comment">// input null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="람다를-활용한-중복-제거"><a href="#람다를-활용한-중복-제거" class="headerlink" title="람다를 활용한 중복 제거"></a>람다를 활용한 중복 제거</h2><p>사이트 방문 데이터에 대항 정보를 통계내는 코드를 작성할 때 람다로 중복을 제거해보자.</p><p>일단 데이터는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    WINDOWS, MAC, IOS, ANDROID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteVisit</span></span>(</span><br><span class="line">    <span class="keyword">val</span> path: String,</span><br><span class="line">    <span class="keyword">val</span> duration: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="keyword">val</span> os: OS</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> log = listOf(</span><br><span class="line">    SiteVisit(<span class="string">&quot;/&quot;</span>, <span class="number">1.0</span>, OS.WINDOWS),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/hello&quot;</span>, <span class="number">2.0</span>, OS.MAC),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/welcome&quot;</span>, <span class="number">3.0</span>, OS.ANDROID),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/goodbye&quot;</span>, <span class="number">4.0</span>, OS.ANDROID),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/welcome&quot;</span>, <span class="number">5.0</span>, OS.IOS),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이제 안드로이드 사용자들의 평균 방문 시간을 출력해보자.</p><blockquote><p>하드 코딩한 필터를 사용한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageAndroidDuration = log</span><br><span class="line">    .filter &#123; it.os == OS.ANDROID &#125;</span><br><span class="line">    .map(SiteVisit::duration)</span><br><span class="line">    .average()</span><br><span class="line">println(averageAndroidDuration)</span><br></pre></td></tr></table></figure><p>이렇게 구현하면 다른 os의 평균을 구할 때마다 중복된 코드를 적어줘야 한다. 이를 개선해보자.</p><blockquote><p>개선한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;SiteVisit&gt;</span>.<span class="title">averageDurationFor</span><span class="params">(os: <span class="type">OS</span>)</span></span> =</span><br><span class="line">    filter &#123; it.os == os &#125;</span><br><span class="line">        .map(SiteVisit::duration)</span><br><span class="line">        .average()</span><br></pre></td></tr></table></figure><p>이제 디바이스 별로 방문시간 통계를 내는 상황을 코드로 짜보자.</p><blockquote><p>하드코딩한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageMobileDuration = log</span><br><span class="line">    .filter &#123; it.os <span class="keyword">in</span> setOf(OS.IOS, OS.ANDROID) &#125;</span><br><span class="line">    .map(SiteVisit::duration)</span><br><span class="line">    .average()</span><br><span class="line">println(averageMobileDuration)</span><br></pre></td></tr></table></figure><p>이를 고차 함수를 활용해서 개선해보자.</p><blockquote><p>개선한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;SiteVisit&gt;</span>.<span class="title">averageDurationFor</span><span class="params">(predicate: (<span class="type">SiteVisit</span>) -&gt; <span class="type">Boolean</span>)</span></span> =</span><br><span class="line">    filter(predicate)</span><br><span class="line">        .map(SiteVisit::duration)</span><br><span class="line">        .average()</span><br><span class="line"></span><br><span class="line">println(log.averageDurationFor &#123; it.os <span class="keyword">in</span> setOf(OS.ANDROID, OS.IOS) &#125;)</span><br></pre></td></tr></table></figure><p>와우! 재활용이 엄청 잘되겠다~</p><h1 id="인라인-함수-람다의-부가-비용-없애기"><a href="#인라인-함수-람다의-부가-비용-없애기" class="headerlink" title="인라인 함수: 람다의 부가 비용 없애기"></a>인라인 함수: 람다의 부가 비용 없애기</h1><p>코틀린은 람다를 보통 무명 클래스로 컴파일 하지만 람다 식을 사용할 때마다 클래스를 만들지는 않는다.<br>람다가 변수를 포획하면 람다가 생성되는 시점에 무명 클래스 객체가 생긴다.<br>따라서 람다는 같은 작업을 하는 일반 함수에 비해 덜 효율적인 것 같다.</p><p>하지만 inline 변경자를 통해 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트 코드로 바꾸치기 한다.</p><h2 id="인라이닝이-작동하는-방식"><a href="#인라이닝이-작동하는-방식" class="headerlink" title="인라이닝이 작동하는 방식"></a>인라이닝이 작동하는 방식</h2><p>어떤 함수를 <code>inline</code>으로 선언하면 해당 함수를 호출하는 코드 대신 해당 함수의 본문이 바이트 코드로 컴파일된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">(callback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    callback()</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;it&#x27;s foo function!&quot;</span>)</span><br><span class="line">    doSomething2 &#123; println(<span class="string">&quot;do foo things~!&quot;</span>) &#125;</span><br><span class="line">    println(<span class="string">&quot;end of foo function!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>이런 식으로 inline을 적용하는 경우 foo 함수는 다음 코드와 같은 바이트 코드로 컴파일 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;it&#x27;s foo function!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;do foo things~!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;end of foo function!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시를 유심히 보면 함수 본문과 전달받은 람다가 인라이닝 된 것을 볼 수 있다.<br>이때 람다 대신 함수 타입의 변수에 람다를 담아서 전달하는 경우 해당 변수에 어떤 값이 담긴지 모르기 때문에 람다 부분은 인라이닝이 되지 않고 함수 본문만 인라이닝 된다.</p><p>만약 특정 람다를 인라이닝하고 싶지않으면 noinline 변경자를 파라미터 이름 앞에 붙이면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">(<span class="keyword">noinline</span> callback: () -&gt; <span class="type">Unit</span>, otherCallback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    callback()</span><br><span class="line">    otherCallback()</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>모듈 밖이나 자바에서 인라인 함수를 호출하는 경우는 컴파일러는 일반 호출로 컴파일한다.</p></blockquote><h2 id="컬렉션-연산-인라이닝"><a href="#컬렉션-연산-인라이닝" class="headerlink" title="컬렉션 연산 인라이닝"></a>컬렉션 연산 인라이닝</h2><p><code>filter</code>, <code>map</code>과 같은 컬렉션 연산은 람다를 매개변수로 받아 사용하는 인라인 함수이다. 이 경우 전달받은 람다와 컬렉션 연산 함수의 본문이 인라인된다!<br>하지만 컬렉션 연산은 매번 연산마다 연산 결과를 컬렉션으로 만들어내서 여러 연산을 하는 경우 비효율적이다.</p><p>이런 비효율을 줄이는 게 시퀀스인데, 시퀀스를 사용하면 중간 시퀀스가 전달 받은 람다를 필드로 저장하는 객체로 표현되며 최종 연산이 진행될 때 중간 시퀀스에 있는 여러 람다를 연쇄 호출하는 방식으로 진행된다.</p><p>즉 시퀀스는 람다를 저장해야 하므로 람다를 인라인하지 않는다. 따라서 지연 계산을 통해 성능 개선하려고 모든 컬렉션 연산을 시퀀스로 하면 안된다. 컬렉션의 크기가 작은 경우 컬렉션 연산을 통한 인라이닝이 더 성능에 도움이 될 수 있다. 컬렉션 크기가 매우 큰 경우에만 시퀀스를 활용하자.</p><h2 id="함수를-인라인으로-선언해야-하는-경우"><a href="#함수를-인라인으로-선언해야-하는-경우" class="headerlink" title="함수를 인라인으로 선언해야 하는 경우"></a>함수를 인라인으로 선언해야 하는 경우</h2><p>inline 키워드를 남용하면 안된다. 왜냐면 일반 함수 호출은 JVM이 이미 강력하게 인라이닝하기 때문이다.</p><p>JVM은 바이트코드가 기계어로 번역되는 과정에서 일어난다. JVM의 최적화는 바이트코드 상에서 호출된 함수 부분에서 따로 함수 코드가 중복되지 않는다. 반면 코틀린의 인라인 함수는 바이트코드에서 함수 호출 지점을 함수 본문으로 변환해서 코드 중복이 생긴다. 게다가 함수 직접 호출은 스택 트레이스가 더 깔끔해진다.</p><p>반면 람다를 인자로 받는 함수를 인라이닝하면 이익이 많다. 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요가 없어진다. JVM이 함수 호출과 람다를 인라이닝할 정도로 똑똑하지는 않다. 인라이닝을 사용하면 일반 람다에서 사용 못하는 기능을 사용할 수 있다.(넌로컬)</p><p>인라이닝을 적용할 때는 해당 함수의 크기를 고려하자. 길이가 매우 긴 함수를 인라이닝하면 바이트코드의 용량이 매우 커질 수 있다. 이런 경우 매개변수의 람다를 선택적으로 인라이닝하지 않거나 하는 방식을 고려해볼 수 있다.</p><h1 id="고차-함수-안에서-흐름-제어"><a href="#고차-함수-안에서-흐름-제어" class="headerlink" title="고차 함수 안에서 흐름 제어"></a>고차 함수 안에서 흐름 제어</h1><p>람다를 호출하는 함수에서 return을 호출하면 어떻게 될까?<br>사람들 중 Alice라는 이름의 사람을 찾는 코드 예시로 흐름 제어 사례를 살펴보자.</p><blockquote><p>명령형 코드 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">27</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (person <span class="keyword">in</span> people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Alice is not found...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="람다-안의-return문-람다를-둘러싼-함수로-반환"><a href="#람다-안의-return문-람다를-둘러싼-함수로-반환" class="headerlink" title="람다 안의 return문: 람다를 둘러싼 함수로 반환"></a>람다 안의 return문: 람다를 둘러싼 함수로 반환</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice2</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Alice is not found...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>람다 안에서 return을 사용하면 람다로부터만 반환되느게 아니라 람다를 호출하는 함수가 실행을 끝내고 반환된다. 이렇게 나를 감싼 블록보다 더 바깥의 블록을 반환하게 만드는 return문을 넌로컬 return이라 부른다. 마치 자바 for 루프 내부에서 return을 하면 해당 루프를 사용하는 함수가 종료되는 것과 같은 논리이다.</p><p>이렇게 return이 바깥쪽 함수를 반환시킬 수 있는 경우는 람다를 인자로 받는 함수가 인라인 함수인 경우에만 그렇다!!!!!!!</p><p>인라인 함수가 아닌 함수는 변수에 저장되어 호출 시점이 바깥 함수 호출 시점과 분리될 수 있다. 그래서 함수 내부의 return이 바깥쪽 함수 반환을 시킬 수 없게 된다.</p><h2 id="람다로부터-반환-레이블을-사용한-return"><a href="#람다로부터-반환-레이블을-사용한-return" class="headerlink" title="람다로부터 반환: 레이블을 사용한 return"></a>람다로부터 반환: 레이블을 사용한 return</h2><p>람다 식에서 for 루프의 break과 비슷한 역할을 하는 로컬 return이 있다. break 시킬 람다나 함수를 레이블로 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice3</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach <span class="symbol">label@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@label</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice4</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="무명-함수-기본적으로-로컬-return"><a href="#무명-함수-기본적으로-로컬-return" class="headerlink" title="무명 함수: 기본적으로 로컬 return"></a>무명 함수: 기본적으로 로컬 return</h2><p>넌로컬 반환문을 여럿 사용해야 하는 경우 무명 함수로 코드를 더 쉽게 만들 수 잇다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice4</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach(<span class="function"><span class="title">fun</span> <span class="params">(person)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) <span class="keyword">return</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;person.name&#125;</span> is not Alice&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무명 함수 내부 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킨다. (무명 함수 바깥 함수를 반환시키지 않는다!!!) 애초에 return은 fun으로 정의된 가장 안쪽 함수를 반환시키는 데, 람다식은 fun으로 정의되지 않아 람다 밖의 함수를 반환시킨 것이다. 무명 함수는 fun으로 함수 선언되었으니 바깥 함수를 종료시키지 않을 수 있다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>연산자 오버로딩과 기타 관례</title>
      <link>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/</guid>
      <pubDate>Thu, 26 Jan 2023 08:38:17 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;산술-연산자-오버로딩&quot;&gt;&lt;a href=&quot;#산술-연산자-오버로딩&quot; class=&quot;headerlink&quot; title=&quot;산술 연산자 오버로딩&quot;&gt;&lt;/a&gt;산술 연산자 오버로딩&lt;/h1&gt;&lt;p&gt;코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="산술-연산자-오버로딩"><a href="#산술-연산자-오버로딩" class="headerlink" title="산술 연산자 오버로딩"></a>산술 연산자 오버로딩</h1><p>코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서 <strong>관례</strong>라고 부른다.<br>코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자다. 기존 자바에서는 원시 타입과 문자열 정도에 산술 연산자를 쓸 수 있다. 하지만 관례를 적절히 사용하면 다른 클래스에도 산술 연산자를 쓸 수 있다.</p><h2 id="이항-산술-연산-오버로딩"><a href="#이항-산술-연산-오버로딩" class="headerlink" title="이항 산술 연산 오버로딩"></a>이항 산술 연산 오버로딩</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p3 = p1 + p2</span><br><span class="line">println(p3) <span class="comment">// x = 4, y = 6</span></span><br></pre></td></tr></table></figure><p>산술 연산자 <code>+</code>는 <code>plus</code> 라는 이름의 함수로 오버로딩할 수 있다. 이때 산술 연산 오버로딩은 함수 앞에 <code>operator</code>가 붙어야 한다.<br>연산자 오버로딩은 확장함수로도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이항 산술 연산자는 <code>times</code>, <code>div</code>, <code>mod(rem)</code>, <code>plus</code>, <code>minus</code> 등 정해진 함수 이름을 사용해야 하며 기존 연산자의 우선순위와 같다.</p><blockquote><p>연산자 함수와 자바<br>코틀린 연산자는 함수로 정의된다. 긴 이름을 사용하면 일반 함수로 호출할 수 있다.</p></blockquote><h3 id="코틀린-연산자가-자동으로-교환-법칙을-지원하지는-않음"><a href="#코틀린-연산자가-자동으로-교환-법칙을-지원하지는-않음" class="headerlink" title="코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음"></a>코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">times</span><span class="params">(scale: <span class="type">Int</span>)</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x * scale, y * scale)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(p1 * <span class="number">2</span>) <span class="comment">// x = 2, y = 4</span></span><br><span class="line"><span class="comment">// p1 * 2는 컴파일 되지 않는다.</span></span><br></pre></td></tr></table></figure><p>연산자 오버로딩은 다양한 매개변수를 가질 수 있다. 위의 예시도 그런 상황인데, 이때 일반적인 산술연산자 처럼 교환법칙을 지원하지는 않는다.<br>그리고 오버로딩된 연산자의 반환값이 반드시 두 피연산자 중 하나여야만 하는 것도 아니다.</p><h2 id="복합-대입-연산자-오버로딩"><a href="#복합-대입-연산자-오버로딩" class="headerlink" title="복합 대입 연산자 오버로딩"></a>복합 대입 연산자 오버로딩</h2><p><code>+=</code>, <code>-=</code> 같은 복합 대입 연산자는 사실 <code>+</code>, <code>-</code> 같은 연산자를 오버로딩하면 자연스럽게 지원된다.<br>하지만 이런 경우 새로운 객체를 만들어서 반환하게 된다. (위 예시를 보면 새로운 객체를 만들어서 반환한다.)</p><p>이를 대비해 복합 대입 연산자도 오버로딩을 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plusAssign</span><span class="params">(other: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.x += other.x</span><br><span class="line">    <span class="keyword">this</span>.y += other.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p1+=p2</span><br><span class="line">println(p1) <span class="comment">// x = 4, y = 6</span></span><br></pre></td></tr></table></figure><p>이때 주의해야 할 점은 복합 대입 연산자와 이에 필요한 이항 산술 연산자를 같이 재정의하면 컴파일러가 어떤 연산자를 사용해서 코드를 실행해야 할 지 알 수 없어서 컴파일 에러가 생긴다.<br>그래서 이 두가지 산술 연산자를 동시에 재정의하지 않도록 하자. 위 예시에서는 <code>plus</code>와 <code>plusAssign</code>을 동시에 재정의하면 <code>+=</code>를 할 때 컴파일 오류가 생긴다. 객체의 프로퍼티를 변경할 수 없는 경우는 <code>plus</code>와 같은 이항 산술 연산자만 오버로딩하고 변경 가능한 클래스를 설계한다면 <code>plusAssign</code>만 제공하는 방식을 고려할 수 있다.</p><h3 id="코틀린-컬렉션에서-대응-예시"><a href="#코틀린-컬렉션에서-대응-예시" class="headerlink" title="코틀린 컬렉션에서 대응 예시"></a>코틀린 컬렉션에서 대응 예시</h3><p>코틀린 컬렉션에서는 변경 가능한 컬렉션에는 <code>+=</code>와 <code>-=</code>를 통해 메모리에 있는 객체 상태를 변경시킬 수 있게 해놨다. 반면 읽기 전용 컬렉션에서는 <code>+=</code>와 <code>-=</code>는 변경을 적용한 복사본을 반환하도록 했다.</p><h2 id="단항-연산자-오버로딩"><a href="#단항-연산자-오버로딩" class="headerlink" title="단항 연산자 오버로딩"></a>단항 연산자 오버로딩</h2><p>단항 연산자도 크게 다르지 않다. <code>unaryPlus</code>, <code>unaryMinus</code>, <code>not</code> 등 정해진 이름을 통해 오버로딩한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(-x, -y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 <code>++</code>와 <code>--</code> 같은 전위와 후위 증가(감소) 연산자는 연산해서 반환할 값만 정해주면 연산자를 어떻게 사용하느냐에 따라 컴파일러가 알아서 전위 혹은 후위 연산을 처리해준다.<br><code>inc</code>와 <code>dec</code>을 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">inc</span><span class="params">()</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(++x, ++y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(p2++)</span><br><span class="line">println(++p2)</span><br></pre></td></tr></table></figure><h1 id="비교-연산자-오버로딩"><a href="#비교-연산자-오버로딩" class="headerlink" title="비교 연산자 오버로딩"></a>비교 연산자 오버로딩</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>코틀린에서 <code>==</code>가 참조 주소를 비교하는 동일성 비교가 아닌 값을 비교하는 동등성 비교로 작동한다. 이를 가능하게 하는 것도 관례의 힘이다.<br>대략 다음과 같은 코드가 작동하는 셈이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a == b</span></span><br><span class="line">a?.equals(b) ?: (b == <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>참고로 <code>!=</code> 또한 <code>==</code>의 결과를 반전시키면 되니 자연스럽게 지원된다.</p><h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h2><p>코틀린에서 관례를 통해 <code>compareTo</code>를 <code>&lt;,&gt;, &lt;=, &gt;=</code>로 해결할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>) : Comparable&lt;Point&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Point</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> compareValuesBy(<span class="keyword">this</span>, other, Point::x, Point::y) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Point(<span class="number">3</span>, <span class="number">4</span>) &lt;= Point(<span class="number">4</span>, <span class="number">3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Point가 Comparable을 구현하여 <code>compareTo</code>를 재정의 했다. 이때 기존 인터페이스에 <code>operator</code> 선언이 되어 있어서 위 예시에는 생략됐다.</p><h1 id="컬렉션과-범위에-대해-쓸-수-있는-관례"><a href="#컬렉션과-범위에-대해-쓸-수-있는-관례" class="headerlink" title="컬렉션과 범위에 대해 쓸 수 있는 관례"></a>컬렉션과 범위에 대해 쓸 수 있는 관례</h1><p>코틀린에서 관례를 통해 컬렉션의 원소에 접근해 읽거나 쓰는 연산을 함수가 아닌 연산자로 할 수 있다.</p><h2 id="인덱스로-원소에-접근-get과-set"><a href="#인덱스로-원소에-접근-get과-set" class="headerlink" title="인덱스로 원소에 접근: get과 set"></a>인덱스로 원소에 접근: get과 set</h2><p><code>mutableMap[key] = newValue</code> 처럼 코틀린에서는 맵에서 대괄호로 원소에 접근하거나 원소를 쓸 수 있다.<br>코틀린에서는 이를 인덱스 연산자라고 한다. Map과 MutalbeMap 인터페이스에는 두 메서드가 이미 들어있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; x</span><br><span class="line">        <span class="number">1</span> -&gt; y</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">when</span>(index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="keyword">this</span>.x = value</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="keyword">this</span>.y = value</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">println(point[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line">point[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">println(point[<span class="number">0</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="in-관례"><a href="#in-관례" class="headerlink" title="in 관례"></a>in 관례</h2><p>코틀린에서 지원하는 in 연산자는 contains 함수에 대응한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">contains</span><span class="params">(other: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> other.x &lt;= x &amp;&amp; other.y &lt;= y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Point(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">in</span> Point(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="rangeTo-관례"><a href="#rangeTo-관례" class="headerlink" title="rangeTo 관례"></a>rangeTo 관례</h2><p>범위를 만드는 <code>..</code> 연산자는 rangeTo 함수에 대응한다.<br>알아둘 점은 Comparable 인터페이스를 구현하면 rangeTo를 구현할 필요가 없다. 왜냐면 코틀린 표준 라이브러리에 Comparable 객체에 대해 적용 가능한 rangeTo 함수가 정의되어 있기 때문이다.<br>rangeTo는 다른 산술 연산자나 범위 메서드보다 우선순위가 낮아서 되도록 괄호로 감싸서 표현해주자.<br><code>0..(n + 1)</code> 이렇게 가독성을 높게 하거나 <code>(0..n).forEach &#123;...&#125;</code> 이렇게 컴파일이 되도록 할 수 있다.</p><h2 id="for-루프를-위한-iterator-관례"><a href="#for-루프를-위한-iterator-관례" class="headerlink" title="for 루프를 위한 iterator 관례"></a>for 루프를 위한 iterator 관례</h2><p>코틀린의 for 루프는 in 연산자를 사용한다. 하지만 contains에 대응하는 in과는 다른 연산자이다.<br><code>for (x in list) &#123;...&#125;</code> 이렇게 for 루프 안에 있는 in은 iterator 함수에 대응한다.<br>코틀린은 확장 함수를 통한 관례를 통해 문자열을 for 루프를 돌 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">iterator</span><span class="params">()</span></span>: CharIterator</span><br></pre></td></tr></table></figure><p>특정 클래스에 적용도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> ClosedRange<span class="type">&lt;Point&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;Point&gt; =</span><br><span class="line">    <span class="keyword">object</span> : Iterator&lt;Point&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> current = start</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = current &lt;= endInclusive</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: Point = current.apply &#123; current = Point(current.x + <span class="number">1</span>, current.y + <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="구조-분해-선언과-component-함수"><a href="#구조-분해-선언과-component-함수" class="headerlink" title="구조 분해 선언과 component 함수"></a>구조 분해 선언과 component 함수</h1><p>구조분해 선언을 관례로 구현하면 다음과 같은 코드를 가능하게 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> (x, y) = point</span><br><span class="line">println(x) <span class="comment">// 1</span></span><br><span class="line">println(y) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>구조분해 선언은 내부적으로 다음과 같이 작동한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val (x, y) = point</span></span><br><span class="line"><span class="keyword">val</span> x = point.component1()</span><br><span class="line"><span class="keyword">val</span> y = point.component2()</span><br></pre></td></tr></table></figure><p>즉 componentN 함수에 대응한 관례를 만들면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component2</span><span class="params">()</span></span> = y</span><br></pre></td></tr></table></figure><p>구조 분해 선언은 Map과 for 루프에서 효과적이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Map의 Entry가 확장함수로 구조 분해를 제공해서 위와 같은 코드가 가능하다.</p><h1 id="프로퍼티-접근자-로직-재활용"><a href="#프로퍼티-접근자-로직-재활용" class="headerlink" title="프로퍼티 접근자 로직 재활용"></a>프로퍼티 접근자 로직 재활용</h1><p>위임 프로퍼티에도 코틀린의 관례가 뒷받침 된다. 위임 프로퍼티를 사용하면 값을 뒤받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있다.</p><h2 id="위임-프로퍼티-소개"><a href="#위임-프로퍼티-소개" class="headerlink" title="위임 프로퍼티 소개"></a>위임 프로퍼티 소개</h2><p>위임 프로퍼티의 일반적인 문법은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로퍼티 p는 접근자 로직을 다른 객체(Delegate)에게 위임한다.<br>컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다.<br>프로퍼티 p는 자신의 작업을 위임 객체에게 전달한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate = Delegate()</span><br><span class="line">    <span class="keyword">var</span> p: Type</span><br><span class="line">    <span class="keyword">set</span>(value:Type) = delegate.setValue(..., value)</span><br><span class="line">    <span class="keyword">get</span>() = delgate.getValue(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 위임 프로퍼티를 위해 생성된 위임객체는 setValue와 getValue 메서드 호출을 통해 위임한다.<br>위임 프로퍼티를 위한 위임 객체이 되려면 setValue와 getValue 메서드를 가져야 한다.<br>다양한 매개변수가 있지만 현재 기본 구조 설명을 위해 생략했다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(...)</span></span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(..., value: <span class="type">Type</span>)</span></span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="위임-프로퍼티-사용-by-lazy-사용한-프로퍼티-초기화-지연"><a href="#위임-프로퍼티-사용-by-lazy-사용한-프로퍼티-초기화-지연" class="headerlink" title="위임 프로퍼티 사용: by lazy() 사용한 프로퍼티 초기화 지연"></a>위임 프로퍼티 사용: by lazy() 사용한 프로퍼티 초기화 지연</h2><p>Person 클래스의 email을 가져오는 loadEmail 메서드가 오래걸리는 작업이라 최초 접근에만 초기화하는 경우를 생각해보자.<br>만약 뒷받침하는 프로퍼티 기법을 사용하면 다음과 같이 null로 초기화 해놓고 사용할 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _emails: List&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> emails:List&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_emails == <span class="literal">null</span>) _emails = loadEmail()</span><br><span class="line">            <span class="keyword">return</span> emails</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 이 방법은 코드가 복잡하고 스레드 안전하지도 않다!</p><p>위임 프로퍼티를 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> emails: List&lt;String&gt; <span class="keyword">by</span> lazy &#123; loadEmail() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lazy는 첫 호출 시 지연 초기화하는 함수이고 람다를 매개변수로 받는다.<br>lazy는 기본적으로 스레드 안전하고 필요에 따라 락을 람다에 전달할 수 있고, lazy가 동기화를 하지 못하게 할 수도 있다.</p><h2 id="위임-프로퍼티-컴파일-규칙"><a href="#위임-프로퍼티-컴파일-규칙" class="headerlink" title="위임 프로퍼티 컴파일 규칙"></a>위임 프로퍼티 컴파일 규칙</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 코드가 있다고 할 때 컴파일러는 Delegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티를 &lt;delegate&gt;라는 이름으로 부른다. 컴파일러는 프로퍼티를 포현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 &lt;property&gt;라는 이름으로 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> &lt;delegate&gt; = Delegate()</span><br><span class="line">    <span class="keyword">var</span> p: Type</span><br><span class="line">    <span class="keyword">get</span>() = &lt;delegate&gt;.getValue(<span class="keyword">this</span>, &lt;property&gt;)</span><br><span class="line">    <span class="keyword">set</span>(value: Type) = &lt;delegate&gt;.setValue(<span class="keyword">this</span>, &lt;property&gt;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위임 프로퍼티의 특징을 보면 프로퍼티를 꼭 초기화 하지 않아도 된다. 즉 프로퍼티 값이 저장될 곳을 바꿀 수 있고 간단한 로직을 추가할 수 도 있다.</p><h2 id="프로퍼티-값을-맵에-저장"><a href="#프로퍼티-값을-맵에-저장" class="headerlink" title="프로퍼티 값을 맵에 저장"></a>프로퍼티 값을 맵에 저장</h2><p>프로퍼티를 동적으로 정의할 수 있는 확장 가능한 객체라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = _attributes[<span class="string">&quot;name&quot;</span>]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 프로퍼티를 담을 수 있는 맵을 가지고, 필수 프로퍼티를 선언하고 접근 로직을 맵을 통해 가져오도록 구현했다.<br>이를 위임 프로퍼티로 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>by 뒤에는 위임 객체가 와야 한다. Map과 MutableMap은 기본적으로 getValue와 setValue를 제공하기 때문에 가능하다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>퀴즈로 학습하는 운영체제와 정보기술의 원리</title>
      <link>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/</guid>
      <pubDate>Sun, 22 Jan 2023 13:39:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;3장&quot;&gt;&lt;a href=&quot;#3장&quot; class=&quot;headerlink&quot; title=&quot;3장&quot;&gt;&lt;/a&gt;3장&lt;/h1&gt;&lt;details&gt;
  &lt;summary&gt;메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?&lt;/summary&gt;
  컨트롤러라는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="3장"><a href="#3장" class="headerlink" title="3장"></a>3장</h1><details>  <summary>메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?</summary>  컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.</details><details>  <summary>운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가</summary>운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코드만 메모리에 올리는데, 이 코드를 커널이라고 부른다.  </details><details>  <summary>입출력 장치에서 읽어온 데이터를 임시 저장하는 하드웨어 장치는 무엇이라고 하는가?</summary>  컨트롤러는 데이터를 데이터를 입출력 장치로 보내거나 가져오기 전에 임시 저장하는 메모리를 로컬 버퍼라고 한다.</details><details>  <summary>데이터를 읽어오는 명령을 컨트롤러가 완료하여 로컬 버퍼로 읽어오는 작업을 완료한 경우 어떻게 CPU에게 해당 사실을 알리는가? 그 사실을 안 CPU는 어떻게 행동하는가?</summary>  컨트롤러는 데이터를 모두 읽어온 경우, CPU의 인터럽트 라인에 인터럽트를 추가하여 해당 작업을 완료했음을 알린다. CPU는 매번 명령을 실행하기 전에 자신의 인터럽트 라인을 확인해서 처리해야할 인터럽트가 있는지 확인한다. 인터럽트가 존재하는 경우 인터럽트 벡터를 통해 인터럽트 처리 루틴이 존재하는 주소로 가서 인터럽트에 맞는 처리 로직을 실행한다.</details><details>  <summary>인터럽트의 종류와 각 종류의 차이점을 설명해보자.</summary>  인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 입출력 컨트롤러같은 하드웨어가 인터럽트 라인을 설정하고, 소프트웨어 인터럽트는 소프트웨어가 인터럽트 라인을 설정한다.</details><details>  <summary>소프트웨어 인터럽트의 종류에 대해 설명해보자.</summary> 소프트웨어 인터럽트는 예외 상황과 시스템콜과 있다. 예외상황은 프로세스가 잘못된 메모리를 접근하려거나 값을 0으로 나누려는 잘못된 연산을 할 때 발생한다. 반면 시스템콜은 사용자 프로그램이 운영체제 코드를 사용해야 할 때 운영체제에게 해당 코드를 실행해주기를 요청하는 방법이다.</details><details>  <summary>인터럽트를 처리할 때 CPU의 상태를 어떻게 저장되는가?</summary>  인터럽트를 처리해야 할 때 CPU의 레지스터 값, 하드웨어 상태, 실행 중인 코드 메무리 주소, 실행중인 위치 등을 PCB에 저장하고 CPU의 레지스터를 지운 다음 인터럽트 루틴을 실행한다.</details><details>  <summary>입출력 방식 두가지에 대해서 설명해보자.</summary>  입출력은 동기식 입출력, 비동기식 입출력이 있다. 동기식 입출력은 한 프로세스가 CPU를 점유해 진행 중에 입출력을 해야 하는 경우 그 프로세스가 해당 입출력 작업이 완료될 때까지 기다리고 CPU는 해당 프로세스의 점유를 뺏고 다른 프로세스를 진행시키는 방식이다. 이때 입출력 작업 완료를 기다리는 프로세스는 봉쇄 상태가 되어서 CPU 자원을 할당받지 못하게 된다. 반면 비동기식 입출력은 입출력을 해야 하는 경우 해당 입출력이 끝날 때까지 기다리지 않고 해당 프로세스에서 입출력 작업이 완료되지 않아도 수행할 수 있는 작업을 이어서 진행한다.</details><details>  <summary>동기식 입출력에서 입출력 발생 시 다른 프로세스에게 CPU를 할당했을 때 이 프로세스에서도 입출력이 발생하면 어떤 문제가 발생할 수 있고 이를 어떻게 방지하는가?</summary>  만약 먼저 실행하던 프로세스에서 입출력이 발생해서 다른 프로세스에게 CPU를 할당했는데 다음 프로세스도 입출력이 발생하면 여러 입출력 요청이 발생할 수 있다. 이 경우 입출력의 동기화가 지켜지지 않는 문제가 발생할 수 있다. 나중에 실행된 프로세스의 입출력 요청을 먼저 수행하고 처음 프로세스의 입출력이 같은 자원에 대한 입출력 요청을 했을 때 처음 프로세스는 예상하지 못한 결과를 얻을 수 있다. 이를 막기 위해 장치 별로 큐를 두어 요청한 순서대로 처리할 수 있게 한다.</details><details>  <summary>DMA라는 장치의 필요성에 대해 설명해보시오</summary>  입출력이 완료되어 로컬버퍼에 담긴 내용을 메모리에 올려야 할 때, 컨트롤러가 인터럽트 라인을 세팅해서 CPU가 메모리에 데이터를 적재하도록 한다. 문제는 이런 입출력 처리를 매번 인터럽트를 통해 CPU가 메모리에 적재하도록 하면 너무 여러번 CPU는 인터럽트 처리를 해야된다. DMA는 CPU가 메모리에 로컬버퍼의 데이터를 적재하는 일을 대리한다. 그래서 로컬버퍼 데이터를 메모리에 적재하는 일 때문에 CPU가 인터럽트 당하지 않도록 한다. DMA는 바이트 단위가 아니라 블록이라는 단위로 메모리를 읽어온 후 다 읽어온 경우 CPU에게 인터럽트를 통해 완료를 알린다.</details><details>  <summary>저장장치 계층 구조에 대해 설명해보자.</summary>  컴퓨터의 저장장치는 주기억장치와 보조기억장치로 나뉜다. 주기억장치는 메모리를 휘발성이고 일반적으로 RAM을 매체로 사용한다. 보조기억장치는 비휘발성으로 하드디스크나 SSD를 매체로 사용한다. 저장장치 계층 구조는 레지스터 - 캐시 메모리 - 메인 메모리 - 마그네틱 디스크- 광디스크- 마그네틱 테이프 이런 구조로 빠를 수록 비싸고 용량이 적다. 앞 세가지는 주기억장치이고 나머지는 보조기억장치이다.</details><details>  <summary>보조기억 장치의 목적에 대해 설명해보자. 각 목적의 비교를 해보자</summary>  보조기억 장치는 비휘발성의 특징을 통해 파일 시스템을 구현하는데 사용된다. 또한 주기억장치인 메모리의 연장 공간인 스왑 영역 역할을 한다. 운영체제는 프로그램 수행에 당장 필요하지 않은 부분은 디스크 스왑 영역에 적재한다. 이렇게 스왑 아웃된 영역은 필요하게 될 때 메모리에 올려서 사용하게 된다. 파일 시스템은 비휘발성을 활용하지만 스왑 영역은 메모리의 연장이므로 휘발성인 특징을 나타낸다.</details><details>  <summary>캐싱 기법에 대해서 설명하고 왜 효과적인지 설명해라.</summary>  상대적으로 빠른 저장장치를 이용해 느린 저장장치의 선응을 향상 시키는 총체적 기법을 일컫는다. 느린 저장장치에서 자주 사용되거나 당장 사용되는 정보를 빠른 저장장치에 선별적으로 저장해서 두 저장 장치 사이의 속도를 완충시킨다. 컴퓨터 내의 데이터나 프로그램을 구성하는 부분이 균등하게 사용되지 않고 일부분만 주로 사용하는 특성이 있기 때문에 적은 양의 캐시로도 효과를 볼 수 있다.</details><details>  <summary>하드웨어 보안이 필요한 이유와 어떻게 달성하는 지 설명해보라</summary>  여러 프로그램이 실행될 때 다른 프로그램의 메모리 영역에 침범하는 일이 발생할 수 있다. 이런 문제를 막기 위해 운영체제는 커널모드와 사용자모드를 분리해서 사용자 프로그램이 보안에 예민한 부분을 직접 제어하지 못하게 막고 운영체제에게 서비스를 요청하는 방식으로 구현했다. 모드비트를 통해 사용자 프로그램이 어떤 모드인지 검증하는 방식으로 위험한 연산을 하지 못하도록 막는다.</details><details>  <summary>메모리 보안을 어떻게 달성하는 지 설명해보고 한계를 설명해보라</summary>  사용자 프로그램이 정해진 메모리 주소 이내에 위치할 수 있도록 기준 레지스터와 한계 레지스터를 정해서 시작주소와 끝 주소를 정해놓는다. 해당 프로그램으로 직접 접근하려는 주소가 기준 레지스터와 한계 레지스터 사이에 없다면 잘못된 접근이라고 판단한다. 다만 이는 하나의 프로그램이 연속적으로 위치하는 단순한 메모리 관리 기법을 사용하는 경우로 한정했을 때 가능하다.</details><details>  <summary>한 프로그램이 CPU의 자원을 오랫동안 독점하는 상황을 막는 역할을 하는 하드웨어에 대해 설명해보자.</summary>  타이머라는 하드웨어를 통해 여러 프로그램이 돌아가면서 CPU를 점유하도록 한다. 특정 시간이 지나면 인터럽트를 일으켜서 운영체제가 CPU 제어권을 획득할 수 있도록 하는 역할을 수행한다.</details><h1 id="4장"><a href="#4장" class="headerlink" title="4장"></a>4장</h1><details>  <summary>CPU에서 프로그램이 실행되려면 메모리에 적재가 되어야 한다. 이때 프로그램 메모리 구조에 대해 설명해보자.</summary>  프로그램 메모리 구조는 네가지로 나뉜다. 소스 코드가 기계어로 변역된 코드가 저장되는 코드 영역, 프로그램의 전역 변수가 저장되는 데이터 영역, 프로그램에서 동적으로 할당된 메모리에 해당하는 힙 영역, 프로그램의 함수 호출 기록과 함수 내에서 사용한 지역 변수를 저장하는 스택 영역으로 나뉜다.</details장<details>  <summary>프로그램 내에서 함수 호출과 프로그램에서 인터럽트 발생 시 복귀 주소 저장 방식의 차이를 설명해보자.</summary>  사용자 프로그램의 함수 호출은 프로그램 메모리 구조 중 스택에 복귀 주소를 저장하고 호출한 함수로 이동해서 함수를 실행한다. 인터럽트 발생 시 복귀 주소는 커널의 메모리 구조 중 데이터 영역 속 PCB에 복귀 주소를 저장한다.</details><details>  <summary>프로그램 카운터 (PC)의 정의와 왜 필요한 지를 설명해보자.</summary>  CPU는 명령어를 하나씩 수행하는 역할을 한다. 이때 CPU가 읽어야할 명령어의 주소를 가리키는 것이 프로그램 카운터이다.</details><details>  <summary>일반명령과 특권명령에 대해 설명해보자.</summary>  일반 명령은 프로그램 메모리에 적재된 데이터를 읽거나 연산하거나 메모리에 데이터를 쓰는 일반적인 명령을 의미한다. 특권명령은 보안과 관련된 명령과 입출력하거나 타이머와 같은 장치가 관련된 명령을 의미한다.</details><details>  <summary>메모리에 프로그램을 적재할 때 프로그램의 모든 내용을 적재하지 않는다. 어떤 방식으로 적재하는 지 설명해보자.</summary>  운영체제는 프로그램에서 당장 필요한 부분만 메모리에 적재한다. 그렇지 않은 코드는 디스크에 스왑 영역에 적재하여 필요한 경우에 메모리에 올려 사용하도록 한다.</details><details>  <summary>커널 메모리 구조에서 스택 영역이 일반 프로그램 구조의 스택과 다른 특징에 대해 설명해보자.</summary>  일반 프로그램은 하나의 스택을 가지는 반면 커널 메모리 구조는 각 프로세스마다 스택을 두어서 분리해서 관리한다.</details><details>  <summary>커널 메모리 구조에서 데어터 영역에는 어떠한 자료구조가 있는지 설명해보자.</summary>  커널 데이터 영역에는 하드웨어와 프로세스를 관리하는 자료구조를 가지고 있다. 외부 입출력 장치를 통해 입출력하려는 프로세스를 줄세우는 큐가 있고, 각 프로세스의 상태 값을 저장하는 PCB가 있다.</details><details>  <summary>프로그램에서 함수 호출의 경우와 시스템콜이 발생하는 경우에 대해 프로그램과 커널의 메모리 구조를 중점으로 설명해보자.</summary>  프로그램에서 함수 호출은 프로그램 메모리의 스택에 복귀 주소를 저장하고 호출된 함수를 처리하고, 시스템콜이 발생하는 경우는 프로그램의 복귀 주소를 커널 메모리의 데이터 영역 속 PCB에 저장해놓고 스택 영역 속 해당 프로세스의 스택에서 실행되는 함수를 기록하고 실행한다.</details><details>  <summary>인터럽트 처리 중 다른 인터럽트가 발생을 허용하지 않는 이유를 설명해보고 만약 허용한다면 어떤 방식으로 처리하는 지 설명해보자.</summary>  인터럽트 처리 도중 다른 인터럽트가 발생해서 처리해야 하는 경우, 해당 인터럽트 루틴에서 사용하는 공유 데이터가 있다면 중간에 처리하는 인터럽트 때문에 공유 데이터의 일관성이 깨질 수 있다. 만약 허용한다면 인터럽트마다 우선 순위를 정해서 수행한다.</details><details>  <summary>일반적인 함수 호출을 다른 함수로 점프하는 반면 시스템콜은 어떻게 다른 코드로 이동하는 지 설명해보자. 그리고 왜 이런 차이가 있는지 설명해보자.</summary>  시스템콜에서 수행되어야 하는 코드는 프로그램의 메모리가 아닌 커널의 메모리에 있다. 이를 실행하려면 CPU 자원 점유를 운영체제가 해야 한다. 그래서 일반 함수 호출은 CPU 점유를 프로세스가 계속 가지지만 시스템콜은 CPU 점유를 운영체제가 하게 된다. 이 과정에서 인터럽트 라인을 세팅해서 CPU에 인터럽트를 발생시킨다.</details><details>  <summary>프로그램이 CPU를 할당받았다가 뺏기는 경우를 설명해보라.</summary>  CPU 할당된 시간이 다 되어서 타이머가 인터럽트를 발생시키거나 프로세스에서 동기식 입출력을 실행할 때 다른 프로그램에게 CPU 자원을 뺏기게 된다.</details><details>  <summary>프로그램이 실행 중이라는 의미는 해당 프로그램의 코드만 실행되는 것을 의미하진 않는다. 실행 될 수 있는 다른 코드를 설명해고 그런 경우에 어떻게 실행되고 있다고 하는지 설명해보자.</summary>  프로세스에서 시스템콜을 호출하는 경우 실행되어야 하는 코드는 해당 프로그램의 코드가 아닌 커널의 코드이다. 이럴 때는 여전히 해당 프로그램이 실행되고 있지만 커널 모드로 실행되고 있다고 말한다.</details><h1 id="5장"><a href="#5장" class="headerlink" title="5장"></a>5장</h1><details>  <summary>프로세스의 문맥이란 무엇일까요?</summary>  프로세스를 실행하기 위한 정보를 의미한다. 하드웨어, 운영체제, 프로세스 메모리 이렇게 세가지로 나뉜다. 하드웨어는 CPU의 PC나 레지스터 값들, 운영체제는 커널 메모리 데이터 영역의 PCB와 스택 영역의 해당 프로세스 커널 스택, 프로세스 메모리는 코드, 스택, 힙, 데이터 영역을 포함한 프로세스가 실행되기 위해 메모리에 올려져야 하는 내용을 말한다.</details><details>  <summary>프로세스의 상태를 설명해보세요?</summary>  프로세스 상태는 크게 6가지로 나뉜다.   시작 상태는 프로세스에 필요한 자료구조는 할당받았지만 아직 메모리를 할당받지 못한 상태이다.   준비 상태는 프로세스가 CPU 할당만 받으면 작업을 수행할 수 있는 상태를 의미한다.  실행 상태는 프로세스가 준비 상태에서 CPU 할당을 받아 작업을 실행 중인 상태다.  봉쇄 상태는 프로세스가 실행 도중 IO 작업 같이 먼저 선행되어야 하는 작업을 해야 해서 CPU를 다음 프로세스에게 넘기고 자신은 IO 작업이 완료될 때까지 대기하는 상태이다.  중지 상태는 외부 요인 때문에 프로세스가 작업을 진행할 수 없는 상태이다. 대표적으로 중기 스케줄러가 스왑 아웃한 프로세스가 중지 상태이다.  완료는 프로세스가 작업을 완수했으나 아직 프로세스와 관련된 자료구업가 아직 해제가 안된 상황이다.</details><details>  <summary>문맥 교환에 대해 설명해보세요</summary>  타이머 인터럽트나 IO 작업 발생으로 인해 실행 중인 프로세스가 다음 프로세스에게 CPU 자원을 넘겨줄 때 이전 프로세스가 실행되던 문맥을 저장하고, 다음 프로세스가 실행할 수 있는 문맥으로 바꾸는 행동을 문맥 교환이라고 한다.</details><details>  <summary>입출력을 진행하는 중이라 봉쇄된 프로세스 A와 지금 진행 중인 프로세스 B가 있다. 이때 디스크 컨트롤러가 인터럽트 라인을 설정하여 CPU가 이를 확인하고 인터럽트 처리 루틴을 실행하는 상황이라면 어떤 프로세스가 진행 중이라고 할 수 있을까?</summary>  이런 경우 아직 B 프로세스가 실행 중이라고 하며, 이때 B 프로세스가 커널 모드로 실행 중이라고 표현한다.</details><details>  <summary>문맥 교환에는 어떤 일이 벌어지는지 설명해보세요</summary>  이전에 실행되던 프로세스의 문맥을 PCB에 저장하고 다음 실행될 프로세스의 PCB를 통해 문맥을 하드웨어에 세팅한다.</details><details>  <summary>문맥 교환과 실행 모드 변경되는 상황의 차이를 설명해보세요</summary>  문맥 교환은 하드웨어 등 프로세스가 실행되는 문맥을 모두 바꾸는 것이지만, 실행 모드 변경은 여전히 같은 프로세스가 진행되고 있기 때문에 모든 문맥을 바꾸지 않고 PCB에 프로세스 명령어의 복귀 지점만 저장해놓는다.</details><details>  <summary>운영체제가 하드웨어와 소프트웨어를 관리하기 위한 큐를 커널의 메모리 구조 중 어떤 곳에서 관리할까요?</summary>  커널의 데이터 영역에서 하드웨어와 소프트웨어를 관리하는 자료구조를 관리한다.</details><details>  <summary>공유 데이터를 접근한 프로세스가 봉쇄 상태라면 다른 프로세스가 공유 데이터에 접근 할 수 있나요?</summary>  접근할 수 없다. 봉쇄 상태이더라도 공유 데이터 사용을 반납한 게 아니다. 프로세스가 공유 데이터 사용을 아직 반납하지 않은 상태에서 다른 프로세스가 이를 접근해서 수정하게 되면 데이터 일관성이 깨져서 기존에 사용하던 프로세스가 예상하지 못한 문제를 일으킬 수 있다.</details><details>  <summary>커널에서 프로세스 관리하는 큐의 종류에는 어떤 것이 있나요?</summary>  준비 상태인 프로세스를 줄 세운 준비큐,  입출력 장치 접근 권한을 줄세운 장치큐,  현재 모든 프로세스를 줄세운 작업큐</details><details>  <summary>단기, 중기, 장기 스케줄러에 대해 설명해보세요</summary>  단기 스케줄러는 준비큐의 프로세스 중 어떤 프로세스를 실행할 지 고른다.  중기 스케줄러는 메모리에 올라간 프로세스가 너무 많아 프로세스 실행이 효율적이지 않을 때 어떤 프로세스를 스왑 아웃할지 고른다. 일반적으로 봉쇄 상태에 있는 프로세스나 준비 상태에 있는 프로세스가 그 대상이 된다.  장기 스케줄러는 시작 상태인 프로세스 중 어떤 프로세스를 준비 상태로 할 지 고른다. 최근에는 메모리 용량이 넉넉해서 장기 스케줄러가 큰 의미가 없어졌다. </details><details>  <summary>부모와 자식 프로세스가 수행되는 모델 두 가지를 설명해보세요.</summary>  부모와 자식이 서로 동등한 입장으로 CPU 자원을 경쟁하는 경우가 있고, 자식 프로세스가 완료 될 때까지 부모 프로세스는 봉쇄 상태가 되는 경우가 있다.</details><details>  <summary>프로세스 간 협력 메커니즘인 IPC의 대표적인 방법 두가지를 설명해보세요.</summary>  공유 메모리 방식은 두 프로세스가 물리적으로 같은 메모리 공간을 참조하는 주소값을 같이 사용하는 방식이다.  메시지 전달 방식은 두 프로세스가 직간접적으로 연결해서 데이터 전달을 커널에게 의뢰하는 방식이다.</details><h1 id="6장"><a href="#6장" class="headerlink" title="6장"></a>6장</h1><details>  <summary>기계어 명령를 세가지로 분류하고 각 명령의 특징을 설명해보자.</summary>  CPU 명령어 : CPU 내부에서 레지스터 값을 제어하는 매우 빠른 명령  메모리 명령어 : 메모리에 값을 읽거나 쓰는 명령어 CPU 명령어보다는 느리지만 빠른 편이다.  입출력 명령어 : 하드웨어를 통해 입출력을 하는 명령어. 굉장히 느리다.</details><details>  <summary>CPU 스케줄링 기법이 필요한 이유는 무엇인가?</summary>  한정된 CPU 자원을 CPU 버스트가 각기 다른 프로세스들에게 효과적으로 분배하기 위해서 CPU 스케줄링이 필요하다.</details><details>  <summary>CPU 스케줄러는 어떤 일을 하는가?</summary>  준비 큐에 있는 프로세스 중 CPU를 할당받고 실행될 프로세스를 선정한다.</details><details>  <summary>CPU 스케줄러가 작동하는 여러 상황을 설명해보자.</summary>  타이머 인터럽트가 발생해서 실행 -> 준비 되는 경우  IO 요청에 의해 실행 -> 봉쇄 되는 경우  CPU 작업 완료되어 실행 -> 종료 되는 경우</details><details>  <summary>선점형과 비선점형 CPU 스케줄러를 구분지어 설명해보자.</summary>  선점형 스케줄러는 특정 프로세스가 실행 중일 때 실행 중인 프로세스보다 우선순위가 더 높은 프로세스가 준비큐에 진입하면 그 프로세스에게 CPU 자원을 넘기는 방식이다.  비선점형 스케줄러는 그런 경우에도 뺏기지 않는다.</details><details>  <summary>디스패처에 대해 설명해보자.</summary>  문맥교환이 일어날 때 PCB의 값을 하드웨어에 세팅해야 하는 일을 하는 운영체제 코드이다.</details><details>  <summary>스케줄링 성능 평가에 사용되는 다섯 가지 지표를 설명해보자.</summary>  CPU 이용률 : 주어진 시간동안 CPU가 작업을 처리한 시간 비율  처리량 : 주어진 시간동안 작업 완료한 프로세스 비율  소요 시간 : 한 프로세스가 CPU를 기다린 시간과 CPU 할당 받아 실행한 시간의 합  대기 시간 : 한 프로세스가 CPU 버스트동안 준비큐에서 기다린 시간  응답 시간 : 한 프로세스가 준비큐에 들어가서 처음 CPU를 할당받은 시간.</details><details>  <summary>선입선출 스케줄링의 장단점은?</summary>  먼저 온 프로세스를 완료할 때까지 CPU 자원 점유를 보장해주니 평균 소요시간과 평균 대기시간이 짧은 편이다. 하지만 CPU 버스트가 긴 프로세스가 점유하면 다른 프로세스들이 오랫동안 CPU를 점유하지 못하게 되는 콘보이 현상을 겪을 수 있다.</details><details>  <summary>최단 작업 우선 스케줄링의 장단점은?</summary>  CPU 버스트가 짧은 프로세스를 먼저 할당해서 IO 자원을 비교적 효율적으로 활용할 수 있고 선입선출 스케줄러의 콘보이 현상도 방지한다.   다만 준비큐에 CPU 버스트가 긴 프로세스가 있을 때 준비큐로 CPU 버스트가 짧은 프로세스가 계속 진입하면 CPU 버스트가 긴 프로세스는 CPU 자원을 점유하지 못하게 되는 기아 현상이 발생할 수 있다.</details><details>  <summary>우선순위 스케줄링의 장단점은?</summary>  우선순위 스케줄링도 기아 현상이 발생할 수 있다. 하지만 CPU 할당을 받지 못한 준비 상태의 프로세스들의 우선순위를 동적으로 한단계 올려주는 노화 기법으로 기아 현상을 해결할 수 있다.</details><details>  <summary>라운드 로빈 스케줄링에서 할당시간을 너무 길게 혹은 너무 짧게 설정하면 생기는 일에 대해 설명해보자.</summary>  라운드 로빈 스케줄링 할당 시간을 너무 늘리면 사실상 선입선출 스케줄링과 같아진다. 그래서 선입선출 스케줄링의 단점을 그대로 가져오게 된다.  할당 시간을 너무 짧게 하면 문맥 교환이 그만큼 더 자주 일어나게 되서 오버헤드가 커진다.</details><details>  <summary>선입선출 스케줄링에 비해 라운드 로빈 스케줄링의 장단점은?</summary>  라운드 로빈 스케줄링은 선입 선출에 비해 평해 소요시간이 길다는 단점이 있다. 하지만 평균 응답시간이 빠르다는 장점이 있다.</details><details>  <summary>멀티레벨 큐에 대해 설명해보자.</summary>  각 프로세스의 특징에 따라 여러 형태의 스케줄링 큐를 운영하는 방식이다. 응답을 빨리 해야되는 프로세스를 할당하는 라운드 로빈 전위 큐와 CPU 버스트가 긴 프로세스를 할당하는 선입 선출 후위 큐를 운영하는 방식으로 구현될 수 있다.</details><details>  <summary>멀티레벨 피드백 큐에 대해 설명해보자.</summary>  우선 순위가 다른 여러 큐를 운영하되, 프로세스가 각 큐를 이동할 수 있는 방식이다. 우선순위가 높은 큐에서 할당 받지 못하면 낮은 큐로 이동하는 방식인데, 이때 해당 프로세스의 우선순위를 높이는 노화 방식을 도입할 수 있다.</details><details>  <summary>스케줄링 알고리즘 평가 방법에 대해 설명해보자.</summary>  큐잉 모델, 시뮬레이션, 구현 및 실축</details>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/os/">OS</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패키지 설계의 원칙</title>
      <link>https://yangdongjue5510.github.io/2023/01/20/package/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/20/package/</guid>
      <pubDate>Fri, 20 Jan 2023 07:27:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;단위-크기-패키지-응집도의-원칙&quot;&gt;&lt;a href=&quot;#단위-크기-패키지-응집도의-원칙&quot; class=&quot;headerlink&quot; title=&quot;단위 크기: 패키지 응집도의 원칙&quot;&gt;&lt;/a&gt;단위 크기: 패키지 응집도의 원칙&lt;/h1&gt;&lt;p&gt;개발자가 어떻게</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="단위-크기-패키지-응집도의-원칙"><a href="#단위-크기-패키지-응집도의-원칙" class="headerlink" title="단위 크기: 패키지 응집도의 원칙"></a>단위 크기: 패키지 응집도의 원칙</h1><p>개발자가 어떻게 클래스를 패키지에 분류해 넣을지 결정할 때 도움이 되는 규칙 세가지를 알아보자. 이때 각 클래스의 상호 관계가 일부분이라도 밝혀져 있음을 가정한다.<br>모듈의 응집도는 모듈이 단 하나의 기능을 수행하는 속성을 의미했지만 패키지 응집도는 그보다 복잡하다. 재사용성과 개발 용이성에서 상충하는 가치를 검토하고 어플리케이션의 요구사항에 따라 패키지를 만들어야 한다.</p><h2 id="재사용-릴리즈-등가-원칙-REP-Reuse-Release-Equivalence-Principle"><a href="#재사용-릴리즈-등가-원칙-REP-Reuse-Release-Equivalence-Principle" class="headerlink" title="재사용 릴리즈 등가 원칙 (REP, Reuse-Release Equivalence Principle)"></a>재사용 릴리즈 등가 원칙 (REP, Reuse-Release Equivalence Principle)</h2><blockquote><p>재사용 단위가 릴리즈의 단위이다</p></blockquote><p>재사용성 릴리즈 등가 원칙은 재사용 단위(예를 들면 패키지)는 릴리즈 단위보다 작을 수 없다. 재사용하는 모든 것은 반드시 릴리즈된 다음 추적되어야 한다. 단일 클래스 달랑 만들고 재사용할 수 있다고 말하기 힘들다. 해당 재사용 단위의 안정성과 지원에 대한 보장을 제공해야 재사용성이라는 말을 할 수 있다.<br>패키지 내용물을 볼 때 잠재적인 재사용자의 입장에서 봐야 한다. 만약 패키지에 재사용될 소프트웨어가 들어 있다면, 그 패키지에는 재사용을 목적으로 설계뙤지 않은 소프트웨어는 들어 있지 않아야 한다. 패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않든지 해야 한다.</p><p>패키지 안의 모든 클래스는 동일한 재사용자를 대상으로 해야 한다. 어떤 사람의 관점에서 봤을 때, 한 패키지 안에서 일부 클래스는 필요하지만 일부는 전혀 필요 없으면 안된다.</p><h2 id="공통-재사용-원칙-CRP-Common-Reuse-Principle"><a href="#공통-재사용-원칙-CRP-Common-Reuse-Principle" class="headerlink" title="공통 재사용 원칙(CRP, Common-Reuse Principle)"></a>공통 재사용 원칙(CRP, Common-Reuse Principle)</h2><blockquote><p>패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 모두 재사용되어야 한다.</p></blockquote><p>함께 자주 재사용되는 클래스들은 동일한 패키지에 속하도록 해야 한다. 혼자 재사용되는 클래스는 거의 없다. 대부분 재사용 가능성에 대해 같은 추상적 범주에 있는 클래스들끼리 협력한다.<br>두 개의 패키지가 하나의 클래스로 인해 의존 관계가 생긴다고 가정하자. 그렇다면 의존되는 패키지가 변경되면 의존하는 패키지도 검증하고 다시 릴리즈 해야 한다. 따라서 어떤 패키징p 의존한다면 그 패키지의 모든 클래스에 의존하는지 확실히 해두어야 한다.<br>즉 CRP에 따르면 클래스 관계로 서로 단단히 묶여 있지 않은 클래스들은 같은 패키지에 넣지 말아야 한다.</p><h2 id="공동-폐쐐-원칙-CCP-Common-Closure-Principle"><a href="#공동-폐쐐-원칙-CCP-Common-Closure-Principle" class="headerlink" title="공동 폐쐐 원칙(CCP, Common-Closure Principle)"></a>공동 폐쐐 원칙(CCP, Common-Closure Principle)</h2><blockquote><p>같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야 한다.</p></blockquote><p>어떤 한 패키지를 변경할 이유도 여러가지면 안된다. 동일한 이유로 변할 것 같은 클래스들은 한 장소에 모아놓아야 한다.<br>이 원칙은 개방 폐쇄   원칙(OCP)과 밀접한 관련이 있다. OCP는 특정 오류의 변화에 개방되어 있는 클래스들은 같은 패키지 안에 몰아넣어서 이 전략을 더욱 확대한다. 따라서 요구사항에 변화가 오더라도 그에 따라 변경할 패키지 수를 최소화 할 수 있다.</p><h1 id="안전성-패키지-결합도의-원칙"><a href="#안전성-패키지-결합도의-원칙" class="headerlink" title="안전성: 패키지 결합도의 원칙"></a>안전성: 패키지 결합도의 원칙</h1><p>패키지 상호 관계에서 개바 ㄹ용이성과 논리적 설계 사이의 균형을 찾아 설계하는데 도움이 되는 세가지 규칙을 알아보자.</p><h2 id="의존-관계-비순환-원칙-ADP-Acyclic-Dependecies-Principle"><a href="#의존-관계-비순환-원칙-ADP-Acyclic-Dependecies-Principle" class="headerlink" title="의존 관계 비순환 원칙(ADP, Acyclic-Dependecies Principle)"></a>의존 관계 비순환 원칙(ADP, Acyclic-Dependecies Principle)</h2><blockquote><p>패키지 의존성 그래프에서 순환을 허용하지 말라</p></blockquote><p><img src="/img/%ED%8C%A8%ED%82%A4%EC%A7%80_%EB%B9%84%EC%88%9C%ED%99%98_%EB%B0%A9%ED%96%A5_%EA%B7%B8%EB%9E%98%ED%94%84.png"><br>이런 형태의 패키지 의존성 그래프가 있다고 가정해보자. 이 상황에서 만약 <code>Service A</code> 패키지를 변경하고 새롭게 릴리즈 하려고 하면 누가 영향 받는지 알기 쉽다. <code>Controller A</code> 패키지가 영향을 받을 것이다. 즉 <code>Service A</code>를 새롭게 릴리즈 되어도 <code>Controller A</code> 패키지만 신경 쓰면 된다. 다른 패키지들은 관심이 없다.</p><p>여기서 <code>Repository A</code> 패키지가 불행하게도 <code>Controller A</code> 패키지를 의존하게 됐다고 해보자.<br><img src="/img/%ED%8C%A8%ED%82%A4%EC%A7%80_%EC%88%9C%ED%99%98_%EB%B0%A9%ED%96%A5_%EA%B7%B8%EB%9E%98%ED%94%84.png"></p><p>이 상황에서 <code>Service A</code>를 새롭게 변경하고 릴리즈 하려는 경우에 얼마나 많은 패키지를 확인해봐야 할까? <code>Controller A</code> 뿐만 아니라 <code>Repository A</code>까지 검사를 해야 한다.</p><p>즉 양방향 의존성이 생기게 되면 그 사이클 안에 패키지가 새롭게 릴리즈 되어야 할 때 그 사이클의 모든 패키지가 영향을 받을 수 있으니 확인해야 하는 문제가 생긴다!!!</p><h3 id="순환-끊기"><a href="#순환-끊기" class="headerlink" title="순환 끊기"></a>순환 끊기</h3><p>의존성 순환이 생긴 경우 두가지 해결법이 있다.</p><ol><li>의존 관계 역전 원칙을 적용한다.<br>위 예시의 경우 <code>Repository A</code>가 필요로 하는 내용을 추상화해서 인터페이스로 만들어 <code>Repository A</code>에 놓고, 그 구현체를 <code>Controller A</code>에 둬서 의존 관계가 역전이 되게 만든다.</li><li>두 패키지가 서로 의존하는 새로운 패키지 만들기<br>위 예시의 경우 <code>Repository A</code>와 <code>Controller A</code> 모두 의존하는 패키지를 새롭게 추가할 수 있다.</li></ol><h1 id="패키지는-하향식-설계를-할-수-없다"><a href="#패키지는-하향식-설계를-할-수-없다" class="headerlink" title="패키지는 하향식 설계를 할 수 없다."></a>패키지는 하향식 설계를 할 수 없다.</h1><p>패키지 의존 관계 다이어그램은 애플리케이션의 기능을 기술하는 일과는 관련없다. 단지 애플리케이션의 빌드 용이성을 보여준다. 설계와 구현 초기 단계에 클래스가 적은 경우 어떤 것을 폐쇄해야 할 지, 재사용 가능한 것은 무엇인지를 알기 어렵다. 그래서 패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 성장하고 진화해야 한다.</p><ol><li>설계와 구현을 해가면서 클래스 수가 점점 증가함</li><li>SRP와 CCP를 통해 변경되기 쉬운 클래스를 함께 묶어둠</li><li>애플리케이션이 성장하면서 재사용 가능 요소를 고려하면서 CRP를 고려</li><li>순환이 나타나게 되면 ADP를 통해 구조 개선</li></ol><h1 id="안정된-의존-관계-원칙-SDP"><a href="#안정된-의존-관계-원칙-SDP" class="headerlink" title="안정된 의존 관계 원칙(SDP)"></a>안정된 의존 관계 원칙(SDP)</h1><blockquote><p>의존은 안정적인 쪽으로 향해야 한다.</p></blockquote><p>설계는 완전히 정적일 수 없다. 설계를 계속 유지보수하려면 어느 정도 변동성이 필요하다. 우리는 공통 폐쇄 원칙(CCP)를 지킴으로써 이것을 달성할 수 있다. 이제 안정된 의존 관계 원칙을 사용해서 어떤 종류의 변화에는 민감한 패키지를 만든다.</p><p>쉽게 바뀔 것이라고 예상되는 패키지들이 바뀌기 어려운 패키지들의 의존 대상이 되어서는 안된다. 이렇게 되면 쉽게 바뀔 패키지들도 바꾸기 어렵게 되어버린다. SDP를 지킴으로써 쉽게 변경할 수 있도록 의도한 모듈이 변경하기 어려운 모듈의 의존 대상이 되지 않도록 보장할 수 있다.</p><p>여기서 안정적인 패키지란 무엇인가? 특정 패키지 X가 있다고 할 때 그 패키지를 여러 곳에서 사용하고 있다고 하자. 그렇다면 X는 변경되기 어렵다. 즉 안정적이라고 볼 수 있다.<br>반면 X가 만약 여러 패키지를 사용하고 있다면? 변경에 제한이 없다. 그래서 변경되기 쉽고 불안정적이라고 볼 수 있다.</p><h2 id="안정성-측정법"><a href="#안정성-측정법" class="headerlink" title="안정성 측정법"></a>안정성 측정법</h2><ul><li><code>a</code> : 이 패키지에 의존하는 외부 클래스 갯수</li><li><code>b</code> : 외부 패키지에 의존하는 이 패키지의 클래스 갯수</li></ul><p>안정성 측정법은 <code>불안전성 = b / (a + b)</code>이다!!<br>만약 불안정성은 0과 1사이이며 클 수록 외부에 의존하는 경향이 크다.<br>결론은 남들 나에게 많이 의존하면 책임을 많이 지는 패키지이며 안정적이고, 내가 남들을 많이 의존하면 책임을 많이 지지 않으며 불안정적이다.</p><blockquote><p>SDP를 위반한다면?<br>불안정한 패키지와 안정한 패키지가 의존하게 되는 불안정한 패키지의 클래스를 찾아서 DIP로 추출한 인터페이스를 새로운 패키지에 둘 수 있다.</p></blockquote><h1 id="안정된-추상화-원칙-SAP"><a href="#안정된-추상화-원칙-SAP" class="headerlink" title="안정된 추상화 원칙(SAP)"></a>안정된 추상화 원칙(SAP)</h1><blockquote><p>패키지는 자신이 안정적인 만큼 추상적이기도 해야 한다</p></blockquote><p>어떤 패키지가 언정적이라면 확장할 수 있도록 추상 클래스들로 구성되어야 한다. 확장이 가능한 안정적인 패키지는 유연하며, 따라서 설계를 지나치게 제약하지 않는다.</p><h2 id="추상성-측정법"><a href="#추상성-측정법" class="headerlink" title="추상성 측정법"></a>추상성 측정법</h2><ul><li><code>a</code>: 패키지 안에 들어 있는 클래스 개수</li><li><code>b</code>: 패키지 안에 들어있는 추상 클래스 개수</li></ul><p>추상성 측정법은 <code>추상성 = b/a</code>이다.</p><h3 id="이상적인-상황과-비교"><a href="#이상적인-상황과-비교" class="headerlink" title="이상적인 상황과 비교"></a>이상적인 상황과 비교</h3><p>패키지는 안정성에 비해 너무 추상적이지 않고 추상성에 비해 너무 불안정하지도 않은 게 좋다. 자신이 추상적인 만큼 의존의 대상이 되고 자신이 구체적인 정도 만큼 다른 패키지에 의존한다.<br>x를 안정성이라하고 y를 추상성이라 할 때, (1,0)과 (0,1)을 잇는 직선을 주계열이라 하고 앞서 말한 좋은 패키지는 주계열에 근접할 수록 좋다.</p><p>이런 이상적인 상황과 거리를 구하는 공식은 다음과 같다.<br><code>정규화된 거리 = | 안전성 + 추상성 - 1 |</code><br>거리가 클 수록 주계열과 멀어지고 이상적이 상황과 멀어진다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-software/">Clean Software</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/20/package/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린 타입 시스템</title>
      <link>https://yangdongjue5510.github.io/2023/01/19/kotlinInAction/kotlinInActionCh6/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/19/kotlinInAction/kotlinInActionCh6/</guid>
      <pubDate>Thu, 19 Jan 2023 12:07:55 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;널-가능성&quot;&gt;&lt;a href=&quot;#널-가능성&quot; class=&quot;headerlink&quot; title=&quot;널 가능성&quot;&gt;&lt;/a&gt;널 가능성&lt;/h1&gt;&lt;h2 id=&quot;널이-될-수-있는-타입&quot;&gt;&lt;a href=&quot;#널이-될-수-있는-타입&quot; class=&quot;headerli</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="널-가능성"><a href="#널-가능성" class="headerlink" title="널 가능성"></a>널 가능성</h1><h2 id="널이-될-수-있는-타입"><a href="#널이-될-수-있는-타입" class="headerlink" title="널이 될 수 있는 타입"></a>널이 될 수 있는 타입</h2><p>어떤 타입이든 타입뒤에 ?를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다. 널 가능성이 있는 타입은 호출 가능한 메서드가 제한된다. 또한 파라미터에 널 가능성이 없는 타입이 선언된 경우 널 가능성이 있는 타입은 인자로 전달할 수 없다. 널 가능성이 있는 타입은 널 체크 이후 널 가능성이 없는 타입처럼 사용할 수 있다.</p><blockquote><p>자바에서 NPE 오류를 다루는 방법<br>어노테이션을 활용해서 널이 될 수 있는 여부를 표시.(<code>@Nullable</code>, <code>NotNull</code>) 하지만 이런 방식이 정식 자바 컴파일에 해당하는 것도 아니고 모든 NPE 발생 가능 지점에 사용하기도 어렵다. null 대신 optional을 사용할 수 있는데 성능이 저하될 수 있고 외부 라이브러리에서 Null 반환을 막을 수 없다.</p></blockquote><blockquote><p>널 가능성이 있는 타입과 널 가능성이 없는 타입의 객체는 같다.<br>널이 될 수 있는 타입이 특별한 래퍼 클래스는 아니다. 모든 검사는 컴파일 시점에 수행되고 런타임에 부가 비용이 들지 않는다.</p></blockquote><h2 id="안전한-호출-연산자"><a href="#안전한-호출-연산자" class="headerlink" title="안전한 호출 연산자 : ?."></a>안전한 호출 연산자 : ?.</h2><p><code>?.</code>은 null 검사와 메서드 호출을 한번의 연산으로 수행한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> upperS = s?.uppercase()</span><br><span class="line"><span class="comment">// 즉 이 코드와 같다.</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>) s.uppercase() <span class="keyword">else</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>이때 안전한 호출의 반환값도 널 가능성이 있는 타입임을 명심하자.</p><h2 id="엘비스-연산자"><a href="#엘비스-연산자" class="headerlink" title="엘비스 연산자 : ?:"></a>엘비스 연산자 : ?:</h2><p>특정 객체가 null 인 경우 디폴트값을 줄 때 엘비스 연산자를 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result : String = s?: <span class="string">&quot;it&#x27;s null&quot;</span></span><br></pre></td></tr></table></figure><p>안전한 호출과 연쇄해서 사용하기도 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result : String = s?.uppercase()?: <span class="string">&quot;it&#x27;s null&quot;</span></span><br></pre></td></tr></table></figure><p>엘비스 연산자 우항에는 식이 올 수 있다. 그래서 <code>return</code>이나 <code>throw</code>도 활용할 수 있다.</p><h2 id="안전한-캐스트-as"><a href="#안전한-캐스트-as" class="headerlink" title="안전한 캐스트: as?"></a>안전한 캐스트: as?</h2><p>코틀린은 타입 캐스트를 as로 하는데, 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다. 그래서 as를 하기 전에 is로 해당 타입으로 검사가 가능한지 확인할 수 있다. 하지만 이보다 더 좋은 방법이 as?이다<br>as?는 해당 타입으로 변경할 수 없으면 null을 반환한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o1: <span class="type">Any</span>?, o2: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1: Person = o1 <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">val</span> person2: Person = o2 <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> person1.name == person2.name &amp;&amp; person1.age == person2.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="널-아님-단언"><a href="#널-아님-단언" class="headerlink" title="널 아님 단언 : !!"></a>널 아님 단언 : !!</h2><p>널이 될 수 있는 타입을 명시적으로 널이 될 수 없는 타입으로 바꾸는 연산자가 !! 이다. 널 아님 단언을 사용했는데 대상 객체가 null이면 NPE가 발생하니 다른 연산자를 통해 처리하도록 하자.</p><h2 id="let-함수"><a href="#let-함수" class="headerlink" title="let 함수"></a>let 함수</h2><p>let은 널 가능성이 있는 타입이 null이 아닌 경우에만 람다를 실행하도록 하는 함수이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    name?.let &#123;</span><br><span class="line">        println(<span class="string">&quot;hi my name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 여러 값이 널인지 검증해야 된다면 let을 중첩시켜서 할 수는 있지만 코드가 복잡해지니 if로 여러값을 한번에 검사하는 게 낫다.</p><h2 id="나중에-초기화할-프로퍼티"><a href="#나중에-초기화할-프로퍼티" class="headerlink" title="나중에 초기화할 프로퍼티"></a>나중에 초기화할 프로퍼티</h2><p>코틀린에서는 클래스 안에 널이 될 수 없는 프로퍼티는 생성자 안에서 초기화되어야 한다. 만약 초기값으로 널이 아닌 값을 주지 못하면 널이 될 수 있는 프로퍼티로 선언해야 한다. 하지만 널이 될 수 있는 타입을 쓰면 모든 프로퍼티 접근에 널 검사를 하거나 !! 연산자를 사용해야 되는 불편함이 생긴다. 이를 해결하기 위해 나중에 초기화하는 기능을 사용할 수 있다. 나중에 초기화는 lateinit 변경자를 붙여서 특정 프로퍼티를 나중에 초기화 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manitto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> manitto: Person</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setManitto</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.manitto = person</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;hi my name is <span class="subst">$&#123;manitto.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> manitto = Manitto()</span><br><span class="line">manitto.setManitto(Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>))</span><br><span class="line">manitto.hello()</span><br></pre></td></tr></table></figure><h2 id="널이-될-수-있는-타입-확장"><a href="#널이-될-수-있는-타입-확장" class="headerlink" title="널이 될 수 있는 타입 확장"></a>널이 될 수 있는 타입 확장</h2><p>널 가능성이 있는 타입에 확장 함수를 정의할 수 있다. 확장 함수는 해당 객체를 통해 디스패치된 메서드가 아니기 때문에 해당 변수가 널인지 검사를 내부에서 할 수 있다. 이렇게 되면 안전한 호출을 사용하지 않아도 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">printHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) println(<span class="string">&quot;it&#x27;s null&quot;</span>) <span class="keyword">else</span> println(<span class="string">&quot;hello <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str: String? = <span class="string">&quot;hey&quot;</span></span><br><span class="line">str.printHello()</span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line">str.printHello()</span><br></pre></td></tr></table></figure><h2 id="타입-파라미터의-널-가능성"><a href="#타입-파라미터의-널-가능성" class="headerlink" title="타입 파라미터의 널 가능성"></a>타입 파라미터의 널 가능성</h2><p>코틀린의 모든 타입 파라미터는 기본적으로 널이 될 수 있다. 그래서 안전한 호출을 써야한다. (물론 예시코드는 안전한 호출없이도 된다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    println(t?.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 타입에 널이 될 수 없게 하려면 상한을 걸어두자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    println(t.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="널-가능성과-자바"><a href="#널-가능성과-자바" class="headerlink" title="널 가능성과 자바"></a>널 가능성과 자바</h2><p>자바에서 타입을 코틀린으로 옮길 때는 어노테이션의 유무에 따라 달라진다.<br>먼저 어노테이션이 있는 경우(@Notnull, @Nullable)는 자연스럽게 널 가능성이 없거나 널 가능성이 있는 타입으로 치환된다.</p><p>문제는 어노테이션이 없는 경우인데, 이 경우 코틀린에서 플랫폼 타입을 사용한다.</p><h3 id="플랫폼-타입"><a href="#플랫폼-타입" class="headerlink" title="플랫폼 타입"></a>플랫폼 타입</h3><p>플랫폼 타입은 널 가능성을 판단할 수 없는 타입을 말한다. 이 경우 널 가능성이 없다고 판단하고 사용해도 되고, 널 가능성이 있다고 판단하고 널 처리를 해도 된다. 개발자에게 판단을 넘긴 셈이다.</p><h3 id="자바-메서드를-오버라이딩할-때-널-주의"><a href="#자바-메서드를-오버라이딩할-때-널-주의" class="headerlink" title="자바 메서드를 오버라이딩할 때 널 주의"></a>자바 메서드를 오버라이딩할 때 널 주의</h3><p>코틀린에서 자바 메서드를 오버라이딩할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할 지 널이 될 수 없는 타입으로 선언할 지 결정해야 한다. 만약 널 가능성이 있는 파라미터로 개발하면 코틀린 컴파일러가 널이 아님을 검사하는 단언문을 만들어줁다. 내부에서 사용하지 않는 파라미터도 널 체크가 되기 때문에 이를 유의하자.</p><h1 id="코틀린의-원시-타입"><a href="#코틀린의-원시-타입" class="headerlink" title="코틀린의 원시 타입"></a>코틀린의 원시 타입</h1><p>코틀린은 숫자나 불린을 래퍼타입으로 구분하지 않는다. 다만 런타임에 숫자 타입은 가장 효율적인 방식으로 표현된다. 원시타입으로 컴파일이 안되는 제네릭 클래스 같은 경우에 래퍼타입이 들어간다.</p><h2 id="널이-될-수-있는-원시-타입-Int-Boolean"><a href="#널이-될-수-있는-원시-타입-Int-Boolean" class="headerlink" title="널이 될 수 있는 원시 타입: Int?, Boolean?"></a>널이 될 수 있는 원시 타입: Int?, Boolean?</h2><p>코틀린의 Int가 자바의 원시타입 int로 대부분 변환되고 제네릭 같은 경우에만 래퍼 클래스로 활용된다는 건 자연스럽다. 둘다 널 가능성이 없기 때문이다.</p><p>한편 코틀린에서 널 가능성이 있는 원시타입을 사용하면 자바에서는 래퍼 타입으로 변환된다. 또한 제네릭 클래스의 경우 래퍼 타입을 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfInts = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>위 예시는 자바에서 리스트 안에 원시 타입이 오지 못하므로 래퍼 클래스인 Integer가 오는 게 자연스럽다.</p><h3 id="숫자-변환"><a href="#숫자-변환" class="headerlink" title="숫자 변환"></a>숫자 변환</h3><p>코틀린은 한 숫자 타입이 정해지면 다른 숫자 타입으로 자동으로 변환되지 않는다. 대신 직접 변환 메서드를 호출해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = i.toLong()</span><br></pre></td></tr></table></figure><h2 id="Any-Any-최상위-타입"><a href="#Any-Any-최상위-타입" class="headerlink" title="Any, Any? : 최상위 타입"></a>Any, Any? : 최상위 타입</h2><p>자바에 Object가 있다면 코틀린에는 Any가 있다. 자바에서는 모든 객체의 조상이 Object이지만 코틀린은 원시 타입도 포함한 모든 값과 객체의 조상이 Any이다.<br>다만 널 가능성에 따라 두 종류로 나뉘며, toString, equals, hashCode 외에 다른 Object 메서드는 지원하지 않는다. 만약 그런 메서드를 호출해야 하는 경우엔 캐스트해서 호출해야 한다.</p><h2 id="Unit-타입-코틀린의-void"><a href="#Unit-타입-코틀린의-void" class="headerlink" title="Unit 타입 : 코틀린의 void"></a>Unit 타입 : 코틀린의 void</h2><p>코틀린의 Unit은 자바의 void와 매우 흡사하다. 다만 Unit은 타입 인자로 사용할 수 있다. Unit도 값이 있다. 단 하나 Unit에 속하는 값은 이름도 Unit이다. 엄밀히 말하면 Unit은 반환값이 없는 것이 아니다. 기본 반환값으로 이해하면 좋다.<br>코틀린에서 인터페이스에 반한값을 적지 않으면 묵시적으로 Unit을 반환하는 것을 의미하며 return Unit을 하지 않아도 컴파일러가 알아서 넣어준다.</p><h2 id="Nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다"><a href="#Nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다" class="headerlink" title="Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다."></a>Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다.</h2><p>예외를 던져서 항상 제대로 값을 돌려주지 않는 함수에 Nothing을 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nothing의 진가는 엘비스 연산자의 우항으로 쓰일 때 진면목을 보인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> address = Company(<span class="literal">null</span>).address ?: fail(<span class="string">&quot;no address&quot;</span>)</span><br><span class="line">println(address.length)</span><br></pre></td></tr></table></figure><p>null 인 경우 Nothing인 메서드가 실행된다면, 이후 address에는 반드시 null이 아니라는 것을 확신할 수 있어서 널 가능성이 없는 타입으로 취급하고 사용할 수 있다.</p><h1 id="컬렉션과-배열"><a href="#컬렉션과-배열" class="headerlink" title="컬렉션과 배열"></a>컬렉션과 배열</h1><h2 id="읽기-전용과-변경-가능한-컬렉션"><a href="#읽기-전용과-변경-가능한-컬렉션" class="headerlink" title="읽기 전용과 변경 가능한 컬렉션"></a>읽기 전용과 변경 가능한 컬렉션</h2><p>코틀린 컬렉션은 자바 컬렉션과는 다르게 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션안의 데이터를 변경하는 인터페이스를 분리했다는 점이 다르다.<br><code>kotlin.collections.Collection</code> 은 이터레이션, 사이즈 조회, 값 유무 검사, 데이터 조회 등을 지원하지만 컬렉션에 추가 및 제거는 지원하지 않는다. 변경 가능한 컬렉션은 이를 확장한 <code>kotlin.collections.MutableCollection</code> 인터페이스를 활용한다.</p><p>하지만 컬렉션 인터페이스를 활용할 때 주의점은 읽기 전용 인터페이스로 컬렉션을 활용하다고 그 컬렉션 객체가 실제로 불변 객체는 아니라는 점이다. 즉 다른 변경 가능한 컬렉션 인터페이스를 참조 변수로 접근하면 충분히 해당 객체에 변경이 생길 수 있고 이는 읽기 전용 컬렉션이 스레드 안전하지는 않음을 의미한다.</p><h2 id="코틀린-컬렉션과-자바"><a href="#코틀린-컬렉션과-자바" class="headerlink" title="코틀린 컬렉션과 자바"></a>코틀린 컬렉션과 자바</h2><p>코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스 두가지 표현을 제공한다.<br>코틀린은 코틀린 컬렉션 인터페이스가 마치 자바 컬렉션 클래스의 상위 타입인 것처럼 취급한다. 이를 통해 자바 호환성을 제공한다.</p><blockquote><p>컬렉션 생성 함수와 자바 객체<br>일반적으로 <code>listOf</code>는 읽기 전용을, <code>mutableListOf</code>는 변경 가능한 객체를 반환하는 식으로 작동한다. 이때 <code>setOf</code>와 <code>mapOf</code>는 자바 표준 라이브러리에 속한 클래스의 인스턴스를 반환한다. 즉 내부는 변경 가능한 컬렉션 객체인 셈이지만 절대 그 사실에 의존하지 않도록 하자</p></blockquote><h3 id="지비-메서드에서-Collection을-매개변수로-코틀린-컬렉션-받을-때-주의-사항"><a href="#지비-메서드에서-Collection을-매개변수로-코틀린-컬렉션-받을-때-주의-사항" class="headerlink" title="지비 메서드에서 Collection을 매개변수로 코틀린 컬렉션 받을 때 주의 사항"></a>지비 메서드에서 Collection을 매개변수로 코틀린 컬렉션 받을 때 주의 사항</h3><p>코틀린에서 읽기 전용과 변경 가능한 컬렉션을 구분해도 자바 메서드에서 Collection을 매개변수로 받을 때는 이 구분이 의미가 없어지게 된다. 즉 읽기 전용으로 제한하던 인스턴스를 Collection을 매개변수로 갖는 자바 메서드에 전달하면 해당 메서드에서 변경 가능하게 할 수 있다는 의미다. 그래서 자바에서 올바른 파라미터 타입을 사용하고, 자바에서 코틀린에서 온 컬렉션을 사용해야 하는 경우 제한을 잘 확인하고 사용하자.</p><h2 id="컬렉션을-플랫폼-타입으로-다루기"><a href="#컬렉션을-플랫폼-타입으로-다루기" class="headerlink" title="컬렉션을 플랫폼 타입으로 다루기"></a>컬렉션을 플랫폼 타입으로 다루기</h2><p>자바에서 코틀린으로 오면 플랫폼 타입으로 온다. 이는 컬렉션도 마찬가지다. 플랫폼 타입인 컬렉션은 기본적으로 읽기 전용과 변경 가능 컬렉션 모두 사용할 수 있도록 한다.</p><p>문제는 플랫폼 타입은 그렇듯이 자바의 시그니처를 오버라이딩 할 때가 문제가 된다. 즉 자바 인터페이스의 시그니처에 컬렉션이 있는 경우 null 가능성과 컬렉션의 변경 가능성을 토대로 타입을 구체화해야 한다.</p><ul><li>컬렉션이 null 가능한가</li><li>컬렉션의 원소가 null 가능한가</li><li>오버라이딩할 메서드가 컬렉션을 수정할 수 있는가</li></ul><h2 id="객체의-배열과-원시값의-배열"><a href="#객체의-배열과-원시값의-배열" class="headerlink" title="객체의 배열과 원시값의 배열"></a>객체의 배열과 원시값의 배열</h2><p>코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소 타입은 타입 파라미터에 의해 정해진다.<br>문제는 코틀린 배열이 항상 제네릭 타입을 받다보니 자바 코드로 바뀔 때 코틀린에서 원시 타입 배열이어도 자바에서는 래퍼 타입 배열이 되버린다. <code>Array&lt;Int&gt;</code> 가 <code>Intger[]</code>이 되어버린다.</p><p>이럴 경우 박싱하지 않은 원시 타입 배열을 의미하는 특별한 클래스를 활용해야 한다. IntArray, ByteArray 등 원시 타입마다 제공해준다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/19/kotlinInAction/kotlinInActionCh6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>람다로 프로그래밍</title>
      <link>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/</guid>
      <pubDate>Tue, 17 Jan 2023 10:21:40 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;람다-식과-멤버-참조&quot;&gt;&lt;a href=&quot;#람다-식과-멤버-참조&quot; class=&quot;headerlink&quot; title=&quot;람다 식과 멤버 참조&quot;&gt;&lt;/a&gt;람다 식과 멤버 참조&lt;/h1&gt;&lt;h2 id=&quot;람다-식의-문법&quot;&gt;&lt;a href=&quot;#람다-식의-문법&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="람다-식과-멤버-참조"><a href="#람다-식과-멤버-참조" class="headerlink" title="람다 식과 멤버 참조"></a>람다 식과 멤버 참조</h1><h2 id="람다-식의-문법"><a href="#람다-식의-문법" class="headerlink" title="람다 식의 문법"></a>람다 식의 문법</h2><p>코틀린의 람다 식은 항상 중괄호로 둘러 쌓여 있다. 그리고 인자 목록을 괄호로 싸지 않는다. 람다를 변수에 저장하고 함수처럼 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125;</span><br><span class="line"></span><br><span class="line">println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>실행 시점에서 코틀린 람다 호출에는 아무 부가 비굥이 들지 않으며 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.</p><p>사람 목록에서 가장 연장자를 찾는 예제를 작성해본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">10</span>), Person(<span class="string">&quot;Rob&quot;</span>, <span class="number">11</span>))</span><br><span class="line">println(people.maxBy &#123; it.age &#125;)</span><br></pre></td></tr></table></figure><p><code>maxBy</code> 함수에 나이를 반환하는 람다를 전달했다. 이때 <code>maxBy</code> 부분을 최대한 풀어서 쓰면 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy(&#123; p:Person -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure><p>하지말 이렇게 쓰면 너무 번잡하다. 어떻게 간편하게 개선되는지 알아보자.</p><p>먼저 함수의 맨 마지막 인자가 람다면 괄호 밖으로 뺄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy() &#123; p:Person -&gt; p.age &#125;</span><br></pre></td></tr></table></figure><p>그리고 람다만 가지고 있는 함수에서 람다를 밖으로 빼면 빈 괄호를 생략할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p:Person -&gt; p.age&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 람다 파라미터를 컴파일러가 예상할 수 있어서 생략할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p.age &#125;</span><br></pre></td></tr></table></figure><p>하지만 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아서 파라미터 타입을 명시해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> getAge = &#123; p: Person -&gt; p.age &#125;</span><br><span class="line">people.maxBy(getAge)</span><br></pre></td></tr></table></figure><p>코틀린에서 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 <code>it</code> 키워드를 통해 파라미터를 표현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; it.age &#125;</span><br></pre></td></tr></table></figure><p>람다의 본문에 여러 줄이 될 수 있다. 그럴 때는 마지막 줄이 해당 람다의 반환값이 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$x</span> and <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="현재-영역에-있는-변수에-접근"><a href="#현재-영역에-있는-변수에-접근" class="headerlink" title="현재 영역에 있는 변수에 접근"></a>현재 영역에 있는 변수에 접근</h2><p>람다는 함수 파라미터를 람다 안에서 사용하 ㄹ수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMessageWithPrefix</span><span class="params">(messages: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;, prefix: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    messages.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$prefix</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바와 다르게 코틀린의 람다는 파이널 변수가 아닌 변수에 접근할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProblemCounts</span><span class="params">(responses: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clientErrors = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> serverError = <span class="number">0</span></span><br><span class="line">    responses.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;4&quot;</span>)) &#123;</span><br><span class="line">            clientErrors++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;5&quot;</span>)) &#123;</span><br><span class="line">            serverError++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$clientErrors</span> and <span class="variable">$serverError</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 만약 함수가 변수를 포획한 람다를 반환한다면 변수의 생명 주기는 함수와 달라지게 된다. 함수가 종료되어도 변수를 포획한 람다를 실행하면 해당 변수를 일고 쓸 수 있다. 파이널 변수를 포획한 경우 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수는 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.</p><p>다만, 람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryToCountButtonClick</span><span class="params">(button: <span class="type">Button</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clicks = <span class="number">0</span></span><br><span class="line">    button.onClick &#123; clicks++&#125;</span><br><span class="line">    <span class="keyword">return</span> clicks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 함수에서 로컬변수를 반환해서 변수의 변화를 볼 수 없다.</p><h3 id="멤버-참조"><a href="#멤버-참조" class="headerlink" title="멤버 참조"></a>멤버 참조</h3><p>자바 8의 메서드 참조와 동일한 기능을 코틀린의 멤버 참조로 할 수 있다. 코틀린은 메서드뿐만 아니라 프로퍼티도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy(Person::age)</span><br></pre></td></tr></table></figure><p>그리고 최상위로 선언된 함수나 프로퍼티를 참조할 수 있다. 또한 생성자를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">salute</span><span class="params">()</span></span> = pritnln(<span class="string">&quot;Salute!&quot;</span>)</span><br><span class="line">run(::salute)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> createPerson = ::Person</span><br><span class="line"><span class="keyword">val</span> person = createPerson(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><h3 id="바운드-멤버-참조"><a href="#바운드-멤버-참조" class="headerlink" title="바운드 멤버 참조"></a>바운드 멤버 참조</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunc = Person::age</span><br><span class="line">println(personAgeFunc(p))</span><br></pre></td></tr></table></figure><p>코틀린 1.0에서는 클래스의 메서드나 프로퍼티에 참조를 얻고 클래스 인스턴스를 전달해줘야 가능했다. 하지만 코틀린 1.1부터는 바운드 멤버 참조를 지원한다. 바운드 멤버 참조는 클래스 인스턴스를 함께 저장한 다음 그 인스턴스에 대해 멤버를 호출한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunc = p::age</span><br><span class="line">println(personAgeFunc())</span><br></pre></td></tr></table></figure><h1 id="컬렉션-함수형-API"><a href="#컬렉션-함수형-API" class="headerlink" title="컬렉션 함수형 API"></a>컬렉션 함수형 API</h1><h2 id="필수적인-함수-filter-map"><a href="#필수적인-함수-filter-map" class="headerlink" title="필수적인 함수: filter, map"></a>필수적인 함수: filter, map</h2><p>filter는 특정 조건에 해당하는 원소만 남길 수 있다.<br>map은 원소를 바꾸어서 새 컬렉션을 만든다.</p><h2 id="all-any-count-find-컬렉션에-술어-적용"><a href="#all-any-count-find-컬렉션에-술어-적용" class="headerlink" title="all, any, count, find: 컬렉션에 술어 적용"></a>all, any, count, find: 컬렉션에 술어 적용</h2><p>count는 조건을 만족하는 원소의 갯수를 반환한다. 참고로 filter를 한 컬렉션의 size를 측정하는 것보다 count를 사용하는 것이 결과 컬렉션을 만들지 않아서 더 효과적이다.<br>find는 조건을 만족하는 원소의 첫번째 원소를 반환한다.<br>all은 모든 원소가 조건에 만족하는 지 반환한다.<br>any는 조건에 만족하는 원소가 하나라도 존재하는 지 확인한다.</p><h2 id="groupBy-리스트를-여러-그룹으로-이뤄진-맵으로-변경"><a href="#groupBy-리스트를-여러-그룹으로-이뤄진-맵으로-변경" class="headerlink" title="groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경"></a>groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(list.groupBy(String::first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map&lt;Int, List&lt;String&gt;&gt;</code>을 만들어서 반환한다. 위 예시는 <code>&#123;a=[a, ab], b=[b]&#125;</code></p><h2 id="flatMap과-flatten-중첩된-컬렉션-안의-원소-처리"><a href="#flatMap과-flatten-중첩된-컬렉션-안의-원소-처리" class="headerlink" title="flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리"></a>flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리</h2><p>flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(map) 결과로 얻어지는 여러 리스트를 한 리스트로 모은다(flat).</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>)</span><br><span class="line">println(strings.flatMap &#123; it.toList() &#125;)</span><br></pre></td></tr></table></figure><p>문자열을 list로 매핑하고, 각 매핑된 컬렉션들을 하나의 컬렉션으로 모은다.<br>중첩된 리스트이 원소를 한 리스트로 단순히 모아야 하는 경우 flatten 함수를 사용할 수 있다.</p><h1 id="지연-계산-lazy-컬렉션-연산"><a href="#지연-계산-lazy-컬렉션-연산" class="headerlink" title="지연 계산(lazy) 컬렉션 연산"></a>지연 계산(lazy) 컬렉션 연산</h1><p>map, filter 같은 컬렉션 함수는 컬렉션을 즉시 생성해서 반환한다. 즉 컬렉션 함수를 연쇄적으로 사용하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;A&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>이 경우에 map과 filter의 결과를 리스트로 만들어 저장한다. 즉 중간 계산 결과가 두번 저장된다. 중간 게산 결과값이 크면 중간 계산 결과 저장이 비효율적일 것이다.</p><p>코틀린에서는 시퀀스를 통해 중간 임시 컬렉션을 사용하지 않도록 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>코틀린 지연 연산 시퀀스는 <code>Sequence</code> 인터페이스에서 시작한다. 이 인터페이스는 iterator라는 메서드를 통해 원소값을 얻어 낸다. 하지만 하나씩 접근하는 것 외에 인덱스로 접근이나 다른 API를 사용하려면 시퀀스를 다른 컬렉션으로 다시 바꿔주자.</p><h2 id="시퀀스-연산-실행-중간-연산과-최종-연산"><a href="#시퀀스-연산-실행-중간-연산과-최종-연산" class="headerlink" title="시퀀스 연산 실행: 중간 연산과 최종 연산"></a>시퀀스 연산 실행: 중간 연산과 최종 연산</h2><p>시퀀스에 적용되는 함수는 일반적인 컬렉션 함수와 다르게 작동한다. 컬렉션 함수는 적용 즉시 컬렉션을 반환하지만, 시퀀스 함수에는 중간 연산과 최종 연산을 나눠서 생각해야 한다. 중간 연산은 최초 시퀀스에서 중간 연산을 적용할 줄 아는 시퀀스이다. 최종 연산은 연산들을 모두 적용한 결과를 반환한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>이 예시는 중간 연산만 적용되어 있어서 아직 연산이 적용된 결과 값이 만들어지지 않았다. 하지만 다음 예시처럼 최종 연산이 들어가면 비로소 모든 연산이 적용되고 결과값이 반환된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>여기서 컬렉션과 시퀀스의 연산 적용 방식에 차이를 알아보자.<br>컬렉션은 하나의 연산마다 모든 컬렉션에 적용을 한다. 반면 시퀀스는 하나의 원소에 모든 연산을 모아서 한번에 적용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).asSequence()</span><br><span class="line">    .map &#123; it*it &#125;</span><br><span class="line">    .find &#123; it &gt; <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>위와 같은 예시에서 컬렉션으로 연산했다면, 1 2 3 4 모두 map해야 한다. 그 다음 find를 진행한다.<br>하지만 시퀀스의 경우 1 2만 모든 연산이 적용된다. 왜? 마지막 find는 최초 원소를 찾는데 2에 모든 연산을 적용하고 나서 조건을 만족함을 확인했기 때문에 3 4에 연산을 적용하지 않는 것이다.</p><blockquote><p>자바 스트림과 코틀린 시퀀스의 차이<br>사실 스트림과 매우 비슷하나 스트림의 병렬 처리를 시퀀스에서 제공하지 않는다. 다만 시퀀스는 자바 8보다 낮은 버전에서도 활용할 수 있다.</p></blockquote><h3 id="시퀀스-만들기"><a href="#시퀀스-만들기" class="headerlink" title="시퀀스 만들기"></a>시퀀스 만들기</h3><p><code>asSequence</code>함수와 <code>generateSequence</code> 함수를 통해 시퀀스를 만들 수 있다.<br><code>generateSequence</code> 함수는 첫 원소를 인자로 받고 다음 원소들을 계산하는 법을 람다로 받아서 만든다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> printZeroTo100 = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span>&#125;</span><br><span class="line">    .takeWhile &#123; it &lt;= <span class="number">100</span> &#125;</span><br><span class="line">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h1 id="자바-함수형-인터페이스-적용"><a href="#자바-함수형-인터페이스-적용" class="headerlink" title="자바 함수형 인터페이스 적용"></a>자바 함수형 인터페이스 적용</h1><h2 id="자바-메소드에-람다로-인자-전달"><a href="#자바-메소드에-람다로-인자-전달" class="headerlink" title="자바 메소드에 람다로 인자 전달"></a>자바 메소드에 람다로 인자 전달</h2><p>함수형 인터페이스를 인자로 요구하는 자바 메서드에 코틀린 람다를 전달해줄 수 있다. 이 경우 컴파일러가 자동으로 람다를 해당 인터페이스의 인스턴스로 변환해준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void compute(Runnable computation); 이란 자바코드가 있다고 가정</span></span><br><span class="line">compute &#123; println(<span class="string">&quot;hi&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>물론 무명 객체를 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compute(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">       println(<span class="string">&quot;hi&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>하지만 람다를 전달하는 것과 무명 객체를 전달하는 것은 차이가 있다. 객체를 명시적으로 선언하면 메서드를 호출할 때마다 새로운 객체가 생성된다. 반면 람다는 람다에 대응하는 무명 객체를 메서드가 호출 할때마다 반복 사용한다. (하지만 함수의 변수에 접근하는 람다는 제외)</p><blockquote><p>람다와 무명 클래스 객체의 this 차이<br>무명 클래스 객체의 this는 자기 자신을 가리킨다. 반면 람다는 컴파일 타임에 아직 인스턴스가 없으므로 자기 자신을 가르킬 방법이 없다. 람다에서 this를 가르킬 경우 람다를 감싼 클래스 객체를 가리키게 된다. 만약 자기 자신을 가르켜야 되는 경우는 람다 대신 무명 객체를 활용하자.</p></blockquote><blockquote><p>람다를 무명 클래스의 인스턴스로 변환하는 것은 함수형 인터페이스를 받는 자바 메서드의 경우에만 그렇다.<br>컬렉션 확장 함수 (inline 표시된 코틀린 함수)에게 람다를 전달해도 무명 클래스가 만들어지지 않는다.</p></blockquote><h2 id="SAM-생성자-람다를-함수형-인터페이스로-명시적-변경"><a href="#SAM-생성자-람다를-함수형-인터페이스로-명시적-변경" class="headerlink" title="SAM 생성자: 람다를 함수형 인터페이스로 명시적 변경"></a>SAM 생성자: 람다를 함수형 인터페이스로 명시적 변경</h2><p>SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동 생성한 함수다. 컴파일러가 자동으로 람다를 함수형 인터페이스의 무명 클래스 인스턴스로 변환하지 못할 때 사용한다. 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 경우 람다로 반환하지 못한다.<br>SAM 생성자는 함수형 인터페이스의 이름과 람다식을 전달해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createAllRunnable</span><span class="params">()</span></span> : Runnable &#123;</span><br><span class="line">    <span class="comment">//람다는 안됨 return &#123; println(&quot;GOOD!&quot;)&#125;</span></span><br><span class="line">    <span class="keyword">return</span> Runnable &#123; println(<span class="string">&quot;GOOD!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="수신-객체-지정-람다-with-amp-apply"><a href="#수신-객체-지정-람다-with-amp-apply" class="headerlink" title="수신 객체 지정 람다 : with &amp; apply"></a>수신 객체 지정 람다 : with &amp; apply</h1><p>수신 객체를 명시하지 않고 람다에서 다른 객체의 메서드를 호출하는 기능을 수신 객체 지정 람다라고 한다.</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with의 힘을 느껴보기 위해 하나의 예시를 들어보고 with로 리팩토링 해보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">&quot;\n alphabet end~\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 StringBuilder를 with로 처리하면 다음과 같다. with에 수신 객체를 적어두면 람다 내부에서 수신 객체를 적는 대신 this로 접근할 수 있다. 이렇게 하면 다양한 StringBuilder에서 해당 로직을 재활용 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>)</span><br><span class="line">        <span class="keyword">this</span>.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 this를 생략할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>메서드 이름 충돌<br>만약 위 예시의 toString이 StringBuilder가 아닌 해당 함수를 감싼 클래스의 toString을 호출하고 싶다면 어떻게 해야되나? <code>this@OuterClass.toString()</code>와 같은 방식으로 적어주면 된다.</p></blockquote><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply는 with와 같다. 다만 항상 수신 객체를 반환한다. 그리고 확장함수로 정의되어 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> StringBuilder().apply &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>) </span><br><span class="line">    &#125;.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 수신 객체 지정 람다를 사용하는 더 구체적인 예시로 buildString 같은 함수가 있다. 인자로 수신 객체 지정 람다를 받으며(매번 수신 객체는 StringBuilder로 고정), StringBuilder 객체 생성과 toString 호출을 알아서 해주는 녀석이다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>구글 엔지니어는 이렇게 일한다. 문화 편</title>
      <link>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/</guid>
      <pubDate>Thu, 12 Jan 2023 12:37:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;구글 엔지니어는 이렇게 일한다&lt;/code&gt; 라는 책에서 필요한 부분을 읽고 기록해두는 포스트다. 많은 부분이 생략되어 있다.&lt;/p&gt;
&lt;h1 id=&quot;혼자-일하지-말라&quot;&gt;&lt;a href=&quot;#혼자-일하지-말라&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>구글 엔지니어는 이렇게 일한다</code> 라는 책에서 필요한 부분을 읽고 기록해두는 포스트다. 많은 부분이 생략되어 있다.</p><h1 id="혼자-일하지-말라"><a href="#혼자-일하지-말라" class="headerlink" title="혼자 일하지 말라"></a>혼자 일하지 말라</h1><p>초기 설계에는 근본적인 실수가 있을 수 있다. 바퀴를 재발명하려는 실수를 범할 수 있다. 우리가 올바른 일을 하고 있는지, 제대로 하고 있는지, 그리고 다른 누군가가 이미 해놓은 일을 아닌지를 확인해봐야 한다.</p><blockquote><p>가능한 일찍 피드백받고, 가능한 일찍 테스트하자.</p></blockquote><p>코드 뿐만 아니라 계획이나 설계 변경이 필요한 시점을 즉시 알려줄 피드백 루프를 팀 플레이를 통해 달성할 수 있다.</p><h1 id="모든-건-팀에-달렸다"><a href="#모든-건-팀에-달렸다" class="headerlink" title="모든 건 팀에 달렸다."></a>모든 건 팀에 달렸다.</h1><h2 id="중요한-소프트-스킬-세가지"><a href="#중요한-소프트-스킬-세가지" class="headerlink" title="중요한 소프트 스킬 세가지"></a>중요한 소프트 스킬 세가지</h2><ol><li>겸손 : 모든 것을 알고있다고 생각하지말고 배움에 열려있어야 한다.</li><li>존중 : 함께 일하는 동료를 진심으로 생각한다.</li><li>신뢰 : 동료들이 유능하고 올바른 일을 하리라 믿는다.</li></ol><p>이 세가지를 바탕으로 사회적 관계에 힘을 써라.</p><h2 id="자존심-버리기"><a href="#자존심-버리기" class="headerlink" title="자존심 버리기"></a>자존심 버리기</h2><p>자신이 팀에서 제일 중요한 사람을 드러내지 말라. 모든 걸 다 아는 듯 행동하지 말라. 집단적 자존심을 찾아라. 팀의 성취와 단체의 자부심을 높이려 노력하라.</p><h2 id="비평하고-비평받는-법-배우기"><a href="#비평하고-비평받는-법-배우기" class="headerlink" title="비평하고 비평받는 법 배우기"></a>비평하고 비평받는 법 배우기</h2><p>상대방을 존중하고 건설적이고 공손하게 비평해라. 우리의 자존감을 우리가 작성한 코드와 동일시 해서 비평을 거부하지 말라.</p><h2 id="빠르게-실패하고-반복하기"><a href="#빠르게-실패하고-반복하기" class="headerlink" title="빠르게 실패하고 반복하기"></a>빠르게 실패하고 반복하기</h2><p>실패하지 않는다면 충분히 혁신적이지 않거나 위험을 충분히 감수하지 않은 것이다.<br>실패를 <code>배우고 다음 단계로 넘어갈 수 있는 절호의 기회</code>라고 생각하자.</p><h2 id="비난-없는-포스트모템-문화"><a href="#비난-없는-포스트모템-문화" class="headerlink" title="비난 없는 포스트모템 문화"></a>비난 없는 포스트모템 문화</h2><p>실패의 원인을 분석해 문서로 남기는 것이 중요하다. 이를 포스트모템이라고 한다.<br>포스트모템은 쓸모 없는 사죄, 변명, 지적으로 채워지지 않고 무엇을 배웠는지 앞으로 어떻게 바꿀지가 담겨야 한다.</p><h3 id="훌륭한-포스트모템"><a href="#훌륭한-포스트모템" class="headerlink" title="훌륭한 포스트모템"></a>훌륭한 포스트모템</h3><ul><li>사건의 개요</li><li>사건을 인지하고 이를 해결하기 까지 타임라인</li><li>사건 근본 원인 파악</li><li>영향과 피해 평가</li><li>문제를 즉시 해결하기 위한 조치 항목(소유자 명시)</li><li>재발 방지를 위한 조치 항목</li><li>해당 경험에서 얻은 교훈</li></ul><h1 id="지식-공유"><a href="#지식-공유" class="headerlink" title="지식 공유"></a>지식 공유</h1><h2 id="심리적-안전"><a href="#심리적-안전" class="headerlink" title="심리적 안전"></a>심리적 안전</h2><p>자신이 이해하지 못한 게 있음을 인정해야 무언가를 배울 수 있다. 모르는 것을 인정하는 사람을 질책하지 말고 반겨야 한다. 배움에는 시도해서 실패해도 안전하다는 인식이 중요하다. 질문을 던지고, 틀리고, 새로운 지식을 얻는 걸 편안하게 생각해야 한다.</p><h2 id="질문하기"><a href="#질문하기" class="headerlink" title="질문하기"></a>질문하기</h2><p>항상 배우고 항상 질문하기를 잊지마라. 잘 모르겠으면 주위 동료들에게 질문하는게 내가 성장하는게 도움이 된다. 아무리 잘하는 사람이라도 모르는 분야가 반드시 있다. 이를 두려워 말고 도움을 청해본다.<br>특히 상급자라고 모든 것을 안다는 인식이 생겨나지 않도록 하라. 사소한 질문이더라도 친절하게 답변해주자. 적절한 도움은 개인과 팀 생산력에 큰 도움이 된다.<br>특히 일대일로 무언가를 배울 때는 기록해두는 습관을 가지자.</p><h1 id="좋은-리더가-되기-위해서"><a href="#좋은-리더가-되기-위해서" class="headerlink" title="좋은 리더가 되기 위해서"></a>좋은 리더가 되기 위해서</h1><h2 id="섬기는-리더십"><a href="#섬기는-리더십" class="headerlink" title="섬기는 리더십"></a>섬기는 리더십</h2><p>내가 누군가를 관리하는 것이 아닌 팀을 떠받드는 것이 중요하다. 겸손, 존중, 신뢰의 분위기를 조성하는 데 힘써야 한다. 혼자서 제거하기 힘든 관료적 장애물을 치워주고, 합의에 이르도록 이끄는 등 팀이 앞으로 나아가는데 필요한 기술적, 사회적 건강 관리를 한다.</p><h2 id="오늘날의-엔지니어링-관리자"><a href="#오늘날의-엔지니어링-관리자" class="headerlink" title="오늘날의 엔지니어링 관리자"></a>오늘날의 엔지니어링 관리자</h2><blockquote><p>전통적인 관리자는 일을 어떻게 처리해야지를 고민하는 반면 훌륭한 관리자는 무슨 일을 처리할지를 고민한다.</p></blockquote><p>관리자는 팀원을 아이처럼 대하지 말고 직원들을 신뢰하자. 직원들은 그 신뢰에 부응해야한다는 긍정적인 압박을 느낀다.</p><h3 id="자존심-버리기-1"><a href="#자존심-버리기-1" class="headerlink" title="자존심 버리기"></a>자존심 버리기</h3><p>겸손과 자신감 결여는 구분하자. 자만하지 않아도 자신감과 의견을 가질 수 있다. 팀을 하나로 모으고 방향을 정하게 도와주는게 리더의 역할이다. 구체적인 방법은 실무자들에게 맡기는 게 그들의 주인의식과 책임감 향상에 더 도움이 된다.<br>리더가 모든 걸 알아야 된다는 강박에서 벗어나자. 완벽한 듯 행동하면 오히려 팀원들의 존경을 빠르게 잃어가고 자리 지키기에만 급급할 것이다.<br>팀의 최종 목표를 명심하고 피드백을 수용하고 비판에 마음을 열자.<br>실수했다면 인정하고 사과하자. 리더가 실수했다는 사실을 언젠간 팀원들이 반드시 알게 된다. 이를 사과할 줄 아는 리더를 팀원들은 존경한다.</p><h3 id="마음-다스리기"><a href="#마음-다스리기" class="headerlink" title="마음 다스리기"></a>마음 다스리기</h3><p>리더는 항상 무대 위에 있다고 생각하는 방법이 좋다. 리더는 주변 사람들이 리더의 일거수일투족을 항시 두 눈 똑바로 뜨고 쳐다보고 있다는 뜻이다. 리더의 몸짓, 사소한 이야기에 돌아오는 반응, 점심식사를 하며 보내는 미묘한 신호들로부터 단서들을 얻어간다. 아무리 사소한 것이라도 리더가 내비치는 거의 모든 것이 무의식적으로 알려지고 팀에 전염된다.</p><h3 id="촉매자-되기"><a href="#촉매자-되기" class="headerlink" title="촉매자 되기"></a>촉매자 되기</h3><p>리더는 합의를 이끌어 낼 줄 알아야 한다. 시작부터 끝까지 과정을 주도할 수 있고 올바른 방향으로 가속이 붙도록 조금만 관여할 수도 있다. 팀이 가야할 방향에 대한 합의를 이끌어내야 하는게 리더의 역할이고 이 과정에서 팀원들이 모두 합의할 수 있도록 촉매자가 되보자.</p><h3 id="장애물-치우기"><a href="#장애물-치우기" class="headerlink" title="장애물 치우기"></a>장애물 치우기</h3><p>리더는 해야할 일에 대한 합의를 이끌어냈지만, 장애물 때문에 진행이 안될 수 있다. 이런 장애물을 해결하는 것도 리더의 역할이다. 이때 리더가 모든 장애물을 직접 해결해야 한다는 의미는 아니다. 다만 해당 장애물을 해결할 줄 아는 사람을 알고 있는 게 바람직하다.</p><h3 id="선생이자-멘토-되기"><a href="#선생이자-멘토-되기" class="headerlink" title="선생이자 멘토 되기"></a>선생이자 멘토 되기</h3><p>내가 하면 더 빨리 될 일이더라도 팀원의 성장을 위해 그 일을 팀원에게 맡기는 일을 감수할 수 있어야 한다. 멘토는 팀의 프로세스와 체계에 대한 경험, 설명하는 능력, 멘티에게 도움이 얼마나 필요한지를 측정하는 능력이 필요하다.</p><h3 id="명확한-목표-세우기"><a href="#명확한-목표-세우기" class="headerlink" title="명확한 목표 세우기"></a>명확한 목표 세우기</h3><p>목표를 명확히 세우고 팀이 제품을 한 방향으로 끌게 해야 한다. 가장 쉬운 방법은 팀이 이루어야 할 임무를 구체적인 문장으로 적어놓는 것이다. 목표를 정하고 나면 팀원들이 각자 책임을 가지고 리더는 잘 가고 있는지 주기적으로 확인하자.</p><h3 id="정직하기"><a href="#정직하기" class="headerlink" title="정직하기"></a>정직하기</h3><p>리던느 팀원에게 모든 것을 알려줄 수 없는 상황에 있는 상황인 경우가 많다. 만약 그런 부분을 묻는다면 차마 말해줄 수 없다 라고 솔직하게 말하자. 그리고 모르는 사실은 모른다고 사실대로 말하자.<br>팀원에게 곤란한 피드백을 줘야 하는 경우는 존중을 담아서 솔직하게 전달하자. 칭찬으로 피드백을 둘러 쌓아서 하지 않도록 하자.</p><h3 id="행복한지-확인하기"><a href="#행복한지-확인하기" class="headerlink" title="행복한지 확인하기"></a>행복한지 확인하기</h3><p>팀원들의 행복을 위해서 일대일 면담을 하거나 다음 업무를 수행하는 데 어려운 점은 없는 지 확인하는 방식을 선택할 수 있다. “더 필요한 것은 없나?”라고 물어보자.</p><h3 id="파도를-일으켜야-할-타이밍을-알자"><a href="#파도를-일으켜야-할-타이밍을-알자" class="headerlink" title="파도를 일으켜야 할 타이밍을 알자"></a>파도를 일으켜야 할 타이밍을 알자</h3><p>문제가 생긴 상황을 지켜보기만 하지 말자. 너무 방치하지 않고 적절한 조치를 찾아 실행시켜라.</p><h3 id="혼란으로부터-팀을-보호하자"><a href="#혼란으로부터-팀을-보호하자" class="headerlink" title="혼란으로부터 팀을 보호하자"></a>혼란으로부터 팀을 보호하자</h3><p>혼란과 불확실성으로 가득 찬 상황을 팀원들이 영향 받지 않도록 보호해야 한다. 다만 회사 위쪽에서 어떤 일이 일어나는 지 공유해주는 것도 중요하다. 다만 팀에 영양가가 없는 조직 차원의 광기로 팀 업무가 방해받지 않도록 하자.</p><h3 id="내적-동기-일으키기"><a href="#내적-동기-일으키기" class="headerlink" title="내적 동기 일으키기"></a>내적 동기 일으키기</h3><p>금전적 보상과 같은 외적 동기와 안에서부터 샘솟는 내적 동기가 있다. 사람들을 행복하게 하는 것은 내적 동기이다. 내적 동기는 자율성, 숙련, 목적이 키워준다.</p><ol><li>자율성 : 스스로 행동할 수 있는 것. 제품과의 관계가 더 끈끈해진다. 제품에 대한 주인 의식이 커진다.</li><li>숙련 : 기술 수준을 높이고 새로운 것을 배울 기회를 제공하는 것.</li><li>목적 : 팀원들의 노력에서 의미를 찾고 그 의미를 분명하게 인식시켜주는 형태로 동기를 부여하자.</li></ol><h1 id="성장하는-조직-이끌기"><a href="#성장하는-조직-이끌기" class="headerlink" title="성장하는 조직 이끌기"></a>성장하는 조직 이끌기</h1><p>하나의 팀이 아닌 여러 팀을 이끌기 위한 행동 지침을 알아보자.</p><h2 id="늘-결정하라"><a href="#늘-결정하라" class="headerlink" title="늘 결정하라"></a>늘 결정하라</h2><p>리더는 팀이 매주 무엇을 해야 하는지 결정해야 한다. 트레이드오프가 명확할 때가 있지만 때로는 시간이 한참 지나야 피해를 주는 예상치 못한 결과를 가져다오기도 한다.<br>리더는 어렵고 명확한 해법이 보이지 않는 문제를 풀게 사람들을 이끄는 것이다. 어느 경우든 문제를 탐구하고 훑어보고 뜯어보면서 통제할 수 있는 상태로 만들어야 한다.<br>이 과정은 세 단계로 나뉜다.</p><ol><li>눈가리개를 찾아내고</li><li>트레이드오프를 파악한다</li><li>해법을 결정하고 반복해야 한다.</li></ol><h3 id="눈가리개-찾기"><a href="#눈가리개-찾기" class="headerlink" title="눈가리개 찾기"></a>눈가리개 찾기</h3><p>항상 그래왔다는 문제에 대해 질문을 던지고, 현재 방식에 대해 문제가 있을 수 있는지 확인해본다.</p><h3 id="핵심-트레이드오프-파악하기"><a href="#핵심-트레이드오프-파악하기" class="headerlink" title="핵심 트레이드오프 파악하기"></a>핵심 트레이드오프 파악하기</h3><p>모든 트레이드오프를 테이블 위에 올려놓고 모두에게 설명한 다음 어떻게 균형을 맞출지를 결정하도록 도와야 한다.</p><h3 id="결정하고-반복하기"><a href="#결정하고-반복하기" class="headerlink" title="결정하고 반복하기"></a>결정하고 반복하기</h3><p>트레이드오프를 파악하고 특정 방법을 결정할 수 있다. 그러나 이 방법에 계속 유지하지 말고 상황이 변하면 트레이드오프를 다시 평가하고 새로운 방법을 결정하도록 하자. 이게 늘 결정한다라는 말의 의미이다.<br>트레이드오프의 지속적인 재조정을 프로세스에 녹여야 한다. 지금 선택한 방법이 계속 유지되지 않을 수 있음을 공유하자.</p><h2 id="늘-떠나라"><a href="#늘-떠나라" class="headerlink" title="늘 떠나라"></a>늘 떠나라</h2><p>리더는 모호한 문제를 풀어줄 뿐만 아니라 맡은 조직이 리더 없이도 스스로 문제를 풀 수 있게 유도해야 한다. 리더가 SPOF가 되면 안된다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/software-engineering-at-google/">Software Engineering At Google</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린의 클래스, 객체, 인터페이스</title>
      <link>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/</guid>
      <pubDate>Tue, 10 Jan 2023 14:52:43 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4&quot;&gt;코틀린 인터페이스&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#open-f</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약<br><a href="#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">코틀린 인터페이스</a><br><a href="#open-final-abstract-%EB%B3%80%EA%B2%BD%EC%9E%90-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-final">open, final, abstact</a><br><a href="#%EA%B0%80%EC%8B%9C%EC%84%B1-%EB%B3%80%EA%B2%BD%EC%9E%90-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EA%B0%9C">가시성 변경자</a><br><a href="#%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%A4%91%EC%B2%A9%EB%90%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A4%91%EC%B2%A9-%ED%81%B4%EB%9E%98%EC%8A%A4">중첩 클래스와 봉인된 클래스</a><br><a href="#%EB%BB%94%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8">뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</a><br><a href="#%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EC%83%9D%EC%84%B1%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9C%84%EC%9E%84">데이터 클래스와 클래스 위임</a><br><a href="#object-%ED%82%A4%EC%9B%8C%EB%93%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8%EA%B3%BC-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1">object 키워드</a></p></blockquote><h1 id="클래스-계층-정의"><a href="#클래스-계층-정의" class="headerlink" title="클래스 계층 정의"></a>클래스 계층 정의</h1><h2 id="코틀린-인터페이스"><a href="#코틀린-인터페이스" class="headerlink" title="코틀린 인터페이스"></a>코틀린 인터페이스</h2><p>코틀린의 인터페이스는 자바와 매우 유사하다. 상태를 가질 수 없지만 구현된 메서드(마치 디폴트 메서드)를 가질 수 있다.</p><p>인터페이스를 구현하는 쪽에서는 <code>:</code>을 통해 나타낸다. 코틀린에서는 클래스의 상속과 인터페이스의 구현 모두 <code>:</code>를 사용한다. 자바와 마찬가지로 코틀린에서 인터페이스는 무제한으로 구현할 수 있지만, 클래스는 하나만 가능하다.</p><p>자바의 <code>@Override</code>와 비슷한 <code>override</code> 변경자가 있다. 코틀린에서는 <code>override</code> 변경자를 반드시 적어줘야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> =</span><br><span class="line">        println(<span class="string">&quot;implemented Method in interface.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> :<span class="type">Clickable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="만약-여러-인터페이스를-구현할-때-각-인터페이스에서-구현된-메서드의-시그니처가-중복되는-경우"><a href="#만약-여러-인터페이스를-구현할-때-각-인터페이스에서-구현된-메서드의-시그니처가-중복되는-경우" class="headerlink" title="만약 여러 인터페이스를 구현할 때 각 인터페이스에서 구현된 메서드의 시그니처가 중복되는 경우"></a>만약 여러 인터페이스를 구현할 때 각 인터페이스에서 구현된 메서드의 시그니처가 중복되는 경우</h3><p>위 예시에서 기존의 인터페이스에서 구현된 메서드와 같은 시그니처를 갖는 인터페이스를 만들고 이 또한 클래스에서 구현해보려고 한다면 문제가 생긴다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> = println(<span class="string">&quot;implemented too!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> :<span class="type">Clickable</span>, <span class="type">Focusable &#123; // 컴파일 에러가 생길 것이다!</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span> = println(<span class="string">&quot;focus!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우 구현하는 클래스에서 충돌되는 구현 메서드를 새롭게 오버라이딩해서 재정의 해줘야 한다.<br>이때 상위 타입의 구현을 사용하려면 다음 코드블럭을 지켜보자. <code>super&lt;상위타입&gt;.메서드()</code> 이런 문법으로 상위 타입의 메서드를 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> : <span class="type">Clickable</span>, <span class="type">Focusable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span> = println(<span class="string">&quot;focus!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Focusable&gt;.methodImpl()</span><br><span class="line">        <span class="keyword">super</span>&lt;Clickable&gt;.methodImpl()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>사실 코틀린에서는 아직 자바의 디폴트 메서드를 지원하지 않는다.<br>코틀린은 자바의 디폴트 메서드가 등장하기 전인 자바 6에 호환되도록 설계됐다. 그래서 자바 인터페이스에 디폴드 메서드가 있으면 코틀린에는 해당 메서드를 추상 메서드로 인터페이스에 해놓고 따로 클래스를 만들어서 디폴트 메서드의 구현을 정적 메서드로 놓는다. 이렇게 되면 자바 클래스가 디폴트 인터페이스가 포함된 코틀린 인터페이스를 구현하려고 하면 디폴트 메서드도 자바 클래스에서 구현해줘야 한다. 왜냐면 자바에서는 코틀린의 디폴트 메서드 구현(정적 메서드)를 의존하지 않기 때문이다.</p></blockquote><h2 id="open-final-abstract-변경자-기본적으로-final"><a href="#open-final-abstract-변경자-기본적으로-final" class="headerlink" title="open, final, abstract 변경자: 기본적으로 final"></a>open, final, abstract 변경자: 기본적으로 final</h2><h3 id="open-final"><a href="#open-final" class="headerlink" title="open, final"></a>open, final</h3><p>자바에서는 final 선언되지 않은 클래스를 상속해서 사용할 수 있다.<br>문제는 상속은 부모 클래스의 가정을 이해하지 않고 자식 클래스에서 가정을 깨는 구현을 했을 때, 부모 클래스가 약간의 변경이 생겨도 자식 클래스가 예상과 다르게 작동할 수 있다. (취약한 기반 클래스 문제)<br>코틀린에서는 상속을 제한적으로 쓰고자 기본적으로 모두 final 선언되어 있는 셈이다. 만약 상속을 하고 싶으면 부모 클래스에 <code>open</code> 키워드를 붙여야 한다. 그와 더불어 자식 클래스에서 오버라이딩이 가능한 메서드나 프로퍼티에도 <code>open</code>을 붙여야 오버라이딩이 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RichButton</span>: <span class="type">Clickable &#123;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cannotOverride</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = print(<span class="string">&quot;rich click&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>override</code> 된 메서드는 당연히 오버라이딩에 열려있다. 하지만 이런 메서드도 앞에 <code>final</code>을 붙이면 하위에서 오버라이딩을 막을 수 있다.</p><blockquote><p>열린 클래스와 스마트 캐스트<br>기본적으로 클래스를 final로 상속을 막으면 스마트 캐스트하기에 유리하다. 스마트 캐스트는 타입 검사 뒤 변경될 수 없는 변수에만 적용된다. 즉 <code>val</code> 이면서 커스텀 접근자가 있어서는 안된다. 여기에 더 나아가 프로퍼티가 <code>final</code>이어야 한다는 조건이 필요하다. 왜냐면 다른 클래스가 상속해서 커스텀 접근자를 정의할 수 있음을 막아야 하기 때문이다.</p></blockquote><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><code>abstract</code>는 자바와 거의 비슷하다. 추상 메서드나 추상 클래스를 정의할 때 사용된다.</p><h2 id="가시성-변경자-기본적으로-공개"><a href="#가시성-변경자-기본적으로-공개" class="headerlink" title="가시성 변경자: 기본적으로 공개"></a>가시성 변경자: 기본적으로 공개</h2><p>가시성 변경자는 클래스 외부 접근을 제어한다. 자바와 다르게 코틀린은 아무 가시성 변경자를 안 적으면 <code>public</code>으로 취급한다.<br>코틀린에는 자바처럼 패키지 전용이 없다. 코틀린에서 패키지는 네임 스페이스를 관리하기 위함이지 가시성을 제어하기 위함이 아니다.</p><h3 id="internal-패키지-전용-가시성을-대체"><a href="#internal-패키지-전용-가시성을-대체" class="headerlink" title="internal: 패키지 전용 가시성을 대체"></a>internal: 패키지 전용 가시성을 대체</h3><p>패키지 전용 가시성를 대신하는 <code>internal</code>이 있다. <code>internal</code>은 모듈 내부에서만 볼 수 있는 변경자이다. 모듈은 같이 컴파일 되는 단위를 말한다. 패키지 기준은 다른 프로젝트더라도 같은 패키지에 클래스를 선언해서 접근 할 수 있게 되는 단점이 있다.</p><blockquote><p>그 외 차이점<br><code>private</code>는 내부에서만 접근 가능한 변경자인데 코틀린은 최상위 선언(클래스, 프로퍼티, 함수)에도 사용할 수 있다.<br><code>protected</code>는 코틀린에서 패키지 전용 가시성이 아닌 하위 클래스 가시성을 제공할 때 쓰인다. 다만 최상위 선언에는 사용할 수 없다.</p></blockquote><h3 id="의존하려면-더-엄한-가시성을-가져야-한다"><a href="#의존하려면-더-엄한-가시성을-가져야-한다" class="headerlink" title="의존하려면 더 엄한 가시성을 가져야 한다."></a>의존하려면 더 엄한 가시성을 가져야 한다.</h3><p>다음 예제를 보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">bye</span><span class="params">()</span></span> = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">doSomething</span><span class="params">()</span></span> &#123; <span class="comment">// public한 확장함수는 internal 클래스에 사용할 수 없다.</span></span><br><span class="line">    hello() <span class="comment">// public한 확장함수는 private 메서드에 접근할 수 없다.</span></span><br><span class="line">    bye() <span class="comment">// public한 확장함수는 protected 메서드에 접근할 수 없다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 다른 클래스에 의존해서 사용하려는 경우 해당 함수나 클래스의 가시성이 사용하려는 클래스의 가시성과 같거나 더 엄해야 한다. 위 경우는 확장함수의 가시성을 internal로 바꾸거나 수신 객체 타입의 가시성을 public으로 올리는 방법이 있다.<br>그리고 private나 protected 조건을 만족하지 않으므로 확장 함수의 메서드 호출이 안된다.</p><h3 id="코틀린-가시성-변경자와-자바"><a href="#코틀린-가시성-변경자와-자바" class="headerlink" title="코틀린 가시성 변경자와 자바"></a>코틀린 가시성 변경자와 자바</h3><p>코틀린의 public, protected, private 변경자는 자바 바이트 코드에도 그대로 들어간다. 다만 private 클래스는 다르게 처리된다. 자바에서는 private 클래스가 안되기 때문인데, 이 경우 코틀린에서 private 클래스를 protected 클래스로 변환해서 컴파일한다.<br>코틀린의 internal은 자바에서 public이 된다. 모듈의 특성 상 어쩔 수 없는 부분이다.<br>이렇게 더 열리게 되면 의도하지 않은 접근이 가능해지는데 코틀린 컴파일러가 internal 멤버 이름을 보기 나쁘게 바꾼다. 이는 예상치 못한 상속에서 생기는 우연한 오버라이딩을 피하고 internal 클래스를 외부에서 사용하지 않도록 하기 위함이다.</p><h2 id="내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스"><a href="#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" class="headerlink" title="내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스"></a>내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스</h2><p>코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근을 할 수 없다. 자바에서는 클래슨 내부에서 클래스를 선언하면 묵시적으로 내부 클래스가 된다. 즉 외부 클래스에 대한 참조를 묵시적으로 포함한다. 자바에서 이런 보이지 않는 참조를 제거하려면 중첩된 클래스에 static을 붙여주면 된다.</p><p>코틀린은 반대다. 기본적으로 외부 클래스에 대한 참조가 끊긴 중첩 클래스로 취급하고 만약 내부 클래스로 만들려면 안쪽 클래스에 <code>inner</code> 변경자를 붙여야 한다. 만약 내부 클래스에서 외부 클래스 참조를 접근하려면 <code>this@외부클래스이름</code> 으로 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getOuterReference</span><span class="params">()</span></span> : Outer = <span class="keyword">this</span><span class="symbol">@Outer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="봉인된-클래스-클래스-계층-정의-시-계층-확장-제한"><a href="#봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" class="headerlink" title="봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한"></a>봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한</h2><p><code>sealed</code> 변경자를 통해 자신의 상속해줄 수 있는 자식 클래스를 제한 할 수 있다. 이때 적용되는 클래스는 코틀린 1.0에는 부모의 중첩 클래스로만 해야하고, 1.1에는 같은 파일 안에 있기만 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Num</span> : <span class="type">Expr</span></span>()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> : <span class="type">Expr</span></span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 정해놓으면 유리한 점이 분기 처리할 때가 유리하다. 자식이 무한하게 허용되면 <code>when</code> 식으로 처리할 때 <code>else</code>로 그 외 처리를 해줘야 한다. 그리고 자식이 생길 때 분기로 처리하기를 놓칠 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>하지만 <code>sealed</code> 되어 있으면 자식이 한정적이라 정해진 자식들만 체크하면 된다. 만약 놓친 자식이 있으면 컴파일 에러가 나서 미리 알 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span> : <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Expr.Num -&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">is</span> Expr.Sum -&gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언"><a href="#뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" class="headerlink" title="뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언"></a>뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</h1><p>코틀린은 주 생성자와 부 생성자가 있다. 주 생성자는 클래스를 초기화할 때 쓰이고 클래스 본문 밖에서 정의된다. 부 생성자는 클래스 본문 안에서 사용되는 생성자이다.<br>또한 코틀린에서는 초기화 블록을 지원해서 초기화 로직을 모을 수 있다.</p><h2 id="클래스-초기화-주-생성자와-초기화-블록"><a href="#클래스-초기화-주-생성자와-초기화-블록" class="headerlink" title="클래스 초기화: 주 생성자와 초기화 블록"></a>클래스 초기화: 주 생성자와 초기화 블록</h2><p>코틀린에서 주 생성자는 다음과 같이 쓰인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String)</span><br></pre></td></tr></table></figure><p>클래스 이름뒤에 괄호로 둘러 쌓인 내용을 주 생성자라고 한다.</p><p>이를 최대한 명시적으로 풀어쓰면 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickName: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nickName = _nickName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여전히 주 생성자는 존재하는데 이때 <code>constructor</code>는 생성자의 정의를 시작함을 의미한다.<br>그리고 <code>init</code>은 클래스의 객체가 만들어질 때 실행되는 초기화 로직을 모은 초기화 블록을 선언한다. 초기화 블록은 별도의 코드를 포함할 수 없는 주 생성자와 함께 많이 쓰인다.<br>그리고 생성자 파라미터 앞 <code>_</code>는 프로퍼티와 파라미터를 구분하기 위해서 적었는데 기존 자바의 <code>this.nickName = nickName</code> 이렇게 해도 된다.</p><p>위 예시를 좀 더 개선하면, 일단 주 생성자 앞에 별도의 어노테이션이나 가시성 변경자가 없다면 <code>constructor</code>를 생략해도 된다. 그리고 프로퍼티 초기화는 굳이 초기화 블록에서 할 필요가 없고 프로퍼티 선언에서 해도 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(_nickName: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName = _nickName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위 예시도 굳이 val 파리미터를 본문에서 하지말고 주 생성자 안에서 해버리면 간단하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String)</span><br></pre></td></tr></table></figure><p>참고로 주 생성자에서 디폴트 값과 이름 있는 선언도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String = <span class="string">&quot;untitled&quot;</span>)</span><br><span class="line"></span><br><span class="line">User().nickName <span class="comment">// untitled</span></span><br><span class="line">User(nickName = <span class="string">&quot;Klay&quot;</span>) <span class="comment">// Klay</span></span><br></pre></td></tr></table></figure><blockquote><p>모든 파라미터에 디폴트값이 있으면 자동으로 파라미터가 없는 생성자를 만들어준다.<br>DI 프레임워크 중 기본 생성자가 반드시 필요한 경우에 이런 기능이 유리하다고 한다.</p></blockquote><p>만약 기반 클래스가 있다면 다음과 같이 기반 클래스에 파라미터를 넘겨줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodUser</span></span>(<span class="keyword">val</span> nickName: String) : User(nickname)</span><br></pre></td></tr></table></figure><p>참고로 만약 기반 클래스가 기본 생성자만 있다하더라도 하위 클래스는 생성자 (괄호) 를 적어줘야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodBook</span> : <span class="type">Book</span></span>()</span><br></pre></td></tr></table></figure><p>인터페이스는 생성자가 없으니 하위 클래스가 구현할 때 괄호를 써주지 않는다.</p><p>마지막으로 private 한 생성자를 만드는 방법이다.<br>이는 동반 객체에 유용하다고 한다. (반면 유틸 클래스나 싱글턴에는 이렇게 하지 않느다. 확장 함수나 객체 선언하는 방식을 한다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CannotConstructUser</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()</span><br></pre></td></tr></table></figure><h2 id="부-생성자"><a href="#부-생성자" class="headerlink" title="부 생성자"></a>부 생성자</h2><p>일반 적으로 코틀린에서는 디폴트 값을 지원해서 여러 생성자를 만들 일이 없다.<br>그래도 여러 생성자가 필요한 경우가 있다면 부 생성자를 이용한다.<br><code>super</code>를 통해 기반 클래스의 생성자에 인자 전달도 되고, this를 통해 자신의 다른 생성자에게 생성을 위임할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(s: String) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(i:<span class="built_in">Int</span>) : <span class="keyword">this</span>(i.toString()) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(s: String) : <span class="keyword">super</span>(s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="인터페이스에-선언된-프로퍼티-구현"><a href="#인터페이스에-선언된-프로퍼티-구현" class="headerlink" title="인터페이스에 선언된 프로퍼티 구현"></a>인터페이스에 선언된 프로퍼티 구현</h2><h3 id="추상-프로퍼티"><a href="#추상-프로퍼티" class="headerlink" title="추상 프로퍼티"></a>추상 프로퍼티</h3><p>코틀린에서는 인터페이스에 추상 프로퍼티를 선언할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 해당 인터페이스를 구현하는 쪽은 nickName을 접근할 수 있는 방법을 제공해야 함을 의미한다. 인터페이스가 실제 상태를 가지는 것은 아니다.</p><p>추상 프로퍼티를 구현하는 세가지 예시를 보자</p><p><strong>1. 주 생성자로 프로퍼티 구현</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickName: String) : User5</span><br></pre></td></tr></table></figure><p>간단하다 override만 붙여주면 된다.</p><p><strong>2. 커스텀 게터</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailUser</span></span>(<span class="keyword">val</span> email: String) : User5 &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickName: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>역시 override가 붙은 프로퍼티에 커스텀 게터를 구현하면 된다. 다만 커스텀 게터는 호출때마다 구현된 내용이 실행된다.</p><p><strong>3. 프로퍼티 초기화 식</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) : User5 &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickName = getFacebookName(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFacebookName</span><span class="params">(id: <span class="type">Int</span>)</span></span> = id.toString()</span><br></pre></td></tr></table></figure><p>프로퍼티 초기화 식은 프로퍼티에 접근할 때마다 구현된 내요을 실행하지 않는다. 초기화 할 때 한번만 한다. 이 점이 2번과 가장 큰 차이다. 만약 <code>getFacebookName</code>이 비용이 큰 메서드라고 상상해보면 프로퍼티에 접근할 때마다 호출되는 커스텀 게터 방식이 많이 불리햇을 것이다.</p><p>마지막으로 인터페이스에는 커스텀 게터와 세터가 있는 프로퍼티를 추가할 수 있다. 물론 실제 값이 있는 건 아니니까 참조할 수 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line">    <span class="keyword">val</span> email: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="게터와-세터에서-뒷받침하는-필드에-접근"><a href="#게터와-세터에서-뒷받침하는-필드에-접근" class="headerlink" title="게터와 세터에서 뒷받침하는 필드에 접근"></a>게터와 세터에서 뒷받침하는 필드에 접근</h2><p>프로퍼티에 저장된 값을 변경할 때 특정 문자열을 출력하려고 한다고 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> address = <span class="string">&quot;undefined&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(_address) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$field</span> -&gt; <span class="variable">$_address</span>&quot;</span>)</span><br><span class="line">            field = _address</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흠 세터를 직접 구현해줬다. 그런데 <code>field</code>는 무엇인가? <code>field</code>는 현재 접근자에 해당하는 필드에 접근할 수 있게 한다. <code>field</code>를 사용하지 않는 커스텀 접근자는 뒷받침 하는 필드가 생기지 않는다.</p><h2 id="접근자의-가시성-변경"><a href="#접근자의-가시성-변경" class="headerlink" title="접근자의 가시성 변경"></a>접근자의 가시성 변경</h2><p>접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 <code>get</code>이나 <code>set</code>앞에 접근자를 선언해서 가시성을 변경할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;hi&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임"><a href="#컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임" class="headerlink" title="컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임"></a>컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임</h1><h2 id="모든-클래스가-정의해야-하는-메서드"><a href="#모든-클래스가-정의해야-하는-메서드" class="headerlink" title="모든 클래스가 정의해야 하는 메서드"></a>모든 클래스가 정의해야 하는 메서드</h2><p>모든 코틀린 클래스는 <code>toString</code>, <code>equals</code>, <code>hashCode</code> 등을 오버라이딩해야 한다.<br>코틀린은 이런 메서드 구현을 자동으로 생성해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>다음과 같은 클래스를 예시로 오버라이딩 해보자.</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;client&quot;</span></span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>참고로 코틀린은 <code>==</code> 연산자가 내부적으로 <code>equals</code>메서드를 호출해서 객체를 비교한다. 참조 비교를 위해서는 <code>===</code> 연산자를 호출해서 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> Client)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; postalCode == other.postalCode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>자바에서 <code>equals</code>를 재정의할 때는 반드시 <code>hashCode</code>도 재정의해야 한다. JVM 언어에서는 <code>equals</code>가 true를 반환하는 두 객체를 반드시 같은 <code>hashCode</code>를 반환해야 한다. <code>Hash</code>를 활용하는 자료구조에서는 원소 비교 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 같은 경우에만 실제 값을 비교한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span> : <span class="built_in">Int</span> = name.hashCode() * <span class="number">31</span> + postalCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성"><a href="#데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성" class="headerlink" title="데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성"></a>데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성</h2><p>코틀린은 이런 메서드를 컴파일러가 생성해준다.<br><code>data</code> 변경자를 붙여주기만 하면 된다. <code>data</code> 변경자가 붙은 클래스를 데이터 클래스라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>이때 주의할 점은 <code>equals</code>와 <code>hashCode</code>는 주 생성자에서 선언된 모든 프로퍼티를 기준으로 만들어진다. 주 생성자 외부에서 선언된 프로퍼티는 고려되지 않는다.</p><p>데이터 클래스는 <code>equals</code>, <code>hashCode</code>, <code>toString</code> 외에도 유용한 메서드 몇 개를 더 만들어준다.</p><h3 id="불변한-데이터-클래스를-쉽게-복사-copy"><a href="#불변한-데이터-클래스를-쉽게-복사-copy" class="headerlink" title="불변한 데이터 클래스를 쉽게 복사: copy"></a>불변한 데이터 클래스를 쉽게 복사: copy</h3><p>데이터 클래스를 쉽게 복제하는 메서드를 제공해준다. 밑은 <code>copy</code> 메서드를 이해를 돕기위해 직접 구현한 예시이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, postalCode = this.postalCode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Client(name, postalCode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용법</span></span><br><span class="line"><span class="keyword">val</span> client = Client(<span class="string">&quot;Klay&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> copiedClient = client.copy(<span class="string">&quot;Curry&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="클래스-위임-by-키워드-사용"><a href="#클래스-위임-by-키워드-사용" class="headerlink" title="클래스 위임: by 키워드 사용"></a>클래스 위임: by 키워드 사용</h2><p>어떤 클래스에 기능을 추가해야 할 때 데코레이터 패턴을 사용한다고 해보자. 데코레이터 패턴은 기존 클래스의 인터페이스를 데코레이터가 제공하되 데코레이터 내부에 기존 클래스 인스턴스를 필드로 갖고 메서드 호출시 기존 클래스에게 메시지를 전달하는 것이다. 그리고 데코레이터에 추가하고자 하는 메서드를 구현하면 된다. 이때 새로운 기능에 기존 클래스의 메서드를 활용할 수 있다.</p><p>하지만 이런 방법은 지나치게 준비 코드가 많다. 코틀린에서는 인터페이스를 구현할 때 <code>by</code> 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에게 위임 중이라는 사실을 명시할 수 있다.</p><p>예를 들어 ArrayList를 감싸는 클래스를 만들어보자. Collection의 인터페이스를 내부 리스트에게 위임하도록 구현해야 했다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingCollection</span>&lt;<span class="type">T</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerList = arrayListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = innerList.size</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span> = innerList.containsAll(elements)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span> = innerList.contains(element)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = innerList.isEmpty()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; = innerList.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 코틀린의 <code>by</code>를 써보자. Set에서 추가된 원소를 카운팅하는 기능을 추가해보자.<br>구현한 인터페이스 뒤에 <code>by</code>와 함께 프로퍼티 이름을 적어준 것을 확인할 수 있다. 이러면 위임 메서드를 컴파일러가 알아서 만들어준다. 다만 여기서 자동으로 만들어진 메서드 대신 개발자가 직접 구현하고 싶으면 override 붙여서 구현해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    <span class="keyword">val</span> innerSet :MutableCollection&lt;T&gt; = HashSet()</span><br><span class="line">) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> addCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        addCount++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       addCount += elements.size</span><br><span class="line">       <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="object-키워드-클래스-선언과-인스턴스-생성"><a href="#object-키워드-클래스-선언과-인스턴스-생성" class="headerlink" title="object 키워드: 클래스 선언과 인스턴스 생성"></a>object 키워드: 클래스 선언과 인스턴스 생성</h1><p>코틀린에서 <code>object</code> 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다. 다양한 상황에 대해서 알아보자.</p><h2 id="객체-선언-싱글턴을-쉽게-만들기"><a href="#객체-선언-싱글턴을-쉽게-만들기" class="headerlink" title="객체 선언: 싱글턴을 쉽게 만들기"></a>객체 선언: 싱글턴을 쉽게 만들기</h2><p>코틀린은 <strong>객체 선언</strong> 기능을 통해 싱글턴을 언어에서 기본 지원한다. 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.</p><p>모든 직원의 급여 대장을 관리하는 객체가 필요하다고 해보자. 이 객체가 굳이 여러개일 필요는 없으니 객체 선언으로 싱글턴 객체로 만들어보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll &#123;</span><br><span class="line">    <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 선언은 <code>object</code> 키워드를 사용하면 된다.객체 선언은 그 클래스를 정의하고 해당 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.<br>하지만 생성자는 객체 선언에 사용할 수 없다. 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문이다.</p><p>객체 선언도 클래스나 인스턴스를 상속받을 수 있다. 예를 들어 특정 클래스를 위해 <code>Comparator</code>를 구현한 객체는 여러 개가 필요없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> FileComparator : Comparator&lt;File&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">File</span>, o2: <span class="type">File</span>)</span></span></span><br><span class="line">       = o1.path.compareTo(o2.path, ignoreCase = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>싱글톤과 의존관계 주입<br>싱글턴 패턴과 마찬가지로 객체 선언은 대규모 시스템에서 안좋은 경우가 있다.<br>객체 생성을 제어할 수 없고 파라미터를 지정할 수 없기 때문이다.<br>그래서 단위 테스트하거나 시스템 설정이 바뀔 때 의존 객체를 바꿔줄 수 없다. 만약 이런 기능이 필요하다면 의존 관계 주입 프레임워크를 사용해보자.</p></blockquote><h3 id="클래스-안에-객체-선언"><a href="#클래스-안에-객체-선언" class="headerlink" title="클래스 안에 객체 선언"></a>클래스 안에 객체 선언</h3><p>클래스 안에 객체 선언을 해도 그 객체는 싱글톤이다. 외부 클래스가 인스턴스화 된다고 객체 선언이 여러번 객체로 만들어지는게 아니다!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> InnerObject &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    OuterClass.InnerObject.hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>자바에서 코틀린 객체 선언된 객체를 접근하기<br>코틀린 객체 선언은 자바에서 정적 필드를 가진 클래스로 컴파일된다. 이때 정적 필드 이름은 항상 <code>INSTANCE</code>다.<br><code>OuterClass.InnerObject.INSTANCE.hello()</code></p></blockquote><h2 id="동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소"><a href="#동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소" class="headerlink" title="동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소"></a>동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소</h2><p>코틀린 클래스 안에는 정적인 멤버가 없다. 코틀린은 <code>static</code> 키워드를 지원하지 않는다. 대신 최상위 함수와 객체 선언을 사용한다. 일반적으로 최상위 함수를 추천하지만 특정 클래스 내부의 private 프로퍼티나 메서드에 접근하지 못하는 경우는 해당 클래스 안에서 객체 선언을 통해 접근하기도 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedPerson</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> InnerObject &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>) <span class="comment">// 접근하지 못한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 <code>companion</code> 키워드를 통해 중첩된 객체 선언에서 클래스 이름을 제거할 수 있다.(물론 이름을 붙여줄 수도 있다.) 마치 자바의 정적 멤버 처럼 활용할 수 있게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedPerson2</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson2</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NamedPerson2.hello(NamedPerson2(<span class="string">&quot;Klay&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="동반-객체를-통해-private-생성자-호출-팩토리-메서드"><a href="#동반-객체를-통해-private-생성자-호출-팩토리-메서드" class="headerlink" title="동반 객체를 통해 private 생성자 호출: 팩토리 메서드"></a>동반 객체를 통해 private 생성자 호출: 팩토리 메서드</h3><p>동반 객체는 외부 클래스의 private 프로퍼티, 메서드, 생성자에 접근할 수 있다. 그래서 팩토리 패턴을 사용하기 좋은 조건을 가졌다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>)</span></span> = Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Man.create(<span class="string">&quot;Klay&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>팩터리 패턴이냐 여러 부 생성자냐<br>상황에 따라 여라가지 부 생성자로 객체를 만들어주도록 할 수 있다. 이를 동반 객체를 통한 팩토리 패턴을 활용해서 이름 있는 메서드로 가독성을 높일 수 있는데, 문제는 클래스를 확장해야 할 경우 동반 객체 멤버를 오버라이딩 할 수 없으므로 여러 생성자를 사용하는 편이 낫다.</p></blockquote><h3 id="동반-객체를-일반-객체처럼-사용"><a href="#동반-객체를-일반-객체처럼-사용" class="headerlink" title="동반 객체를 일반 객체처럼 사용"></a>동반 객체를 일반 객체처럼 사용</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Creatable</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">of</span><span class="params">(name: <span class="type">String</span>)</span></span> : T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Creatable&lt;Boy&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">of</span><span class="params">(name: <span class="type">String</span>)</span></span> = Boy(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">createSomething</span><span class="params">(name:<span class="type">String</span>, creatable: <span class="type">Creatable</span>&lt;<span class="type">T</span>&gt;)</span></span> = creatable.of(name)</span><br></pre></td></tr></table></figure><p>동반 객체도 인터페이스를 구현할 수 있으며, 만들어진 동반 객체가 매개변수로 사용됐음을 주목하라. 이때 동반 객체의 이름이 없어서 <code>Boy</code>로 인자를 전달해줬음을 주목하자.</p><blockquote><p>자바에서 코틀린 동반 객체<br>자바에서 코틀린 동반 객체는 이름이 있으면 해당 이름으로 정적 멤버 접근하면 되고 이름이 없는 경우는 <code>Companion</code>이라는 이름의 정적 멤버로 접근하면 된다.</p></blockquote><h3 id="동반-객체-확장"><a href="#동반-객체-확장" class="headerlink" title="동반 객체 확장"></a>동반 객체 확장</h3><p>이름 없는 동반 객체를 만들어서 비즈니스 객체에서 보고 싶지 않은 코드를 분리할 수 있다. 예를 들어 JSON으로부터 역직렬화 함수를 만들어서 제공하고 싶은데 이를 비즈니스 클래스 내부에 위치하고 싶지 않을 때 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비즈니스 모듈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클라이언트 서버 통신 모듈</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Human.Companion.<span class="title">fromJson</span><span class="params">(jsonValue: <span class="type">String</span>)</span></span> : Human &#123;</span><br><span class="line">    <span class="keyword">return</span> Human(jsonValue.toInt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="객체-식-무명-내부-클래스를-다른-방식으로-작성"><a href="#객체-식-무명-내부-클래스를-다른-방식으로-작성" class="headerlink" title="객체 식: 무명 내부 클래스를 다른 방식으로 작성"></a>객체 식: 무명 내부 클래스를 다른 방식으로 작성</h3><p>무명 객체를 정의할 때도 <code>object</code> 키워드를 사용한다. 무명 객체는 자바의 무명 내부 클래스를 대신한다.<br>이때 중요한 점은 무명 객체로 <code>object</code> 키워드를 사용하면 싱글톤이 아님을 명심하자. 무명 객체와 동반 객체나 객체 선언과 다르다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = <span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// logic...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mousePressed</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 무명 객체(객체 식)은 그 식이 포함된 함수의 변수에 접근할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickAmount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">           clickAmount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린 함수 정의와 호출</title>
      <link>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/</guid>
      <pubDate>Mon, 09 Jan 2023 07:52:10 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번 포스트에서는 코틀린의 컬렉션, 문자열, 정규식 영역에서 함수 정의와 호출을 알아보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 코틀린의 컬렉션, 문자열, 정규식 영역에서 함수 정의와 호출을 알아보자.</p><blockquote><p>요약<br><a href="#%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0">함수를 사용하기 쉽게 만들기</a><br><a href="#%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98">확장 함수</a><br><a href="#%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">확장 프로퍼티</a><br><a href="#%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EA%B0%80%EB%B3%80-%EA%B8%B8%EC%9D%B4-%EC%9D%B8%EC%9E%90-%EC%A4%91%EC%9C%84-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%A7%80%EC%9B%90">가변인자, 중위 호출</a><br><a href="#%EC%BD%94%EB%93%9C-%EB%8B%A4%EB%93%AC%EA%B8%B0-%EB%A1%9C%EC%BB%AC-%ED%95%A8%EC%88%98%EC%99%80-%ED%99%95%EC%9E%A5">로컬 함수</a></p></blockquote><h1 id="코틀린에서-컬렉션-만들기"><a href="#코틀린에서-컬렉션-만들기" class="headerlink" title="코틀린에서 컬렉션 만들기"></a>코틀린에서 컬렉션 만들기</h1><p>코틀린에서는 <code>&#123;컬렉션 종류&#125;Of(~)</code> 이런 형태로 쉽게 컬렉션을 만들 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">&quot;hi&quot;</span>, <span class="number">2</span> to <span class="string">&quot;ho&quot;</span>)</span><br></pre></td></tr></table></figure><p>코틀린은 자기만의 컬렉션 객체를 가지지 않고 자바의 컬렉션 프레임워크를 사용한다. 자바에서 사용하던 컬렉션을 코틀린에서도 그대로 사용하므로 특별한 변환 작업이 필요없다.</p><h1 id="함수를-호출하기-쉽게-만들기"><a href="#함수를-호출하기-쉽게-만들기" class="headerlink" title="함수를 호출하기 쉽게 만들기"></a>함수를 호출하기 쉽게 만들기</h1><p>자바에서 <code>toString</code> 메서드를 커스텀하게 구현해본 경험이 있을 것이다. 코틀린에서는 이를 어떻게 쉽게 해결하는 지 체험해보자!</p><p>우리는 리스트의 원소들을 다양한 구분자와 접두사, 접미사를 추가해서 문자열을 만드는 함수를 만들어 볼 것이다!</p><h2 id="무식하게-구현하기"><a href="#무식하게-구현하기" class="headerlink" title="무식하게 구현하기"></a>무식하게 구현하기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>제네릭을 활용해서 확장성이 좋은 함수를 만들었다. 만든 함수를 사용하는 코드도 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(joinToString(list, <span class="string">&quot;:&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><p>흠.. 호출하는 쪽은 조금 난잡하다. 함수를 호출할 때 인자 4개를 모두 전달하지 않는 방법은 없을까??</p><h2 id="이름-붙인-인자"><a href="#이름-붙인-인자" class="headerlink" title="이름 붙인 인자"></a>이름 붙인 인자</h2><p>코틀린에서는 함수를 호출할 때 매개변수의 이름을 통해 인자를 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(joinToString(prefix = <span class="string">&quot;&#123;&quot;</span>, collection = list, separator = <span class="string">&quot;:&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><p>이름을 붙인 인자를 활용할 때는 이름이 붙은 첫 인자 뒤로 모든 인자들에게 이름을 붙여줘야 한다. 왜냐면 이름을 명시하면 순서가 의미가 없어지기 때문에 이름을 붙여주지 않으면 혼동이 올 수 있다.<br>함수 호출하는 코드에서 인자들의 역할이 명확해졌다. 하지만 여전히 난잡한 느낌을 지울 수 없다.</p><h2 id="디폴트-파라미터-값"><a href="#디폴트-파라미터-값" class="headerlink" title="디폴트 파라미터 값"></a>디폴트 파라미터 값</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(joinToString(prefix = <span class="string">&quot;&#123;&quot;</span>, collection = list, postfix= <span class="string">&quot;&#125;&quot;</span>));</span><br></pre></td></tr></table></figure><p>이렇게 매개변수 선언부에 디폴트값을 할당해서 적어줄 수 있다. 이렇게 디폴트값을 활용하면 비효율적인 생상자 오버로딩을 대폭 줄일 수 있다.</p><blockquote><p>자바 메서드를 코틀린에서 디폴트 값 적용해서 사용하기<br>매개변수의 디폴트값을 지원하지 않는 자바 메서드를 코틀린에서 디폴트 값으로 활용하기 까다롭다는게 문제다. 이를 위해서 자바 메서드에 <code>@JvmOverloads</code> 어노테이션을 붙이면 맨 뒤 매개변수부터 하나씩 빼서 오버로딩된 메서드가 만들어진다.</p></blockquote><h2 id="정적인-유틸리티-클래스-없애기-최상위-함수와-프로퍼티"><a href="#정적인-유틸리티-클래스-없애기-최상위-함수와-프로퍼티" class="headerlink" title="정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티"></a>정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티</h2><h3 id="최상위-함수"><a href="#최상위-함수" class="headerlink" title="최상위 함수"></a>최상위 함수</h3><p>자바의 경우 모든 메서드는 클래스 안에 있어야 했다. 그래서 우리가 원하는 건 작동하는 함수 하나여도 클래스를 선언해서 해당 메서드를 포함해야 했다. 하지만 코틀린은 그럴 필요가 없다.<br>코틀린은 함수를 최상위 수준으로 위치할 수 있다. 다음과 같이 특정 패키지 바로 다음에 함수가 올 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 최상위 함수는 컴파일 될 때 새로운 클래스를 정의해서 컴파일한다. 코틀린만 사용하면 그냥 특정 클래스가 생기나보다 하고 넘기면 되지만, 자바에서 코틀린의 최상위 함수를 호출해야 할 경우에는 코틀린의 최상위 함수를 위한 클래스가 어떤 모양인지 알아야 한다.</p><p>최상위 함수를 위한 클래스는 최상위 함수를 포함하는 파일 이름에 따라 달라진다. 예를 들어 <code>join.kt</code>파일에 <code>joinToString</code>메서드를 구현한 경우에는 다음과 같이 자바 클래스가 만들어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinKt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> &lt;T&gt; joinToString(...) &#123;</span><br><span class="line">        ... 생략</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line">JoinKt.joinToString(...);</span><br></pre></td></tr></table></figure><blockquote><p>최상위 함수를 위한 클래스 명 바꾸기<br><code>@file:JvmName(&quot;ClassName&quot;)</code>을 패키지 선언문 위에 적으면 클래스 이름도 바꿀 수 있다.</p></blockquote><h3 id="최상위-프로퍼티"><a href="#최상위-프로퍼티" class="headerlink" title="최상위 프로퍼티"></a>최상위 프로퍼티</h3><p>프로퍼티도 최상위에 둘 수 있다. 연산 수행 횟수를 재는 프로퍼티 같은 경우 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blahBlah</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>이런 경우 프로퍼티는 정적 필드에 저장된다. 이때 특이한 점은 최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 제공하는데 만약 최상위 프로퍼티를 상수처럼 보이는 데 실제로는 접근자 메서드를 통해 접근하는 것이 어색할 수 있다. 그렇다면 <code>const</code> 키워드를 사용해서 <code>public static final</code> 필드로 컴파일 되게 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티"><a href="#메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티" class="headerlink" title="메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티"></a>메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티</h1><h2 id="확장-함수"><a href="#확장-함수" class="headerlink" title="확장 함수"></a>확장 함수</h2><p>확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다. 확장 함수는 기존 자바 API에 코틀린의 추가 기능을 쉽게 제공할 수 있도록 돕기 위해 등장했다.</p><p>확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장하려는 클래스 이름을 덧붙이면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>[<span class="keyword">this</span>.length - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용하는 코드</span></span><br><span class="line">println(<span class="string">&quot;hello&quot;</span>.lastChar()) <span class="comment">// o</span></span><br></pre></td></tr></table></figure><p>위 예시는 <code>String</code> 클래스에 마지막 문자를 찾아 반환하는 확장 함수를 추가했다.<br>확장 함수에서 붙여진 클래스 이름을 수신 객체 타입(receiver type) 이라고 부르며 확장 함수가 호출되는 대상이 되는 값을 수신 객체(receiver object)라고 부른다.<br><code>fun String.lastChar(): Char = this.get(this.length - 1)</code><br>위 확장 함수에서는 <code>String</code>이 수신 객체 타입이고, <code>this</code>가 수신 객체가 된다.<br>확장 함수는 자바 클래스로 컴파일한 클래스 파일이 있는 한 원하는대로 확장할 수 있다. 그리고 멤버 메서드와 확장 함수를 통틀어 메서드라고 부르겠다.</p><p>하지만 멤버 메서드와 가장 큰 차이점은 private나 protected 멤버는 확장 함수가 접근할 수 없다.<br>그리고 확장 함수를 사용할 때는 임포트를 해야 한다. (다른 함수와 동일한 이름을 가져서 충돌할 수 있으므로.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;패키지&#125;.&#123;확장함수 명&#125;</span><br><span class="line"><span class="keyword">import</span> &#123;패키지&#125;.&#123;확장함수 명&#125; <span class="keyword">as</span> &#123;다른 이름&#125;</span><br></pre></td></tr></table></figure><blockquote><p>자바에서 확장 함수 활용하기<br>확장 함수는 내부적으로 수신 객체를 첫 매개변수로 가지는 정적 메서드다. 위 예시에서 자바는 다음과 같이 작성하면 된다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = StringUtilKt.lastChar(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>이제 <code>joinToString</code> 메서드를 확장 함수로 리팩토링 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 호출 코드</span></span><br><span class="line">println(list.joinToString2(prefix = <span class="string">&quot;&#123;&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>확장 함수를 더 엄격하게 사용<br>확장 함수 수신 타입 객체를 더 엄격한 타입을 사용하면 확장 함수를 사용하는 수신 객체를 제한할 수 있다.<br><code>fun &lt;T&gt; Collection&lt;String&gt;.joinToString(...) &#123;...&#125;</code><br>이런 식으로 구현하면 문자열 리스트만 확장 함수를 사용할 수 있게 된다.</p></blockquote><h3 id="확장-함수는-오버라이드-할-수-없다"><a href="#확장-함수는-오버라이드-할-수-없다" class="headerlink" title="확장 함수는 오버라이드 할 수 없다."></a>확장 함수는 오버라이드 할 수 없다.</h3><p>오버라이드는 변수에 저장된 객체의 동적인 타입에 따라 호출할 메서드가 달라지는 기능이다.<br>왜 확장 함수는 오버라이드 할 수 없을까? 확장 함수는 정적으로 선언된 메서드이기 때문이다. 확장 함수는 인스턴스 메서드가 아닌 인스턴스를 매개변수로 받는 정적 메서드이므로 오버라이딩이 불가능하다.</p><blockquote><p>멤버 함수와 확장 함수의 시그니처가 같으면 멤버 함수가 우선한다.</p></blockquote><h2 id="확장-프로퍼티"><a href="#확장-프로퍼티" class="headerlink" title="확장 프로퍼티"></a>확장 프로퍼티</h2><p>확장 프로퍼티를 사용하면 기존 클래스 객체에 프로퍼티 형식의 구문을 사용할 수 있는 API를 추가할 수 있다. 이때 중요한 점은 확장 프로퍼티는 아무 상태도 가질 수 없다. 기존 클래스의 인스턴스 객체에 필드를 추가할 방법이 없기 때문이다. 하지만 프로퍼티 문법으로 더 짧게 코드를 작성할 수 있다.<br>확장 프로퍼티는 마치 프로퍼티 접근 방식과 유사하게 API를 제공하는 것이지 실제로 필드를 가져서 접근자 메서드를 제공하는 것이 아님을 명심하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sb = StringBuilder(<span class="string">&quot;Kotlin?&quot;</span>)</span><br><span class="line">sb.lastChar2 = <span class="string">&#x27;!&#x27;</span></span><br><span class="line">println(sb)</span><br></pre></td></tr></table></figure><p>만약 자바에서 사용하려면 다음과 같을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Char lastChar = StringUtilKt.getLastChar();</span><br></pre></td></tr></table></figure><h1 id="컬렉션-처리-가변-길이-인자-중위-함수-호출-라이브러리-지원"><a href="#컬렉션-처리-가변-길이-인자-중위-함수-호출-라이브러리-지원" class="headerlink" title="컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원"></a>컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원</h1><h2 id="가변-인자-함수-인자의-개수가-달라질-수-있는-함수-정의"><a href="#가변-인자-함수-인자의-개수가-달라질-수-있는-함수-정의" class="headerlink" title="가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의"></a>가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의</h2><p>자바에서는 <code>...</code>으로 가변 인자를 표현할 수 있었다. 코틀린에서는 <code>vararg</code> 변경자를 앞에 붙여주면 된다.<br>대표적인 가변 인자 함수인 <code>listOf</code> 함수의 경우를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> listOf<span class="type">&lt;T&gt;</span><span class="params">(varargs values: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>코틀린은 자바처럼 배열을 바로 가변 인자로 넘겨줄 수 없다. 배열의 원소를 풀어서 각 원소가 인자로 전달되게 해야한다.<br>이 역할을 스프레드 연산자 <code>*</code>가 한다. 스프레드 연산자를 활용하면 배열과 함께 다른 인자들도 같이 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;args &quot;</span>, *args)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="값의-쌍-다루기-중위-호출과-구조-분해-선언"><a href="#값의-쌍-다루기-중위-호출과-구조-분해-선언" class="headerlink" title="값의 쌍 다루기: 중위 호출과 구조 분해 선언"></a>값의 쌍 다루기: 중위 호출과 구조 분해 선언</h2><p>대표적인 중위 호출인 <code>map</code>에서 <code>to</code> 메서드 호출을 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">2</span> to <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>중위 호출은 수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣는다. 다음 두 호출은 동일하다!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>to(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure><p>중위 호출은 수신 객체의 메서드 중 매개변수가 하나뿐인 경우에 사용할 수 있다.</p><p>실제 <code>to</code> 메서드의 구현을 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure><p>일단 <code>infix</code> 키워드를 통해 중위 호출을 사용할 수 있도록 했다. 제네릭을 활용해서 <code>A</code> 수신 객체 타입에 확장 함수로 구현했다.</p><h3 id="구조-분해-선언"><a href="#구조-분해-선언" class="headerlink" title="구조 분해 선언"></a>구조 분해 선언</h3><p><code>to</code> 메서드는 <code>Pair</code> 인스턴스를 반환하는데 <code>Pair</code> 인스턴스로 두 변수를 즉시 초기화 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (number, name) = <span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure><p>이렇게 <code>number</code> 와 <code>name</code> 두 변수를 <code>Pair</code>를 구조 분해해서 할당했다.</p><p>이런 구조 분해 선언은 루프에서도 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h1 id="문자열과-정규식-다루기"><a href="#문자열과-정규식-다루기" class="headerlink" title="문자열과 정규식 다루기"></a>문자열과 정규식 다루기</h1><p>코틀린 문자열은 자바 문자열과 같다. 다만 코틀린은 확장 함수로 더 다양한 기능을 제공한다.</p><h3 id="문자열-나누기"><a href="#문자열-나누기" class="headerlink" title="문자열 나누기"></a>문자열 나누기</h3><p>코틀린의 <code>split</code>은 정규식으로 나눠야 하는 경우 <code>Regex</code> 객체를 요구한다. 이로써 개발자가 혼동하는 일이 없도록 한다.<br>또한 여러 구분 문자열을 지정할 수 있도록 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> line = <span class="string">&quot;12.345-6.A&quot;</span></span><br><span class="line">println(line.split(<span class="string">&quot;\\.|-&quot;</span>.toRegex()))</span><br><span class="line">println(line.split(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;-&quot;</span>))</span><br></pre></td></tr></table></figure><h1 id="코드-다듬기-로컬-함수와-확장"><a href="#코드-다듬기-로컬-함수와-확장" class="headerlink" title="코드 다듬기: 로컬 함수와 확장"></a>코드 다듬기: 로컬 함수와 확장</h1><p>코드 중복을 줄이기 위해서 메서드 추출을 통해 작은 메서드로 분리하기 시작하면 메서드가 너무 많아져서 코드가 파악하기 어려워진다.<br>코틀린은 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.</p><p>먼저 중복되는 예시를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty name&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty email&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보면 비슷한 검증로직이 존재한다.</p><p>이를 로컬 함수로 개선해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(user: <span class="type">User</span>, value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user, user.name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(user, user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 안에 함수를 만들어서 중복 코드를 줄였다. 하지만 <code>User</code> 객체를 로컬 함수에게 일일히 전달하는게 아쉽다.<br>사실 그러지 않아도 된다. 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user.name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아재 곰중 로직을 확장 함수로 추출해보자. 이렇게 하면 외부에서 사용되지 않는 로직은  도메인 클래스에서 제거할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="variable">$id</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser4</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateBeforeSave()</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 식의 결과 타입</title>
      <link>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/</guid>
      <pubDate>Mon, 09 Jan 2023 04:39:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;10^6 개 중 중복 없이 2개를 조합하는 경우의 수를 계산하는 코드를 다음과 같이 작성했다.&lt;br&gt;하지만 실행해보면 완전 엉뚱한 값이 반환된다.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</description>
        
      
      
      
      <content:encoded><![CDATA[<p>10^6 개 중 중복 없이 2개를 조합하는 경우의 수를 계산하는 코드를 다음과 같이 작성했다.<br>하지만 실행해보면 완전 엉뚱한 값이 반환된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Math.pow(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">long</span> b = a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">System.out.println(b); <span class="comment">//-364189984라는 값이 나온다.</span></span><br></pre></td></tr></table></figure><p>음수가 나오는 것으로 봐서는 타입에서 감당할 수 있는 범위를 벗어난 값을 표현하려고 해서 오버플로우가 발생했음을 추측할 수 있다.<br>하지만 <code>10^6 * (10^6 - 1) / 2</code>는 499999500000이다.<br><code>long</code>은 8바이트(64비트)로 최대 2^63까지 저장할 수 있다. 즉 <code>b</code>에는 충분히 계산값을 저장할 수 있어야 한다.</p><p>하지만 왜 오버플로우가 발생했을까?<br>이를 위해서는 자바의 식 결과 타입을 어떻게 결정하는 지 알아야 한다.</p><p>일단 식 (expression)은 하나의 결과 값을 반환하는 코드로 변수, 연산자, 함수 호출 등으로 이뤄져있다.<br><code>1 + 2</code>, <code>int a = 1</code> 이런 코드들이 모두 식이다.<br>식의 반환 타입은 식의 구성 요소들에 따라 달라진다.</p><p>여기서 우리가 작성했던 코드를 다시 보자.<br>문제가 됐었던 부분은 바로 이 부분이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>여기서 코드는 한 줄이지만 여러 식으로 분해할 수 있다.</p><ol><li><code>a * (a - 1)</code> -&gt; 이 식도 여러 식으로 나눌 수 있겠지만 생략.</li><li><code>&#123;결과 값&#125; / 2</code></li><li><code>long b = &#123;결과 값&#125;</code></li></ol><p>여기서 1번식은 어떤 타입을 반환할까? 산술 연산은 서로 다른 타입이 연산될 경우 피연산자를 일반적인 타입으로 변환하고 연산을 진행한다.<br>하지면 1번식은 모두 int 타입만 사용되고 있다. 즉 1번 식의 반환 값은 int 타입이다.<br>int형은 4바이트(32비트)로 최대 20억의 값만 저장할 수 있다. 그러나 1번식의 결과값은 999999000000이다. 그래서 식의 결과를 제대로 저장하지 못하고 오버플로우가 발생했다.</p><p>이런 문제를 해결하려면 식의 피연산자의 타입을 <code>long</code>으로 캐스팅하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>) a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> b = a * (<span class="keyword">long</span>) (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>하지만 다음과 같이 식 밖에서 캐스팅을 하면 안된다. 이미 식이 수행되고 나서 캐스팅은 의미가 없기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>) (a * (a - <span class="number">1</span>)) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린 기초</title>
      <link>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/</guid>
      <pubDate>Mon, 02 Jan 2023 01:32:24 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%EA%B8%B0%EB%B3%B8_%EC%9A%94%EC%86%8C:_%ED%95%A8%EC%88%98%EC%99%80_%EB%B3%80%EC%88%98&quot;&gt;함수와 변수&lt;/a&gt;&lt;br&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약<br><a href="#%EA%B8%B0%EB%B3%B8_%EC%9A%94%EC%86%8C:_%ED%95%A8%EC%88%98%EC%99%80_%EB%B3%80%EC%88%98">함수와 변수</a><br><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">클래스와 프로퍼티</a><br><a href="#%EC%84%A0%ED%83%9D-%ED%91%9C%ED%98%84%EA%B3%BC-%EC%B2%98%EB%A6%AC-enum%EA%B3%BC-when">enum과 when</a><br><a href="#%EB%8C%80%EC%83%81%EC%9D%84-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-while%EA%B3%BC-for-%EB%A3%A8%ED%94%84">while과 for 루프</a><br><a href="#%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC">예외 처리</a></p></blockquote><h1 id="기본-요소-함수와-변수"><a href="#기본-요소-함수와-변수" class="headerlink" title="기본 요소: 함수와 변수"></a>기본 요소: 함수와 변수</h1><h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> &#123;함수이름&#125;<span class="params">(&#123;매개변수 이름&#125;: &#123;매개변수 타입&#125;)</span></span> : &#123;반환값 타입&#125; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>반환값이 없는 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반환값이 있는 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>문(statement)과 식(expression)의 구분<br>코틀린의 <code>if</code>는 식이지 문이 아니다. 반환값이 있는 함수 예시를 보면 반환값에 if식이 들어 간 것을 확인할 수 있다. 식은 값을 만들어내며 다른 식의 하위 요소로 계싼에 참여할 수 있다. 반면 문은 자신이 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 자바는 모든 제어 구조가 문인 반면, 코틀린은 루프를 제외한 모든 제어 구조가 식이다.</p></blockquote><h3 id="식이-본문인-함수"><a href="#식이-본문인-함수" class="headerlink" title="식이 본문인 함수"></a>식이 본문인 함수</h3><p><code>max</code> 함수를 좀 더 간결하게 줄여보자.<br>먼저 본문이 식 하나인 블록으로 구성되어 있어서 이를 식으로 대체할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>위 처럼 등호와 식으로 이뤄진 함수를 <strong>식이 본문인 함수</strong>라고 하고, 본문이 중괄호로 쌓인 함수를 <strong>블록이 본문인 함수</strong>라고 한다.</p><p>그리고 식이 본문인 함수인 경우 반환 타입을 생략할 수 있다. 식이 본문인 경우 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다. 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 <strong>타입추론</strong> 이라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><p>코틀린에서는 변수를 초기화할 때 타입을 생략할 수 있다. 타입을 생략하는 경우 타입추론을 활용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> statement = <span class="string">&quot;중요한 문장입니다.&quot;</span></span><br><span class="line"><span class="keyword">val</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> numberWithType: <span class="built_in">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>초기화 식을 사용하지 않고 변수를 선언하려면 반드시 타입을 적어줘야 한다. 변수에 저장될 값에 대한 정보가 없어서 타입추론을 할 수 없기 때문이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value : <span class="built_in">Int</span></span><br><span class="line">value = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="변경-가능한-변수와-변경-불가능한-변수"><a href="#변경-가능한-변수와-변경-불가능한-변수" class="headerlink" title="변경 가능한 변수와 변경 불가능한 변수"></a>변경 가능한 변수와 변경 불가능한 변수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 값을 뜻하는 value - 초기화 이후 변경 불가</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수를 뜻하는 variable - 초기화 이후 변경 가능</span></span><br><span class="line"><span class="keyword">var</span> variable = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>이때 재밌는 점은 자바 final은 선언과 동시에 초기화해줘야 하지만 코틀린의 <code>val</code>은 한번만 초기화된다. 즉 다음과 같은 제어 구조를 구성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doMessage</span><span class="params">(input : <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> message : String</span><br><span class="line">    <span class="keyword">if</span> (input.length == <span class="number">0</span>) &#123;</span><br><span class="line">        message = <span class="string">&quot;빈 문자열 전달받음.&quot;</span></span><br><span class="line">        <span class="comment">// 연산...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        message = input + <span class="string">&quot; 전달받음&quot;</span></span><br><span class="line">        <span class="comment">// 연산...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="문자열-템플릿"><a href="#문자열-템플릿" class="headerlink" title="문자열 템플릿"></a>문자열 템플릿</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringTemplate</span><span class="params">(input: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = input.ifEmpty &#123; <span class="string">&quot;Kotlin&quot;</span> &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;HELLO <span class="subst">$&#123;name.uppercase()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문자열 리터럴 안에서 변수를 사용할 수 있도록 하는 방법이다. <code>$</code>를 앞에 붙여주고 변수명을 적어주면 상요할 수 있다.<br>중괄호를 써주면 변수명이 아닌 간단한 식을 넣어줄 수도 있다.</p><h1 id="클래스와-프로퍼티"><a href="#클래스와-프로퍼티" class="headerlink" title="클래스와 프로퍼티"></a>클래스와 프로퍼티</h1><p>자바빈 클래스인 <code>Person</code>을 자바와 코틀린으로 구현해보자.<br>자바</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>와우! 어떻게 이렇게 된 것일까?<br>코틀린에서는 생성자를 통해 필드 대입 로직을 묵시적으로 생략해도 된다. 그리고 가시성 변경자가 public 인 경우 생략할 수 있다.</p><h2 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h2><p>클래스라는 개념의 목적은 데이터를 캡슐화 하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.<br>자바에서는 데이터를 필드에 저장하고 해당 데이터를 접근할 수 있는 접근자 메서드를 제공한다. (보통 게터, 세터)<br>자바에서는 이런 필드와 접근자 메서드를 묶어서 프로퍼티라고 정의한다.<br>코틀린은 프로퍼티를 언어 기본 기능으로 제공한다. 코틀린 프로퍼티는 자바의 필드 + 접근자 메서드를 완전히 대체한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>변수 선언과 비슷하게 <code>val</code>과 <code>var</code> 키워드로 선언할 수 있다. 이때 두 키워드에 따라 프로퍼티 유형이 달라진다.</p><ul><li><code>val</code> : 읽기 전용 프로퍼티, 비공개 필드 + 게터</li><li><code>var</code> : 쓸 수 있는 프로퍼티, 비공개 필드 + 게터 + 세터</li></ul><blockquote><p><code>is</code>가 붙은 변수명의 게터 세터<br><code>isMarried</code>와 같이 변수명이 <code>is</code>로 시작하는 경우 게터가 <code>get</code>이 붙지 않고 원래 이름 그대로 사용한다.<br>그리고 세터는 <code>is</code> 부분을 <code>set</code>으로 바꿔 사용한다. <code>isMarried</code>는 <code>setMarried</code>가 될 것이다.</p></blockquote><p>그렇다면 자바와 코틀린의 클래스 활용법을 비교해보자.<br>자바</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;yang&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(person.getName());</span><br><span class="line">person.setMarried(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(person.isMarried());</span><br></pre></td></tr></table></figure><p>코틀린</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person(<span class="string">&quot;yang&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">println(person.name)</span><br><span class="line">person.isMarried = <span class="literal">true</span></span><br><span class="line">println(person.isMarried)</span><br></pre></td></tr></table></figure><h3 id="커스텀-접근자"><a href="#커스텀-접근자" class="headerlink" title="커스텀 접근자"></a>커스텀 접근자</h3><p>프로퍼티는 그 값을 저장하기 위해 프로퍼티를 뒷받침하는 필드가 존재한다. 그런데 필요하면 프로퍼티 값을 그때그때 계산할 수도 있다. 커스텀 게터를 사용하면 그런 프로퍼티를 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> height == width</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> isSquare2: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = height == width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>직사각형이 정사각형인지를 굳이 필드로 저장하지 않고 커스텀 접근자로 구현한 예시이다. 본문이 식인 경우와 블록인 경우 모두 가능하다. 식이 복잡하면 블록으로 구현할 수 있다.</p><h1 id="선택-표현과-처리-enum과-when"><a href="#선택-표현과-처리-enum과-when" class="headerlink" title="선택 표현과 처리: enum과 when"></a>선택 표현과 처리: enum과 when</h1><h2 id="enum-클래스-정의"><a href="#enum-클래스-정의" class="headerlink" title="enum 클래스 정의"></a>enum 클래스 정의</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, ORANGE, YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린에서 <code>enum</code>은 소프트 키워드이다. 소포트 키워드는 특정 조건에서만 특정한 의미를 갖는 키워드이다. 소프트 키워드는 변수 명 같이 다른 이름으로 사용할 수 있다. 하지만 <code>class</code>는 키워드이고 다른 곳에서 이름으로 사용할 수 없다.</p><p>코틀린 enum도 프로퍼티와 메서드를 추가해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(</span><br><span class="line">    <span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), </span><br><span class="line">    ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>),</span><br><span class="line">    YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>); <span class="comment">// 반드시 끝에 세미콜론</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(Color.YELLOW.rgb())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적인 클래스와 비슷하게 생성자를 통해 프로퍼티를 선언할 수 있다. 각 상수마다 프로퍼티 값을 정의해준다.<br>그리고 중요한 점은 enum에 메서드가 존재하는 경우 마지막 enum 상수 끝에 세미콜론을 넣어줘야 한다!</p><h2 id="when으로-enum-클래스-다루기"><a href="#when으로-enum-클래스-다루기" class="headerlink" title="when으로 enum 클래스 다루기"></a>when으로 enum 클래스 다루기</h2><p>자바의 <code>switch</code>가 있다면 코틀린에는 <code>when</code>이 있다. 각 색깔에 맞는 과일 이름을 반환하는 메서드를 <code>when</code>을 활용해서 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFruitNameOf</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED -&gt; <span class="string">&quot;Apple&quot;</span></span><br><span class="line">        Color.ORANGE -&gt; <span class="string">&quot;Orange&quot;</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">&quot;Banana&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTemperatureOf</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED, Color.ORANGE -&gt; <span class="string">&quot;Hot&quot;</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">&quot;warm&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>코틀린의 <code>when</code>은 <code>if</code>와 마찬가지로 값을 반환하는 식이다. 그래서 식이 본문인 함수로 구현할 수 있다. 자바 <code>switch</code>와는 다르게 매번 <code>break</code>을 넣어주지 않아도 된다.</p><h2 id="when과-임의의-객체를-함께-사용"><a href="#when과-임의의-객체를-함께-사용" class="headerlink" title="when과 임의의 객체를 함께 사용"></a>when과 임의의 객체를 함께 사용</h2><p><code>when</code>은 분기 조건에 임의의 객체도 지원해서 상수(enum 상수나 숫자 리터럴)만 허용하는 <code>switch</code>보다 강력하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mix</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (setOf(c1, c2)) &#123;</span><br><span class="line">        setOf(RED, YELLOW) -&gt; ORANGE</span><br><span class="line">        setOf(RED, ORANGE) -&gt; RED</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>분기 조건에 두 색을 가진 집합 객체를 받아서 사용할 수 있다. 이때 임의의 객체를 분기 조건으로 사용하면 해당 분기가 맞는지는 동등성을 통해 확인한다.<br>하지만 위 코드는 매번 메서드를 실행할 때마다 여러 Set 객체를 만들어서 비교한다. 메서드 호출이 굉장히 많을 경우 불필요한 가비지 객체가 많아짐을 의미한다.</p><h2 id="인자-없는-when-사용"><a href="#인자-없는-when-사용" class="headerlink" title="인자 없는 when 사용"></a>인자 없는 when 사용</h2><p>인자가 없는 <code>when</code> 식 사용하면 불필요한 객체 생성을 막을 수 있다. 코드는 장황해지만 성능 상의 이점을 얻을 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mixOptimized</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        (c1 == RED &amp;&amp; c2 == YELLOW) ||</span><br><span class="line">                (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE</span><br><span class="line">        (c1 == RED &amp;&amp; c2 == ORANGE) ||</span><br><span class="line">                (c1 == ORANGE &amp;&amp; c2 == RED) -&gt; RED </span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>when</code> 식에 인자가 없으려면 매 분기가 참 거짓을 판별하는 식이어야 한다.</p><h2 id="스마트-캐스트-타입-검사와-타입-캐스트를-조합"><a href="#스마트-캐스트-타입-검사와-타입-캐스트를-조합" class="headerlink" title="스마트 캐스트: 타입 검사와 타입 캐스트를 조합"></a>스마트 캐스트: 타입 검사와 타입 캐스트를 조합</h2><p><code>(1 + 2) + 4</code> 와 같이 덧셈을 계산하는 함수를 만들어보자.<br>우선 식을 인코딩하는 방법을 생각해본다. 우리는 식을 트리 구조로 저장한다. 노드는 <code>Num</code>(값)과 <code>Sum</code>(합) 두가지 형식을 가지고, 최하단 노드는 항상 <code>Num</code>이고 <code>Sum</code>은 자식을 가진 중간 노드다.<br><img src="/img/calculatorTreeDiagram.png" alt="트리로 표현한 계산"></p><p><code>Expr</code> 인터페이스를 선언하고 <code>Sum</code>과 <code>Num</code> 모두 구현하도록 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr</span><br></pre></td></tr></table></figure><p>그렇다면 <code>(1 + 2) + 4</code>라는 식은 <code>Sum(Sum(Num(1), Num(2)), Num(4))</code> 이런 객체로 표현할 수 있다.</p><p>그렇다면 해당 <code>Expr</code> 객체의 값을 반환하는 <code>eval</code> 메서드를 통해 값을 구한다고 하면 다음과 같은 코드가 된다.<br><code>println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))</code></p><p><code>Expr</code> 객체가 <code>Sum</code>과 <code>Num</code>에 따라 <code>eval</code>이 다르게 작동해야 한다.</p><ul><li><code>Num</code> : 그 값을 반환</li><li><code>Sum</code> : 좌항과 우항을 계산한 다음 두 값을 합한 값을 반환</li></ul><p>이런 분기를 처리하는 코드를 짜보는데, Java 방식으로 Kotlin 코드를 짜보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">        <span class="keyword">val</span> n = e <span class="keyword">as</span> Num</span><br><span class="line">        <span class="keyword">return</span> n.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">        <span class="keyword">val</span> n = e <span class="keyword">as</span> Sum</span><br><span class="line">        <span class="keyword">return</span> eval(n.left) + eval(n.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>is</code>는 Java의 <code>instancof</code>와 비슷하고, <code>as</code>는 캐스팅하는 역할을 한다.<br>Kotlin에서는 <code>is</code>로 검사하고 나면 해당 변수는 컴파일러가 검사했던 타입으로 캐스팅해준다. 이를 스마트 캐스트라고 부른다.</p><p>스마트 캐스트를 적용하면 캐스팅하던 코드가 사라진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> eval(e.left) + eval(e.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="리팩토링-if를-when으로-변경"><a href="#리팩토링-if를-when으로-변경" class="headerlink" title="리팩토링: if를 when으로 변경"></a>리팩토링: if를 when으로 변경</h3><p>Kotlin의 <code>if</code>는 값을 만들어내는 식임을 더 활용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =  </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) e.value</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) eval(e.left) + eval(e.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br></pre></td></tr></table></figure><p>식이 본문인 함수로 변경됐다. 하지만 <code>if</code>를 <code>when</code>으로 변경해서 더 다듬을 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>분기 조건에 값 동등성 조건 대신 다른 기능을 활용하였다. 이 경우에도 스마트 캐스트가 작동한다.</p><h3 id="if와-when의-분기에서-블록-사용"><a href="#if와-when의-분기에서-블록-사용" class="headerlink" title="if와 when의 분기에서 블록 사용"></a>if와 when의 분기에서 블록 사용</h3><p><code>if</code>와 <code>when</code>의 분기에서 복잡한 로직을 실행하려면 블록을 사용한다. 그리고 각 블록은 반환하려는 값을 맨 마지막에 작성하면 된다. <strong>즉 블록의 마지막 식이 블록의 결과이다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">evalWithLogging</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;num: <span class="subst">$&#123;e.value&#125;</span>&quot;</span>)</span><br><span class="line">            e.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> right = evalWithLogging(e.right)</span><br><span class="line">            <span class="keyword">val</span> left = evalWithLogging(e.left)</span><br><span class="line">            println(<span class="string">&quot;num: <span class="subst">$&#123;left + right&#125;</span>&quot;</span>)</span><br><span class="line">            left + right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="대상을-이터레이션-while과-for-루프"><a href="#대상을-이터레이션-while과-for-루프" class="headerlink" title="대상을 이터레이션: while과 for 루프"></a>대상을 이터레이션: while과 for 루프</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>코틀린의 <code>while</code>은 자바와 별반 다르지 않다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span> (조건)</span><br></pre></td></tr></table></figure><h2 id="수에-대한-이터레이션-범위와-수열"><a href="#수에-대한-이터레이션-범위와-수열" class="headerlink" title="수에 대한 이터레이션: 범위와 수열"></a>수에 대한 이터레이션: 범위와 수열</h2><p>전통적인 for문을 코틀린에서 제공하지 않는다. 이를 대신하기 위해 코틀린에서는 범위를 사용한다.<br>범위는 <code>val oneToTen = 1..10</code> 이런 방식으로 만든다. 코틀린의 범위는 폐구간 혹은 양 끝을 포함하는 구간이다.</p><p>이때 역방향으로 수열을 만들고 싶으면 <code>100 downTo 1</code> 이런 식으로 구현할 수 있다. 이때 감소폭을 다루고 싶으면 <code>step</code> 키워드를 붙이면 된다. 즉 <code>100 downTo 1 step 2</code> 이런 식으로 구현할 수 있다.</p><p>코틀린은 기본적으로 개발자가 작성한 마지막 끝 점을 포함한 수열을 만든다. 만약 닫힌 구간을 구현하고 싶으면 <code>until</code> 키워드를 사용하자. <code>0 until 101</code>은 <code>0..100</code>과 같다.</p><h2 id="맵에-대한-이터레이션"><a href="#맵에-대한-이터레이션" class="headerlink" title="맵에 대한 이터레이션"></a>맵에 대한 이터레이션</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> someMap) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$key</span> = <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 형태로 맵 객체를 구조 분해해서 사용할 수 있다.<br>물론 굳이 맵이 아니더라도 구조 분해할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> someList.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$index</span>: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="in으로-컬렉션이나-범위의-원소-검사"><a href="#in으로-컬렉션이나-범위의-원소-검사" class="headerlink" title="in으로 컬렉션이나 범위의 원소 검사"></a>in으로 컬렉션이나 범위의 원소 검사</h2><p>in 연산자로 순회 뿐만아니라 원소가 포함됐는지 검사할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> || c <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c !<span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure><p><code>when</code> 절에서도 분기를 구분할 때 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recognize</span><span class="params">(c: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span>(c) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> -&gt; <span class="string">&quot;is lower case&quot;</span></span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;is upper case&quot;</span></span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="string">&quot;is numeric value&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;don&#x27;t know&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code> 절로 원소 겁사할 수 있는 범위는 비교가 가능한 클래스(<code>Comparable</code>을 구현한 클래스)면 무엇이든 된다.</p><h1 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h1><p>코틀린의 예외 발생은 자바와 거의 비슷하다. 다만 코틀린에서는 <code>throw</code> 키워드가 식을 만든다는 점만 알고 있자. 그래서 다른 식 내부에서 사용될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> percentage =</span><br><span class="line">        <span class="keyword">if</span> (number <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) number</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> Exception()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try, catch, finally"></a>try, catch, finally</h2><p>자바와 마찬가지로 try, catch, finally를 사용한다. 다만 <code>throws IOException</code>이 없다는 점을 주목하자. 자바는 체크 예외를 반드시 어떻게든 처리해줘야 하는데 코틀린은 체크 예외와 언체크드 예외를 구분하지 않는다. 체크 예외가 발생한다고 해서 클라이언트 프로그램이 취할 수 있는 의미있는 동작이 마땅하지 않은 경우가 많기 때문에 의미 없는 예외를 다시 던지거나 예외를 잡고 처리하지 않도록 구현하는 경우가 많기 때문이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span> <span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try를 식으로도 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우 catch 블록을 보면 return 문을 통해 메서드를 종료시키고 있다. 이런 방식은 catch 됐을 때 메서드를 종료시키고 싶은 경우 적절하다. 하지만 다른 값을 반환해야 하는 경우는 다르게 작성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 마지막줄에 블록의 결과를 넣는 규칙에 따라 null을 결과값으로 반환되도록 구현했다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>널 오브젝트 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/</guid>
      <pubDate>Wed, 28 Dec 2022 07:25:25 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e = DB.getEmployee(<span class="string">&quot;Yang&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.isTimeToPay(today)) &#123;</span><br><span class="line">    e.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식의 코드가 있다고 하자. 데이터베이스에서 조회하는 직원이 존재하지 않으면 null을 반환할 수 있기 때문에 조건문에서 먼저 null 여부를 체크해줬다. 이런 번거로운 작업을 줄이고 로직 코드를 보다 더 깔끔하게 만드는 패턴이 널 오브젝트 패턴이다.</p><h1 id="널-오브젝트-패턴"><a href="#널-오브젝트-패턴" class="headerlink" title="널 오브젝트 패턴"></a>널 오브젝트 패턴</h1><p><img src="/img/nullObjectDiagram.png"><br>널 오브젝트 패턴은 추상화하려는 객체의 인터페이스를 만들고 그 구현체로 null을 의미하는 구현체와 진짜 객체를 의미하는 구현체를 만들어서 활용한다.<br>null을 의미하는 클래스의 메서드는 ‘아무 일’도 하지 않도록 구현한다. ‘아무 일’의 경우 각 메서드에 따라 다르다. <code>isTimeToPay</code> 메서드 같은 경우 null인 객체는 false를 반환하는게 자연스럽다.</p><p>널 오브젝트 패턴으로 코드를 고치면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e = DB.getEmployee(<span class="string">&quot;Yang&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (e.isTimeToPay(today)) &#123;</span><br><span class="line">    e.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 자바 8이후에는 Optional을 사용하면서 이런 문제가 많이 해소되었다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>퍼사드와 미디에이터 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/</guid>
      <pubDate>Fri, 23 Dec 2022 09:43:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;퍼사드-패턴&quot;&gt;&lt;a href=&quot;#퍼사드-패턴&quot; class=&quot;headerlink&quot; title=&quot;퍼사드 패턴&quot;&gt;&lt;/a&gt;퍼사드 패턴&lt;/h1&gt;&lt;p&gt;퍼사드는 외관, 건물의 정면을 의미한다.&lt;br&gt;퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="퍼사드-패턴"><a href="#퍼사드-패턴" class="headerlink" title="퍼사드 패턴"></a>퍼사드 패턴</h1><p>퍼사드는 외관, 건물의 정면을 의미한다.<br>퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 객체 그룹을 간단하고 구체적인 인터페이스를 제공한다.</p><p>DB를 활용하기 위해 <code>java.sql</code> 패키지의 복잡한 인터페이스를 가진 객체들을 상위 모듈에서 사용하기는 어렵다.<br>이를 위해 퍼사드 역할을 하는 객체를 만들 수 있다.<br><img src="/img/facadeDBDiagram.png"></p><p><code>Application</code> 입장에는 <code>java.sql</code>을 알지 못해도 DB에 접근할 수 있게 된다.<br>다만 퍼사드 패턴은 반드시 퍼사드 객체를 통하기를 강요한다.</p><h1 id="미디에이터-패턴"><a href="#미디에이터-패턴" class="headerlink" title="미디에이터 패턴"></a>미디에이터 패턴</h1><p>미디에어터는 중재자라는 뜻을 의미한다. 복잡한 객체들의 관계를 캡슐화해서 관리하는 패턴이다. 미디에이터 패턴은 구성 요소들이 서로 직접 통신하지 말고 중재자를 거쳐서 통신한다.</p><p>간단한 비유를 해보자면, 관제탑과 비행기들의 관계가 미디에이터 패턴에 해당한다. 비행기들은 이착륙할 때 서로 부딪히지 않기 위해 비행기들끼리 직접 통신하지 않는다. 대신 관제탑과 통신하여 수많은 다른 비행기들과 부딪히지 않고 이착륙을 할 수 있게 된다.</p><p>구현은 다음을 참고하자.<br><a href="https://refactoring.guru/design-patterns/mediator/java/example">https://refactoring.guru/design-patterns/mediator/java/example</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/design-pattern/">Design Pattern</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>의존성 분리를 통해 설계 개선하기 2편 (우아한객체지향)</title>
      <link>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/</guid>
      <pubDate>Thu, 22 Dec 2022 13:37:19 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;도메인-컨셉&quot;&gt;&lt;a href=&quot;#도메인-컨셉&quot; class=&quot;headerlink&quot; title=&quot;도메인 컨셉&quot;&gt;&lt;/a&gt;도메인 컨셉&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/storeAndMenuDomainConcept.png&quot; alt=&quot;가게와</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="도메인-컨셉"><a href="#도메인-컨셉" class="headerlink" title="도메인 컨셉"></a>도메인 컨셉</h1><p><img src="/img/storeAndMenuDomainConcept.png" alt="가게와 메뉴"><br><img src="/img/orderDomainConcept.png" alt="주문"></p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사용자가 가게에서 메뉴 A를 골라서 장바구니에 저장해놓은 상태에서 가게 주인이 메뉴 A의 세부 내용을 바꾸면 사용자 장바구니에 있는 메뉴 A와 가게에서 판매 중인 메뉴 A의 불일치가 생긴다.<br>그래서 이제 주문할 때마다 사용자가 주문하려는 메뉴 A가 실제 가게에서 판매 중인 메뉴 A와 일치하는 지 검증하려고 한다.</p><h2 id="주문-검증"><a href="#주문-검증" class="headerlink" title="주문 검증"></a>주문 검증</h2><ol><li>메뉴 이름 &#x3D;&#x3D; 주문 항목의 이름</li><li>옵션 그룹의 이름 &#x3D;&#x3D; 주문 옵션 그룹 이름</li><li>옵션 이름 &#x3D;&#x3D; 주문 옵션 이름</li><li>옵션 가격 &#x3D;&#x3D; 주문 옵션의 가격</li><li>가게가 영업중인지 확인</li><li>주문금액 &gt;&#x3D; 최소 주문 금액</li></ol><p><img src="/img/orderFlow.png" alt="주문 검증 협력 흐름"></p><p>이런 식으로 협력 구조를 잡으면 어떻게든 런타임에서 같은 방향으로 의존성을 가져야 한다.<br>그렇다면 의존성의 방향을 어떤 종류의 의존성으로 구현할 지 선택하면 된다. 협력은 연관관계와 의존관계로 구현할 수 있다.</p><h3 id="연관관계"><a href="#연관관계" class="headerlink" title="연관관계"></a>연관관계</h3><p>연관관계는 영구적인 탐색 구조이다. 매우 빈번하게 협력해야 하는 경우에 사용한다.<br>연관 관계는 탐색 가능성을 의미한다. 즉 객체 A를 알면 객체 B를 탐색할 수 있음을 의미한다.</p><blockquote><p>일반적인 연관관계 구현 방식 : 객체 참조</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderLineItem&gt; orderLineItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">voidrplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getShopId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Money <span class="title">getTotalPrice</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        validate()</span><br><span class="line">        ordered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (OrderLineItem orderLineItem : orderLineItems) &#123;</span><br><span class="line">            orderLineItem.validate(); <span class="comment">// 협력!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로 연관관계는 개념이고 객체 참조는 그 개념의 구현방법이다. 연관관계가 즉 객체 참조는 아니다!</p><p>지금 예시의 도메인 모델에서는 다음과 같이 연관관계를 객체 참조로 가지고 있다<br><img src="/img/orderClassDiagram.png"></p><h1 id="설계-진화시키기"><a href="#설계-진화시키기" class="headerlink" title="설계 진화시키기"></a>설계 진화시키기</h1><p>설계를 개선하기 위해서는 의존성을 그려보자. 의존성이 순환하는 경우는 코드를 잘못 나눴거나 같이 있어야 할 코드를 잘못 위치시킨 것을 판단할 수 있다.</p><h2 id="대표적인-문제"><a href="#대표적인-문제" class="headerlink" title="대표적인 문제"></a>대표적인 문제</h2><ol><li>객체 참조로 결합도 상승</li><li>패키지 의존성 사이클</li></ol><p><img src="/img/orderPackageCycle.png" alt="패키지 의존성 사이클"><br>위 그림을 보면 알 수 있듯이 <code>shop</code> 패키지와 <code>order</code> 패키지가 서로 의존성이 순환되고 있다. 이렇게 되면 의존성 방향이 잘못 됐거나 패키지 분리를 잘못한 것이다.</p><p>자 이제 이런 문제를 해결하는 몇가지 방법을 배워보자</p><h2 id="중간-객체-이용해서-의존성-사이클-끊기"><a href="#중간-객체-이용해서-의존성-사이클-끊기" class="headerlink" title="중간 객체 이용해서 의존성 사이클 끊기"></a>중간 객체 이용해서 의존성 사이클 끊기</h2><p><img src="/img/middleObjectClassDiagram.png" alt="중간 객체를 사용한 예시 클래스 다이어그램"><br>중간 객체를 둬서 두 패키지 간 의존성이 한 방향으로 흐르게 만들었다.<br>이렇게 구현하면 <code>OrderOptionGroup</code>을 통해 <code>OptionGroup</code>을 생성하고 <code>OptionGroupSpecification</code>이 생성된 <code>OptionGroup</code>과 비교하여 데이터 불일치를 검증하는 방식으로 구현한다.</p><h2 id="객체-참조의-문제점"><a href="#객체-참조의-문제점" class="headerlink" title="객체 참조의 문제점."></a>객체 참조의 문제점.</h2><ol><li>성능 문제 : 어디까지 조회 할 것인가?</li><li>수정 시 도메인 규칙을 함께 적용할 경계는? : 즉 트랜잭션의 범위가 어디까지인가?</li></ol><h3 id="수정-시-도메인-규칙을-함께-적용할-경계-문제"><a href="#수정-시-도메인-규칙을-함께-적용할-경계-문제" class="headerlink" title="수정 시 도메인 규칙을 함께 적용할 경계 문제"></a>수정 시 도메인 규칙을 함께 적용할 경계 문제</h3><p>간단한 예시를 들어보자.<br>배달 완료됐음을 알리는 서비스 로직이 있다.</p><ol><li>주문 객체의 상태를 배달 완료로 변경</li><li>가게 객체의 수수료를 부과</li><li>배달 객체의 상태를 배달 완료로 변경</li></ol><p>언뜻 보면 이 세 객체를 한 트랜잭션으로 묶어서 수정하는 게 큰 문제가 없어보인다.<br>그러나 문제는 주문, 가게, 배달 이 세가지 객체의 트랜잭션 주기가 다르다는 사실이다!</p><p>가게는 주인이 가게 정보를 바꾸려고 할 때도 트랜잭션이 걸릴 수 있다.<br>주문은 고객이 주문을 취소할 때도 트랜잭션이 걸릴 수 있다.<br>배달은 배달 성공 실패에 트랜잭션이 걸릴 수 있다.</p><p>즉 만약 개발자가 서비스의 모든 가게 객체의 특정 정보를 일괄 수정하는 트랜잭션을 실행한다고 가정하자.<br>우리가 개발한 배달 완료 로직은 개발자가 수행한 모든 가게 정보 수정 트랜잭션이 완료될 때까지 기다려야 될 것이다!!!<br>이는 트랜잭션 주기가 다른 여러 객체들이 한 트랜잭션에 묶여있어서 생긴 문제이다!</p><blockquote><p>그렇다면 언제 객체 참조를 해야하나?<br>도메인 규칙마다 다르다. 생명 주기가 같은 객체. 즉 같이 생성되고 같이 제거되는 객체는 객체 참조할 법하다.<br>혹은 도메인 제약 사항을 공유하는 객체들을 함께 묶어라! (도메인 제약 사항에 다른 객체가 필요한 경우!)<br>이렇게 객체 참조로 연결된 단위는 트랜잭션&#x2F;조회&#x2F;비즈니스 제약의 단위이다!</p></blockquote><h3 id="객체-참조-문제-해결법-레포지토리를-활용한-간접-참조"><a href="#객체-참조-문제-해결법-레포지토리를-활용한-간접-참조" class="headerlink" title="객체 참조 문제 해결법 : 레포지토리를 활용한 간접 참조"></a>객체 참조 문제 해결법 : 레포지토리를 활용한 간접 참조</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shop shop = shopRepository.findById(order.getShopId());</span><br></pre></td></tr></table></figure><p>이렇게 구현하면 <code>Shop</code>과 <code>Order</code> 사이의 강한 결합이 제거된다!</p><h3 id="검증-로직은-Validator-객체를-만들어서-도입하기"><a href="#검증-로직은-Validator-객체를-만들어서-도입하기" class="headerlink" title="검증 로직은 Validator 객체를 만들어서 도입하기"></a>검증 로직은 Validator 객체를 만들어서 도입하기</h3><p>문제는 이렇게 구현하면 기존에 객체들이 가지고 있던 검증 로직을 도메인 객체에서 수행할 수 없게 된다!<br>Validator라는 객체를 만들어서 주입해서 사용하는 건 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderValidator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShopRepository shopRepository;</span><br><span class="line">    <span class="keyword">private</span> MenuRepository menuRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderValidator</span><span class="params">(ShopRepository shopRepository,</span></span></span><br><span class="line"><span class="params"><span class="function">                          MenuRepository menuRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shopRepository = shopRepository;</span><br><span class="line">        <span class="keyword">this</span>.menuRepository = menuRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        validate(order, getShop(order), getMenus(order));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Order order, Shop shop, Map&lt;Long, Menu&gt; menus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!shop.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;가게가 영업중이 아닙니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order.getOrderLineItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;주문 항목이 비어 있습니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shop.isValidOrderAmount(order.calculateTotalPrice())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">&quot;최소 주문 금액 %s 이상을 주문해주세요.&quot;</span>, shop.getMinOrderAmount()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderLineItem item : order.getOrderLineItems()) &#123;</span><br><span class="line">            validateOrderLineItem(item, menus.get(item.getMenuId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이런 방식이 낯설 수 있다. 객체가 주도적으로 행동하는 것이 아닌 외부에 따로 객체를 만들어서 검증 책임을 하는 것처럼 보인다. 이런 방식은 객체지향적이지 않은 대신 제약조건을 한 눈에 볼 수 있고, 객체들의 응집도(검증 로직과 비즈니스 로직이 하나의 객체가 아닌 다른 객체로 분리)가 높아진다.</p><h3 id="다른-서비스-객체를-만들어서-도입하기"><a href="#다른-서비스-객체를-만들어서-도입하기" class="headerlink" title="다른 서비스 객체를 만들어서 도입하기"></a>다른 서비스 객체를 만들어서 도입하기</h3><p>그리고 객체 참조를 제거하면 다른 문제가 또 생긴다. 배달 완료 로직에서 객체 참조가 끊겨서 객체 내부에서 협력을 통해 로직을 실행 시킬 수 없다<br>-&gt; 그렇다면 다른 Service를 객체를 추가해서 로직을 절차지향적으로 구성할 수 있다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDeliveredService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">        Order order = orderRepository.findById(orderId);</span><br><span class="line">        Shop shop = shopRepository.findById(order.getShopId());</span><br><span class="line">        Delivery delivery = deliveryRepository.findById(orderId);</span><br><span class="line"></span><br><span class="line">        order.delivered();</span><br><span class="line">        shop.billComissionFee(order.calculateTotalPrice());</span><br><span class="line">        delivery.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 서비스를 주입받아서 사용하면 된다. 이때 서비스를 새로 만들면서 의존성 사이클이 도는 경우는 DIP를 활용한 인터페이스를 추가해서 적용해보자. 이 방법은 객체간의 결합도를 낮추는 대신 로직간의 결합도를 높이는 방법이다.</p><h3 id="도메인-이벤트-퍼블리싱"><a href="#도메인-이벤트-퍼블리싱" class="headerlink" title="도메인 이벤트 퍼블리싱"></a>도메인 이벤트 퍼블리싱</h3><p>위 방법들 외에도 도메인 이벤트 퍼블리싱 방법을 사용할 수 있다. 도메인 이벤트는 객체 간 결합은 최대한 느슨하게 하는 방법이다.<br>도메인 객체가 이벤트 객체를 발행하면 다른 패키지의 이벤트 리스너들이 이를 감지해 해당 패키지의 도메인 객체에게 알리는 방식이다.</p><p>주문 완료의 예시에서는</p><ol><li><code>Order</code> 객체가 배달 완료됐다는 메시지를 받는다.</li><li><code>Order</code>는 <code>OrderDeliveredEvent</code>라는 이벤트를 발행한다</li><li><code>shop</code> 패키지는 발행된 이벤트를 감지해 가게에 수수료를 부과하는 로직을 실행한다.</li><li><code>delivery</code> 패키지도 발행된 이벤트를 감지해 <code>Delivery</code> 객체의 상태를 완료로 변경한다.</li></ol><h3 id="도메인-이벤트-발행-코드로-이해하기"><a href="#도메인-이벤트-발행-코드로-이해하기" class="headerlink" title="도메인 이벤트 발행 코드로 이해하기"></a>도메인 이벤트 발행 코드로 이해하기</h3><p>이런 식으로 <code>Order</code> 객체는 이제 이벤트를 발행하기만 한다. 다른 패키지 도메인 객체에는 관심이 없다.<br>예제는 Spring Data의 <code>AbstractAggregatedRoot</code>를 상속받아서 <code>registerEvent</code> 메서드를 활용해서 이벤트를 등록한다. <code>registerEvent</code> 메서드는 이벤트를 모아놨다가 DB에 커밋될 때 이벤트를 발행한다. 이런 클래스의 도움을 받기 보다는 직접 구현하는 게 낫다고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">extends</span> <span class="title">AbstractAggregatedRoot</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderStatus = OrderStatus.DELIVERED;</span><br><span class="line">        registerEvent(<span class="keyword">new</span> OrderDeliveredEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDeliveredEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getShopId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getTotalPrice</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트 발행을 받는 쪽(shop 패키지)은 Spring의 이벤트 리스너를 활용해서 이벤트 핸들러를어만들어 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillShopWithOrderDeliveredEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DI 생략...</span></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//비동기로 처리. 동기로도 가능</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 다른 트랜잭션으로 분리해서도 가능</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(OrderDeliveredEvent event)</span> </span>&#123;</span><br><span class="line">        Shop shop = shopRepository.findById(event.getShopId());</span><br><span class="line">        shop.billCommissionFee(event.getTotalPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 이렇게 이벤트와 관련된 객체를 만들고 나서 다시 의존성 사이클이 발생할 수 있다는 사실이다.<br>이벤트를 받아 처리하는 리스너에서 파라미터로 <code>order</code> 패키지의 이벤트를 받도록 했기 때문에 <code>shop</code>과 <code>order</code>가 서로 의존하고 있다.</p><p><img src="/img/orderClassDiagramWithEvents.png"></p><p>이 문제는 <code>order</code>에서 발행한 이벤트를 처리하는 이벤트 핸들러가 <code>shop</code> 패키지에 있기 때문이다!<br>그렇다면 문제가 되는 이벤트 핸들러를 패키지 분리하면 어떨까?</p><p><img src="/img/orderClassDiagramWithEventsAddBilling.png" alt="billing 패키지를 추가해봤다."></p><p>그리고 이벤트 핸들러가 의존하던 수수료 관련 코드를 <code>Shop</code>과 분리하자!</p><p>기존의 <code>Shop</code> 객체는 다음과 같이 수수료 모으는 코드가 존재했었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ratio commissionRate;</span><br><span class="line">    <span class="keyword">private</span> Money commissin = Money.Zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">billCommissionFee</span><span class="params">(Money price)</span> </span>&#123;</span><br><span class="line">        commission = commission.plus(commissionRate.of(price));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 <code>Billing</code> 이란 객체를 도입해서 역할을 분리하자!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Billing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line">    <span class="keyword">private</span> Money commission = Money.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">billCommissionFee</span><span class="params">(Money commission)</span> </span>&#123;</span><br><span class="line">        commission = commission.plus(commission);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ratio commissionRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateCommissionFee</span><span class="params">(Money price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commissionRate.of(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이벤트 핸들러도 <code>shop</code>과 <code>billing</code>을 구분해서 협력하도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillShopWithOrderDeliveredEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DI 생략...</span></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//비동기로 처리. 동기로도 가능</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 다른 트랜잭션으로 분리해서도 가능</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(OrderDeliveredEvent event)</span> </span>&#123;</span><br><span class="line">        Shop shop = shopRepository.findById(event.getShopId());</span><br><span class="line">        Billing billing = billingRepository.findById(event.getShopId());</span><br><span class="line">        billing.billCommissionFee(shop.calculateCommissionFee(event.getTotalPrice()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러면 패키지끼리 순환하지 않게 된다!<br><img src="/img/billingClassDiagram.png"></p><h3 id="패키지-의존성-사이클-제거하는-세가지-방법-정리"><a href="#패키지-의존성-사이클-제거하는-세가지-방법-정리" class="headerlink" title="패키지 의존성 사이클 제거하는 세가지 방법 정리!"></a>패키지 의존성 사이클 제거하는 세가지 방법 정리!</h3><ol><li>중간 객체 추가!</li><li>의존성 역전 시키기! -&gt; 새로운 서비스 객체를 사용할 때 생긴 의존성 제거에 유용했다.</li><li>새로운 패키지 추가! -&gt; 도메인 이벤트 퍼블리싱을 사용할 때 생긴 의존성 제거에 유용했다.</li></ol><h2 id="의존성과-시스템-분리"><a href="#의존성과-시스템-분리" class="headerlink" title="의존성과 시스템 분리"></a>의존성과 시스템 분리</h2><p>도메인 패키지 간의 의존성 사이클을 제거하면 각 패키지를 분리해서 배포할 수 있게된다!<br>그리고 이벤트는 메시징을 통해 외부 시스템으로 보내줄 수 있다!<br><img src="/img/%08systemDevidedWithEvent.png"></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>의존성 분리를 통해 설계 개선하기 1편 (우아한객체지향)</title>
      <link>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/</guid>
      <pubDate>Thu, 22 Dec 2022 12:41:03 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;의존성&quot;&gt;&lt;a href=&quot;#의존성&quot; class=&quot;headerlink&quot; title=&quot;의존성&quot;&gt;&lt;/a&gt;의존성&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/whatIsDependency.png&quot;&gt;&lt;br&gt;두 클래스 A, B가 있을 때 어느 한 쪽이 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="의존성"><a href="#의존성" class="headerlink" title="의존성"></a>의존성</h1><p><img src="/img/whatIsDependency.png"><br>두 클래스 A, B가 있을 때 어느 한 쪽이 변화가 생길 때 다른 한 쪽도 함께 변경될 가능성이 있는 경우를 의존성이 있다고 말한다.</p><blockquote><p>여기서 변경이란<br>클래스의 이름 변경, 메서드의 이름 변경, 메서드의 구현 변경 등을 의미한다.</p></blockquote><p>의존에는 클래스 간 의존성과 패키지 간 의존성이 존재한다.</p><h2 id="클래스-의존성의-종류"><a href="#클래스-의존성의-종류" class="headerlink" title="클래스 의존성의 종류"></a>클래스 의존성의 종류</h2><h3 id="연관-관계-Association"><a href="#연관-관계-Association" class="headerlink" title="연관 관계 Association"></a>연관 관계 Association</h3><p><img src="/img/whatIsAssociation.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A에서 B로 연결되어 있는 관계를 의미한다. 쉽게 말해 A에서 B의 객체 참조가 있는 경우를 의미한다. A라는 클래스에 B로 가는 영구적인 연결 통로가 생긴다.</p><h3 id="의존-관계-Dependency"><a href="#의존-관계-Dependency" class="headerlink" title="의존 관계 Dependency"></a>의존 관계 Dependency</h3><p><img src="/img/whatIsDependency.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">method</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드 상에서 인자 혹은 리턴 값으로 해당 타입을 사용하거나 메서드 안에서 해당 인스턴스를 생성하면 의존 관계이다. 이 관계는 해당 메서드를 사용할 때 일시적으로 맺어지는 관계이다. (영구적인 관계인 연관 관계와 다르다.)</p><h3 id="상속-관계-Inheritance"><a href="#상속-관계-Inheritance" class="headerlink" title="상속 관계 Inheritance"></a>상속 관계 Inheritance</h3><p><img src="/img/whatIsInheritance.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>상속 관계는 B 클래스의 구현을 그대로 가져와서 재사용하는 방식이다. 그래서 B 클래스의 구현이 변경되면 해당 구현을 사용하고 있던 A 클래스에 영향이 생긴다.</p><h3 id="실체화-관계-Realization"><a href="#실체화-관계-Realization" class="headerlink" title="실체화 관계 Realization"></a>실체화 관계 Realization</h3><p><img src="/img/whatIsRealization.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>실체화 관계는 인터페이스 B의 시그니처만 가져와서 사용하는 방식이다. 상속 관계와는 다르게 시그니처가 변경되지 않는 한 A 클래스에 영향이 생기지 않는다.</p><h2 id="패키지-의존성"><a href="#패키지-의존성" class="headerlink" title="패키지 의존성"></a>패키지 의존성</h2><p>패키지 의존성은 A 패키지의 클래스 중 어느 하나라도 B 패키지의 클래스에 의존하는 경우 A 패키지가 B 패키지에 의존함을 의미한다.</p><h1 id="좋은-설계를-위한-의존성-규칙"><a href="#좋은-설계를-위한-의존성-규칙" class="headerlink" title="좋은 설계를 위한 의존성 규칙"></a>좋은 설계를 위한 의존성 규칙</h1><h2 id="양방향-의존성을-피하라"><a href="#양방향-의존성을-피하라" class="headerlink" title="양방향 의존성을 피하라"></a>양방향 의존성을 피하라</h2><h3 id="양방향-Bi-Directional"><a href="#양방향-Bi-Directional" class="headerlink" title="양방향 Bi-Directional"></a>양방향 Bi-Directional</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b != <span class="keyword">null</span>) &#123; <span class="comment">// 동기화</span></span><br><span class="line">            <span class="keyword">this</span>.b.setA(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.b.setA(<span class="keyword">this</span>); <span class="comment">// 동기화</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123; <span class="comment">// 동기화</span></span><br><span class="line">            <span class="keyword">this</span>.a.setB(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.A = a;</span><br><span class="line">        <span class="keyword">this</span>.A.setB(<span class="keyword">this</span>); <span class="comment">// 동기화</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A와 B가 서로 의존한다는 의미는 A가 변할 때 B가 변할 수 있고, B가 변할 때 A가 변할 수 있다는 의미이다. 이런 경우 원래 이 두 클래스가 하나의 클래스로 묶어야 될 수 있다.</p><blockquote><p>양방향 의존 관계에서는 setter 메서드를 사용할 때 동기화 해줘야 한다.</p></blockquote><p>동기화를 왜 해줘야 하는 지 코드로 간략하게 알아보자.<br>만약 A와 B에서 주석으로 동기화라고 적혀 있는 코드가 없는 상태로 setter를 사용한다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="keyword">new</span> A();</span><br><span class="line">B b1 = <span class="keyword">new</span> B();</span><br><span class="line">B b2 = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// 1. 서로 양방향 의존하도록 설정.</span></span><br><span class="line">a1.setB(b1);</span><br><span class="line">b1.setA(a1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 이때 의존하는 인스턴스를 다른 인스턴스로 바꾸고 싶으면?</span></span><br><span class="line">a1.setB(b1); <span class="comment">// 이렇게 되면 b2는 a1에 연결되지 않은 상태다!!!! 그리고 심지어 b1은 아직 의존하고 있게 된다.</span></span><br></pre></td></tr></table></figure><p>이렇게 양방향은 고려해야 할 부분이 많고 예상하지 못한 버그가 발생할 수 있다.</p><h2 id="다중성이-적은-방향을-선택하라"><a href="#다중성이-적은-방향을-선택하라" class="headerlink" title="다중성이 적은 방향을 선택하라."></a>다중성이 적은 방향을 선택하라.</h2><p>즉 일대다 대신 다대일 관계를 선택하는 게 좋다. 일대다를 JPA를 사용하다보면 N+1 문제에서 큰 성능 저하를 일으키게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일대다 관계 (비추!)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;B&gt; bs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다대일 관계 (추천!)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="패키지-사이의-의존성-사이클을-제거하라"><a href="#패키지-사이의-의존성-사이클을-제거하라" class="headerlink" title="패키지 사이의 의존성 사이클을 제거하라"></a>패키지 사이의 의존성 사이클을 제거하라</h2><p>의존성 사이클은 여러 패키지의 의존성 방향이 결국 연결되는 것을 의미한다. 크게 보면 결국 양방향 의존인 셈이다. 패키지가 양방향 의존하게 되면 하나가 바뀌면 다같이 바뀌게 될 가능성이 존재한다는 의미이다. 즉 원래 같이 묶여야 될 패키지라는 의미일 수 있다.</p><p>구체적인 실습은 2편에서 해보자!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
