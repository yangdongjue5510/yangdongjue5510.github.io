<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Mon, 31 Jul 2023 13:35:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>girigiri-rent-refactor</title>
      <link>https://yangdongjue5510.github.io/2023/07/31/girigiri-rent-refactor/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/31/girigiri-rent-refactor/</guid>
      <pubDate>Mon, 31 Jul 2023 13:35:47 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/31/girigiri-rent-refactor/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>girigiri-time-instant</title>
      <link>https://yangdongjue5510.github.io/2023/07/31/girigiri-time-instant/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/31/girigiri-time-instant/</guid>
      <pubDate>Mon, 31 Jul 2023 13:22:37 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/31/girigiri-time-instant/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>girigiri-member-check</title>
      <link>https://yangdongjue5510.github.io/2023/07/31/girigiri-member-check/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/31/girigiri-member-check/</guid>
      <pubDate>Mon, 31 Jul 2023 13:22:21 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/31/girigiri-member-check/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>girigir-page-api</title>
      <link>https://yangdongjue5510.github.io/2023/07/31/girigiri-page-api/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/31/girigiri-page-api/</guid>
      <pubDate>Mon, 31 Jul 2023 13:16:14 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/31/girigiri-page-api/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>girigiri-db</title>
      <link>https://yangdongjue5510.github.io/2023/07/31/girigiri-db/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/31/girigiri-db/</guid>
      <pubDate>Mon, 31 Jul 2023 13:13:13 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/31/girigiri-db/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>실전 자바 소프트웨어 개발을 읽고 재밌었던 부분 모음</title>
      <link>https://yangdongjue5510.github.io/2023/07/16/realWorldJava/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/16/realWorldJava/</guid>
      <pubDate>Sun, 16 Jul 2023 09:25:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;실전 자바 소프트웨어 개발을 읽고 몇가지 재밌는 포인트를 적어본다.&lt;/p&gt;
&lt;h3 id=&quot;Q-유지보수에-유리한-코드는-어떤-코드인가&quot;&gt;&lt;a href=&quot;#Q-유지보수에-유리한-코드는-어떤-코드인가&quot; class=&quot;headerlink&quot; title=&quot;Q</description>
        
      
      
      
      <content:encoded><![CDATA[<p>실전 자바 소프트웨어 개발을 읽고 몇가지 재밌는 포인트를 적어본다.</p><h3 id="Q-유지보수에-유리한-코드는-어떤-코드인가"><a href="#Q-유지보수에-유리한-코드는-어떤-코드인가" class="headerlink" title="Q. 유지보수에 유리한 코드는 어떤 코드인가?"></a>Q. 유지보수에 유리한 코드는 어떤 코드인가?</h3><p>특정 기능을 담당하는 코드를 빠르게 찾을 수 있어야 한다. 코드가 어떤 일을 수행하는 지 쉽게 파악할 수 있어야 한다. 새로운 기능을 추가하기 쉽고 기존의 기능을 제거하기 쉬워야 한다. 캡슐화가 잘 되어 있어야 한다. 사용자가 내부 구현을 몰라도 쉽게 이해할 수 있어야 하고 쉽게 다른 기능으로 바꿀 수 있어야 한다.</p><h3 id="Q-코드-중복은-왜-안좋은가"><a href="#Q-코드-중복은-왜-안좋은가" class="headerlink" title="Q. 코드 중복은 왜 안좋은가?"></a>Q. 코드 중복은 왜 안좋은가?</h3><p>코드 중복은 해당 기능 변경이 일어나면 변경 작업을 여러 곳에서 해야 한다. 이 과정에서 빼먹는 곳이 있다면 버그가 발생한다.</p><h3 id="Q-응집도가-무엇인가-왜-중요한가"><a href="#Q-응집도가-무엇인가-왜-중요한가" class="headerlink" title="Q. 응집도가 무엇인가? 왜 중요한가?"></a>Q. 응집도가 무엇인가? 왜 중요한가?</h3><p>응집도는 메서드나 클래스 혹은 모듈 속에 있는 구성 요소들이 얼마나 연관있는지를 가르킨다. 코드를 쉽게 찾고 이해하고 사용할 수 있게한다.</p><h3 id="Q-클래스-수준-응집도를-어떤-기준으로-높일-수-있나"><a href="#Q-클래스-수준-응집도를-어떤-기준으로-높일-수-있나" class="headerlink" title="Q. 클래스 수준 응집도를 어떤 기준으로 높일 수 있나?"></a>Q. 클래스 수준 응집도를 어떤 기준으로 높일 수 있나?</h3><p>기능, 정보, 유틸리티, 논리, 순차, 시간 등 기준으로 클래스를 분리할 수 있다. 기능이 비슷한 메서드를 모아서 할 수 있다. 함께 사용하는 메서드가 같은 클래스에 모여 있어서 찾기 쉽고 이해하기 쉽다. 하지만 기능이 세세하게 나눠질 경우 클래스파일이 매우 많아져 더 이해하기 어려워질 수 있다.</p><p>정보를 기준으로 메서드를 모을 수 있다. 특정 객체를 처리하는 메서드를 모으는 방식이다. 하지만 이 경우 여러 기능이 한 클래스에 모이게 되고 일부 기능만 사용하고 싶어도 해당 클래스에 의존하게 된다.</p><p>유틸리티는 어디에 포함시키기 어려운 메서드를 모으는 방식이다. 이렇게 모인 메서드들은 서로 연관성이 낮기 때문에 주의해야 한다.</p><p>논리는 비슷해보이는 메서드를 모은다. 책에서 나온 예시는 문자열을 입력받아 특정 객체로 파싱하는 로직이 있는데, 문자열의 형식이 CSV, JSON 등 다양하므로 이에 따른 다양한 파싱 로직을 한 클래스에 모은 방식이다. 이렇게하면 다양한 로직이 모이게 되는 것이므로 SRP에 위반하게 된다.</p><p>하나의 비즈니스 로직의 순차적인 진행을 묶을 수 있다. 로직의 진행을 이해하기 쉬울 수는 있으나 다양한 기능이 하나의 단위로 묶이게 되므로 SRP를 위배하게 된다.</p><p>마지막으로 시간 응집 클래스는 특정 시점에 실행되어야 하는 기능을 모은 클래스다. 책에서는 특정 작업 이전과 이후에 해야할 작업들을 모으는 예시를 들고 있다.</p><h3 id="Q-개방-폐쇄-원칙이-무엇이고-구체적으로-어떤-예시를-들-수-있나"><a href="#Q-개방-폐쇄-원칙이-무엇이고-구체적으로-어떤-예시를-들-수-있나" class="headerlink" title="Q. 개방 폐쇄 원칙이 무엇이고 구체적으로 어떤 예시를 들 수 있나?"></a>Q. 개방 폐쇄 원칙이 무엇이고 구체적으로 어떤 예시를 들 수 있나?</h3><p>개방 폐쇄 원칙은 기존의 기능을 확장할 때 다른 코드를 변경하지도 않고 가능해야 한다는 의미다. 책에서는 은행 거래 내역 찾기를 예시로 들었다.</p><p>다음은 특정 금액 이상의 거래 내역 찾기이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;BankTransaction&gt; <span class="title function_">findGreaterThanEqual</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> amount)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;BankTransaction&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> BankTransaction bankTransaction : bankTransactions) &#123;</span><br><span class="line"><span class="keyword">if</span> (bankTransaction.getAmount() &gt;= amount) &#123;</span><br><span class="line">result.add(bankTransaction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>비슷한 로직을 가진 특정 월에 거래된 거래 내역 찾기이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;BankTransaction&gt; <span class="title function_">findInMonth</span><span class="params">(<span class="keyword">final</span> Month month)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;BankTransaction&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> BankTransaction bankTransaction : bankTransactions) &#123;</span><br><span class="line"><span class="keyword">if</span> (bankTransaction.getDate().getMonth() == month) &#123;</span><br><span class="line">result.add(bankTransaction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기에 특정 월에 거래되었고, 특정 금액 이상의 거래 내역을 찾으려고 한다면 비슷한 메서드를 또 추가해줘야 할 것이다. 이 예시의 거래 내역 찾기 기능은 확장에 열려있지 않다. 그리고 위 예시는 비슷한 로직을 가진 여러 개의 메서드가 생기는, 즉 중복 코드를 가지기 때문에 중복된 부분에 변경이 생길 경우 여러 곳을 변경해야 한다. 즉 변경에 닫혀있지 않다.</p><p>이를 위해서 메서드들마다 중복되는 코드와 그렇지 않은 코드를 분리하자. 위 예시에서는 거래 내역을 순회하는 로직이 있고, 거래 내역이 조건에 맞는 지 확인하는 로직이 있다. 거래 내역 순회 로직은 각 메서드마다 중복되고, 거래 내역 조건 확인하는 로직은 각 메서드마다 달라진다. 문제는 이 두 로직이 결합되어 있어서 순회 로직이 거래 내역 조건 확인 로직이 추가될 때마다 중복되어 작성된다는 점이다.</p><p>이를 위해서는 두 로직의 결합을 제거하기로 한다. 우리는 인터페이스로 로직을 분리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BankTransactionFilter</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(BankTransaction bankTransaction)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 조건 맞는지 확인하는 로직을 해당 인터페이스로 추상화할 수 있다. 인터페이스로 순회로직이 검증 로직들과 분리되었다. 매개변수로 함수형 인터페이스의 구현체 객체를 전달하거나 람다를 전달하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;BankTransaction&gt; <span class="title function_">findTransactions</span><span class="params">(<span class="keyword">final</span> BankTransactionFilter filter)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;BankTransaction&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> BankTransaction bankTransaction : bankTransactions) &#123;</span><br><span class="line"><span class="keyword">if</span> (filter.test(bankTransaction) &#123;</span><br><span class="line">result.add(bankTransaction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Q-인터페이스를-잘게-분리하는-게-좋나-큰-인터페이스는-어떤-문제가-있나"><a href="#Q-인터페이스를-잘게-분리하는-게-좋나-큰-인터페이스는-어떤-문제가-있나" class="headerlink" title="Q. 인터페이스를 잘게 분리하는 게 좋나? 큰 인터페이스는 어떤 문제가 있나?"></a>Q. 인터페이스를 잘게 분리하는 게 좋나? 큰 인터페이스는 어떤 문제가 있나?</h3><p>한 인터페이스가 많은 연산을 제공하면 그 만큼 인터페이스가 변경될 여지가 많아진다. 인터페이스가 변경될 때마다 모든 구현체를 변경해줘야 한다. 변경이 많아지면 문제가 생길 여지가 많아진다. 그리고 인터페이스에 특정 도메인 내부 구현이 드러나면 안된다. 구현이 변경되면 인터페이스에도 변경이 생기고 결과적으로 모든 구현체에 변경해야 할 일이 생긴다.</p><p>하지만 인터페이스를 극단적으로 잘게 나누면 기능이 여러 인터페이스로 분산되서 필요한 기능을 찾기 어려워지는 문제가 생길 수 있다.</p><h3 id="Q-명시적-API-VS-암묵적-API"><a href="#Q-명시적-API-VS-암묵적-API" class="headerlink" title="Q. 명시적 API VS 암묵적 API"></a>Q. 명시적 API VS 암묵적 API</h3><p>개방 폐쇄 원칙으로 하나의 메서드로 기능을 쉽게 확장할 수 있게 했던 <code>findTransactions()</code> 메서드와 같이 유연하지만 처음에 사용하기 어려운 암묵적 API와 구체적으로 어떤 작동을 하는 지 드러나는 <code>findTransactionsGreaterThanEqual()</code> 같은 메서드를 명시적 API라고 한다. 흔하게 사용하는 경우는 명시적 API를 추가해놓는 게 편할 수 있다.</p><h3 id="Q-CheckedException과-UncheckedException-의-차이는-뭘까"><a href="#Q-CheckedException과-UncheckedException-의-차이는-뭘까" class="headerlink" title="Q. CheckedException과 UncheckedException 의 차이는 뭘까?"></a>Q. CheckedException과 UncheckedException 의 차이는 뭘까?</h3><p>CheckedException은 API 사용자가 회복해야 할 예외다. 시그니처에 드러내거나 Try catch로 처리해줘야 한다. 반면 UncheckedException은 프로그램 실행 중 언제든지 발생할 수 있는 예외다.</p><p>이 두가지를 선택하는 기준은 응용 프로그램을 회복시켜야 하는가(혹은 회복 시킬 수 있는가?)이다. 일시적으로 문제가 발생한 경우는 API 사용자가 회복을 하려고 하는 것보다 잠시 뒤에 다시 재요청하는 게 나을 것이다. 그리고 비즈니스 로직 검증 시 발생한 문제는 불필요한 Try catch나 시그니처에 노출하지 않도록 하기 위해서 unchecked로 하는 게 좋다. 마지막으로 시스템 예외가 발생한 경우 API 사용자가 회복 시킬 수 있는 상황이 아닌 경우도 있다. 이럴 때도 unchecked로 처리하는 것이 좋다. 결론은 대부분의 unchecked 예외로 처리해서 불필요한 try catch나 메서드 시그니처에 노출하지 않도록 하는 게 좋다.</p><h3 id="Q-검증-코드는-어디에-두는-것이-좋을까-객체-생성-시-VS-검증자"><a href="#Q-검증-코드는-어디에-두는-것이-좋을까-객체-생성-시-VS-검증자" class="headerlink" title="Q. 검증 코드는 어디에 두는 것이 좋을까? 객체 생성 시 VS 검증자"></a>Q. 검증 코드는 어디에 두는 것이 좋을까? 객체 생성 시 VS 검증자</h3><p>책에서는 검증자를 추천한다. 검증 로직을 재사용할 수 있고 로직을 독립적으로 테스트할 수 잇고 SRP를 지키기 때문이다.</p><h3 id="Q-예외로-흐름을-제어하면-안되는-이유가-무엇인가"><a href="#Q-예외로-흐름을-제어하면-안되는-이유가-무엇인가" class="headerlink" title="Q. 예외로 흐름을 제어하면 안되는 이유가 무엇인가?"></a>Q. 예외로 흐름을 제어하면 안되는 이유가 무엇인가?</h3><p>예외를 처리하는 불필요한 try catch가 코드 가독성을 떨어트린다. try catch는 흐름 제어가 아닌 예외나 오류 처리를 위한 코드라서 흐름 제어에 사용하면 코드 이해하기가 어려워진다. 마지막으로 예외를 생성했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생긴다.</p><h3 id="Q-예외-대신에-사용할-수-있는-기능은-무엇인가"><a href="#Q-예외-대신에-사용할-수-있는-기능은-무엇인가" class="headerlink" title="Q. 예외 대신에 사용할 수 있는 기능은 무엇인가?"></a>Q. 예외 대신에 사용할 수 있는 기능은 무엇인가?</h3><p>Null을 반환하도록 할 수 있다. 다만 어느 시점에서 Null이 반환됐는 지 추적하기가 어렵다. 그리고 API 호출마다 null 체크를 해야 하는 번거로움이 생기고 Null 만으로는 그 어떤 정보도 얻을 수 없어서 추천하지 않는다.</p><p>Null 오브젝트 패턴을 사용할 수 있다. 반환되어야할 인터페이스를 구현하되 바디가 비어있는 형식을 가진 게 Null 오브젝트의 특징이다. 사용자에게 제공하고 싶은 내용을 담을 수 있고 NPE나 null 체크를 하지 않아도 된다. 다만 null 오브젝트는 발생 시 아무 단서를 주지 않기 때문에 문제를 파악하기가 어렵다.</p><p>그 외에 자바 8의 Optional을 사용할 수 있다.</p><h3 id="Q-빌드-도구를-왜-사용하는가"><a href="#Q-빌드-도구를-왜-사용하는가" class="headerlink" title="Q. 빌드 도구를 왜 사용하는가?"></a>Q. 빌드 도구를 왜 사용하는가?</h3><p>프로젝트를 실행하기 위해서는 컴파일해야 한다. 이때 여러 파일을 컴파일하는 명령어를 기억하기 힘들다. 여러 패키지를 컴파일하려면 어떤 명령어를 사용해야 할까? 다른 라이브러리 의존성은 어떻게 관리할 것인가? JAR와 같이 특정한 형식으로 어떻게 패키징할까 등 다양한 문제가 있다. 프로그램을 실행할 때마다 이런 문제를 고민하기 보다는 스크립트를 통해 모든 명령어를 자동화하면 훨씬 편한다. 다음은 빌드 도구 장점을 정리한 내용이다.</p><ul><li>응용 프로그램 빌드하고 실행하는 표준적인 작업 설정</li><li>저수준 설정과 초기화에 들이는 시간을 절약해서 개발에 집중 가능</li><li>설정과 빌드 과정에서의 오류 범위를 줄임</li></ul><h3 id="Q-리스코프-치환-원칙에-대해-설명해보라"><a href="#Q-리스코프-치환-원칙에-대해-설명해보라" class="headerlink" title="Q. 리스코프 치환 원칙에 대해 설명해보라"></a>Q. 리스코프 치환 원칙에 대해 설명해보라</h3><p>리스코프 치환 원칙은 크게 네가지 원칙으로 쉽게 설명할 수 있다.</p><ul><li>하위형식에서 선행조건을 더할 수 없다.<br>자식이 부모보다 더 많은 선행조건을 요구할 수 없다.</li><li>하위형식에서 후행조건을 약화시킬 수 없다.<br>후행조건은 코드를 실행한 다음에 만족해야 하는 규칙이다. 자식은 부모의 후행조건을 반드시 만족해야 한다.</li><li>슈퍼형식의 불변자는 하위형식에서 보존</li><li>히스토리 규칙<br>부모가 허용하지 않은 상태 변화를 허용해서는 안된다. (부모가 불변 객체면 자식도 이를 준수)</li></ul><h3 id="Q-클라이언트-서버-모델에서-서버가-먼저-데이터를-전달하고-싶으면-어떻게-하는가"><a href="#Q-클라이언트-서버-모델에서-서버가-먼저-데이터를-전달하고-싶으면-어떻게-하는가" class="headerlink" title="Q. 클라이언트 서버 모델에서 서버가 먼저 데이터를 전달하고 싶으면 어떻게 하는가?"></a>Q. 클라이언트 서버 모델에서 서버가 먼저 데이터를 전달하고 싶으면 어떻게 하는가?</h3><p>푸시 기반 통신을 사용한다. 리액티브 혹은 이벤트 주도 통신이라고도 한다. 푸시 기반 통신에서는 작성자(publisher)가 이벤트 스트림을 구독하는 상대들에게 데이터를 전달한다. 푸시 기반 통신은 일대다 통신을 지원하고 복잡한 컴포넌트들과 통신해야 할 때 유리하다. </p><p>풀 기반 통신은 푸시 기반 통신의 반대다. 클라이언트가 원하는 데이터를 먼저 서버에게 요청하고 응답받는 방식이다.</p><h3 id="Q-저장소-패턴이란-무엇인가-레포지토리의-책임은-무엇인가"><a href="#Q-저장소-패턴이란-무엇인가-레포지토리의-책임은-무엇인가" class="headerlink" title="Q. 저장소 패턴이란 무엇인가? 레포지토리의 책임은 무엇인가?"></a>Q. 저장소 패턴이란 무엇인가? 레포지토리의 책임은 무엇인가?</h3><p>저장소 패턴은 비즈니스 로직과 저장소 백엔드 간의 인터페이스를 정의한다. 저장소 패턴은 저장소 백엔드를 추상화해서 저장소를 다른 방식으로 구현해도 비즈니스 로직에는 영향이 가지 않도록 한다. 저장소 패턴을 사용하면 도메인 모델 데이터로 매핑하는 로직을 중앙화 할 수 있다.</p>]]></content:encoded>
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/16/realWorldJava/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>가상 면접 사례로 배우는 대규모 시스템 설계 - part 1</title>
      <link>https://yangdongjue5510.github.io/2023/07/02/systemDesign-1/</link>
      <guid>https://yangdongjue5510.github.io/2023/07/02/systemDesign-1/</guid>
      <pubDate>Sun, 02 Jul 2023 10:02:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;사용자-수에-따른-규모-확장성&quot;&gt;&lt;a href=&quot;#사용자-수에-따른-규모-확장성&quot; class=&quot;headerlink&quot; title=&quot;사용자 수에 따른 규모 확장성&quot;&gt;&lt;/a&gt;사용자 수에 따른 규모 확장성&lt;/h1&gt;&lt;h2 id=&quot;단일-서버&quot;&gt;&lt;a</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="사용자-수에-따른-규모-확장성"><a href="#사용자-수에-따른-규모-확장성" class="headerlink" title="사용자 수에 따른 규모 확장성"></a>사용자 수에 따른 규모 확장성</h1><h2 id="단일-서버"><a href="#단일-서버" class="headerlink" title="단일 서버"></a>단일 서버</h2><p><img src="https://user-images.githubusercontent.com/87690744/250348842-d230dc82-184b-4ea2-ac2c-b3e1d765b54c.png" alt="Untitled"></p><ol><li>클라이언트가 도메인 이름으로 요청을 날릴 때 DNS를 통해 도메인 주소를 통해 웹 서버의 IP 주소를 얻을 수 있다.</li><li>클라이언트는 IP 주소로 HTTP 요청을 날린다.</li><li>웹 서버는 요청을 처리할 때 필요한 경우 데이터베이스에게 쿼리를 실행하도록 한다.</li><li>요청의 결과를 클라이언트에게 응답한다.</li></ol><h3 id="어떤-데이터베이스를-사용하나"><a href="#어떤-데이터베이스를-사용하나" class="headerlink" title="어떤 데이터베이스를 사용하나?"></a>어떤 데이터베이스를 사용하나?</h3><p>RDB(관계형 DB)와 NoSQL(비관계형 DB)로 나뉜다.</p><p>RDB는 테이블 단위로 데이터를 관리하고, 조인을 활용해서 다른 테이블의 자료를 같이 조회해올 수 있다.</p><p>NoSQL은 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나뉘는데 조인 연산을 지원하지 않는다.</p><h3 id="수직적-규모-확장-VS-수평적-규모-확장"><a href="#수직적-규모-확장-VS-수평적-규모-확장" class="headerlink" title="수직적 규모 확장 VS 수평적 규모 확장"></a>수직적 규모 확장 VS 수평적 규모 확장</h3><p>스케일업은 서버를 더 고사양으로 되도록 램이나 더 좋은 CPU를 교체하는 행위이다. 반면 스케일아웃은 서버를 더많이 추가하여 서비스의 수행력을 높이는 행위다.</p><p>하지만 각 방법의 장단점이 있다.</p><ul><li>수직적 확장은 한계가 있다. 아무리 돈을 많이 써도 하나의 서버의 성능을 무한대로 높일 수 있다.</li><li>수직적 확장은 적은 서버를 운영하게 된다. 장애에 대한 자동복구(Fail over)나 다중화가 되지않아 불리하다.</li></ul><h2 id="다중-서버"><a href="#다중-서버" class="headerlink" title="다중 서버"></a>다중 서버</h2><p><img src="https://user-images.githubusercontent.com/87690744/250348838-8be0d21d-b09e-4401-bb1a-6ae0b9477d9a.png" alt="Untitled"></p><p>이번엔 웹 서버를 스케일아웃한 예시이다. DNS를 통해 로드밸런서의 IP 주소를 얻어낸다. 로드밸런서는 요청을 웹서버들에게 나눠줘서 처리하도록 한다. 다만 웹 서버의 IP는 private IP로 같은 네트워크에 속한 서버 사이 통신에만 사용된다. private IP는 외부 인터넷에서 접속할 수 없다. 이제 웹 서버 하나가 운영할 수 없게 되더라도 다른 웹 서버가 트래픽을 처리할 수 있다.</p><h3 id="데이터베이스-다중화"><a href="#데이터베이스-다중화" class="headerlink" title="데이터베이스 다중화"></a>데이터베이스 다중화</h3><p>데이터베이스 다중화는 주-부 관계(master-slave)를 통해 이뤄진다. 주 데이터베이스에는 원본을 저장하고 부 데이터베이스에는 사본을 저장한다.</p><p>쓰기 연산은 주 데이터베이스에서만 한다. 부 데이터베이스에서는 주 데이터베이스의 사본만 전달받으며, 읽기 연산만 한다.</p><p><img src="https://user-images.githubusercontent.com/87690744/250348835-c749c188-3dd8-4585-9609-6667c9e99a38.png" alt="Untitled"></p><p>데이터베이스 다중화는 다음과 같은 장점이 있다.</p><ul><li>성능 향상 : 읽기 연산을 여러 데이터베이스에서 나눠서 진행해서 성능이 더 올라갈 수 있다.</li><li>안정성 : 데이터베이스 하나가 작동하지 않아도 다른 데이터베이스의 존재 때문에 데이터가 보존된다.</li><li>가용성 : 데이터베이스 하나가 작동하지 않아도 다른 데이터베이스가 트래픽을 소화할 수 있게 된다.</li></ul><h3 id="데이터베이스-다중화-환경의-가용성-시나리오"><a href="#데이터베이스-다중화-환경의-가용성-시나리오" class="headerlink" title="데이터베이스 다중화 환경의 가용성 시나리오"></a>데이터베이스 다중화 환경의 가용성 시나리오</h3><ul><li>부 데이터베이스가 하나 뿐인데 다운된 경우 : 읽기 연산을 주 데이터베이스가 한시적으로 처리한다. 그 동안 새로운 부 데이터베이스가 생성되어 대체한다.</li><li>주 데이터베이스가 다운된 경우 : 부 데이터베이스 중 하나가 주 데이터베이스가 되고 부 데이터베이스를 새로 추가한다. 다만 주 데이터베이스 역할을 하게 될 부 데이터베이스의 데이터 상태가 최신 상태가 아닌 경우가 있을 수 있다. 이 경우 복구 스크립트를 돌려서 최신 상태로 만들거나, 다중 마스터(Multi-masters)나 원형 다중화 방식을 도입하면 이런 상황을 대처할 수 있다.</li></ul><h1 id="응답-시간-latency-개선"><a href="#응답-시간-latency-개선" class="headerlink" title="응답 시간(latency) 개선"></a>응답 시간(latency) 개선</h1><h2 id="캐시"><a href="#캐시" class="headerlink" title="캐시"></a>캐시</h2><p>비싼 연산 결과나 자주 참조되는 데이터를 메모리에 두고 뒤이은 요청에 빠르게 처리하는 저장소.</p><h3 id="읽기-주도형-캐시-전략"><a href="#읽기-주도형-캐시-전략" class="headerlink" title="읽기 주도형 캐시 전략"></a>읽기 주도형 캐시 전략</h3><p>요청을 받으면 일단 해당 데이터를 찾아 보고 있으면 반환한다. 없으면 데이터베이스에서 조회해와서 캐시에 저장하고 반환한다.</p><h3 id="캐시-사용-시-유의할-점"><a href="#캐시-사용-시-유의할-점" class="headerlink" title="캐시 사용 시 유의할 점"></a>캐시 사용 시 유의할 점</h3><ul><li>데이터 갱신이 자주 일어나지 않지만 참조가 빈번하게 일어나는 경우 유리하다.</li><li>영속적으로 보관할 데이터를 캐시에 두지 말고 중요 데이터는 지속적 저장소(persistent data store)에 저장한다.</li><li>만료 정책을 정해둬야 한다. 너무 짧으면 데이터베이스 조회가 자주 일어난다. 너무 길면 캐시 데이터가 원본과 달라질 수 있다.</li><li>데이터 저장소 원본 갱신 연산과 캐시 갱신하는 연산이 단일 트랜잭션으로 처리 되지 않는 경우 일관성이 무너진다.</li><li>캐시 서버 한 대만 두면 SPOF가 된다. 캐시 서버는 여러개가 되어야 한다.</li><li>캐시 메모리 크기. 캐시 메모리가 너무 작으면 액세스 패턴에 따라 데이터가 캐시에서 밀려날 수 있다. 캐시 메모리를 과할당하면 데이터가 갑자기 늘어났을 때 메모리에서 밀려나는 상황을 막을 수 있다.</li><li>데이터 방출 정책. 캐시가 꽉 찬 경우 어떤 데이터를 내보내야 하는 지 정하는 방법이다. LRU(가장 마지막에 쓰인 데이터 빼기), LFU(가장 덜 빈번하게 쓰인 데이터 빼기), FIFO(가장 먼저 들어온 캐시 데이터를 내보내기)</li></ul><h3 id="콘텐츠-전송-네트워크-CDN"><a href="#콘텐츠-전송-네트워크-CDN" class="headerlink" title="콘텐츠 전송 네트워크 (CDN)"></a>콘텐츠 전송 네트워크 (CDN)</h3><p>정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크. 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등 정보에 기반해서 정적 콘텐츠를 캐싱한다.</p><p><img src="https://user-images.githubusercontent.com/87690744/250348832-ce153a03-f22e-4544-97d1-0d3f1e9b61a9.png" alt="Untitled"></p><ul><li>비용 : CDN을 통해 데이터가 들어나고 나가는 양에 따라 요금을 내게 된다.</li><li>적절한 만료 시한 설정 : 시의성 중요한 컨텐츠의 경우 만료 시점을 잘 정해야 한다.</li><li>CDN 장애에 대한 대처 : CDN 자체가 죽었을 경우 대응을 해야 한다. 만약 클라이언트에서 CDN으로 접근이 불가능한 경우 원본 서버로 바로 접근하도록 구현할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/87690744/250348830-4b9c2cd9-79e8-4c6b-9f5f-1e29d51187f3.png" alt="Untitled"></p><h1 id="무상태-웹-계층"><a href="#무상태-웹-계층" class="headerlink" title="무상태 웹 계층"></a>무상태 웹 계층</h1><p>웹 계층을 수평적으로 확장하기 위해서는 무상태로 유지해야 한다. 무상태는 서버에서 상태 정보를 저장하지 않는 모습을 의미한다.</p><h2 id="상태-정보-의존적인-아키텍처"><a href="#상태-정보-의존적인-아키텍처" class="headerlink" title="상태 정보 의존적인 아키텍처"></a>상태 정보 의존적인 아키텍처</h2><p><img src="https://user-images.githubusercontent.com/87690744/250348822-ffefc9e7-9e04-48c6-923c-c26f58050536.png" alt="Untitled"></p><p>각 서버가 클라이언트의 세션 정보를 저장하는 경우는 상태 정보에 의존적인 아키텍처이다. 이 경우 클라이언트가 기존에 요청하던 서버가 아닌 다른 서버로 요청할 경우 해당 서버에는 클라이언트의 세션 정보가 없어서 요청 처리에 문제가 생길 수 있다. 상태 정보 의존적인 아키텍처는 클라이언트가 통신하던 서버와만 계속 통신해야 하는 문제가 있다. 이 문제를 로드밸런서가 원래 소통하던 서버로 요청을 중개하는 sticky session 기능을 해줄 수 있으나 로드밸런서에 부담을 주게 된다.</p><h2 id="무상태-아키텍처"><a href="#무상태-아키텍처" class="headerlink" title="무상태 아키텍처"></a>무상태 아키텍처</h2><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/5e4dc4ae-978b-4f91-80d6-dcf760c524b5"></p><p>웹서버들이 공유해야 하는 세션 정보와 같은 내용을 공유 저장소로 모아두고 해당 데이터가 필요할 때마다 공유 저장서에서 데이터를 가져오도록 한다. 이렇게 각 서버들이 공유해야 할 정보를 공유 저장소로 모으면 서버들은 상태 데이터를 관리하지 않아도 되고, 클라이언트들도 어떤 서버에 요청하던지 상관 없게 된다.</p><h1 id="데이터-센터-아키텍처"><a href="#데이터-센터-아키텍처" class="headerlink" title="데이터 센터 아키텍처"></a>데이터 센터 아키텍처</h1><p>데이터 센터를 여러 지역마다 운영해서 사용자와 지리적으로 가까운 데이터 센터에 라우팅하는 방식의 아키텍처이다. 이 절차를 지리적 라우팅 (geoDNS-routing, geo-routing)이라고 한다.</p><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/bf8cb1b7-0516-4af4-9020-55e7843fb1f1" alt="Untitled"></p><p>이렇게 여러 데이터센터를 운영하면 다른 데이터 센터에 장애가 생겨도 다른 데이터 센터로 트래픽을 옮기면 장애에 대응할 수 있다.</p><p>다만 다중 트래픽센터 아키텍처는 다음과 같은 어려움이 있다.</p><ul><li>트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 효과적 방법을 찾아야 한다. GeoDNS는 사용자와 가장 가까운 데이터 센터로 트래픽을 보내도록 한다.</li><li>데이터 동기화 : 데이터 센터마다 별도의 데이터베이스를 사용하는 상황이면 다른 데이터센터의 데이터베이스에 기존의 데이터 센터의 데이터가 없을 수 있다. 데이터를 여러 데이터센터에 걸쳐 다중화하는 전략을 사용할 수 있다. (넷플릭스의 다중화 :<a href="https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b">https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b</a>)</li><li>테스트와 배포 : 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 여러 위치에서 테스트를 해야 한다.</li></ul><h1 id="메시지-큐"><a href="#메시지-큐" class="headerlink" title="메시지 큐"></a>메시지 큐</h1><p>시스템이 대규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여 독립적으로 확장해야 한다. 분리된 컴포넌트들의 통신을 지원한다. 메시지 큐는 메시지의 무손실(큐에 넣어두면 꺼내기 전까지 안전하게 보관된다.)을 보장하고 비동기적 통신을 지원하는 컴포넌트다. </p><p>메시지 큐 기본 아키텍처는 간단하다. 생산자(발행자, producer, publisher) 역할하는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다. 큐에는 소비자(구독자, consumer, subscriber)라 불리는 서비스가 연결되어 있다. 큐에 연결된 소비자가 메시지를 받아 그에 맞는 동작을 수행한다.</p><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/f737b3c0-b56b-488d-bdc1-b739891f9f4d" alt="Untitled"></p><p>메시지 큐를 사용하면 서비스 또는 서버 간 결합이 느슨해져서 규모 확장성을 안정적으로 확보할 수 있다. 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다. 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.</p><p>즉 일반적인 HTTP 통신으로 서비스 간 통신을 한다면, 클라이언트와 서버 중 한 쪽이라도 가용하지 않다면 해당 통신 내용은 실패하고 사라지게 된다. 메시지 큐는 한 쪽이 가용하지 않더라도 메시지가 사라지지 않는다.</p><h1 id="로그-메트릭-자동화"><a href="#로그-메트릭-자동화" class="headerlink" title="로그, 메트릭, 자동화"></a>로그, 메트릭, 자동화</h1><ul><li>로그 : 여러 서버에서 로그를 만들 때 이를 단일 서비스로 모아주면 편리하게 관리할 수 있다.</li><li>메트릭 : 메트릭은 시스템의 현재 상태를 나타내는 몇가지 지표를 의미한다.<br>호스트 단위 메트릭 : CPU, 메모리, 디스크 IO<br>종합 메트릭 : 데이터베이스 계층 성능, 캐시 계층 성능<br>핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문</li><li>자동화 : 생산성을 높이기 위한 자동화 도구를 활용할 수 있다. 지속적 통합을 자동화하면 코드를 검증을 자동화할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/87690744/250426454-635100f1-61aa-400d-8116-59183047dbe4.png" alt="Untitled"></p><h1 id="데이터베이스-규모-확장"><a href="#데이터베이스-규모-확장" class="headerlink" title="데이터베이스 규모 확장"></a>데이터베이스 규모 확장</h1><p>데이터 양이 많아지면 데이터베이스 부하도 증가한다. 데이터베이스를 증설할 방법에 대해 알아본다. 데이터베이스도 웹 서버 규모 확장과 동일하게, 수직적 확장(스케일 업)과 수평적 확장(스케일 아웃) 전략이 있다.</p><h3 id="샤딩"><a href="#샤딩" class="headerlink" title="샤딩"></a>샤딩</h3><p>샤딩은 데이터베이스를 작은 단위(샤드)로 분할하는 기술이다. 각 샤드는 같은 스키마를 쓰지만 보관되는 데이터 사이에 중복이 없다.</p><p>예를 들어 유저 테이블을 4개로 확장한다면, 유저 아이디를 4로 나눈 나머지 값에 따라 테이블에 나눠서 저장하면 중복 없이 샤딩할 수 있다.</p><p>다만 다음과 같은 부분을 고려해야 한다.</p><ul><li>재샤딩(resharding) : 데이터가 기존 샤드로 버틸 수 없을 때, 일부 샤드에 데이터가 지나치게 몰려서 가득 찰 때 샤드 키 계산하는 함수를 수정하여 데이터를 재배치시킬 수 있다. (안정 해시 기법을 활용하면 문제를 해결할 수 있다.)</li><li>유명인사 문제(핫스팟 키) : 특정 샤드에 질의가 집중되어 과부하가 걸리는 문제. 이 경우에는 자주 질의되는 데이터들을 한 샤드에 몰리지 않도록 하거나 샤드를 더 잘게 나눠야 한다.</li><li>조인과 비정규화 : 샤딩된 테이블들과 조인하기가 힘들다. 비정규화를 통해 하나의 테이블에서 질의할 수 있도록 하는 방법을 고민해야 한다.</li></ul><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul><li>웹 계층은 무상태 계층</li><li>모든 계층 다중화</li><li>가능한 많은 데이터 캐시</li><li>여러 데이터 센터 지원</li><li>정적 컨텐츠는 CDN을 통해 서비스</li><li>데이터 계층은 샤딩을 통해 규모 확장</li><li>각 계층은 독립적 서비스로 분할</li><li>시스템을 지속적으로 모니터링, 자동화 도구 활용</li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/07/02/systemDesign-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS Elastic Beanstalk에서 HTTPS 적용하기</title>
      <link>https://yangdongjue5510.github.io/2023/06/18/ebsHttps/</link>
      <guid>https://yangdongjue5510.github.io/2023/06/18/ebsHttps/</guid>
      <pubDate>Sun, 18 Jun 2023 05:20:06 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제-상황&quot;&gt;&lt;a href=&quot;#문제-상황&quot; class=&quot;headerlink&quot; title=&quot;문제 상황&quot;&gt;&lt;/a&gt;문제 상황&lt;/h1&gt;&lt;p&gt;광운대학교 미디어 기자재 대여 웹 서비스 프로젝트에서 AWS Elastic Beanstalk(이하 EBS</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h1><p>광운대학교 미디어 기자재 대여 웹 서비스 프로젝트에서 AWS Elastic Beanstalk(이하 EBS)를 활용해 CICD를 구현했다. 문제는 EBS를 활용한 인프라에서 HTTPS 프로토콜을 적용해야 하는 상황에서 발생했다. 우리 서비스의 EBS는 새 버전을 배포할 때 새로운 EC2를 생성해서 빌드된 파일을 배포하도록 했다. 보통 HTTPS 프로토콜은 서버 측에 인증서가 저장되어 있어야 한다. 매번 새로운 EC2를 생성하는 현 방식에서는 어떻게 매번 새롭게 서버(EC2)에 인증서를 설치해야 하는 걸까? 그리고 꼭 그래야 할까? 다른 방법은 없는 걸까?</p><h1 id="요구-사항"><a href="#요구-사항" class="headerlink" title="요구 사항"></a>요구 사항</h1><p>프론트에서 HTTPS로 백엔드와 통신해야 한다. 왜냐면 쿠키로 JSESSIONID를 주고 받아야 하는데 다른 오리진에서 설정한 쿠키가 요청에 포함되어 전달되려면 <code>SAME-SITE=NONE</code>, <code>SECURE=TRUE</code>이 설정되어야 한다. 이때 <code>SECURE=TRUE</code>로 설정하기 위해서는 HTTPS가 적용되어야 한다. 즉 백엔드에서 설정한 쿠키를 활용하기 위해서 프론트와 백엔드는 HTTPS로 통신해야 한다.</p><h3 id="쿠키의-SameSite-속성"><a href="#쿠키의-SameSite-속성" class="headerlink" title="쿠키의 SameSite 속성"></a>쿠키의 SameSite 속성</h3><p>쿠키가 어떤 상황에서만 전송될 수 있는지를 지정한다. CSRF와 쿠키를 통한 정보 유출을 막기 위해 도입됐다.</p><p>다음 값으로 SameSite를 설정한 쿠키는 특정 조건에 만족해야만 함께 전송된다.</p><ol><li>Strict : 현재 사이트와 동일한 출처(오리진)로 요청할 때만 쿠키가 전송된다.</li><li>Lax(기본값) : 현재 사이트에서 다른 오리진의 이미지를 로드하는 요청과 같은 경우에는 쿠키를 포함하지 않되, 현재 사이트에서 다른 링크로 이어지는 경우에는 요청에 포함된다.</li><li>None : 동일한 출처가 아니더라도 쿠키가 함께 전송된다. 이 경우에는 <code>Secure</code>가 포함되어야 한다.(즉, HTTPS가 적용되어야 한다.)</li></ol><h1 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h1><p>일단 AWS 공식문서에 내가 하고 있는 고민에 대해 설명하고 있다.</p><p><a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https.html">Configuring HTTPS for your Elastic Beanstalk environment</a></p><p>위 문서에 따르면 EBS 환경에 가장 쉽게 HTTPS를 사용하는 방법은 로드밸런서에 서버 인증서를 할당하는 것이라 한다. EBS는 로드밸런서가 일종의 프록시처럼 백엔드의 서버 인스턴스들을 프론트엔드에 노출시키지 않고 소통한다. 즉 프론트엔드와 백엔드가 HTTPS 통신하려면 로드밸런서에 서버 인증서를 할당하여 프론트엔드와 HTTPS 통신하도록 하고, 로드밸런서 뒷편의 EC2들은 HTTP로 통신함으로써 서버 인스턴스에 추가적인 설정을 하지 않아도 요구사항을 충족할 수 있게 된다.</p><p>로드밸런서에 서버 인증서를 할당할 때는 AWS Certificate Manager를 활용하는 것이 쉽다. ACM은 AWS 서비스 및 연결된 리소스에 SSL&#x2F;TLS 인증서를 관리해주는 서비스다. AWS의 리소스를 사용하고 있다면 별도의 비용을 지불하지 않고도 쉽게 인증서를 발급받아 사용할 수 있다.</p><h1 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h1><h2 id="도메인-레코드-설정하기"><a href="#도메인-레코드-설정하기" class="headerlink" title="도메인 레코드 설정하기"></a>도메인 레코드 설정하기</h2><p>나는 <code>kwmedialab.com</code>을 가비아를 통해 구입해놨었다. 이제 프론트가 백엔드와 통신할 도메인을 도메인 레코드를 통해 추가해본다.</p><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/3db090d6-2974-4bf2-aa6c-a49d50eb3ad2"></p><p>여기서 <code>CNAME</code> 타입으로 백엔드 도메인을 서브 도메인으로 추가했다. <code>값/위치</code>에 실제 연결되는 주소를 적어주면 된다. 우리의 경우는 EBS 환경의 주소를 넣어주면 된다. (참고로 EBS 환경의 주소는 로드밸런서 주소의 도메인 주소이다.)</p><h2 id="ACM을-통해-인증서-발급하기"><a href="#ACM을-통해-인증서-발급하기" class="headerlink" title="ACM을 통해 인증서 발급하기"></a>ACM을 통해 인증서 발급하기</h2><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/5f555def-7f5d-4f3a-9743-43119bd36637"><br>ACM을 들어가면 다음과 같이 인증서 요청 버튼이 있다. 눌러준다.</p><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/3edf1e46-08f1-4775-829a-bb0b619337cc"><br>인증서 유형은 퍼블릭 인증서를 요청한다.</p><p><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/5b190934-1041-4cd9-a626-8cf1d7ffce15"><br>완전히 정규화된 도메인 이름(즉 우리의 경우에는 <code>back-dev.kwmedialab.com</code>)을 입력해주고 아래는 사진과 동일하게 한다.<br>검증이 이뤄지고 나면 인증서 발급된다.</p><h2 id="로드밸런서에-인증서-할당하고-포트-포워딩-설정"><a href="#로드밸런서에-인증서-할당하고-포트-포워딩-설정" class="headerlink" title="로드밸런서에 인증서 할당하고 포트 포워딩 설정"></a>로드밸런서에 인증서 할당하고 포트 포워딩 설정</h2><p>이제 ACM에서 만든 인증서를 로드밸런서에 설정하고 포트 포워딩하도록 하자.<br>EBS의 환경에서 <code>구성</code> -&gt; <code>인스턴스 트래픽 및 크기 조정 구성</code> -&gt; <code>리스너</code> 로 가서 리스너를 추가하면 된다. HTTPS의 443포트로 HTTPS 프로토콜로 설정하고 SSL 인증서를 우리가 ACM에서 만든 인증서를 할당하면 된다.<br><img src="https://github.com/yangdongjue5510/yangdongjue5510.github.io/assets/87690744/9abb16c8-9100-4be7-b09e-c2fff89111ba"></p><p>이렇게 설정하고 <code>https://&#123;완전히 정규화된 도메인 주소&#125;</code>로 요청을 보내서 정상 작동을 확인하면 끝난다!</p><h1 id="더-나아가기"><a href="#더-나아가기" class="headerlink" title="더 나아가기"></a>더 나아가기</h1><p>현재의 방식은 주어진 요구 사항을 해결하기 위한 솔루션이다. 프론트엔드에서 백엔드의 로드밸런서까지만 HTTPS 통신할 수 있고 로드밸런서부터 서버 인스턴스까지는 HTTP 통신을 한다.</p><p>만약 서버 인스턴스까지 HTTP 통신을 하려면 인증서를 로드 밸런서가 아닌 EC2 서버에 할당해야 한다. 이 경우에는 EBS에서 <code>procfile</code>을 통해 매번 EC2가 새롭게 실행될 때마다 터미널에 실행할 명령어를 적어줄 수 있다. <code>procfile</code>을 통해 새 EC2에 인증서를 설치할 수 있다.</p><p>다만 이 솔루션은 배포 과정에서 인증서 설치 과정이 포함된다. 그래서 배포 시간이 더 길어질 수 있다.</p>]]></content:encoded>
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/06/18/ebsHttps/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드 서비스의 인증과 보안 (HTTPS)</title>
      <link>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/</link>
      <guid>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/</guid>
      <pubDate>Sun, 07 May 2023 09:26:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h1&gt;&lt;p&gt;API와 통신할 때 사용하는 프로토콜인 HTTP는 통신 내용을 평문으로 전달된다. 그래서 도청하면 내용을</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>API와 통신할 때 사용하는 프로토콜인 HTTP는 통신 내용을 평문으로 전달된다. 그래서 도청하면 내용을 그대로 알 수 있게 된다.<br>HTTPS는 통신 내용에 보안이 중요한 내용을 다룰 때 사용되는 기술이다. HTTP over SSL&#x2F;TLS이라는 의미다. HTTPS는 포트번호로 443을 사용한다.<br>SSL&#x2F;TLS는 OSI 참조모델에서 L4인 전송 계층에서 적용된다.</p><blockquote><p>SSL과 TLS<br>둘다 인터넷 상의 안전한 통신을 위한 프로토콜. SSL은 1990년대에 개발되었지만 3.0까지만 지원하고 보안 취약점이 많다. 그래서 SSL의 후속버전인 TLS이 1999년에 개발됐다. 현재는 TLS가 SSL의 대체제로 널리 사용된다.</p></blockquote><h2 id="인증서와-암호화-방식"><a href="#인증서와-암호화-방식" class="headerlink" title="인증서와 암호화 방식"></a>인증서와 암호화 방식</h2><p>HTTPS에는 인증서가 사용된다. 인증서는 크게 서버 인증서와 클라이언트 인증서로 분류된다. 기본적으로 HTTPS에서는 서버 인증서로 서버의 신원을 검증한다.<br>필요한 경우에는 클라이언트 신원을 검증하는 클라이언트 인증서를 사용해서 보안 수준을 높일 수 있으나, 서버 인증서만 적용하는 게 일반적이다.<br>클라이언트 검증은 HTTP 헤더의 User-Agent 정보를 활용해서 알아내는 등 다양한 다른 방법으로 검증할 수 있다.</p><p>이런 인증서는 인증기관에서 발급한다.</p><h3 id="키"><a href="#키" class="headerlink" title="키"></a>키</h3><p>통신 내용을 암복호화 하려면 키가 필요하다. 키를 활용하는 방식은 공유 키 암호화 방식과 공개 키 암호화 방식이 있다.</p><p>**공유 키 암호화 방식(대칭키 암호화 방식)**은 하나의 키로 암호화와 복호화에 모두 사용하는 방식이다.<br>암호화와 복호화에 같은 키를 사용해서 속도가 빠르고 구조가 간단하다. 반면 하나의 키를 안전하게 보관해야 하는 부담이 있다.</p><p>**공개 키 암호화 방식(비대칭 암호화 방식)**은 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 방식이다.<br>공개 키는 누구나 알 수 있다. 하지만 비밀 키는 자신만 알 수 있게 한다.<br>공개 키로 암호화하면 비밀 키로 복호화 할 수 있다. 비밀 키로 암호화하면 공개 키로 복호화 할 수 있다.<br>공개 키 암호화 방식은 더 안전한 대신 공유 키 암호화 방식에 비해 느리다.</p><h3 id="HTTPS-암호화-방식"><a href="#HTTPS-암호화-방식" class="headerlink" title="HTTPS 암호화 방식"></a>HTTPS 암호화 방식</h3><p>HTTPS는 공유 키 암호화 방식과 공개 키 암호화 방식을 혼합해서 사용한다.<br>처음에 공유 키를 공개 키 암호화 방식으로 안전하게 전달하고, 전달된 공유 키로 빠르게 암호화 통신을 하게 된다.<br>구체적인 동작 과정에 대해 알아보자.</p><p><strong>1. 일단 웹 브라우저는 인증 기관들과 각 인증 기관들의 공개 키를 알고 있다.</strong></p><p>웹 브라우저는 인증 기관들과 각 인증 기관들의 공개 키를 알고 있다.<br>즉 웹 브라우저는 인증 기관들이 비밀 키로 암호화 한 내용을 복호화할 수 있고, 웹 브라우저가 암호화한 내용을 인증 기관이 복호화할 수 있다.<br>웹 브라우저들이 가지고 있는 인증 기관들의 공개 키는 인증 기관이 발급한 인증서를 복호화할 때 사용된다.</p><p><strong>2. 웹 서버는 인증기관으로부터 인증서를 발급받는다.</strong></p><p>웹 서버는 사이트 정보와 자신의 공개키를 인증기관에 전달하여 인증서를 발급받는다.<br>인증 기관은 사이트 정보와 사이트 공개키를 인증 기관의 개인 키로 암호화하여 인증서를 발급한다.</p><blockquote><p>인증 기관 (CA, Certificate Authority)<br>인증 기관은 공개키와 공개 DNS명의 연결을 보장한다. 웹 서버가 인증 기관으로 부터 서버 인증서를 발급받으려 할 때 사이트 정보와 자신의 개인키를 전달한다.<br>인증 기관은 자신의 개인 키로 웹사이트의 공개키를 암호학적으로 사인한 인증서를 만들어서 웹 서버에게 전달한다.<br>이제 인증 기관이 발급한 인증서는 웹 브라우저가 가진 인증 기관의 공개키로 복호화 할 수 있고, 인증서를 복호화하면 웹 서버의 개인키를 얻을 수 있게 된다.</p></blockquote><p><strong>3. 클라이언트와 웹서버에 접근하여 인증서를 검증하고 대칭키를 발급한다.</strong></p><p>클라이언트가 웹 서버에 통신하려고 할 때 SSL 핸드쉐이크를 진행한다.<br>이 과정에서 서로 암호화 알고리즘을 정하거나 인증 방시을 정한다.<br>또한 서버의 인증서를 전달받아서 브라우저가 인증 기관의 개인키로 복호화한다. 이를 통해 서버가 인증 기관이 검증한 서버임을 알 수 있고, 서버의 개인키를 얻을 수 있다.</p><p>그리고 클라이언트 측에서 데이터 암호화 복호화에 쓰일 대칭키를 정하고 서버의 개인키로 암호화해서 서버에게 알린다.<br>이제 대칭키로 클라이언트와 서버는 데이터를 암호화 복호화해서 주고 받게 된다.<br>세션이 종료되고 나면 대칭키를 폐기한다.</p><h1 id="사용자-그룹-롤-정책"><a href="#사용자-그룹-롤-정책" class="headerlink" title="사용자, 그룹, 롤, 정책"></a>사용자, 그룹, 롤, 정책</h1><p>클라우드에서 인증하는 단위와 권한 제어 방식에 대해 살펴보자.</p><h2 id="테넌트"><a href="#테넌트" class="headerlink" title="테넌트"></a>테넌트</h2><p>태넌트는 클라우드 서비스애서 최상위 개념이다. AWS에서는 어카운트가 테넌트 개념에 해당한다.<br>원착적으로 태넌트는 여러 태넌트애 걸쳐서 작업을 하지 못한다. 클라우드는 인증도 리소스의 일종이라 적어도 하나의 태넌트애 속한다.<br>하지만 예외적으로 여러 테넌트애 걸쳐서 인증하는 방법도 있다.</p><h2 id="사용자"><a href="#사용자" class="headerlink" title="사용자"></a>사용자</h2><p>클라우드에서는 API를 실행하게 하는 액터가 존재한다. 액터는 즉 사용자를 의미한다.<br>클라우드에서는 사용자도 리소스의 종류로 취급한다.<br>처음 클라우드를 구성할 때는 리소스가 존재하지 않으므로 사용자도 없다. 대신 클라우드에는 테넌트에 연결된 특별한 관리자 계정이 있다.<br>이 관리자 계정을 사용자처럼 사용해서 리소스를 생성한다. 관리자 계정은 막강한 권한이 있어서 운영 시에는 일반적으로 사용하지 않는다.</p><p>관리자 계정으로 사용자를 만들고 권한을 할당해서 사용하도록 한다. 권한을 할당하려면 정책을 생성하고 사용자에게 할당해야 한다.</p><h2 id="그룹과-정책"><a href="#그룹과-정책" class="headerlink" title="그룹과 정책"></a>그룹과 정책</h2><p>클라우드에는 사용자를 그룹으로 묶을 수 있다. 그룹 단위로 정책을 할당하여 많은 사용자를 쉽게 관리할 수 있다.<br>정책은 권한을 제어할 때 사용하는 기능이다. 클라우드 리소스 중 통제가 필요한 대상에 정책으로 접근이나 실행을 제한할 수 있다.<br>정책은 액션과 리소스의 집합체에 대해 이펙트를 허가하거나 거부하는 방식으로 JSON 형식으로 나열한다.</p><h3 id="AWS-IAM-정책의-기본-요소"><a href="#AWS-IAM-정책의-기본-요소" class="headerlink" title="AWS IAM 정책의 기본 요소"></a>AWS IAM 정책의 기본 요소</h3><ul><li>이펙트 : 허가하면 ‘Allow’, 거부는 ‘Deny’로 표현</li><li>액션 : 허가 혹은 거부할 액션 API를 기재</li><li>리소스 : 허가하거나 거부할 리소스를 ARN 형식으로 기재. (ARN은 아마존 리소스 이름 형식.)</li></ul><p>정책에 정해지지 않은 것은 묵시적인 거부로 판단한다. 만약 하나의 액션이나 리소스에 여러 이펙트가 정의되면 다음 우선순위로 적용한다.<br><code>명시적인 Deny &gt; 명시적인 Allow &gt; 묵시적인 Deny</code></p><p>그 외 정책 규칙은 다음 문서를 참고하자. (<a href="https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/reference_policies_grammar.html">https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/reference_policies_grammar.html</a>)<br>JSON으로 일일히 작성하기 까다로우니 Policy Generator를 사용하고, 실제로 잘 작동하는지 확인할 때 Policy Simulator를 사용할 수 있다.</p><h2 id="인증-키와-토큰"><a href="#인증-키와-토큰" class="headerlink" title="인증 키와 토큰"></a>인증 키와 토큰</h2><h3 id="인증-키"><a href="#인증-키" class="headerlink" title="인증 키"></a>인증 키</h3><p>사용자가 인증하려면 ID와 패스워드에 해당하는 인증 키가 필요하다. AWS는 콘솔, API, CLI, SDK에 따라 인증 방식이 약간 다르다. 콘솔에서는 패스워드로 인증하고, 그외는 ID에 상응하는 액세스 키와 시크릿 액세스 키를 사용한다.</p><h3 id="토큰"><a href="#토큰" class="headerlink" title="토큰"></a>토큰</h3><p>설정 파일에 패스워드를 미리 넣어두거나, 헤더나 쿼리 파라미터로 패스워드를 전달하는 방식은 매우 위험하다. 그래서 유효 기간이 정해진 임시 비밀번호를 발급해서 사용하는 방식을 선택한다. 임시 비밀번호를 토큰이라고 한다.<br>일반적으로 사용자의 ID와 패스워드로 토큰을 발급받고 API호출할 때 사용한다. AWS는 STS라는 서비스가 임시 자격 증명 토큰 발급을 해준다. AWS는 토큰과 액세스 키(아이디)를 조합해서 API를 호출한다.<br>토큰은 임시 비밀번호 역할 뿐만 아니라 IAM 롤과 페더레이션에도 사용된다.</p><h3 id="서명"><a href="#서명" class="headerlink" title="서명"></a>서명</h3><p>클라이언트의 요청을 처리하기전에 클라이언트가 실존하는지, 전송된 데이터가 위변조되지는 않았는지 확인해야 한다. 이때 필요한 게 전자 서명이다.<br>CLI나 SDK는 내부적으로 이런 과정을 거치지만 API는 전자 서명에 의존할 수 밖에 없다.</p><p>전자 서명을 위해서는 요청 정보의 해시 값과 요청 값, 시크릿 액세스 키를 조합하여 만든다. 이때 사용되는 알고리즘은 SHA이고, 해시 값에따라 버전이 달라진다.<br>시크릿 액세스 키로부터 서명 키를 얻어내고, 본문 페이로드로부터 해시(서명 문자열)을 얻어낸다. 서명 키를 해시 키로 서명 문자열을 해시 처리하면 서명 값이 나온다.<br>서명 값을 HTTP 헤더의 Authorization에 설정되면 전자서명이 이뤄진다.</p><h2 id="IAM-롤과-리소스-기반-정책"><a href="#IAM-롤과-리소스-기반-정책" class="headerlink" title="IAM 롤과 리소스 기반 정책"></a>IAM 롤과 리소스 기반 정책</h2><p>정책인 기본적으로 사용자와 그룹에게 적용된다. 하지만 리소스 지향적인 관점으로 리소스에 정책을 할당할 수 있어야 한다.<br>이를 위해 AWS에서는 IAM롤과 리소스 기반 정책을 사용한다. IAM 롤은 리소스에게 정책을 부과한다. IAM 롤은 내부적으로 STS를 통해 토큰을 발행받아서 API를 실행할 때 다른 인증 키가 필요없다.<br>IAM 롤은 어떤 리스소가 특정 리소스에 대한 접근을 다루는 정책을 관리한다. 즉 API 호출하는 주체가 중점이 된다. 그래서 IAM 롤은 API 호출 주체에게 할당한다.<br>반면 리소스 기반 롤 정책은 관점이 다르다. 접근이 되는 대상이 중점이 된다. 즉 API 호출 대상이 중점이 된다. 이때 호출 대상을 호출하는 주체를 Principal이라는 이름으로 관리한다. 리소스 기반 롤 정책은 호출 대상 리소스에 할당한다.</p><h2 id="복수-테넌트에-대한-제어-권한"><a href="#복수-테넌트에-대한-제어-권한" class="headerlink" title="복수 테넌트에 대한 제어 권한"></a>복수 테넌트에 대한 제어 권한</h2><p>일반적으로 테넌트는 다른 테넌트와 분리되어 있다. AWS에서는 인증도 테넌트의 리소스에 속하므로 테넌트를 넘나드는 작업은 기본적으로 불가능하다.<br>하지만 정책을 통해 권한을 부여하면 테넌트를 넘나드는 작업이 가능하다.</p><p>일단 오픈스택에서는 여러 테넌트에 접근할 수 있는 사용자를 만들 수 있다. 다만 각 테넌트의 토큰이 서로에게 호환되지 않기 때문에 다른 테넌트의 리소스를 다룰때는 해당 테넌트의 토큰을 발급받아 사용해야 한다.<br>한편 AWS에서는 한 테넌트의 관리자 계정이 다른 테넌트의 리소스를 접근하지 못하는 게 일반적이다. 하지만 IAM 롤을 잘 활용하면 된다.<br>먼저 접근을 허용할 테넌트의 IAM 롤에 AssumeRole API에 대해 Principal에 접근할 테넌트의 어카운트 번호를 입력한다. 이러면 해당 테넌트가 일부 리소스에 대해 접근할 수 있게 된다.<br>하지만 당연히 제 3자의 접근을 막기 위해 Principal에서 접근을 허용할 테넌트의 정보만 적어줘야 한다.</p><h1 id="페더레이션"><a href="#페더레이션" class="headerlink" title="페더레이션"></a>페더레이션</h1><p>인증이 필요한 API를 사용할 때 인증을 다른 서비스의 계정에 권한을 위임하는 것을 페더레이션이라고 한다.<br>대표적으로 다른 SNS 계정으로 로그인 가능한 사이트들이 페더레이션을 사용한 예시다.</p><p>인증 권한을 위임받아서 처리하는 서비스를 ID 프로바이더라고 하고 또다른 ID를 사용하는 시스템과 상호 신뢰 관계를 맺어 통합 인증을 구현한다.</p><h3 id="대표적인-방법들"><a href="#대표적인-방법들" class="headerlink" title="대표적인 방법들"></a>대표적인 방법들</h3><p>통합 인증 방식은 SAML, OIDC, WebID로 구현할 수 있다.<br>SAML은 인증 인가에 필요한 정보등르 기술하는 마크업 언어다. SAML을 HTTP(HTTPS)로 주고받으면 통합 인증이 되는 방식이다. SAML의 메타 데이터는 클라우드 측에서 제공한다.<br>OIDC는 OAuth 2.0을 채용하여 웹 API를 통한 접근 제어하는 방법이다. </p><p>AWS에서는 ID 인증과 페더레이션 처리가 되어 인증 어썰션을 취득한다.<br>인증 어썰션을 기반으로 STS에서 토큰을 발급받아서 API를 실행할 수 있게 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>오케스트레이션</title>
      <link>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/</link>
      <guid>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/</guid>
      <pubDate>Wed, 05 Apr 2023 11:35:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오케스트레이션과-오토메이션&quot;&gt;&lt;a href=&quot;#오케스트레이션과-오토메이션&quot; class=&quot;headerlink&quot; title=&quot;오케스트레이션과 오토메이션&quot;&gt;&lt;/a&gt;오케스트레이션과 오토메이션&lt;/h1&gt;&lt;p&gt;데브옵스 관점에서 오케스트레이션은 &lt;co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오케스트레이션과-오토메이션"><a href="#오케스트레이션과-오토메이션" class="headerlink" title="오케스트레이션과 오토메이션"></a>오케스트레이션과 오토메이션</h1><p>데브옵스 관점에서 오케스트레이션은 <code>소프트웨어 개발의 자동화를 위해 태스크를 만드는 작업</code>이다.<br>데브옵스 관점에서 오토메이션은 <code>CI 툴을 사용해서 빌드나 소스 코드 정적 검사를 자동화하는 작업</code>이다.</p><p>일반적으로 오케스트레이션 및 오토메이션의 접근 방법은 두가지로 나뉜다.</p><ul><li>프로그래밍 언어처럼 애플리케이션 설치나 설정 순서를 열거하고 절차형 툴을 통해 자동화</li><li>애플리케이션에 최적화된 인프라 상태를 템플릿 형태로 정의하고 이를 관리하는 선언형 기능 사용</li></ul><p>절차형 툴은 앤서블 등이 대표적이다. 절차형 툴은 구성 정보나 설정 정보를 관리하는 서버와 설정을 적용하는 클라이언트로 나뉜다. 서버가 클라이언트의 상태를 모니터링하면서 원하는 상태로 유지되도록 관리한다.<br>선언형 툴은 AWS CloudFormation이 있다. 시스템 리소스들을 하나의 템플릿으로 정의하고 이 템플릿으로 인프라의 프로비저닝을 한다.</p><blockquote><p>절차형 툴과 선언형 툴의 작용 범위<br>절차형 툴과 선연형 툴의 작용 범위가 다르다.<br>선언형 툴은 네트워크 및 블록 스토리지를 준비하고 이미지를 사용한 서버를 기동하는 등 인프라 리소스를 구성할 때 주로 사용된다.<br>절차형 툴은 선언형 툴이 구성한 클라우드 리소스 위에 OS를 설치하고 어플리케이션을 설치할 때 주로 사용된다.<br>이 차이를 잘 알고 충돌하지 않도록 툴을 사용해야 한다.</p></blockquote><h2 id="오케스트레이션과-리소스-집합체의-기본-사상"><a href="#오케스트레이션과-리소스-집합체의-기본-사상" class="headerlink" title="오케스트레이션과 리소스 집합체의 기본 사상"></a>오케스트레이션과 리소스 집합체의 기본 사상</h2><p>클라우드 리소스를 관리할 때 REST API를 활용해서 제어해도 된다. 문제는 관리할 리소스가 매우 많아지거나 의존성 때문에 API 호출 순서가 복잡해지면 리소스 관리가 어려워진다. 그래서 리소스를 그룹으로 묶어서 관리하는 상황에 이르게 된다.<br>오케스트레이션은 궁극적으로 리소스의 집합체를 정의하는 기술이다. 오케스트레이션은 액션에 해당하는 API로 처리하는 방식에서 리소스 그룹으로 처리하는 방식으로 전환함을 의미한다. 리소스의 집합체를 <code>스택</code>으로 지칭하며 스택을 활용하면 개별 리소스마다 액션에 해당하는 API 호출보다 훨씬 적은 API 호출로 다수의 리소스를 관리할 수 있다.</p><h2 id="오케스트레이션의-근간인-템플릿"><a href="#오케스트레이션의-근간인-템플릿" class="headerlink" title="오케스트레이션의 근간인 템플릿"></a>오케스트레이션의 근간인 템플릿</h2><p>템플릿은 리소스를 정의하는 역할을 한다. 템플릿은 클라우드 서비스마다 상이하다. 다만 몇 가지는 공통된다. 리소스, 파라미터, 아웃풋이 공통된다.</p><h3 id="리소스"><a href="#리소스" class="headerlink" title="리소스"></a>리소스</h3><p>템플릿이 오케스트레이션의 근간이면, 리소스는 템플릿의 근간이다. 템플릿에는 다수의 리소스를 정의할 수 있다. 리소스의 이름, 타입, 프로퍼티를 통해 리소스에 대한 정보를 정할 수 있고, 필요하면 다른 리소스와 의존관계를 표현해서 리소스 간 순서를 제어할 수도 있다.(AWS CloudFormation에서 <code>DependsOn</code>) 다른 리소스의 속성 정보를 참조하는 <code>Ref</code>도 활용할 수 있다.</p><p>다음은 시큐리티 그룹에 속한 EC2 인스턴스를 정의하는 AWS CloudFormation의 리소스 부분이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;EC2Instance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;InstanceType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceType&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SecurityGroups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceSecurityGroup&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;KeyName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KeyName&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ImageId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;AWSRegionArch2AMI&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::Region&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;AWSInstanceType2Arch&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceType&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;Arch&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="attr">&quot;InstanceSecurityGroup&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::SecurityGroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;GroupDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable SSH access via port 22&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SecurityGroupIngress&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;IpProtocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;FromPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ToPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;CidrIp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SSHLocation&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="파라미터"><a href="#파라미터" class="headerlink" title="파라미터"></a>파라미터</h3><p>템플릿의 리소스와 프로퍼티 값이 고정되어 있으면 템플릿을 특정 설정에만 사용할 수 있게 된다. 즉 재사용이 안된다. 이를 대응하는 부분이 파라미터다. 파라미터는 템플릿의 가변적인 정보를 입력할 수 있는 부분이다. 파라미터를 통해 템플릿 재사용성을 높일 수 있다.</p><p>파라미터로 입력된 값을 사용하려면 앞서 리소스에서 언급한 <code>Ref</code>로 파라미터의 이름을 입력하면 된다.</p><p>다음은 시큐리티 그룹에 속하는 EC2 인스턴스를 만드는 AWS CloudFormation의 템플릿 중 파라미터 부분이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;KeyName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Name of an existing EC2 KeyPair to enable SSH access to the instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::KeyPair::KeyName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be the name of an existing EC2 KeyPair.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;InstanceType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebServer EC2 instance type&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t2.small&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;AllowedValues&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;t1.micro&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">//...생략</span></span><br><span class="line">      <span class="string">&quot;cg1.4xlarge&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be a valid EC2 instance type.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;SSHLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The IP address range that can be used to SSH to the EC2 instances&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MinLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MaxLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;AllowedPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)/(\\d&#123;1,2&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be a valid IP CIDR range of the form x.x.x.x/x.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="아웃풋"><a href="#아웃풋" class="headerlink" title="아웃풋"></a>아웃풋</h3><p>템플릿 처리 과정에서 출력하는 내용을 다룬다.</p><p><code>Fn::GetAtt</code>로 리소스의 프로퍼티 정보를 직접 인용할 수 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;InstanceId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceId of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EC2Instance&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AZ&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Availability Zone of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;AvailabilityZone&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PublicDNS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Public DNSName of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;PublicDnsName&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PublicIP&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Public IP address of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;PublicIp&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>템플릿을 어느 세월에 다만드냐..?<br>일일히 템플릿을 작성하는게 부담되는 경우, 이미 존재하는 리소스를 기반으로 템플릿을 생성할 수 있다.(AWS CloudFormer)</p></blockquote><h1 id="오케스트레이션의-장점"><a href="#오케스트레이션의-장점" class="headerlink" title="오케스트레이션의 장점"></a>오케스트레이션의 장점</h1><h2 id="인프라-환경-구축-단계-관점"><a href="#인프라-환경-구축-단계-관점" class="headerlink" title="인프라 환경 구축 단계 관점"></a>인프라 환경 구축 단계 관점</h2><p>서버, 네트워크, 스토리지를 생성할 때 웹 콘솔을 사용하던지 API를 조합한 CLI를 실행하던지 SDK를 활용한 프로그램을 사용할 수 있다. 다만 이런 방법들은 리소스 종류가 달라지면 수정해줘야 한다.</p><p>오케스트레이션은 템플릿으로 리소스 관계 및 상태를 정의할 수 있게 돕고, 오케스트레이션 엔진이 리소스 배치와 시스템 상태 유지를 자동으로 지원한다.<br>관리자는 리소스마다 상태 확인할 필요 없이 각 스택의 상태를 확인하면 된다. 그리고 템플릿의 상한 값 설정으로 잘못된 값 입력을 방지할 수 있다.</p><h2 id="인프라-환경-운영-단계-관점"><a href="#인프라-환경-운영-단계-관점" class="headerlink" title="인프라 환경 운영 단계 관점"></a>인프라 환경 운영 단계 관점</h2><p>리소스가 생성되고 나서도 오케스트레이션의 장점이 있다. 먼저 리소스 간 의존 관계를 정의해서 리소스 기동 순서를 제어할 수 있다.<br>또한 오토스케일링과 오토 힐링도 구현할 수 있다. 감시서버를 두고 로드 밸런서가 장애를 통보하면 이를 오케스트레이션 API를 통해 오케스트레이션 엔진에게 알려주고 오케스트레이션 엔진이 서버 API를 통해 리소스를 다시 기동하거나 리소스를 추가하는 방식으로 대응할 수 있다. (오토 힐링과 오토스케일링은 굳이 오케스트레이션이 아니어도 가능하다.)</p><h2 id="재사용-템플릿을-활용한-환경-복제-방식-관점"><a href="#재사용-템플릿을-활용한-환경-복제-방식-관점" class="headerlink" title="재사용 템플릿을 활용한 환경 복제 방식 관점"></a>재사용 템플릿을 활용한 환경 복제 방식 관점</h2><p>오케스트레이션은 템플릿을 통해 동일한 인프라 환경 구성을 빠르게 복제할 수 있다. 특히 파라미터를 통해 하나의 템플릿도 동적으로 변화를 줄 수 있다. 예를 들면 어떤 검증을 해야 할 때 하나의 템플릿을 파라미터를 다르게 해서 여러 환경을 만들어서 병렬로 검증을 해볼 수 있다. 또한 리전 정보를 파라미터로 전달하면 특정 리전에 속한 리소스에 문제가 생겼을 경우, 빠르게 파라미터를 바꾸서 새로운 인프라를 구축해서 활용할 수 있다.</p><h2 id="오케스트레이션을-활용한-지속적-통합-관점"><a href="#오케스트레이션을-활용한-지속적-통합-관점" class="headerlink" title="오케스트레이션을 활용한 지속적 통합 관점"></a>오케스트레이션을 활용한 지속적 통합 관점</h2><p>기존의 지속적 통합은 특정 환경에 애플리케이션을 배포하는 용도로 많이 사용했다. 애플리케이션의 변경 사항만 반영해서 릴리즈하고 서버, 스토리지, 네트워크의 구성 변경에는 관여하지 않았다. 하지만 클라우드 환경에서는 오케스트레이션 기능으로 인프라도 코드처럼 제어할 수 있다. 즉 CI 작업에 인프라 변경도 포한할 수 있게 됐다. 스택에 인프라 환경 뿐만 아니라 애플리케이션을 함께 정의하는 방식으로 구현한다.</p><h1 id="오케스트레이션의-주의사항"><a href="#오케스트레이션의-주의사항" class="headerlink" title="오케스트레이션의 주의사항"></a>오케스트레이션의 주의사항</h1><h2 id="스택으로-생성한-리소스는-개별-액션-API로-변경하지-않는다"><a href="#스택으로-생성한-리소스는-개별-액션-API로-변경하지-않는다" class="headerlink" title="스택으로 생성한 리소스는 개별 액션 API로 변경하지 않는다."></a>스택으로 생성한 리소스는 개별 액션 API로 변경하지 않는다.</h2><p>스택으로 생성한 리소스, 즉 오케스트레이션 API로 관리하는 리소스를 개별 액션 API로 변경하면 안된다. 왜냐면 개별 액션 API로 스택 내부의 리소스를 변경하면 템플릿 설정 내용과 변경된 상태에 차이가 생겨 정합성이 깨지게 된다. 그렇다고 사소한 작업 모두 오케스트레이션 API를 활용하면 더 느리고 번거로울 수 있다. 그래서 현업에서는 오케스트레이션 API로 관리되는 리소스와 그렇지 않은 리소스를 나눠서 관리하곤 한다.</p><h2 id="스택-반영-후-각-리소스에-정상-반영됐는-지-확인한다"><a href="#스택-반영-후-각-리소스에-정상-반영됐는-지-확인한다" class="headerlink" title="스택 반영 후 각 리소스에 정상 반영됐는 지 확인한다."></a>스택 반영 후 각 리소스에 정상 반영됐는 지 확인한다.</h2><p>오케스트레이션에는 스택을 갱신하는 기능이 있다. 이 작업을 통해 리소스에 정상 반영됐는 지 모니터링 해야 한다. 특히 일부 리소스는 갱신하는 과정에서 일정 시간동안 서비스를 하지 못하는 다운 타임이 발생할 수 있다. (AWS에서는 <code>Update requires: Replacement</code>로 표시된 리소스가 해당) 이런 경우, 스택을 따로 만들어놓고 바꿔치는 이뮤터블 인프라 스터럭처를 고려해본다.</p><h2 id="오케스트레이션-기능을-지원하지-않는-컴포넌트나-리소스를-미리-식별한다"><a href="#오케스트레이션-기능을-지원하지-않는-컴포넌트나-리소스를-미리-식별한다" class="headerlink" title="오케스트레이션 기능을 지원하지 않는 컴포넌트나 리소스를 미리 식별한다."></a>오케스트레이션 기능을 지원하지 않는 컴포넌트나 리소스를 미리 식별한다.</h2><p>내가 사용할 리소스가 오케스트레이션으로 지원하지 않으면 당연히 문제가 된다. 이를 미리 파악하고 사용하자.</p><h2 id="스택과-템플릿의-적정-크기와-스택-중첩"><a href="#스택과-템플릿의-적정-크기와-스택-중첩" class="headerlink" title="스택과 템플릿의 적정 크기와 스택 중첩"></a>스택과 템플릿의 적정 크기와 스택 중첩</h2><p>한 스택에서 관리하는 리소스의 갯수가 점점 늘어나고 리소스마다 릴리즈의 빈도나 서비스 수준이 달라질 수 있다. 이러면 스택을 분리해야 한다.<br>일반적으로 스택 분리는 공통 요소와 서브 시스템으로 나눈다. 서브 시스템으로 분리하면 서로 의존도가 낮아지고 릴리즈가 더 빨라진다.<br>공통 요소는 AWS CloudFormation에서 다음 예시들이 해당한다.</p><ul><li>공통 운영 서비스</li><li>네트워크(VPC)</li><li>인증(IAM)</li><li>프론트엔드(DMZ)</li><li>데이터스토어(DB, Storage)</li></ul><p>이렇게 스택을 여러개로 나누면 스택 사이의 정보 전달이 필요할 수 있다. 이럴 때 쓰이는게 파라미터와 아웃풋이다. 한 스택의 아웃풋을 다른 스택의 파라미터로 활용하여 분리된 스택이 서로 소통할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드에서 네트워크 리소스를 제어하는 방법</title>
      <link>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/</link>
      <guid>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/</guid>
      <pubDate>Tue, 04 Apr 2023 11:58:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;네트워크-리소스의-기본&quot;&gt;&lt;a href=&quot;#네트워크-리소스의-기본&quot; class=&quot;headerlink&quot; title=&quot;네트워크 리소스의 기본&quot;&gt;&lt;/a&gt;네트워크 리소스의 기본&lt;/h1&gt;&lt;p&gt;네트워크의 기능은 크게 L2 네트워크(OSI 참조 모델</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="네트워크-리소스의-기본"><a href="#네트워크-리소스의-기본" class="headerlink" title="네트워크 리소스의 기본"></a>네트워크 리소스의 기본</h1><p>네트워크의 기능은 크게 L2 네트워크(OSI 참조 모델의 데이터링크 계층)과 L3 네트워크(OSI 참조 모델의 네트워크)로 나눠볼 수 있다.<br>L2 네트워크는 같은 네트워크에 속한 장비를 연결한다. 대표적으로 스위치가 이런 역할을 한다.<br>L3 네트워크는 서로 다른 L2 네트워크를 연결한다. 대표적으로 라우터가 이런 역할을 한다.</p><p>네트워크에서 중요한 포인트는 IP 주소를 잘 다루느냐이다. 클라우드 환경에서는 IP 관리를 기본으로 포함하는 경우가 많다. 클라우드 환경에서는 IP 주소를 DHCP를 통해 할당된다. 다만 클라우드 환경에서는 DNS 확장성이나 오토 스케일링, 오토 힐링 같은 기능을 이용하기 위해서 IP 주소에 종속되지 않도록 해야 한다.</p><h1 id="클라우드-환경의-네트워크-리소스"><a href="#클라우드-환경의-네트워크-리소스" class="headerlink" title="클라우드 환경의 네트워크 리소스"></a>클라우드 환경의 네트워크 리소스</h1><table><thead><tr><th>네트워크 리소스</th><th>AWS VPC</th><th>오픈스택 Neutron</th></tr></thead><tbody><tr><td>네트워크 전체</td><td>없음</td><td>VPC</td></tr><tr><td>스위치</td><td>네트워크</td><td>(서브넷에 포함)</td></tr><tr><td>서브넷</td><td>서브넷</td><td>서브넷</td></tr><tr><td>라우터</td><td>라우터</td><td>게이트웨이, 라우팅 테이블</td></tr><tr><td>포트</td><td>포트</td><td>ENI</td></tr><tr><td>시큐리티 그룹</td><td>시큐리티 그룹</td><td>시큐리티 그룹</td></tr><tr><td>네트워크 접근 제어</td><td>Fwaas</td><td>NACL</td></tr></tbody></table><p>AWS는 한 테넌트가 여러 VPC를 생성할 수 있지만, 오픈스택은 한 테넌트는 하나의 가상 네트워크만 만들 수 있다.<br>두 서비스 모두 가상 네트워크별로 가상 라우터를 배치한다.</p><h1 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h1><p>가상 스위치는 L2 네트워크 기능을 수행한다. 가상 스위치에 연결된 가상 서버는 별도의 라우팅 없이 서로 통신할 수 있다.<br>가상 스위치는 L3 네트워크에서 쓰이는 IP 주소 범위(CIDR)를 서브넷이라는 이름으로 할당 받는다! 서브넷 범위 내의 IP를 사용자가 자유롭게 할당할 수 있다.<br>클라우드 환경에서는 네트워크끼리 직접 연결되어 있지 않으면 같은 IP 주소를 써도 된다. 다만 공인 IP와 중복되지 않도록 사설 IP 주소의 범위에서 할당되는 게 일반적이다.</p><p>AWS VPC에서는 가상 스위치에 대응하는 리소스가 없다. 대신 서브넷에서 가상 스위치의 개념과 기능을 한다. 대부분 가상 스위치와 서브넷이 1대1 관계이고 TCP&#x2F;IP를 사용할 때는 서브넷만 정의해도 충분하기 때문이다.</p><p>IP 주소 범위는 두단계로 지정된다. VPC를 생성할 때 정하고, VPC의 IP 범위 안에서 서브넷에서 사용할 범위를 정할 수 있다. VPC는 한번 할당받은 IP주소 범위를 수정할 수 없기 때문에 애초에 여유있게 정할 필요가 있다.</p><p><img src="https://user-images.githubusercontent.com/87690744/229852310-21903512-9800-4e96-9162-152881101a62.png"></p><h2 id="서브넷"><a href="#서브넷" class="headerlink" title="서브넷"></a>서브넷</h2><p>서브넷에 연결된 서버는 기동 시 DHCP를 통해 IP 주소를 할당받고 그 IP 주소로 통신하게 된다. 다만 DHCP로 IP 주소를 받는다고 해서 매번 기동할 때마다 다른 주소를 받는게 아니다. 이미 IP 주소가 할당된 것을 DHCP가 전달할 뿐이다. 그래서 한번 기동한 서버를 여러번 재기동해도 같은 IP 주소가 부여된다.</p><p>서브넷은 할당된 IP 주소에만 통신을 허용한다. 그래서 사용자가 임의로 IP 주소 설정을 바꿔도 변경된 IP 주소로 통신하지 못한다.</p><p>서브넷은 해당 범위 안에서 통신할 수 있는 폐쇄적인 환경이라 다른 사람의 서브넷이나 IP주소가 중복되도 상관없다.</p><h3 id="IP-주소의-범위-CIDR"><a href="#IP-주소의-범위-CIDR" class="headerlink" title="IP 주소의 범위 (CIDR)"></a>IP 주소의 범위 (CIDR)</h3><p>서브넷을 생성할 때 지정하는 IP 주소 범위를 CIDR(사이더)라고 한다. Classless Inter Domain Routing을 줄인 말으로 직역하면 ‘클래스가 없는 내부 도메인 라우팅’이다.</p><p>CIDR은 IP 주소를 서브넷을 식별하는 네트워크 부분과 서브넷 안에서 개별 통신 장비를 식별하는 호스트 부분으로 나눈다. 그리고 네트워크 부분의 비트 길이를 서브넷 마스크로 표현한다.</p><p>인터넷 초창기에는 IP 주소의 상위 비트 값에 따라 서브넷 마스크가 결정됐다.<br>0으로 시작하면 서브넷 마스크가 8비트로 클래스 A로 부른다. 대략 1600만개 주소가 가능하다.<br>128으로 시작하면 서브넷 마스크가 16비트로 클래스 B로 부른다. 대략 65000개 주소가 가능하다.<br>223으로 시작하면 서브넷 마스크가 24비트로 클래스 C로 부른다. 대략 256개 주소가 가능하다.<br>하지만 1600만개 주소가 필요한 서브넷은 별로 없다. 그래서 클래스 A는 남는 주소가 많아 비효율적이다.</p><p>이런 고정된 서브넷 마스크 대신 가변 길이의 서브넷 마스크를 가진 CIDR를 통해 효율적으로 IP 주소를 할당한다.</p><h1 id="라우터"><a href="#라우터" class="headerlink" title="라우터"></a>라우터</h1><p>라우터는 서로 다른 네트워크를 연결한다.<br>라우터는 다음과 같은 세가지 유형의 연결 방식이 가능하다.</p><ol><li>내부 -&gt; 내부</li><li>내부 -&gt; 외부</li><li>외부 -&gt; 내부<br>여기서 내부는 클라우드 네트워크를 의미한다.</li></ol><h3 id="내부-gt-내부"><a href="#내부-gt-내부" class="headerlink" title="내부 -&gt; 내부"></a>내부 -&gt; 내부</h3><p>서로 다른 네트워크에 속한 서버끼리 통신한다. 기본적으로 VPC 내의 네트워크들을 연결한다. 경우에 따라서는 다른 테넌트의 네트워크를 라우팅해야 할 때가 있다. AWS에서는 VPC Peering, 오픈스택 Neutron에서는 네트워크 공유 기능을 사용한다.</p><h3 id="내부-gt-외부"><a href="#내부-gt-외부" class="headerlink" title="내부 -&gt; 외부"></a>내부 -&gt; 외부</h3><p>가상 네트워크에 속한 서버가 인터넷을 통해 외부로 접속되는 경우를 의미한다. 이때 라우터에서는 내부 네트워크에서 사용하는 사설 IP 주소를 공인 IP 주소로 변환하는 IP 마스커레이드를 하게된다.</p><blockquote><p>IP 마스커레이드는 내부의 호스트들이 하나의 공인 IP로 사용. NAT를 통해 내부 IP에게 전달.</p></blockquote><h3 id="외부-gt-내부"><a href="#외부-gt-내부" class="headerlink" title="외부 -&gt; 내부"></a>외부 -&gt; 내부</h3><p>외부에서 내부 네트워크로 접근하려면 공인 IP가 필요하다. 오픈 스택에서는 플로팅 IP, AWS에서는 EIP가 활용된다. 이런 공인 IP는 리전 별로 관리가 되고 어드레스 풀에서 확보해서 논리포트에 할당한다.</p><h2 id="오픈스택-Neutron의-라우터"><a href="#오픈스택-Neutron의-라우터" class="headerlink" title="오픈스택 Neutron의 라우터"></a>오픈스택 Neutron의 라우터</h2><p>크게 가상 라우터와 서브넷의 연결 관계로 구성된다. 가상 라우터는 논리 포트로 연결된다.<br>연결된 후 가상 라우터의 라우팅 테이블이 갱신되어 이에 따라 전송 트래픽이 흘러간다.<br>만약 외부 네트워크와 통신하되 각 서브넷끼리 통신을 막고 싶으면 서브넷마다 라우터를 만들어서 각 라우터를 외부 네트워크에 연결해서 사용하면 된다.</p><h2 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h2><p>크게 게이트웨이와 라우팅 테이블로 구성된다. AWS에서는 외부로 통신하기 위해 VPC 안에 게이트웨이를 만든다. 그런 다음 서브넷의 라우팅 테이블에서 외부로 통신할 때 만든 게이트웨이를 통과하도록 라우팅 정보를 설정한다.</p><p>게이트웨이는 역할에 따라 여러 종류가 있다.</p><ul><li>인터넷 통신을 위한 인터넷 게이트웨이 (IGW)</li><li>사설 네트워크 통신을 위한 버추얼 게이트웨이 (VGW)</li><li>리전 안에서 VPC끼리 연결하는 피어링 커넥션 (PCX)</li><li>인터넷에 연결된 서비스(S3)를 VPC에서 인터넷을 거치지 않고 연결하는 VPC 엔드포인트</li></ul><p>AWS에서는 실제로 라우터가 리소스로 존재하지 않는다. 대신 라우팅 테이블을 통해 라우팅을 정한다. 라우팅 테이블은 VPC와 서브넷에 설정할 수 있다. VPC에 설정하는 건 메인 라우팅 테이블이고, 서브넷에 설정하는 것은 서브 라우팅 테이블이라 한다.</p><h1 id="포트"><a href="#포트" class="headerlink" title="포트"></a>포트</h1><p>논리 포트는 물리 스위치의 포트를 가상화한 개념이다. Neutron에서는 가상 스위치의 접점 의미가 강하고, AWS에서는 서버와 네트워크의 연결 인터페이스 개념이 강하고 ENI(elastic network interface)라고 부른다.</p><p>논리 포트는 물리적인 포트와 다른 점이 있다. 논리 포트는 생성될 때 자신이 소속된 가상 서브넷으로부터 IP 주소를 할당 받는다. 그리고 해당 포트는 그 IP 주소 외 통신은 차단한다. 논리 포트는 여러개의 IP 주소를 할당 받을 수 있다.</p><h3 id="논리-포트-NIC-로-Failover"><a href="#논리-포트-NIC-로-Failover" class="headerlink" title="논리 포트(NIC)로 Failover"></a>논리 포트(NIC)로 Failover</h3><p>논리 포트를 다른 가상 서버에 옮겨서 할당할 수 있다. 즉 하나의 서버에 문제가 생기면 다른 가상 서버에 논리 포트를 옮겨서 장애에 대응할 수 있다. IP 주소의 변경 없이 사용하는 가상 서버를 교체할 수 있다.</p><h3 id="게이트웨이로써-논리-포트"><a href="#게이트웨이로써-논리-포트" class="headerlink" title="게이트웨이로써 논리 포트"></a>게이트웨이로써 논리 포트</h3><p>논리 포트는 서버와 가상 네트워크 연결에만 사용되지 않는다. 가상 네트워크와 라우터를 연결할 때도 쓰인다. 이런 포트에 할당된 IP 주소는 가상 서브넷의 게이트웨이 역할을 한다. 논리 포트를 통해 서브넷에 연결된 가상 서버는 이 게이트웨이(가상 포트)를 통해 클라우드 외부로 통신할 수 있다.</p><p>플로팅 IP(AWS의 엘라스틱 IP)도 논리 포트에 할당한다. 가상의 NAT에서 플로팅 IP로 온 트래픽을 할당된 논리포트로 라우팅한다.</p><h3 id="논리-포트와-맥-주소"><a href="#논리-포트와-맥-주소" class="headerlink" title="논리 포트와 맥 주소"></a>논리 포트와 맥 주소</h3><p>논리 포트는 IP 주소말고 맥 주소도 가진다. 맥 주소는 물리적인 L2 네트워크 정보로 가상 서버와 연결할 때 가상 서버 NIC의 맥 주소로 활용된다.</p><h1 id="시큐리티-그룹"><a href="#시큐리티-그룹" class="headerlink" title="시큐리티 그룹"></a>시큐리티 그룹</h1><p>시큐리티 그룹은 트래픽을 필터링한다.<br>물리 환경에서는 방화벽 장비로 L2 네트워크 간의 트래픽을 제어한다. 서버 OS에서 제어하거나 스위치 장비에서 제공하는 ACL을 통해 접근 제어할 수 있다. 그러나 유지보수 측면에서 손이 많이 간다.</p><p>클라우드 환경에서는 논리 포트에 시큐리티 그룹을 설정해서 세밀하게 접근 제어를 할 수 있다.<br>기본적으로 모든 트래픽을 폐기하는 암묵적 Deny 정책을 따른다.<br>네트워크에서 접근 제어를 해야 OS나 어플리케이션에 종속되지 않고 보안 정책을 수립할 수 있다.</p><h3 id="시큐리티-그룹-규칙-구성"><a href="#시큐리티-그룹-규칙-구성" class="headerlink" title="시큐리티 그룹 규칙 구성"></a>시큐리티 그룹 규칙 구성</h3><ul><li>입력 혹은 출력에 적용할 지 선택</li><li>허용할 프로토콜 종류 선택</li><li>통신 상대 지정 (통신 상대는 IP 주소 범위나 다른 시큐리티 그룹)</li></ul><h3 id="다른-시큐리티-그룹을-상대로-지정"><a href="#다른-시큐리티-그룹을-상대로-지정" class="headerlink" title="다른 시큐리티 그룹을 상대로 지정"></a>다른 시큐리티 그룹을 상대로 지정</h3><p>서버 대수가 늘어날 때마다 시큐리티 그룹에 대상에 새로 생긴 서버를 추가하면 유지보수에 손이 많이 간다. 대상 서버들이 적용되는 시큐리티 그룹을 대상으로 하면 효율적으로 서버 추가에 대응할 수 있다.</p><h3 id="시큐리티-그룹-활용"><a href="#시큐리티-그룹-활용" class="headerlink" title="시큐리티 그룹 활용"></a>시큐리티 그룹 활용</h3><p>시큐리티 그룹을 웹 서버, DB 서버, 관리용으로 만들어 두고 각 리소스마다 포트에 할당하는 방식으로 운영할 수 있다.</p><h1 id="네트워크-액세스-컨트롤-리스트-NACL"><a href="#네트워크-액세스-컨트롤-리스트-NACL" class="headerlink" title="네트워크 액세스 컨트롤 리스트(NACL)"></a>네트워크 액세스 컨트롤 리스트(NACL)</h1><p>서브넷에 대해 필터링한다. 패캣 필터링 하거나 권한을 분리하는 것이 가능하다.</p><h3 id="시큐리티-그룹과-차이"><a href="#시큐리티-그룹과-차이" class="headerlink" title="시큐리티 그룹과 차이"></a>시큐리티 그룹과 차이</h3><p>상태 관점에서 차이가 있다. 상태는 통신 허용 정보를 생각하면 된다.</p><p>NACL은 Stateless이다. 즉 허용 정보를 관리하지 않는다. 왜냐면 암묵적으로 허용하는 정책을 따르기 때문이다.<br>반면 시큐리티 그룹은 Stateful하다. 즉 허용 정보를 관리한다. 왜냐면 암묵적으로 모두 금지하는 정책을 따르기 때문이다.</p><p>NACL은 서브넷 단위로 적용한다.<br>반면 시큐리티 그룹은 논리 포트 단위로 적용한다.</p><h1 id="네트워크를-구성하기-위한-API-처리-흐름"><a href="#네트워크를-구성하기-위한-API-처리-흐름" class="headerlink" title="네트워크를 구성하기 위한 API 처리 흐름"></a>네트워크를 구성하기 위한 API 처리 흐름</h1><p>오픈스택 Neutron에서 네트워크 리소스를 구성하는 흐름은 다음과 같다.</p><ul><li>가상 네트워크 생성</li><li>가상 네트워크에 서브넷 할당</li><li>논리 포트 생성</li><li>가상 라우터 생성해서 서브넷과 연결</li><li>가상 라우터를 외부 L2 네트워크와 연결</li></ul><p>각 단계마다 JSON 데이터를 포함해서 요청하면 된다. 네트워크의 CIDR 같은 정보를 JSON 형식으로 정의할 수 있다. 일관된 포맷으로 네트워크 정보를 유지할 수 있다.</p><p>한편 AWS에서는 다음과 같다.</p><ul><li>CreateVPC : VPC(가상 네트워크) 생성</li><li>CreateSubnet : 서브넷 생성</li><li>CreateNetworkInterface : ENI(포트) 생성</li></ul><p>이 과정을 마친 뒤, 논리 포트(ENI)를 가상 서버에 연결하면 가상 서버는 즉시 통신 가능한 상태가 된다. 이런 클라우드 API를 활용한 네트워크 구축은 물리 환경에서 구축하기보다 훨씬 간편하다.</p><h1 id="네트워크-리소스의-내부-구성"><a href="#네트워크-리소스의-내부-구성" class="headerlink" title="네트워크 리소스의 내부 구성"></a>네트워크 리소스의 내부 구성</h1><p>클라우드 환경에서 네트워크를 조작할 때 가상 네트워크가 어떻게 만들어지는 지 알아보자.<br>오픈스택인 Neutron을 기준으로 파악해보자.</p><h2 id="가상-네트워크를-제어하는-프로세스"><a href="#가상-네트워크를-제어하는-프로세스" class="headerlink" title="가상 네트워크를 제어하는 프로세스"></a>가상 네트워크를 제어하는 프로세스</h2><p>오픈스택 Neutron에는 두 종류의 호스트가 있다.<br>사용자가 실행한 API를 처리하는 프로세스가 동작할 호스트(컨트롤러 노드)<br>가상 서버가 기동하고 가상 네트워크를 구성하는 호스트(컴퓨트 노드)</p><h2 id="여러-노드를-가진-테넌트의-가상-네트워크"><a href="#여러-노드를-가진-테넌트의-가상-네트워크" class="headerlink" title="여러 노드를 가진 테넌트의 가상 네트워크"></a>여러 노드를 가진 테넌트의 가상 네트워크</h2><p><img src="https://user-images.githubusercontent.com/87690744/230054652-966e9b20-f742-4d38-81a6-48f6cb2b5fee.png"></p><p>위 예시를 보면 하나의 컴퓨트 노드에 동일한 IP 주소를 가진 두개의 가상 서버가 작동하고 있다. 일반적인 환경이나 가상화 환경에서는 불가능한 구성이다. 왜냐면 다른 호스트의 가상 서버와 통신하려면 IP 주소가 같아서 어떤 가상 서버와 통신하는 지 알 수 없기 때문이다.<br>클라우드 환경에서는 이런 충돌이 발생해도 문제가 되지 않도록 한다.</p><h2 id="네트워크-식별"><a href="#네트워크-식별" class="headerlink" title="네트워크 식별"></a>네트워크 식별</h2><p>컴퓨터 노드에는 <code>br-init</code>과 <code>br-turn</code> 이라는 OVS(Open vSwitch) 브릿지가 만들어져 있다.</p><p><code>br-init</code>은 가상 서버와 리눅스의 가상 인터페이스로 연결된다. 이 가상 인터페이스가 논리 포트가 된다.<br><code>br-init</code>은 <code>br-turn</code>과 연결된다. <code>br-turn</code>은 컴퓨트 노드 사이 패킷 전송을 담당한다.</p><p>가상 서버에서 전송되는 패킷은 가상 서버에 연결된 논리 포트(가상 인터페이스)를 통해 가상 서버가 어떤 네트워크에 속한 지 파악한다. 그래서 해당 패킷의 소속 네트워크를 식별하기 위해 <code>VLAN ID</code>를 패킷에 할당한다.<br>즉 하나의 컴퓨트 노드에 분리된 두 네트워크에 각자 속한 같은 IP 주소의 가상 서버는 패킷에 할당된 <code>VLAN ID</code>를 통해 각자의 네트워크를 식별할 수 있게된다.</p><p>두 컴퓨트 노드 사이 패킷 전송은 <code>VXLAN</code>이 사용된다. <code>VXLAN</code>은 이더넷 프레임을 캡슐화해서 L3 네트워크 상에 논리적인 L2 네트워크를 구성하는 터널링 프로토콜이다. </p><p><code>br-turn</code>에서 내부로 패킷을 받아올 때는 <code>VXLAN ID</code>를 꺼내고 <code>VLAN ID</code>로 할당한다. 외부로 패킷을 내보낼 때는 <code>VLAN ID</code>를 꺼내고 <code>VXLAN ID</code>를 할당한다.</p><blockquote><p>VLAN과 VXLAN<br>둘 다 가상 네트워크를 식별하기 위한 네트워크 가상화 기술이다. 두 기술의 차이는 구분 가능한 네트워크 갯수에 있다. VLAN은 4094개, VXLAN은 1600만개를 구분할 수 있다.</p></blockquote><h1 id="클라우드-네트워크와-SDN"><a href="#클라우드-네트워크와-SDN" class="headerlink" title="클라우드 네트워크와 SDN"></a>클라우드 네트워크와 SDN</h1><p>SDN (Software Defined Networking)는 제어와 전송을 분리해서 API로 제어하겠다는 개념이다. 제어하는 부분은 컨트롤러, 전송을 담당하는 부분은 데이터 플랜이라고 한다.</p><p>SDN의 구성요소는</p><ul><li>클라우드 네트워크 컨트롤러 : 클라우드에서 가상 네트워크를 동작시키기 위한 태스크를 실행</li><li>네트워크 오케스트레이터 : 각종 네트워크 장비를 제어하면서 가상 네트워크 기능 구현.</li><li>네트워크 장비 : 실제로 패킷을 다루는 장비. 장비를 제어할 수 있도록 API 제공</li></ul><p>특히 클라우드 네트워크 컨트롤러는 사용자에게 노출되는 API를 담당한다. 즉 내부의 변화가 사용자에게 최대한 영향을 덜 미치도록 해야한다. 사용자들이 사용하기 편하도록 설계되어야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드에서 서버 리소스를 제어하는 방법</title>
      <link>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/</guid>
      <pubDate>Wed, 29 Mar 2023 12:46:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;서버-리소스&quot;&gt;&lt;a href=&quot;#서버-리소스&quot; class=&quot;headerlink&quot; title=&quot;서버 리소스&quot;&gt;&lt;/a&gt;서버 리소스&lt;/h1&gt;&lt;p&gt;서버 리소스는 타입과 이미지로 구성된다.&lt;br&gt;타입은 리소스의 크기나 속성을 유형화한 개념이다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="서버-리소스"><a href="#서버-리소스" class="headerlink" title="서버 리소스"></a>서버 리소스</h1><p>서버 리소스는 타입과 이미지로 구성된다.<br>타입은 리소스의 크기나 속성을 유형화한 개념이다.<br>이미지는 서버의 기동 이미지로 AWS의 AMI가 이에 해당한다.</p><h2 id="서버-리소스-제어-API-흐름"><a href="#서버-리소스-제어-API-흐름" class="headerlink" title="서버 리소스 제어 API 흐름"></a>서버 리소스 제어 API 흐름</h2><h3 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h3><p>서버 리소스를 제어하기 위해서 가장 먼저 인증을 해야 한다.<br>인증 요청은 <code>POST</code>로 회원이름과 암호를 보내고 토큰과 엔드포인트를 받는다.</p><p>이후 요청에서 헤더에 토큰을 포함해서 인증할 수 있다.</p><h3 id="템플릿-이미지-유효성-검증"><a href="#템플릿-이미지-유효성-검증" class="headerlink" title="템플릿 이미지 유효성 검증"></a>템플릿 이미지 유효성 검증</h3><p>서버 리소스에 사용할 템플릿 이미지가 존재하는지, 접근 권한이 있는지 확인하고 템플릿 이미지를 반환하는 API를 거친다.<br>템플릿 이미지 유효성 검증은 굳이 하지 않아도 서버 리소스 제어에 큰 문제가 생기지 않는다. 다만 이 과정을 거치지 않으면 서버 기동 중에 문제가 발생해서 여러 문제점이 함께 발생하는 기동 중에 문제 파악이 오래걸릴 수 있다.</p><h3 id="가상-서버-생성"><a href="#가상-서버-생성" class="headerlink" title="가상 서버 생성"></a>가상 서버 생성</h3><p>생성할 가상 서버의 조건을 요청 바디에 담아서 가상 서버를 생성할 수 있다.<br>가상 서버 조건 정보는 가상 서버 이름, 플레이버(인스턴스 유형), 템플릿 이미지, 접속할 가상 네트워크, 시큐리티 그룹 등 다양하다.<br>생성에 성공하면 서버의 UUID를 응답한다.</p><p>서버 생성 요청에 성공했다고 바로 서버가 생성된 건 아니다. 단지 클라우드 제공자가 서버 생성 요청을 확인한 것이다.<br>실제로 AWS에서 가상 서버를 만들어도 약간의 시간 뒤에 생성된다. 이는 API로 생성 요청을 접수하는 처리와 실제 가상 서버를 만드는 처리가 비동기적으로 분리되어 실행되기 때문이다.</p><h3 id="생성된-가상-서버-상태-확인"><a href="#생성된-가상-서버-상태-확인" class="headerlink" title="생성된 가상 서버 상태 확인"></a>생성된 가상 서버 상태 확인</h3><p>가상 서버 생성 요청의 응답으로 받은 UUID로 가상 서버의 상태를 확인할 수 있다.<br>이때 가상 서버를 만드는 중에도 가상 서버의 상태를 보여줄 수 있다.</p><h2 id="가상-서버의-수명-주기"><a href="#가상-서버의-수명-주기" class="headerlink" title="가상 서버의 수명 주기"></a>가상 서버의 수명 주기</h2><p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/instance_lifecycle.png"></p><p>AWS의 경우 여러 단계로 서버 리소스의 상태를 알려준다.<br>pending : running할 준비하는 중<br>running : 인스턴스 실행 중<br>stopping : 인스턴스 중지 혹은 절전 모드로 전환 준비<br>stopped : 인스턴스 종료됨. 하지만 다시 시작 가능<br>shutting-down : 인스턴스가 종료할 준비<br>terminated : 인스턴스가 영구적으로 삭제</p><h3 id="메타-데이터와-사용자-데이터"><a href="#메타-데이터와-사용자-데이터" class="headerlink" title="메타 데이터와 사용자 데이터"></a>메타 데이터와 사용자 데이터</h3><p>메타 데이터와 사용자 데이터는 가상 서버의 환경 설정에 활용되는 데이터이다.<br>메타 데이터는 서버별로 따로 만들어지고 여러 개의 서버가 같은 메타 데이터를 공유하지 못한다.</p><p>사용자 데이터는 가상 서버에 액션을 실행해야 할 때 사용한다. 대표적으로 쉘 스크립트 같은 데이터가 있다. 만약 실행되야 할 사용자 데이터가 무수히 많으면 Cloud-init 이란 툴을 사용한다.</p><h3 id="이미지-생성과-공유"><a href="#이미지-생성과-공유" class="headerlink" title="이미지 생성과 공유"></a>이미지 생성과 공유</h3><p>이미지는 가상 머신 템플릿 이미지를 의미한다. 이미지 정보에는 디스크 포맷이나 디바이스 매핑과 같은 구성 정보들이 포함되어 있다. 특이한 점은 정보 여부를 결정할 수 있어서 다른 테넨트의 사용자에게 공개 여부를 정할 수 있다.</p><p>AWS <code>CreateImage</code> API로 인스턴스 ID를 통해 서버의 이미지를 만들 수 있다.<br>AWS <code>DescribeImages</code> API로 이미지 정보를 가져올 수 있다.</p><h3 id="VM-이미지-가져오기"><a href="#VM-이미지-가져오기" class="headerlink" title="VM 이미지 가져오기"></a>VM 이미지 가져오기</h3><p>이미지를 임포트하는 API를 지원한다. AWS에서는 <code>ImportImage</code>, <code>ImportInstance</code>,<code>ImportVolume</code> API로 가상 머신 템플릿을 AMI로 등록할 수 있다.<br><code>ImportImage</code>는 가상 머신 템플릿을 AMI로 임포트한다.<br><code>ImportInstance</code>는 AMI를 등록하고 서버 기동까지 한번에 한다.<br><code>ImportVolume</code>는 볼륨이 분할되어 있는 경우 볼륨 단위로 임포트할 때 사용한다.</p><h1 id="서버-리소스의-내부-구성"><a href="#서버-리소스의-내부-구성" class="headerlink" title="서버 리소스의 내부 구성"></a>서버 리소스의 내부 구성</h1><p>가상 서버의 생성 요청을 접수하고 오픈스택 내부에서 벌어지는 처리 내용을 정리해보자.</p><h3 id="가상-서버-생성-요청을-메시지-큐에-넣기"><a href="#가상-서버-생성-요청을-메시지-큐에-넣기" class="headerlink" title="가상 서버 생성 요청을 메시지 큐에 넣기"></a>가상 서버 생성 요청을 메시지 큐에 넣기</h3><p>가상 서버 생성 API가 실행되면 메시지 큐에 메시지를 넣고 비동기로 처리한다.<br>그리고 가상 서버 생성 요청이 큐에 들어가는 시점에 가상 서버의 구성 정보와 상태정보가 구성 관리 데이터베이스에 저장한다.</p><h3 id="스케줄러에-요청-전달"><a href="#스케줄러에-요청-전달" class="headerlink" title="스케줄러에 요청 전달"></a>스케줄러에 요청 전달</h3><p>스케줄러(컨덕터)라고 부르는 프로세스가 큐에 있는 메시지를 꺼내서 처리한다.<br>스케줄러 프로세스를 다중화하면 가용성이 높아진다. 스케줄러는 하나의 요청을 처리한다. 많은 요청이 오는 경우 여러 스케줄러에 분산되어 처리된다.</p><h3 id="가상-서버를-기동할-호스트-결정"><a href="#가상-서버를-기동할-호스트-결정" class="headerlink" title="가상 서버를 기동할 호스트 결정"></a>가상 서버를 기동할 호스트 결정</h3><p>오픈 스택은 상태 관리 데이터베이스에 각 호스트들의 리소스 사용 상태를 기록하고 갱신한다.<br>스케줄러는 메시지를 꺼낸 후 가상 서버에 필요한 리소스를 가진 호스트를 상태 관리 데이터베이스를 기반으로 찾는다.</p><h3 id="호스트에-가상-서버-기동-지시"><a href="#호스트에-가상-서버-기동-지시" class="headerlink" title="호스트에 가상 서버 기동 지시"></a>호스트에 가상 서버 기동 지시</h3><p>스케줄러가 호스트를 결정했으면 그 호스트에 가상 서버를 기동하라는 요청을 메시지 큐에 넣는다.</p><h3 id="메시지-수신과-가상-서버-생성"><a href="#메시지-수신과-가상-서버-생성" class="headerlink" title="메시지 수신과 가상 서버 생성"></a>메시지 수신과 가상 서버 생성</h3><p>메시지 큐에서 메시지를 받은 호스트는 가상 서버를 구축한다.<br>템플릿 이미지 가져오기, IP 주소 할당, 네트워크 접속 준비 등을 진행한다.</p><h3 id="가상-서버-상태-갱신"><a href="#가상-서버-상태-갱신" class="headerlink" title="가상 서버 상태 갱신"></a>가상 서버 상태 갱신</h3><p>기동에 성공하면 구성 관리 데이터베이스의 상태를 ACTIVE로 갱신한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IT 인프라의 진화와 API의 기본 철학</title>
      <link>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/</guid>
      <pubDate>Tue, 28 Mar 2023 09:07:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이&quot;&gt;&lt;a href=&quot;#서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이&quot; class=&quot;headerlink&quot; title=&quot;서버를 추가 구축해야 하는 상</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이"><a href="#서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이" class="headerlink" title="서버를 추가 구축해야 하는 상황에서 물리적 장비와 가상화 장비의 차이"></a>서버를 추가 구축해야 하는 상황에서 물리적 장비와 가상화 장비의 차이</h1><h2 id="물리적-장비로-환경-구축하기"><a href="#물리적-장비로-환경-구축하기" class="headerlink" title="물리적 장비로 환경 구축하기"></a>물리적 장비로 환경 구축하기</h2><p>웹 서버 요구사항을 수행할 수 있는 물리 장비를 발주해야 한다.<br>장비가 도착하면 데이터 센터의 랙에 물리 장비를 장착해야 한다.<br>이 과정에서 빈 공간이 있는 지, 네트워크 스위치 포트가 비어 있는 지, 네트워크 스위치까지 배선이 가능한 지, 전원 용량이 허용 범위 안에 있는 지 등,,, 수많은 물리적 요소를 확인해야 한다.</p><p>랙에 장비를 장착하고 나서 OS와 어플리케이션, 환경설정을 한다. 그리고 개발팀에게 계정 권한 정보를 전달한다.</p><p>물리적 장비로 인프라 환경을 구축하면 OS와 어플리케이션을 설치하는 것 외에도 고려할 사항이 많다.</p><h2 id="가상화-장비로-환경-구축하기"><a href="#가상화-장비로-환경-구축하기" class="headerlink" title="가상화 장비로 환경 구축하기"></a>가상화 장비로 환경 구축하기</h2><p>가상화 장비로 환경 구축하면 물리적 요소 고려가 줄어든다.</p><p>어떤 장비를 구입해야 할 지 고민하지 않고 필요한 스펙의 리소스만 가상 서버에 할당하면 된다.<br>장비를 데이터 센터 랙에 설치하는 작업은 가상 서버를 물리 서버에 할당하는 과정으로 대체된다.</p><p>랙 빈 공간을 찾거나, 네트워크 스위치 포트, 배선, 전원 용량 등 물리적 요소 고려를 하지 않아도 된다.<br>대신 가상화 장비로 환경 구축하면 소프트웨어 요구 사항만 고려하면 된다.</p><p>물리적 장비에 OS와 소프트웨어 설치 및 환경 설정할 때도 매번 비슷한 작업을 반복하게 된다.<br>가상화 장비로 환경 설정할 때는 환경 설정이 완료된 템플릿을 복제해오는 방식으로 대체된다.</p><h2 id="서버-가상화의-한계"><a href="#서버-가상화의-한계" class="headerlink" title="서버 가상화의 한계"></a>서버 가상화의 한계</h2><p>가상화 장비로 환경 구축해서 물리적 고려가 줄었다. 하지만 그 외 작업은 여전히 해야 한다.<br>가상 서버 리소스 구성 방식 정하기, 가상 서버를 물리 서버에 할당, IP 주소 확보, 시스템 설계 및 작업 계획서 작성 등 작업들은 가상 장비로 구축해도 동일하다.<br>이런 작업들은 사람이 판단하고 수작업한다는 특성이 있다.<br>시스템이 커지면 위와 같은 작업 때문에 인프라 운영이 번거로워 진다.</p><p>클라우드 API는 이런 작업을 더 쉽게 만든다.</p><h1 id="클라우드-환경에서-인프라-구축-작업"><a href="#클라우드-환경에서-인프라-구축-작업" class="headerlink" title="클라우드 환경에서 인프라 구축 작업"></a>클라우드 환경에서 인프라 구축 작업</h1><p>서버 가상화 환경에서도 줄이지 못한 사람이 수작업해야 하는 작업을 클라우드 환경에서 어떻게 줄이는 지 확인하자</p><h2 id="클라우드로-환경-구축하기"><a href="#클라우드로-환경-구축하기" class="headerlink" title="클라우드로 환경 구축하기"></a>클라우드로 환경 구축하기</h2><p>클라우드(오픈스택, AWS)에서 웹서버 추가는 세가지 단계로 나뉜다.</p><ul><li>인스턴스 유형 선택</li><li>서버 설정 적용</li><li>가상 서버 기동</li></ul><h2 id="클라우드-적용의-장점"><a href="#클라우드-적용의-장점" class="headerlink" title="클라우드 적용의 장점"></a>클라우드 적용의 장점</h2><h3 id="가상-서버-스펙-선택"><a href="#가상-서버-스펙-선택" class="headerlink" title="가상 서버 스펙 선택"></a>가상 서버 스펙 선택</h3><p>클라우드에서는 가상 서버 사양을 인스턴스 유형(플레이버)로 규격화했다.<br>유형이 있으면 재활용하기 쉬워진다. 스펙 결정할 때 고려해야 될 요소를 줄여준다.<br>다만 세밀한 부분까지 설정하지 못할 수 있다. 하지만 리소스 가격은 시간이 갈수록 낮아지고, 사양 고민할 시간을 줄이는 게 더 중요하다.<br>요구사항이 달라졌을 때도 스펙을 처읍부터 다시 정하지 않고 다른 인스턴스 유형을 선택하면 된다.</p><h3 id="가상-서버를-배치할-호스트-결정"><a href="#가상-서버를-배치할-호스트-결정" class="headerlink" title="가상 서버를 배치할 호스트 결정"></a>가상 서버를 배치할 호스트 결정</h3><p>가상화 서버로 환경을 구축하면 가상 서버를 물리 서버에 배치해야 한다.<br>클라우드 환경에서는 가상 서버를 정하고 구축 요청을 하면 프로그램이 자동으로 적절한 물리 서버를 찾아 배치한다.<br>(일반적으로 물리 서버를 정하는 기준은 일반 사용자는 몰라도 된다. 오픈 스택에서는 기준을 사용자화할 수 있다.)<br>사람이 직접 가장 적절한 물리 서버를 찾는 것보다 약간의 리소스 손해를 보더라도 사람이 고민하는 시간을 줄여준다.</p><h3 id="IP-주소-할당"><a href="#IP-주소-할당" class="headerlink" title="IP 주소 할당"></a>IP 주소 할당</h3><p>클라우드 환경에서는 가상 서버가 접속할 네트워크를 정하면 사용 가능한 IP 주소가 자동으로 확보된다.<br>IP 주소는 가상 서버가 기동될 때 할당되고, 가상 서버가 제거되면 IP 주소를 회수한다.</p><p>클라우드에서는 대량의 가상 서버를 생성했다가 제거하기 때문에 수없이 IP 할당하고 제거한다.<br>만약 IP 할당 및 제거를 자동화하지 않았다면 매우 번거로운 수작업이 된다.</p><p>IP 주소가 자동 할당되면 가상 서버의 IP 주소를 예상할 수 없다.<br>대신 클라우드는 동적 DNS로 IP 주소를 추상화 한다.</p><h3 id="설정-스크립트-작성"><a href="#설정-스크립트-작성" class="headerlink" title="설정 스크립트 작성"></a>설정 스크립트 작성</h3><p>가상 서버가 구동될 때 설정을 적용하는 스크립트를 작성하면 실수 없이 여러 서버에 자동으로 적용된다.<br>그리고 클라우드에서는 이런 설정 스크립트가 잘 적용됐는지 검증하는 툴도 제공한다.</p><h3 id="가상-서버-생성의-자동화"><a href="#가상-서버-생성의-자동화" class="headerlink" title="가상 서버 생성의 자동화"></a>가상 서버 생성의 자동화</h3><p>클라우드 환경에서 가상 서버 생성할 때 인스턴스 유형과 설정 스크립트만 준비되어 있다면 수많은 작업이 순서대로 자동 진행된다.<br>템플릿 복제, 스크립트 실행, 가상 서버 배치할 호스트, IP 주소 할당과 같은 일련의 작업을 클라우드 사용자가 고민하지 않아도 된다.</p><p>클라우드 환경에서는 HTTP&#x2F;HTTPS로 통신하는 API를 제공한다. 다만 JSON 형식이 사람이 이해하기 어려워서 CLI나 웹 콘솔을 제공한다.</p><h3 id="스토리지와-네트워크도-효율적으로"><a href="#스토리지와-네트워크도-효율적으로" class="headerlink" title="스토리지와 네트워크도 효율적으로"></a>스토리지와 네트워크도 효율적으로</h3><p>클라우드 환경에서는 스토리지와 네트워크도 웹 서버 추가하는 것과 비슷하게 효율적으로 수행한다.</p><p>스토리지를 추가할 때 디스크 영역을 확보하기 위해 RAID 구성이나 LUN 매핑하는 과정이 필요하다. 이 과정에서 장비나 제조사의 기능이나 설정을 사람이 수작업으로 하게 된다.<br>클라우드 환경은 스토리지 용량과 접속할 서버만 정하면 나머지는 알아서 자동으로 처리한다.</p><p>네트워크를 추가할 때 VLAN을 구성하고 포함되는 물리 호스트의 네트워크 설정과 네트워크 기기 설정 모두 맞춰줘야 하낟.<br>클라우드 환경에서는 사용할 네트워크 세그먼트나 가상 라우터를 정하면 다른 설정은 자동으로 설정된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot에서 잘못된 타입으로 파라미터를 보내면 어떻게 될까?</title>
      <link>https://yangdongjue5510.github.io/2023/03/22/spring-validation/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/22/spring-validation/</guid>
      <pubDate>Wed, 22 Mar 2023 11:01:03 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;목적&quot;&gt;&lt;a href=&quot;#목적&quot; class=&quot;headerlink&quot; title=&quot;목적&quot;&gt;&lt;/a&gt;목적&lt;/h1&gt;&lt;p&gt;스프링 부트에서 잘못된 타입으로 파라미터를 보내는 예외 상황에 어떤 예외가 발생하는 지 확인해보고 이를 검증하는 코드를 만들어</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h1><p>스프링 부트에서 잘못된 타입으로 파라미터를 보내는 예외 상황에 어떤 예외가 발생하는 지 확인해보고 이를 검증하는 코드를 만들어본다!</p><h3 id="컨트롤러-코드"><a href="#컨트롤러-코드" class="headerlink" title="컨트롤러 코드"></a>컨트롤러 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/equipments&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EquipmentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EquipmentService equipmentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EquipmentController</span><span class="params">(<span class="keyword">final</span> EquipmentService equipmentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.equipmentService = equipmentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> EquipmentDetailResponse <span class="title function_">getEquipment</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">final</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> equipmentService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-코드"><a href="#테스트-코드" class="headerlink" title="테스트 코드"></a>테스트 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(controllers = &#123;EquipmentController.class&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EquipmentControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;id가 문자열이면 400을 응답한다.&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getEquipment_400_idIsNotNumeric</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">invalidId</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when, then</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/api/equipments/&quot;</span> + invalidId))</span><br><span class="line">                .andExpect(status().isBadRequest());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드는 PathVariable이 Long이어야 하는데 문자열이 전달된 경우이다.<br>이 테스트 코드를 실행하고 <code>DispatcherServlet</code>의 <code>doDispatch</code>에 break point를 걸고 디버깅을 해보자.</p><h3 id="디버깅하면서-찾아보기"><a href="#디버깅하면서-찾아보기" class="headerlink" title="디버깅하면서 찾아보기"></a>디버깅하면서 찾아보기</h3><p>디버깅을 하다보면 <code>InvocableHandlerMethod</code> (컨트롤러에서 요청을 처리하는 메서드)라는 객체에서 <code>invokeForRequest</code>라는 메서드를 호출하면서 인자를 <code>Object</code> 배열로 변환한다.<br>이 변환 로직을 각 리졸버에게 위임한다. 리졸버는 <code>Object</code>로 변환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocableHandlerMethod</span> <span class="keyword">extends</span> <span class="title class_">HandlerMethod</span> &#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">        Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">        args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">                <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">                    logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Object</code>로 변환된 인자는 <code>DataBinder</code>가 적절한 타입으로 바꿔준다. 이 과정에서 <code>ConversionException</code>이 발생하고 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataBinder</span> <span class="keyword">implements</span> <span class="title class_">PropertyEditorRegistry</span>, TypeConverter &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> MethodParameter methodParam)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getTypeConverter().convertIfNecessary(value, requiredType, methodParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataBinder</code>에서 시작한 형 변환 로직 중 형 변환에 실패하면 <code>ConversionException</code>이 발생하고 이 예외는 <code>TypeMismatchException</code>이 대신 던져진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TypeConverterSupport</span> <span class="keyword">extends</span> <span class="title class_">PropertyEditorRegistrySupport</span> <span class="keyword">implements</span> <span class="title class_">TypeConverter</span> &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">        Assert.state(<span class="built_in">this</span>.typeConverterDelegate != <span class="literal">null</span>, <span class="string">&quot;No TypeConverterDelegate&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.typeConverterDelegate.convertIfNecessary(<span class="literal">null</span>, <span class="literal">null</span>, value, requiredType, typeDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConversionNotSupportedException</span>(value, requiredType, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ConversionException | IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeMismatchException</span>(value, requiredType, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>TypeMismatchException</code>은 <code>AbstarctNamedValueMethodArgumentResolver</code>에서 <code>MethodArgumentTypeMismatchException</code>으로 바뀌어 던져지게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">            NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">                handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">                        namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">                        namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line">            <span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">                handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결론만 말하자면 타입이 맞지 않으면 <code>MethodArgumentTypeMismatchException</code>이 발생한다.</p><h2 id="예외-처리-코드"><a href="#예외-처리-코드" class="headerlink" title="예외 처리 코드"></a>예외 처리 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentTypeMismatchException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleMethodArgumentTypeMismatch</span><span class="params">(<span class="keyword">final</span> MethodArgumentTypeMismatchException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest()</span><br><span class="line">                .body(String.format(<span class="string">&quot;%s이 잘못된 타입으로 입력됐습니다. 입력값 : %s&quot;</span>,</span><br><span class="line">                        e.getParameter().getParameter().getName(), e.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RestControllerAdvice</code>로 예외를 처리해주면 된다. 파라미터의 이름과 입력값을 가져와서 에러 메시지를 출력하는 코드이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/boot/">Boot</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/22/spring-validation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드를 제어하는 API의 작동 방식</title>
      <link>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/</guid>
      <pubDate>Mon, 20 Mar 2023 11:24:40 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;클라우드와-API의-관계&quot;&gt;&lt;a href=&quot;#클라우드와-API의-관계&quot; class=&quot;headerlink&quot; title=&quot;클라우드와 API의 관계&quot;&gt;&lt;/a&gt;클라우드와 API의 관계&lt;/h1&gt;&lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="클라우드와-API의-관계"><a href="#클라우드와-API의-관계" class="headerlink" title="클라우드와 API의 관계"></a>클라우드와 API의 관계</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API는 어떤 소프트웨어에서 다른 소프트웨어를 제어하기 위해 미리 약속된 인터페이스나 규약을 의미한다.<br>API를 사용하면 내부 구조를 자세히 몰라도 다른 소프트웨어를 무리 없이 사용할 수 있다.</p><h3 id="웹-API"><a href="#웹-API" class="headerlink" title="웹 API"></a>웹 API</h3><p>클라우드에서는 웹 API를 사용하는 것이 일반적이다.<br>웹 API는 HTTP(HTTPS) 같은 웹 프로토콜을 사용해서 네트워크를 통해 호출하는 API를 말한다.</p><h3 id="아마존에서-시작도니-클라우드-컴퓨팅에서의-웹-API-적용"><a href="#아마존에서-시작도니-클라우드-컴퓨팅에서의-웹-API-적용" class="headerlink" title="아마존에서 시작도니 클라우드 컴퓨팅에서의 웹 API 적용"></a>아마존에서 시작도니 클라우드 컴퓨팅에서의 웹 API 적용</h3><p>아마존은 특정 기간에 사용량이 폭주하는 경향이 있었다. 그래서 많은 서버와 스토리지를 구비해놓고 제어하는 웹 API를 구축했다.<br>아마존의 서버와 스토리지 같은 리소스 관리 방식은 AWS의 EC2와 S3의 기반이 된다.<br>이런 웹 API 기반 리소스 관리는 다음과 같은 이점이 있다.</p><ul><li>인터넷을 통해 서버나 스토리지를 시간제로 임대해서 사용할 수 있다.</li><li>API를 통해 사용자가 원하는 시점에 원하는 만큼 리소스를 할당받을 수 있다.</li></ul><h3 id="가상화-기술과-클라우드-컴퓨팅"><a href="#가상화-기술과-클라우드-컴퓨팅" class="headerlink" title="가상화 기술과 클라우드 컴퓨팅"></a>가상화 기술과 클라우드 컴퓨팅</h3><p>물리적인 서버와 스토리지를 직접 확보하려면 장비를 구하고 설치하는 과정에서 많은 시간이 쓰인다.<br>물리적인 서버를 구하지 않고 가상화된 환경에서 API를 호출해서 필요한 리소스를 바로 구할 수 있다.</p><p>하지만 가상화가 클라우드 컴퓨팅의 본질은 아니다.<br>성능이나 보안이 중요한 경우, 물리적인 리소스를 직접 사용해야 하는 경우도 있기 때문이다.<br>클라우드의 본질은 리소스의 가상화 여부가 아닌 인터넷을 통해 필요한 자원을 제어할 수 있는 API 방식에 있다.</p><h3 id="웹-API의-구성요소"><a href="#웹-API의-구성요소" class="headerlink" title="웹 API의 구성요소"></a>웹 API의 구성요소</h3><p>웹 API에서는 인증 처리, 제어 대상, 제어 행동으로 구성된다.<br>제어 대상은 리소스를 의미하며 URI로 표현된다.<br>제어 행위는 액션에 해당하며 HTTP 메서드로 표현된다.</p><h1 id="리소스와-URI"><a href="#리소스와-URI" class="headerlink" title="리소스와 URI"></a>리소스와 URI</h1><h3 id="도메인-도메인-트리-FQDN"><a href="#도메인-도메인-트리-FQDN" class="headerlink" title="도메인, 도메인 트리, FQDN"></a>도메인, 도메인 트리, FQDN</h3><p>URI는 크게 네트워크 관련 부분과 경로 관련 부분으로 나뉜다.<br>네트워크 부분에 서버 IP 주소를 사용하는 것보다는 도메인 주소를 사용하는 게 편리하다.(<code>www.naver.com</code>)</p><p>EC2 자원의 외부 DNS 호스트 이름인 <code>ec2-54-10-10-10.ap-northeast-2.compute.amazonaws.com</code>은 오른쪽부터 점을 기준으로 계층 구조를 나타낸다.<br>TLD(탑 레벨 도메인)인 <code>com</code><br>2LD(세컨드 레벨 도메인)인 <code>amazonaws</code><br>…</p><p>이런 식으로 상위 도메인에 하위 도메인이 포한되는 방식이다.<br>이런 모습이 마치 트리 구조로 형상화되어서 도메인 트리라고도 한다.<br>그리고 가장 왼쪽에 위치한 부분 <code>ec2-54-10-10-10</code>라는 호스트가 리소스에 해당하게 된다.<br>즉 호스트 명 + 도메인 명을 합친 전체 이름을 FQDN이라고 한다. FQDN은 세상의 수많은 호스트 중 하나를 지정할 수 있게 한다.</p><blockquote><p>클라우드에서 도메인 계층 확장하기</p></blockquote><p>클라우드 리소스에 접속할 때도 계층화된 도메인 명을 사용한다.<br>도메인 명을 정할 때는 일종의 규칙이 있다. AWS의 도메인 예시를 보면, <code>ec2.ap-northeast-2.compute.amazonaws.com</code>에서 <code>ap-northeast-2</code>는 리전을 의미하고, <code>ec2</code>는 서비스(컴포넌트)에 해당한다. (만약 서비스가 리전에 종속되지 않는 경우, 리전 계층에 서비스가 사용될 수 있다.)</p><p>이 규칙을 이해하면 다양한 리전에 다양한 서비스를 도메인 명으로 표현할 수 있다.</p><h3 id="DNS-가상-호스트-레지스트리"><a href="#DNS-가상-호스트-레지스트리" class="headerlink" title="DNS, 가상 호스트, 레지스트리"></a>DNS, 가상 호스트, 레지스트리</h3><p>도메인 명은 사람이 쉽게 식별할 수 있기 위한 내용이라 TCP&#x2F;IP으로 통신하기 위해서는 도메인을 IP 주소로 바꿔야 한다.<br>도메인 주소와 IP 주소를 변환하는 역할을 DNS가 한다.</p><blockquote><p>복수 IP와 가상호스트</p></blockquote><p>일반적으로 FQDN과 IP가 1대1 매핑되지만 필요에 따라서 1:N, N:1 매핑이 가능하다.<br>1:N은 대규모 시스템에 활용된다. 하나의 FQDN으로 많은 요청이 오면 하나의 IP로 대응하지 못할 수 있다.<br>이럴 때 여러 IP를 매핑해서 DNS가 순차적으로 IP를 돌려써서 부하를 줄일 수 있다. (DNS 라운드 로빈)</p><p>클라우드에서는 CDN이나 로드 밸런서에서 DNS 라운드 로빈 기능을 활용하여 대규모 트래픽에 대응할 수 있다.<br>DNS 라운드 로빈은 사용자 입장에서 주소 변경 없이 확장 할 수 있다.</p><p>반면 N:1은 서버 리소스 더 효율적으로 사용하고 싶을 때 사용한다.</p><blockquote><p>도메인과 IP 주소 변환 방법</p></blockquote><p>클라이언트 쪽에서 IP 주소로 변환하려고 하면 스텁 리졸버를 통해 캐시 DNS 서버에 해당 도메인 정보가 있는 지 확인한다.(이 과정을 로컬 쿼리, 재귀적 질의라고 함)<br>만약 없으면 루트 도메인부터 최하위 도메인까지 각 도메인의 네임 스페이스를 관리하는 DNS에게 물어본다. (이를 반복적 질의, 비재귀적 질의라고 함)<br>이렇게 되면 루트 도메인에 상당한 부하가 생기는 데, 이를 방지하기 위한 것이 캐시 DNS 서버이다.<br>(캐시 DNS 서버는 클라이언트 컴퓨터에서 네트워크 설정에서 지정된 DNS 서버이다.)</p><blockquote><p>비재귀적 질의를 많이 사용하는 URL</p></blockquote><p>URL을 설계할 때는 비재귀적 질의가 많이 사용되도록 하는 게 좋다. 비재귀적 질의가 많이 사용되는 URL은 다양한 DNS를 거쳐서 IP 주소를 찾도록 하는 것이다. 즉 서버의 특성에 따라 잘 계층화하면  확정성을 확보할 수 있다. <code>ec2-north-east-amazon.com</code>은 계층화가 잘 이뤄지지 않았고 비재귀적 질의가 적다. (루트DNS - <code>com</code> DNS - <code>ec2...</code> DNS)<br>반면 <code>ec2.north-east.amazon.com</code>과 같이 잘 계층화 된 URL은 비재귀적 질의가 많이 사용됐고 각 DNS가 목적에 따라 확장에 더 유리해졌다. (루트 DNS - <code>com</code> DNS - <code>amazon</code> DNS - <code>north-east</code> DNS - <code>ec2</code> DNS)<br>물론 이런 설계 방법이 성능에는 약간의 손해를 볼 수 있으나 DNS 캐시 서버의 존재 때문에 이런 손해는 줄일 수 있다.</p><blockquote><p>자신이 등록한 도메인 사용하기</p></blockquote><p>자신의 도메인에 CNAME을 등록하면 된다.<br>일반적으로 클라우드 서비스를 제공하는 업체에서는 DNS 서비스를 제공한다. AWS도 Route 53이란 기능을 제공한다.</p><blockquote><p>도메인 레코드</p></blockquote><p>IP 주소와 도메인을 짝 지은 설정정보를 DNS 레코드라고 한다.</p><ul><li><code>A</code> : FQDN에 대한 IPv4 주소 정보</li><li><code>AA</code> : FQDN에 대한 IPv6 주소 정보</li><li><code>CNAME</code> : FQDN 별칭 정보</li><li><code>PTR</code> : FQDN 역방향 질의 정보</li><li><code>SOA</code> : DNS 영역에 대한 권한 정보</li><li><code>NS</code> : DNS 서버 정보</li><li><code>MX</code> : 이메일 서버 정보</li><li><code>SPF</code> : 이메일 발신자 자격 증명 정보</li><li><code>SRV</code> : 프로토콜, 포트 번호 등 ㅈ어보</li><li><code>TXT</code> : 호스트의 부가 정보</li></ul><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>웹 API에서 리소스를 지정하는 식별자를 URI라고 한다. URI에는 URL과 URN이 포함된다.</p><blockquote><p>URL</p></blockquote><p>URL은 네트워크 상에 있는 리소스의 위치를 알려줄 때 사용한다.<br>URL은 네트워크 부분과 경로 부분으로 나눌 수 있다.<br>스키마, 인증정보, FQDN, 포트번호까지 네트워크 경로이고, 네트워크 부분 이후를 경로 부분이라고 한다.</p><h3 id="엔드포인트"><a href="#엔드포인트" class="headerlink" title="엔드포인트"></a>엔드포인트</h3><p>클라이언트가 공개된 API를 실행하기 위해 접속하는 연결 접점을 엔드포인트라고 한다.<br>웹 API에서는 URI가 엔드포인트로 일종의 게이트웨이 역활을 한다. 엔드 포인트 뒤편에는 컨트롤러가 실제 처리를 수행하게 된다.</p><p>물리적인 장비를 사용하는 온프레미스 환경에서는 직접 장비를 설치한 후 장비의 어드레스에 접속해서 제어를 해야 한다.<br>만약 인프라 환경이 커지면 이런 방식은 운영하기 어려워진다. 특히 다른 리전에 있는 리소스를 제어해야 할 경우 어렵다.<br>API의 엔드포인트를 통한 제어는 일관되고 효율적인 작업이 가능하다.</p><blockquote><p>엔드포인트와 도메인</p></blockquote><p>AWS 엔드포인트는 IP가 아닍 도메인으로 접속하게 된다.<br>그 이유는 일단 사람이 알아보기 쉽고, 사용자로부터 IP 주소를 숨길 수 있기 때문이다.</p><p>IP 주소는 데이터 센터 장비를 옮기거나 부하 분산을 위해 변경될 수 있다. 이런 변경이 사용자에게 노출되지 않기 위해 도메인으로 접속하도록 한다.</p><h1 id="ROA-리소스-지향-아키텍쳐"><a href="#ROA-리소스-지향-아키텍쳐" class="headerlink" title="ROA (리소스 지향 아키텍쳐)"></a>ROA (리소스 지향 아키텍쳐)</h1><p>리소스 지향 아키텍처란 REST API의 사상을 기반으로 리소스 중심적인 API를 사용하는 아키텍처를 말한다.</p><h3 id="REST-기반-서비스"><a href="#REST-기반-서비스" class="headerlink" title="REST 기반 서비스"></a>REST 기반 서비스</h3><p>REST는 프로토콜이 아니라 사고방식이다. REST에는 네가지 설계 지침으로 요약될 수 있다.</p><ol><li>상태를 가지지 않는다. : 사태를 가지지 않으므로 구현이 쉽고 캐시를 사용할 수 있고 성능이 우수.</li><li>URI는 디렉터리 구조처럼 계층적 구조를 가진다. : 가독성과 리소스 구조 이해가 쉬움.</li><li>HTTP 메서드를 명시적으로 사용 : 리소스 상태 변화를 HTTP 메서드를 통해 리소스 중심으로 표현.</li><li>응답은 XML이나 JSON 사용 : 데이텨 표현을 정규화해서 다양한 언어와 기술에도 데이터가 활용될 수 있음.</li></ol><blockquote><p>비동기 멱등성, 재시도</p></blockquote><p>클라우드에서 REST API를 사용할 때는 비동기, 멱등성, 재시도 개념을 알아두자.<br>AWS같은 퍼블릭 클라우드 서비스는 인터넷으로 REST API를 제공한다. 수많은 요청을 처리할 때 반드시 순서대로 처리하지 않고 내부에서 비동기로 요청을 처리한다.<br>멱등성은 여러번 동일한 요청을 날려도 리소스에 변경이 없는 특성을 의미한다. 이런 특성은 네트워크 문제로 오류가 발생하더라도 재시도 했을 때 리소스의 정합성에 문제가 생기지 않는다는 사실을 보장하는 근거가 된다.</p><h3 id="클라우드-API-활용-예시"><a href="#클라우드-API-활용-예시" class="headerlink" title="클라우드 API 활용 예시"></a>클라우드 API 활용 예시</h3><blockquote><p>특정 네트워크에 연결된 서버를 기동하되, IP 주소는 공인 IP를 할당하고 해당 IP 주소에 대한 도메인을 DNS에 설정</p></blockquote><ol><li>사설 IP 주소를 확보하기 위해 서브넷을 만듬 -&gt; POST로 서브넷 생성 요청하고 서브넷 ID 반환</li><li>서버에 사설 IP 주소를 할당 -&gt; POST로 서브넷 ID를 함께 사설 IP 할당 요청하고 서버 ID 반환</li><li>서버에 공인 IP 주소를 할당 -&gt; PUT으로 서버 ID를 함께 해당 서버의 퍼블릭 IP 할당 요청하고 공인 IP 주소 반환</li><li>해당 공인 IP 주소에 대한 DNS 레코드를 설정 -&gt; POST로 DNS 레코드에 공인 IP 주소를 A 레코드에 할당.</li></ol><h3 id="API-이력-확인하기"><a href="#API-이력-확인하기" class="headerlink" title="API 이력 확인하기"></a>API 이력 확인하기</h3><p>AWS에서는 AWS CloudTrail로 API 호출 이력을 모니터링할 수 있다.<br>AWS에서는 AWS Config로 리소스의 구성 형태와 설정의 변경 이력을 관리한다.</p><h3 id="독자적인-API-구성하기"><a href="#독자적인-API-구성하기" class="headerlink" title="독자적인 API 구성하기"></a>독자적인 API 구성하기</h3><p>독자적으로 만든 API를 게이트웨이처럼 두어 실제 클라우드 엔드포인트나 API를 외부에서 보이지 않도록 구성할 수 있다.<br>독자적으로 구성한 IaaS 상이나 독자적으로 개발한 애플리케이션과 기존 클라우드를 연계할 때, 여러 다양한 클라우드를 조합해야 할 때 사용한다.</p><p>AWS에서는 Amazon API Gateway를 사용해서 독자적인 API를 구성할 수 있다. 독자적인 API를 정의하고 백엔드에서 오리지널 API를 펑션으로 정의해서 연동할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring MVC의 ArgumentResolver 파헤치기</title>
      <link>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/</guid>
      <pubDate>Thu, 16 Mar 2023 12:28:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;궁금한-점&quot;&gt;&lt;a href=&quot;#궁금한-점&quot; class=&quot;headerlink&quot; title=&quot;궁금한 점&quot;&gt;&lt;/a&gt;궁금한 점&lt;/h1&gt;&lt;p&gt;스프링 MVC로 컨트롤러 코드를 작성하다보면 다음과 같이 컨트롤러 메서드의 파라미터에 다양한 값을 받을 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="궁금한-점"><a href="#궁금한-점" class="headerlink" title="궁금한 점"></a>궁금한 점</h1><p>스프링 MVC로 컨트롤러 코드를 작성하다보면 다음과 같이 컨트롤러 메서드의 파라미터에 다양한 값을 받을 수 있음을 알게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/some&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getSome(<span class="keyword">final</span> Pageable pageable, <span class="meta">@RequestBody</span> <span class="keyword">final</span> String body) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 파리미터 매핑을 스프링에서 해준다!<br>하지만 어떤 경우에는 어노테이션 (<code>@RequestBody</code>, <code>@PathVariable</code>)을 넣어줘야 되는 경우도 있고, 어떤 경우에는 어노테이션을 생략해도 된다.(<code>@ModelAttribute</code>, <code>@RequestParam</code>) 심지어 어느 경우는 어노테이션이 없는 경우도 있다.(<code>Pageable</code>)</p><p>이번 기회에 날잡아서 스프링에서 어떻게 파라미터에 값을 넣어주는지, 어떤 경우에 어노테이션이 필요한 지 살펴보자.</p><h1 id="디스패처-서블릿-부터-시작한다"><a href="#디스패처-서블릿-부터-시작한다" class="headerlink" title="디스패처 서블릿 부터 시작한다"></a>디스패처 서블릿 부터 시작한다</h1><p>스프링 MVC는 프론트 컨트롤러 패턴을 사용한다. 요청을 처리하는 과정에서 중복되는 과정을 프론트 컨트롤러에서 모아서 처리한다.</p><p>우리가 궁금해하는 컨트롤러 메서드의 파라미터 처리도 디스패처 서블릿과 관련된 어디에선가 처리할 것이다!</p><h3 id="doService"><a href="#doService" class="headerlink" title="doService"></a><code>doService</code></h3><p>디스패처 서블릿은 <code>doService</code>라는 메서드를 통해 요청을 처리한다. <code>doService</code>는 <code>doDispatch</code> 메서드로 요청 처리를 넘긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       logRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">                <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                    restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">                ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a><code>doDispatch</code></h3><p><code>doDispatcher</code>는 핸들러에게 요청을 처리하도록 한다. 정확하게 말하면 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code>를 통해 핸들러 어댑터를 통해 핸들러에게 요청을 처리하도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processedRequest = checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">                mappedHandler = getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">                <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">                <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                dispatchException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">                <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">                <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">                dispatchException = <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler dispatch failed: &quot;</span> + err, err);</span><br><span class="line">            &#125;</span><br><span class="line">            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler processing failed: &quot;</span> + err, err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">                <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                    cleanupMultipart(processedRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Handler와-HandlerAdapter"><a href="#Handler와-HandlerAdapter" class="headerlink" title="Handler와 HandlerAdapter"></a>Handler와 HandlerAdapter</h1><p>위 <code>DispatcherServlet</code>의 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code> 코드가 핸들러 어댑터를 활용해서 핸들러에게 요청을 처리하도록 한다.</p><p>여기서 <code>mappedHandler</code>는 <code>HandlerExecutionChain</code>이라는 객체다. <code>HandlerExecutionChain</code>은 핸들러와 같이 실행되는 인터셉터들을 가지고 있다.<br><code>HandlerMapping</code> 인터페이스는 <code>getHandler(HttpServletRequest request)</code>를 통해 해당 요청을 처리해야하는 핸들러와 적용되야 하는 인터셉터를 포함한 <code>HandlerExecutionChain</code>을 반환한다.</p><p>여기서 <code>HandlerExecutionChain</code>은 핸들러를 <code>Object</code>로 저장하고 있다. 즉 요청을 처리할 핸들러가 어떤 메서드를 통해 요청을 처리할 줄 모른다는 뜻이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">interceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결국 <code>Object</code>로 핸들러를 전달받으면 어떤 메서드를 호출해야 할 지 알 수 없다. 특히 스프링에서는 다양한 종류의 핸들러가 존재해서 하나의 타입으로 캐스팅 할 수도 없다.<br>이래서 <code>HandlerAdapter</code>가 존재한다. <code>HandlerAdapter</code>는 전달받은 핸들러가 어떤 객체이든 해당 핸들러를 호출할 수 있는 방법을 추상화한 인터페이스이다!!!</p><h2 id="RequestMappingHandlerAdapter에서-ArgumentResolver를-관리한다"><a href="#RequestMappingHandlerAdapter에서-ArgumentResolver를-관리한다" class="headerlink" title="RequestMappingHandlerAdapter에서 ArgumentResolver를 관리한다."></a>RequestMappingHandlerAdapter에서 ArgumentResolver를 관리한다.</h2><p>그래서 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code>를 디버깅을 해보면 <code>AbstractHandlerMethodAdapter</code>의 <code>handle</code>메서드를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>handlerInternal</code>메서드는 <code>AbstractHandlerMethodAdapter</code>를 상속한 <code>RequestMappingHandlerAdapter</code>의 메서드가 호출된다.</p><p><code>RequestMappingHandelrAdapter</code>에 우리가 그렇게 찾던 <code>HandlerMethodArgumentResolver</code>를 관리하고 있다!!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ModelAndViewResolver&gt; modelAndViewResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ContentNegotiationManager</span> <span class="variable">contentNegotiationManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentNegotiationManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; requestResponseBodyAdvice = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestMappingHandlerAdapter</code>에서는 <code>argumentResolver</code>와 <code>customArgumentResolvers</code>를 가지고 있다.</p><p><code>argumentResolver</code>는 <code>getDefaultArgumentResolvers</code>메서드를 통해 초기화된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title function_">getDefaultArgumentResolvers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestPartMethodArgumentResolver</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionAttributeMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestAttributeMethodArgumentResolver</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletResponseMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RedirectAttributesMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ModelMethodProcessor</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MapMethodProcessor</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ErrorsMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionStatusMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">UriComponentsBuilderMethodArgumentResolver</span>());</span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> <span class="title class_">ContinuationHandlerMethodArgumentResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom arguments</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="literal">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PrincipalMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">true</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 보면 어노테이션을 붙여야 하는 리졸버 -&gt; 타입에 맞춰서 해주는 리졸버 -&gt; 커스텀 리졸버(<code>Pageable</code>리졸버가 해당) -&gt; 그외 모든 대상을 리졸브 대상으로 하는 리졸버 순으로 등록된다!</p><p>다시 <code>handlerInternal</code> 메서드로 돌아오면 결국 <code>invokeHandlerMethod</code>를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeHandlerMethod</code>는 <code>ServletInvocableHandlerMethod</code>를 만들어서 <code>argumentResolver</code>를 세팅해서 <code>invokeAndHandle</code>한다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">    <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">    invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p><code>@RequestMapping</code>으로 매핑된 핸들러(메서드)는 <code>RequestMappingHandlerAdapter</code>에서 처리된다!<br><code>RequestMappingHandlerAdapter</code>에서 핸들러의 인자를 리졸브하는 <code>HandlerMethodArgumentResolver</code>들을 관리한다!<br><code>RequestMappingHandlerAdapter</code>에서는 정해진 우선순위 (어노테이션이 필요한 리졸버 - 타입으로 리졸브하는 리졸버 - 커스텀 리졸버 - 모든 것을 리졸브하려는 리졸버)로 인자를 리졸브한다!<br><code>@PathVariable</code>은 어노테이션이 필요한 리졸버이다.<br><code>ServletRequest</code>나 <code>ServletResponse</code>는 타입 기반으로 리졸브하는 리졸버이다. (그래서 인자에 다른 매개변수가 필요없다!)<br><code>Pageable</code>은 커스텀 리졸버이다!! (Spring Data에서 제공하는 리졸버이다!)<br><code>@ModelAttribute</code>나 <code>@RequestParam</code> 은 어노테이션이 있어도 작동하고, 없어도 작동하는 리졸버이다!!! (가장 우선순위가 낮은 리졸버들이다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드 컴퓨팅과 API의 역할, 대표적인 컴포넌트</title>
      <link>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/</guid>
      <pubDate>Wed, 15 Mar 2023 04:52:36 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;클라우드-컴퓨팅-그게-뭐야&quot;&gt;&lt;a href=&quot;#클라우드-컴퓨팅-그게-뭐야&quot; class=&quot;headerlink&quot; title=&quot;클라우드 컴퓨팅? 그게 뭐야?&quot;&gt;&lt;/a&gt;클라우드 컴퓨팅? 그게 뭐야?&lt;/h1&gt;&lt;p&gt;클라우드 컴퓨팅은 IT 자원이 필</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="클라우드-컴퓨팅-그게-뭐야"><a href="#클라우드-컴퓨팅-그게-뭐야" class="headerlink" title="클라우드 컴퓨팅? 그게 뭐야?"></a>클라우드 컴퓨팅? 그게 뭐야?</h1><p>클라우드 컴퓨팅은 IT 자원이 필요할 때 즉시 사용할 수 있는 환경을 의미한다.</p><h2 id="공용-클라우드와-사설-클라우드를-어떤-차이가-있나"><a href="#공용-클라우드와-사설-클라우드를-어떤-차이가-있나" class="headerlink" title="공용 클라우드와 사설 클라우드를 어떤 차이가 있나?"></a>공용 클라우드와 사설 클라우드를 어떤 차이가 있나?</h2><p>목적이 다르다.<br>공용 클라우드는 IT 리소스를 제공하고 수익을 버는 것!<br>사설 클라우드는 자사에 IT 리소스를 제공하는 것이지만 수익을 위한 것이 아니다.</p><p>비용이 다르다.<br>공용 클라우드는 IT 리소스를 사용하는 만큼만 지불해서 하드웨어와 관련된 비용 문제가 없다.<br>사설 클라우드는 하드웨어 비용이 크게 든다.</p><h2 id="IaaS-PaaS-SaaS가-뭐지"><a href="#IaaS-PaaS-SaaS가-뭐지" class="headerlink" title="IaaS, PaaS, SaaS가 뭐지?"></a>IaaS, PaaS, SaaS가 뭐지?</h2><p>SaaS : 소프트웨어를 제공 -&gt; 바로 사용!<br>PaaS : 플랫폼 (개발 환경, 프레임워크)를 제공 -&gt; 바로 개발!<br>IaaS : 인프라(서버, 네트워크, 스토리지, OS)를 제공 -&gt; 자신만의 서비스 인프라 구성!</p><h2 id="컴포넌트-추상화는-뭐지"><a href="#컴포넌트-추상화는-뭐지" class="headerlink" title="컴포넌트 추상화는 뭐지?"></a>컴포넌트 추상화는 뭐지?</h2><p>클라우드 인프라 서비스는 인프라 리소스를 가상화하여 하드웨어와 분리한다.<br>리소스를 다룰 때 하드웨어 문제를 신경쓰지 않아도 된다.</p><p>컴포넌트 추상화는 하드웨어와 분리되어 사용자의 요구사항을 인프라로 구현하도록 돕는 개념이다.<br>요구사항을 하드웨어를 통해 구축하는 것보다 요구사항 자체를 컴포넌트에 전달하면 실제 구현을 알아서 적용되도록 한다.</p><p>이렇게 요구사항을 컴포넌트를 통해 추상화 해놓으면 컴포넌트를 통해 클라우드 환경에서 시스템 구축 과정을 표준화 할 수 있게 된다.</p><h2 id="클라우드-컴퓨팅을-활용하기"><a href="#클라우드-컴퓨팅을-활용하기" class="headerlink" title="클라우드 컴퓨팅을 활용하기"></a>클라우드 컴퓨팅을 활용하기</h2><p>Iaas에서 컴포넌트를 활용해서 서비스 인프라 구축을 표준화할 수 있게됐다.<br>클라우드는 API를 통해 리소스를 제어할 수 있게 한다. 이를 통해 시스템 구축부터 서버의 설치나 네트워크결 연결까지 자동화할 수 있다.</p><h1 id="클라우드의-대표적인-컴포넌트"><a href="#클라우드의-대표적인-컴포넌트" class="headerlink" title="클라우드의 대표적인 컴포넌트"></a>클라우드의 대표적인 컴포넌트</h1><h2 id="테넌트"><a href="#테넌트" class="headerlink" title="테넌트"></a>테넌트</h2><p>테넨트는 세입자다. AWS로 치면 사용자 계정이 해당된다.<br>하나의 계정에 여러 시스템을 관리할 수 있다.<br>테넨트는 비용 청구의 단위가 된다.<br>테넨트는 가상 네트워크, 가상 머신 인스턴스, 가상 스토리지 끼리만 서로 연결 가능하다.<br>또한 여러 테넌트를 합쳐서 멀티 테넨트를 하나의 테넨트로 쓸 수 있다. (AWS Organization)</p><h2 id="리전"><a href="#리전" class="headerlink" title="리전"></a>리전</h2><p>클라우드 인프라를 지역단위로 묶어서 관리하기 위해 등장한 개념이다.<br>리전은 각각 독립된 환경이라 여러 리전을 걸친 가상 네트워크를 구현할 수 없다.<br>즉 가상 네트워크는 리전별로 독립된 형태로 만들어진다. 이런 가상 네트워크를 VPC라고 한다. 한 리전에 여러 VPC 가능하다.</p><h3 id="다른-리전에-DR"><a href="#다른-리전에-DR" class="headerlink" title="다른 리전에 DR"></a>다른 리전에 DR</h3><p>다만 다른 리전에 DR 환경을 구축할 수는 있다.</p><blockquote><p>DR : disaster recovery 서울에 재난이 생기면 시드니에 동일한 환경을 가진 시스템을 작동시키는 것.</p></blockquote><p>이때 퍼블릭 IP의 범위가 달라질 수 있어서 DNS에 IP를 업데이트 해줘야 할 수 있다.<br>환경 뿐만 아니라 데이터도 다른 리전에 역제해놔야 한다.<br>이때 오브젝트 리소스를 활용한다. 오브젝트 리소스는 리전에 종속되지 않기 때문이다!</p><h2 id="가용영역"><a href="#가용영역" class="headerlink" title="가용영역"></a>가용영역</h2><p>리전이 지역이라면 가용 영역은 그 리전에 속한 데이터 센터라고 이해하자.<br>(AWS의 <code>ap-northeast-2a</code> 같은 것, 오픈 스택에서는 데이터 센터 안에서 가용 영역을 더 나눌 수 있다고 한다.)<br>다른 가용영역에 있는 가상 머신 인스턴스와 블록 스토리지는 서로 연결할 수 없다.<br>(물론 네트워크를 통한 연결은 된다. 블록 스토리지를 마운트 하는 행위 같은 연결이 안된다는 의미다.)</p><h1 id="네트워크-리소스"><a href="#네트워크-리소스" class="headerlink" title="네트워크 리소스"></a>네트워크 리소스</h1><h2 id="라우터-그냥-공유기"><a href="#라우터-그냥-공유기" class="headerlink" title="라우터 (그냥 공유기)"></a>라우터 (그냥 공유기)</h2><p>독립된 가상 네트워크(VPC)는 공유기로 구성한 LAN과 같이 외부의 접근이 차단된 네트워크와 비슷하다.<br>가정용 LAN을 인터넷과 연결하기 위해서는 인터넷 라우터가 필요하다.<br>클라우드 환경에서도 가상 네트워크와 물리적인 외부 네트워크를 연결하는 가상 라우터가 있어야 한다.<br>가상 네트워크에서는 LAN과 같이 프라이빗 IP주소를 사용한다.<br>외부 네트워크와 통신할 때는 가상 라우터의 NAT 기능을 사용해서 Public IP로 변환한다.<br>(NAT는 <a href="https://yangdongjue5510.github.io/2021/11/17/cs/network/network7/">네트워크 계층 포스트</a>를 통해 알아보자.)</p><p>AWS에서 VPC를 만들면 Internet Gateway가 생기는데, Internet Gateway가 라우터 역할을 한다.</p><h2 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h2><p>가상 스위치는 가상 라우터와 가상 머신 인스턴스의 가상 NIC가 연결되는 지점<br>가상 스위치는 물리 스위치와 다르게 포트 제한이 없다.<br>(물리 스위치는 포트가 부족하면 허브를 두거나 스위치를 더 둔다.)<br>가상 스위치는 가상 NIC를 써서 포트 문제를 해결한다. (AWS에서는 ENI. 인스턴스가 올라갈 때 ENI가 할당된다)<br>가상 인스턴스와 연결해야 할 때 포트가 추가 → 해당 포트에 서브넷 범위 안에서 사용할 수 있는 IP 주소 할당 → DHCP 방식으로 가상 NIC에 연결됨</p><h2 id="서브넷"><a href="#서브넷" class="headerlink" title="서브넷"></a>서브넷</h2><p>가상 스위치에 해당하는 컴포넌트를 서브넷이라고 한다.<br>가용 영역 별로 서브넷을 구성 할 수 있다.<br>가상 스위치에 하나의 서브넷이 할당된다.<br>서브넷은 가상 머신 인스턴스가 사용할 수 있는 사설 IP 주소의 범위</p><p>AWS는 가상 스위치과 서브넷을 합쳐서 서브넷이라고 부른다.<br>AWS에서는 하나의 가상 스위치(서브넷)이 하나의 가용 영있에 할당.</p><p>라우터는 집이고 서브넷은 집안에 방이라고 생각하면 된다.</p><h2 id="공인-IP-주소"><a href="#공인-IP-주소" class="headerlink" title="공인 IP 주소"></a>공인 IP 주소</h2><p>사설 IP주소를 가상 라우터의 NAT 기능을 통해 공인 IP(퍼블릭)로 변환하는 방식<br>이걸 IP 마스커레이딩이라 한다. (외부로 통신할 때 나의 사설 IP를 사설 라우터의 공인 IP로 변환!)<br>이런 마스커레이딩은 내부에서 외부로 통신할 수는 있지만, 외부에서 내부의 서버로 통신은 안된다!!</p><p>결국 모든 사설 IP(private ip)를 같은 공인 IP로 변환하여 외부 네트워크에 통신한다.<br>이 방식은 private ip가 외부 접근은 되지만 외부에서 사설 ip접근은 안된다.</p><h3 id="AWS의-엘라스틱-IP"><a href="#AWS의-엘라스틱-IP" class="headerlink" title="AWS의 엘라스틱 IP"></a>AWS의 엘라스틱 IP</h3><p>미리 개별적으로 확보해둔 퍼블릭 아이피를 라우터가 가상 인스턴스에 할당 (즉 공인 IP를 private ip에 매핑하는 방식)<br>내부 → 외부, 외부 → 내부 모두 가능하다.<br>단 리전마다 따로 확보해야 한다. 다른 리전에서 재사용 불가.</p><h2 id="시큐리티-그룹"><a href="#시큐리티-그룹" class="headerlink" title="시큐리티 그룹"></a>시큐리티 그룹</h2><p>가상 머신 인스턴스가 주고받을 네트워크 패킷을 필터링하는 기능<br>아이피 포트 뿐만 아니라 프로토콜 종류를 통해 필터링도 가능하다.<br>여러개의 가상 스위치에 접속하고 싶으면 여러 가상 NIC가 있어야되고 각 가상 NIC는 스위치 포트에 접속하러 갈 때 시큐리티 그룹을 설정해줄 수 있다.</p><p>시큐리티 그룹과 비슷한 방식으로 라우팅 테이블에서도 필터링을 해줄 수 있다.<br>다만 라이퉁 테이블은 서브넷에 접속하기 전에 작동하고, 시큐리티 그룹은 인스턴스에 접근하기 전에 작동한다.</p><h1 id="서버-리소스"><a href="#서버-리소스" class="headerlink" title="서버 리소스"></a>서버 리소스</h1><h2 id="템플릿-이미지"><a href="#템플릿-이미지" class="headerlink" title="템플릿 이미지"></a>템플릿 이미지</h2><p>가상 머신 인스턴스를 기동하기 위해 게스트 OS가 설치된 기동 디스크가 필요하다.<br>이 기동디스크를 만들어주는 애가 템플릿 이미지.<br>템플릿 이미지가 다운로드 되서 가상 디스크 형태로 만들어지고 가상 머신 인스턴스가 가상 디스크를 연결해서 사용</p><p>루트 디스크와 임시 디스크는 가상 머신 인스턴스를 종료하면 날라간다. (남기고 싶으면 블록 스토리지를 사용할 수 있다.)<br>만약 루트 디스크에 저장된 어플리케이션을 보존하고 싶으면 스냅샷을 남기자. (EC2로 DB를 운영할 경우 매일 데이터베이스의 스냅샷을 남길 수 있다.)<br>스냅샷은 루트 디스크를 복제하고 템플릿 이미지로 만든다.</p><h2 id="네트워크-접속과-시큐리티-그룹"><a href="#네트워크-접속과-시큐리티-그룹" class="headerlink" title="네트워크 접속과 시큐리티 그룹"></a>네트워크 접속과 시큐리티 그룹</h2><p>인스턴스의 가상 NIC가 네트워크와 연결되려면 가상 스위치에 연결되어 있어야 한다! (그래야 가상 스위치가 가상 라우터와 연결이 되니까)</p><p>인스턴스 하나에 여러 NIC를 연결할 수 있다.<br>다만 컨테이너를 인스턴스에 사용할 때는 <a href="https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/container-instance-eni.html">ECS ENI Trunking</a>을 유의하자.</p><p>시큐리티 그룹은 NIC에 적용된다! 즉 한 인스턴스라도 NIC마다 다르게 시큐리티 그룹을 적용할 수 있다.</p><h2 id="로그인-인증과-키페어"><a href="#로그인-인증과-키페어" class="headerlink" title="로그인 인증과 키페어"></a>로그인 인증과 키페어</h2><p>기본적으로 SSH의 공개 키 인증 방식이 사용한다.<br>테넌트 이용자는 접속 전용 키페어를 만든다.<br>공개키는 클라우드 환경에 등록 &amp; 개인 키는 사용자가 다운로드<br>가상 머신 인스턴스에 템플릿 이미지로 게스트 os를 설치할 때 공개키도 같이 설정된다.</p><h2 id="블록-스토리지"><a href="#블록-스토리지" class="headerlink" title="블록 스토리지"></a>블록 스토리지</h2><p>가상 머신 인스턴스가 종료되어도 내용을 보존하는 영속적인 디스크 영역(AWS에서는 EBS라고 부름.)<br>가상 머신 인스턴스는 어플리케이션을 가동하는 가상 컴퓨터.<br>가상 머신 인스턴스에 블록 스토리지를 마운트 해서 보통의 물리적 디스크 디바이스처럼 쓸 수 있게 된다.<br>블록 스토리지는 여러 가상 머신 인스턴스에도 마운트할 수 있다.</p><h3 id="블록-스토리지에-있는-게스트-OS로-가상-머신-인스턴스를-가동하는-방법"><a href="#블록-스토리지에-있는-게스트-OS로-가상-머신-인스턴스를-가동하는-방법" class="headerlink" title="블록 스토리지에 있는 게스트 OS로 가상 머신 인스턴스를 가동하는 방법."></a>블록 스토리지에 있는 게스트 OS로 가상 머신 인스턴스를 가동하는 방법.</h3><p>AWS에서는 EBS Boot<br>미리 볼륨을 만들어 놓고 템플릿 이미지를 복제해서 가상 머신 인스턴스에 연결.<br>다른 가상 머신 인스턴스에 연결해도 이어서 할 수 잇음</p><h2 id="오브젝트-스토리지-리소스"><a href="#오브젝트-스토리지-리소스" class="headerlink" title="오브젝트 스토리지 리소스"></a>오브젝트 스토리지 리소스</h2><p>파일 단위로 데이터를 저장하는 데이터 스토어.<br>HTTP, HTTPS로 사용하는 파일서버<br>테넨트가 생성한 S3 버킷은 모든 리전과 가용영역에서 접근 가능!<br>컨테이너(버킷)은 디렉토리처럼 계층적 구조는 되지 않지만 파일 이름을 디렉토리처럼(abc&#x2F;file) 묘사해서 비슷한 효과를 낼수 잇다.<br>키와 값으로 메타 데이터를 부여할 수도 있다.</p><h3 id="버저닝"><a href="#버저닝" class="headerlink" title="버저닝"></a>버저닝</h3><p>컨테이너에서 관리하는 오브젝트에 버전 번호를 붙여서 관리하는 기능.<br>롤백같은 기능을 수행할 수 있다.</p><h3 id="백업"><a href="#백업" class="headerlink" title="백업"></a>백업</h3><p>블록 스토리지의 볼륨을 여러 블록으로 분할해서 하나의 파일 형태로 간주하여 오브젝트 스토리지에 저장.<br>리전이나 가용영역을 뛰어넘어서 복원할 수 있다.</p><h1 id="웹-애플리케이션-시스템-구축-예시"><a href="#웹-애플리케이션-시스템-구축-예시" class="headerlink" title="웹 애플리케이션 시스템 구축 예시"></a>웹 애플리케이션 시스템 구축 예시</h1><h2 id="여러-가용-영역으로-가용성-확보"><a href="#여러-가용-영역으로-가용성-확보" class="headerlink" title="여러 가용 영역으로 가용성 확보"></a>여러 가용 영역으로 가용성 확보</h2><p>AWS는 VPC별로 가상 네트워크가 만들어지고, 가상 네트워크 속 가용 영역 별로 가상 스위치(서브넷)이 생기고,<br>각 사용 용도에 따라 네트워크를 분리하기 위해 가상 스위치(서브넷)를 만들어서 통신할 수 있다.<br>가상 머신 인스턴스에 해당 스위치(서브넷)를 통해서만 통신할 수 있도록 하면 접근을 제한 할수 잇다.<br>다른 가용영역에 현재 가용영역과 동일한 환경을 구축해놓고 문제가 생기면 해당 가용영역으로 접근하도록 로드밸런싱을 해주거나 DNS 설정을 바꿔줘야 한다.<br><a href="https://aws.amazon.com/ko/builders-library/static-stability-using-availability-zones/">가용 영역을 사용한 정적 안정성</a></p><h2 id="오브젝트-스토리지로-데이터-지키기"><a href="#오브젝트-스토리지로-데이터-지키기" class="headerlink" title="오브젝트 스토리지로 데이터 지키기"></a>오브젝트 스토리지로 데이터 지키기</h2><p>DB 서버가 관리하는 데이터를 블록 스토리지 볼륨에 저장시키면 가상 머신 인스턴스가 잘못되어도 데이터를 지킬 수 있다.<br>근데 블록 스토리지가 잘못될 경우를 예상해서 이마저도 오브젝트 스토리지에 백업해두면 된다.<br>그런데 볼륨 백업은 오브젝트 스토리지로 전송해야 되니까 좀 느릴 순 있다.</p><p>백업하기 전에는 볼륨을 가상 머신 인스턴스에서 분리해야 됨.<br>이때는 당연히 디비 서버가 요청을 처리하지 못한다.<br>그러면 볼륨의 스냅샷을 떠서 백업하도록 하면 된다.<br>스냅샷을 만들때도 인스턴스에서 볼륨을 분리하지만 시간이 적게 든다.</p><p>가상 머신 인스턴스에 블록 스토리지를 연결해두고 오브젝트 스토리지에 백업해둔다.<br>가용 영역 전환할 때 해당 가용 영역의 블록 스토리지에 오브젝트 스토리지의 데이터를 통해 데이터 구축 가능하다.</p><p>다른 방법으로는 데이터베이스가 네트워크를 통해 동기화하는 기능을 사용할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>F12 서비스 의존성 개선 리팩토링</title>
      <link>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/</guid>
      <pubDate>Sun, 12 Mar 2023 12:35:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;F12 서비스 링크(&lt;a href=&quot;https://f12.app/&quot;&gt;https://f12.app/&lt;/a&gt;)&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/87690744/224546124-003</description>
        
      
      
      
      <content:encoded><![CDATA[<p>F12 서비스 링크(<a href="https://f12.app/">https://f12.app/</a>)<br><img src="https://user-images.githubusercontent.com/87690744/224546124-0037780b-5215-4073-a1d4-dcd9dff96703.png"></p><h1 id="기존-상황"><a href="#기존-상황" class="headerlink" title="기존 상황"></a>기존 상황</h1><p>F12 서비스 백엔드 아키텍처는 도메인 개념 별로 의존성을 그려보면 다음과 같다.<br><img src="https://user-images.githubusercontent.com/87690744/224546691-84ff0950-5692-4212-aa7c-bbeaba9e2ee0.png"><br>총 세가지 양방향 의존이 생긴다. 이런 상황이면 Review에 변경이 생기면 Product -&gt; InventoryProduct -&gt; Member -&gt; Following 까지 변경에 따른 영향이 생길 수 있다.</p><h1 id="Member-lt-–-gt-InventoryProduct"><a href="#Member-lt-–-gt-InventoryProduct" class="headerlink" title="Member &lt;–&gt; InventoryProduct"></a>Member &lt;–&gt; InventoryProduct</h1><h3 id="Member의-상황"><a href="#Member의-상황" class="headerlink" title="Member의 상황"></a><code>Member</code>의 상황</h3><p>회원을 의미한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;github_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gitHubId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;image_url&quot;, length = 65535, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;registered&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> registered;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;career_level&quot;)</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> CareerLevel careerLevel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;job_type&quot;)</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> JobType jobType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;follower_count&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> followerCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">InventoryProducts</span> <span class="variable">inventoryProducts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InventoryProducts</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;role&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> Role.USER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Member</code>의 엔티티는 <code>InventoryProduct</code> 도메인에 해당하는 <code>InventoryProducts</code>를 멤버로 가지고 있다. <code>InventoryProducts</code>를 통해 사용자의 프로필 장비를 조회할 수 있다.</p><p>F12 서비스에서 다음과 같은 프로필을 구현할 때 사용자의 회원정보와 그 사용자의 프로필 장비를 같이 보여주기 때문에 멤버 변수로 의존하게 됐다.<br><img src="https://user-images.githubusercontent.com/87690744/224551081-b73bb136-a654-48b5-a30d-330b30853032.png"><br>즉 Member를 조회할 때 InventoryProduct를 함께 조회해서 위와 같은 프로필을 만들기 용이하기 위해 Member가 InventoryProduct에 의존한다.</p><p>그리고 <code>Member</code>의 서비스 로직에서 사용자들의 프로필을 만들 때 해당 회원들의 인벤토리 장비도 조회해와야 한다.아래가 사용자들의 프로필을 만드는 서비스 로직이다. <code>Member</code>를 조회해오고 그에 해당하는 <code>InventoryProduct</code>를 조회해서 조립하고 있다. 이렇게 <code>Member</code>와 <code>InventoryProduct</code>를 따로 조회해서 조립하면 <code>InventoryProductRepository</code>에 의존성이 생긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FollowingRepository followingRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MemberService</span><span class="params">(<span class="keyword">final</span> MemberRepository memberRepository, <span class="keyword">final</span> FollowingRepository followingRepository,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memberRepository = memberRepository;</span><br><span class="line">        <span class="built_in">this</span>.followingRepository = followingRepository;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="keyword">public</span> MemberPageResponse <span class="title function_">findBySearchConditions</span><span class="params">(<span class="meta">@Nullable</span> <span class="keyword">final</span> Long loggedInId,</span></span><br><span class="line"><span class="params">                                                     <span class="keyword">final</span> MemberSearchRequest memberSearchRequest,</span></span><br><span class="line"><span class="params">                                                     <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Slice&lt;Member&gt; slice = findBySearchConditions(memberSearchRequest, pageable);</span><br><span class="line">        <span class="keyword">if</span> (slice.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> MemberPageResponse.ofByFollowingCondition(slice, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setInventoryProductsToMembers(slice);</span><br><span class="line">        <span class="keyword">if</span> (isNotLoggedIn(loggedInId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> MemberPageResponse.ofByFollowingCondition(slice, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Following&gt; followings = followingRepository.findByFollowerIdAndFollowingIdIn(loggedInId,</span><br><span class="line">                extractMemberIds(slice.getContent()));</span><br><span class="line">        <span class="keyword">return</span> MemberPageResponse.of(slice, followings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Slice&lt;Member&gt; <span class="title function_">findBySearchConditions</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest,</span></span><br><span class="line"><span class="params">                                                 <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CareerLevel</span> <span class="variable">careerLevel</span> <span class="operator">=</span> parseCareerLevel(memberSearchRequest);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobType</span> <span class="variable">jobType</span> <span class="operator">=</span> parseJobType(memberSearchRequest);</span><br><span class="line">        <span class="keyword">if</span> (memberSearchRequest.getQuery() == <span class="literal">null</span> &amp;&amp; careerLevel == <span class="literal">null</span> &amp;&amp; jobType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memberRepository.findWithOutSearchConditions(pageable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memberRepository.findWithSearchConditions(memberSearchRequest.getQuery(), careerLevel,</span><br><span class="line">                jobType, pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInventoryProductsToMembers</span><span class="params">(<span class="keyword">final</span> Slice&lt;Member&gt; slice)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;InventoryProduct&gt; mixedInventoryProducts = inventoryProductRepository.findWithProductByMembers(</span><br><span class="line">                slice.getContent());</span><br><span class="line">        <span class="keyword">for</span> (Member member : slice.getContent()) &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;InventoryProduct&gt; memberInventoryProducts = mixedInventoryProducts.stream()</span><br><span class="line">                    .filter(it -&gt; it.getMember().isSameId(member.getId()))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            member.updateInventoryProducts(memberInventoryProducts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JobType <span class="title function_">parseJobType</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobTypeConstant</span> <span class="variable">jobTypeConstant</span> <span class="operator">=</span> memberSearchRequest.getJobType();</span><br><span class="line">        <span class="keyword">if</span> (jobTypeConstant == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jobTypeConstant.toJobType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CareerLevel <span class="title function_">parseCareerLevel</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CareerLevelConstant</span> <span class="variable">careerLevelConstant</span> <span class="operator">=</span> memberSearchRequest.getCareerLevel();</span><br><span class="line">        <span class="keyword">if</span> (careerLevelConstant == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> careerLevelConstant.toCareerLevel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; <span class="title function_">extractMemberIds</span><span class="params">(<span class="keyword">final</span> List&lt;Member&gt; members)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> members.stream()</span><br><span class="line">                .map(Member::getId)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 생긴 의존성은 <code>MemberRepository</code>에서 <code>Member</code>를 조회할 때 Left join 기반으로 한 fetch join으로 연관된 엔티티를 한번에 읽어오게 하면 서비스 로직에서 <code>InventoryProductRepository</code>에 의존하지 않고 회원들의 인벤토리 장비를 가져올 수 있다.</p><blockquote><p>여기서 한가지 포인트를 알고가자.<br>fetch join으로 한번에 같이 조회해서 서비스 로직에서 <code>InventoryProduct</code> 의존성을 제거할 수 있다. 하지만 <code>Member</code> 엔티티에서 <code>InventoryProduct</code>를 멤버 변수로 의존하게 된다. 또 <code>MemberRepository</code>에서 <code>InventoryProduct</code>를 알게 된다.<br><code>Member</code> 엔티티에서 <code>InventoryProduct</code> 의존성을 제거하면 <code>MemberService</code>에서 <code>Member</code>를 조회해올 때 <code>InventoryProduct</code>를 한번에 조회할 수 없고 <code>InventoryProductRepository</code>에 의존하게 된다.</p></blockquote><p><code>Member</code> 입장에서 보면 프로필을 만드는 로직 때문에 서비스 레이어 혹은 엔티티에서 <code>InventoryProduct</code>에 의존하게 된다.</p><h3 id="InventoryProduct의-상황"><a href="#InventoryProduct의-상황" class="headerlink" title="InventoryProduct의 상황"></a><code>InventoryProduct</code>의 상황</h3><p>회원이 리뷰를 남긴 제품을 의미한다.인벤토리 장비가 프로필 장비인 지 구분할 수 있다. 리뷰를 남긴 제품은 자동으로 회원의 인벤토리 장비가 된다.<br>InventoryProduct는 DB 테이블로 생각하면 Member와 Product의 다대다 매핑 테이블 역할도 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProduct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;selected&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> selected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 상으로는 <code>Member</code>와 <code>Product</code>에 의존한다. <code>Product</code> 의존성은 <code>InventoryProduct</code>가 대부분 장비의 정보를 함께 조회해서 멤버 변수로 가져도 괜찮다.<br>하지만 <code>Member</code>가 문제다. <code>InventoryProduct</code>는 <code>Member</code>를 사용하지 않는데 멤버 변수로 갖고 있다.<br>이런 불필요한 직접 참조는 id로 간접 참조하면 쉽게 해결할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProduct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;selected&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> selected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long memberId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 서비스 레이어에서 <code>Member</code>에 의존하고 있다는 점이다. 특정 사용자id로 해당 사용자의 인벤토리 장비를 조회해야 하는 경우 사용자 Id가 유효한 지 확인해야 한다.<br>그래서 다음과 같은 의존이 생긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProductService</span> &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="keyword">public</span> InventoryProductsResponse <span class="title function_">findByMemberId</span><span class="params">(<span class="keyword">final</span> Long memberId)</span> &#123;</span><br><span class="line">        validateMember(memberId);</span><br><span class="line">        <span class="keyword">final</span> List&lt;InventoryProduct&gt; inventoryProducts = inventoryProductRepository.findWithProductByMemberId(memberId);</span><br><span class="line">        <span class="keyword">return</span> InventoryProductsResponse.from(inventoryProducts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateMember</span><span class="params">(<span class="keyword">final</span> Long memberId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memberRepository.existsById(memberId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MemberNotFoundException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 의존을 AOP로 분리할 수는 있을 것 같다. 하지만 그렇게 하면 서비스 로직이 여러군데 퍼지는 것 같고 실수할 여지가 많을 것 같다.<br>혹은 DIP를 적용해서 <code>MemberValidator</code>라는 인터페이스를 <code>InventoryProduct</code> 패키지에 두고, <code>MemberValidator</code>의 구현체는 <code>Member</code>에 두고 빈 등록하여 <code>InventoryService</code>는 <code>MemberValidator</code> 인터페이스를 주입받아서 사용하면 <code>Member</code>에게 의존하지 않고 <code>Member</code>가 <code>InventoryProduct</code>에 의존하게 할 수 있다.</p><p>하지만 <code>InventoryProduct</code>이 <code>Member</code>에 의존하는게 잘못된 걸까?<br>의미 상 <code>InventoryProduct</code>는 특정 회원의 인벤토리 장비이다. <code>InventoryProduct</code>의 로직 상 <code>Member</code>에게 의존해서 협력하는 게 자연스럽고, 이 의존을 없애거나 역전하기 위해 복잡도를 높이는 게 오히려 코드를 이해하는 데 어려울 수 있다.</p><h2 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h2><p>현재까지 문제점을 정리하자면 다음과 같다.<br><code>Member</code>는 프로필 관련 기능 때문에 <code>InventoryProduct</code>를 의존할 수 밖에 없다. (서비스 레이어 혹은 엔티티)<br><code>InventoryProduct</code>는 <code>Member</code> 의존성을 다양한 방법으로 제거할 수 는 있지만 의미 상 의존하는게 자연스럽고 의존을 제거하면 복잡도가 높아질 것 같다.</p><p>그렇다면 <code>Member</code>에서 프로필 관련 기능을 아예 다른 패키지로 추출하면 어떨까?<br><code>profile</code> 이라는 새로운 패키지를 도입해서 프로필 관련 기능을 모을 수 있지 않을까?</p><p>프로필 관련 로직을 <code>profile</code>에 모으면 다음과 같이 의존성이 그려진다.<br><img src="https://user-images.githubusercontent.com/87690744/225565744-0291cac3-7079-4033-a0c2-e2675fb6fcc8.png"></p><p>한번 로직을 모아보자!</p><h3 id="도메인"><a href="#도메인" class="headerlink" title="도메인"></a>도메인</h3><p>먼저 프로필 기능에 필요한 도메인 클래스를 만들어보자. 프로필은 특정 대상이 팔로잉하는지 알려줄 수 있어야 하고, 대표장비와 회원정보를 알려줄 수 있어야 한다.</p><p>여기서 중요한 점은 프로필의 의미이다. 프로필은 아래 그림을 보면 알 수 있듯이, 특정 회원의 회원정보와 대표장비 그리고 보는 사람이 팔로우 했는지를 알려주는 개념이다.<br>즉 프로필은 보는 사람에 따라 팔로우 여부를 상대적으로 가지게 된다는 사실을 명심하자.</p><p><img src="https://user-images.githubusercontent.com/87690744/224551081-b73bb136-a654-48b5-a30d-330b30853032.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Profile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Member member;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProducts inventoryProducts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFollowing;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Profiles</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Profile&gt; profiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Profiles</span><span class="params">(<span class="keyword">final</span> List&lt;Profile&gt; profiles)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.profiles = profiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Profiles <span class="title function_">of</span><span class="params">(<span class="keyword">final</span> List&lt;Member&gt; members, <span class="keyword">final</span> List&lt;InventoryProduct&gt; inventoryProductsOfMembers,</span></span><br><span class="line"><span class="params">                              <span class="keyword">final</span> List&lt;Following&gt; followingRelations)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Long, List&lt;InventoryProduct&gt;&gt; inventoryProductsGroups = groupByMemberId(inventoryProductsOfMembers);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Profile&gt; profiles = members.stream()</span><br><span class="line">                .map(member -&gt; createProfile(member, inventoryProductsGroups, followingRelations))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Profiles</span>(profiles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="서비스-코드"><a href="#서비스-코드" class="headerlink" title="서비스 코드"></a>서비스 코드</h3><p>이제 기존에는 <code>MemberService</code>에서 수행하던 프로필 로직(<code>Member</code>조회하고 <code>InventoryProduct</code> 조회해서 합치기)를 <code>ProfileService</code>에서 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FollowingRepository followingRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProfileService</span><span class="params">(<span class="keyword">final</span> MemberRepository memberRepository,</span></span><br><span class="line"><span class="params">                          <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository,</span></span><br><span class="line"><span class="params">                          <span class="keyword">final</span> FollowingRepository followingRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memberRepository = memberRepository;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">        <span class="built_in">this</span>.followingRepository = followingRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PagedProfilesResponse <span class="title function_">findBySearchConditions</span><span class="params">(<span class="meta">@Nullable</span> <span class="keyword">final</span> Long loggedInId,</span></span><br><span class="line"><span class="params">                                                        <span class="keyword">final</span> ProfileSearchRequest profileSearchRequest,</span></span><br><span class="line"><span class="params">                                                        <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Slice&lt;Member&gt; slice = findBySearchConditions(profileSearchRequest, pageable);</span><br><span class="line">        <span class="keyword">if</span> (slice.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> PagedProfilesResponse.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Profiles</span> <span class="variable">profiles</span> <span class="operator">=</span> createProfiles(loggedInId, slice.getContent());</span><br><span class="line">        <span class="keyword">return</span> PagedProfilesResponse.of(slice.hasNext(), profiles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="의존성을-정리하고-나면"><a href="#의존성을-정리하고-나면" class="headerlink" title="의존성을 정리하고 나면,,"></a>의존성을 정리하고 나면,,</h3><p>이제 <code>Member</code>는 회원 정보 관리와 팔로우 관련 기능만 수행한다.<br><code>InventoryProduct</code>는 인벤토리 장비 추가, 삭제, 대표장비 수정 관련 기능만 수행하게 된다.<br><code>Profile</code>은 <code>Member</code>와 <code>InventoryProduct</code>를 기반으로 프로필 생성하는 기능을 수행하게 된다.</p><p>이전보다 각 도메인들의 역할이 간단명료해졌다!</p><h1 id="Product-lt-–-gt-InventoryProduct-Review"><a href="#Product-lt-–-gt-InventoryProduct-Review" class="headerlink" title="Product &lt;–&gt; InventoryProduct, Review"></a>Product &lt;–&gt; InventoryProduct, Review</h1><h2 id="Product의-상황"><a href="#Product의-상황" class="headerlink" title="Product의 상황"></a>Product의 상황</h2><p>리뷰 대상인 장비를 의미한다. 엔티티만 살펴보면 특별히 다른 도메인에 의존하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_IMAGE_URL_LENGTH</span> <span class="operator">=</span> <span class="number">15000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;image_url&quot;, nullable = false, length = MAXIMUM_IMAGE_URL_LENGTH)</span></span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;review_count&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> reviewCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;total_rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> totalRating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;avg_rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> rating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;category&quot;, nullable = false, length = 8)</span></span><br><span class="line">    <span class="meta">@Enumerated(value = EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 <code>Product</code> 도메인은 서비스 레이어에서 여러 도메인들에 의존한다.<br>특히 <code>Product</code> 엔티티가 제거되면 해당 장비에 대한 리뷰와 해당 장비를 인벤토리 장비 설정한 내역도 모두 제거해야 된다.<br>그래서 <code>ProductService</code>에서는 다음과 같이 다른 도메인의 레포지토리를 의존한 경우가 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="comment">//... 생략</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Product</span> <span class="variable">target</span> <span class="operator">=</span> productRepository.findById(productId)</span><br><span class="line">                .orElseThrow(ProductNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">        reviewRepository.deleteByProduct(target);</span><br><span class="line">        inventoryProductRepository.deleteByProduct(target);</span><br><span class="line">        productRepository.delete(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InventoryProduct와-Review의-상황"><a href="#InventoryProduct와-Review의-상황" class="headerlink" title="InventoryProduct와 Review의 상황"></a>InventoryProduct와 Review의 상황</h3><p><code>InventoryProduct</code>의 경우, 회원이 리뷰를 남긴 장비라는 의미이기 때문에 항상 제품 정보를 함께 보여줘야 한다. 그래서 엔티티에서 멤버로 <code>Product</code>를 의존하고, 서비스 레이어에서도 <code>Product</code>가 유효한 지 체크하는 로직도 있다.</p><p><code>Review</code>의 경우, 회원이 장비에 남긴 리뷰를 의미한다. 리뷰도 <code>inventoryProduct</code>와 비슷하게 제품 정보를 같이 보여줘야 하는 경우가 많아서 엔티티에서 멤버로 <code>Product</code>를 의존하고, 서비스 레이어에서도 <code>Product</code> 유효성 검증을 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Review</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;content&quot;, nullable = false, length = MAXIMUM_CONTENT_LENGTH)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;created_at&quot;, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdAt;</span><br><span class="line">    <span class="comment">//생략</span></span><br></pre></td></tr></table></figure><h2 id="해결책-1"><a href="#해결책-1" class="headerlink" title="해결책"></a>해결책</h2><p>지금까지 파악한 문제는 <code>InventoryProduct</code>, <code>Review</code>는 <code>Product</code>와 조회되는 일이 많고 <code>Product</code> 검증해야 하는 로직 때문에 <code>Product</code>에 의존하고 있었다. <code>Product</code>는 장비 삭제할 때 해당하는 <code>InvnentoryProduct</code>와 <code>Review</code>를 제거해야 해서 의존성이 생겼었다.</p><p>이런 문제는 <code>Product</code> 삭제 시, 이벤트를 발행해서 해당 이벤트를 처리하는 이벤트 리스너를<code>Review</code>와 <code>InvnetoryProduct</code>에 추가하는 방식으로 해결했다.</p><h3 id="이벤트-구현"><a href="#이벤트-구현" class="headerlink" title="이벤트 구현"></a>이벤트 구현</h3><p><code>product</code> 패키지에 장비가 삭제됐음을 알리는 이벤트를 만들어본다. <code>ApplicationEvent</code>를 상속해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDeletedEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductDeletedEvent</span><span class="params">(<span class="keyword">final</span> Object source, <span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getProductId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>ProductDeletedEvent</code>를 장비 삭제 당시에 발행하도록 해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProductRepository productRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Product</span> <span class="variable">target</span> <span class="operator">=</span> productRepository.findById(productId)</span><br><span class="line">                .orElseThrow(ProductNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">        productRepository.delete(target);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProductDeletedEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductDeletedEvent</span>(<span class="built_in">this</span>, productId);</span><br><span class="line">        eventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationEventPublisher</code>를 주입받고 생성한 이벤트를 발행하도록 한다.</p><h3 id="이벤트-리스너-구현하기"><a href="#이벤트-리스너-구현하기" class="headerlink" title="이벤트 리스너 구현하기"></a>이벤트 리스너 구현하기</h3><p>이제 <code>review</code>와 <code>inventoryProduct</code> 패키지에 <code>ProductDeletedEvent</code>를 처리하는 이벤트 리스너를 구현해보자. <code>@EventListener</code>를 이벤트 처리하는 메서드에 붙여주고, 매개변수를 처리할 이벤트로 해놓는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReviewEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReviewEventListener</span><span class="params">(<span class="keyword">final</span> ReviewRepository reviewRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reviewRepository = reviewRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> ProductDeletedEvent event)</span> &#123;</span><br><span class="line">        reviewRepository.deleteByProductId(event.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProductEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InventoryProductEventListener</span><span class="params">(<span class="keyword">final</span> InventoryProductRepository inventoryProductRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> ProductDeletedEvent event)</span> &#123;</span><br><span class="line">        inventoryProductRepository.deleteByProductId(event.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>양방향 의존성을 새로운 개념의 패키지 추가하기, 이벤트 퍼블리싱 방식으로 패키지 양방향 의존을 해결했다.<br>해결한 뒤 의존성을 그려보면 다음과 같다.<br><img src="https://user-images.githubusercontent.com/87690744/225596574-c91abcb4-3a9d-460c-8d77-add194526341.png"></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링의 프록시</title>
      <link>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/</guid>
      <pubDate>Thu, 23 Feb 2023 13:01:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;프록시-패턴의-종류&quot;&gt;&lt;a href=&quot;#프록시-패턴의-종류&quot; class=&quot;headerlink&quot; title=&quot;프록시 패턴의 종류&quot;&gt;&lt;/a&gt;프록시 패턴의 종류&lt;/h1&gt;&lt;p&gt;간단하게 프록시 패턴을 어떻게 구현하는 지 간략하게 알아보자.&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="프록시-패턴의-종류"><a href="#프록시-패턴의-종류" class="headerlink" title="프록시 패턴의 종류"></a>프록시 패턴의 종류</h1><p>간단하게 프록시 패턴을 어떻게 구현하는 지 간략하게 알아보자.</p><h2 id="인터페이스-기반-프록시"><a href="#인터페이스-기반-프록시" class="headerlink" title="인터페이스 기반 프록시"></a>인터페이스 기반 프록시</h2><p>인터페이스가 있고 그 인터페이스를 구현한 구현체가 있는 상황일 때 사용한다. 그 구현체의 프록시는 인터페이스를 구현하여 만든다. 프록시는 타겟으로 구현체를 멤버 변수로 가지며 퍼블릭 메서드를 수행할 때 타겟 객체의 메서드 호출과 함께 프록시 로직을 수행한다.</p><p>클라이언트 코드에서는 인터페이스를 통해 메시지를 던지므로 이때 메시지 수신 객체가 프록시던 원래 구현체건 신경쓰지 않는다.</p><h2 id="구현체-기반-프록시"><a href="#구현체-기반-프록시" class="headerlink" title="구현체 기반 프록시"></a>구현체 기반 프록시</h2><p>인터페이스가 없고 그냥 구현체만 있을 때 사용하는 방식이다. 프록시 클래스가 구현체의 클래스를 상속하도록 하고 멤버 변수로 타겟 구현체를 가진다. 구현체의 퍼블릭 메서드를 오버라이딩 하는데, 프록시 객체의 메서드가 호출 될 때 타겟 객체의 메서드 호출과 함께 프록시 로직도 같이 수행되도록 구현한다.</p><p>클라이언트 코드에서는 구현체의 타입을 통해 메시지를 던지므로 실제 구현체의 객체나 프록시의 객체 모두 해당 메시지를 처리할 수 있게 된다.</p><h2 id="차이"><a href="#차이" class="headerlink" title="차이"></a>차이</h2><p>구현체의 종류가 확장되지 않고, 인터페이스가 굳이 없는 상황이면 구현체 기반 프록시가 낫다.<br>하지만 구현체 기반 프록시는 구현체 클래스가 final이거나 확장하려는 메서드가 final이면 프록시를 적용할 수 없다.</p><h1 id="JDK-동적-프록시"><a href="#JDK-동적-프록시" class="headerlink" title="JDK 동적 프록시"></a>JDK 동적 프록시</h1><p>프록시 객체를 동적으로 만들어주는 기술이다. JDK 동적 프록시는 인터페이스 기반 프록시이기 때문에 인터페이스가 있어야 가능하다.</p><p>JDK 동적 프록시는 프록시에 적용할 로직을 <code>InvocationHandler</code> 인터페이스를 구현해서 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(<span class="keyword">final</span> Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 프록시 로직,,,</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy begin&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 프록시 로직,,,</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리플렉션을 사용해서 호출된 메서드에 프록시 로직을 추가해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FooInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooImpl</span> <span class="keyword">implements</span> <span class="title class_">FooInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FOO~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDKProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">JDKProxyTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FooInterface</span> <span class="variable">fooRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FooImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(fooRef);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FooInterface</span> <span class="variable">proxy</span> <span class="operator">=</span>(FooInterface) Proxy.newProxyInstance(FooInterface.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FooInterface.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인터페이스가 있는 상황에서 <code>Proxy.newProxyInstance</code> 메서드를 통해 ,어떤 클래스 로더에 프록시 클래스를 둘 것인지, 어떤 인터페이스를 구현해야 하는지, 어떤 핸들러(프록시 로직)을 적용할 것인지 정한다.</p><p>생성된 프록시는 메시지를 전달받으면 <code>InvocationHandler</code> 를 호출한다. 이때 프록시 로직과 본 객체의 메서드가 실행된다.</p><p>프록시 로직은 <code>InvocationHandler</code> 하나만 만들고 프록시를 적용해야 할 대상마다 재활용하면 된다.</p><p>하지만 이 방법은 타입 캐스팅을 해줘야 하고 인터페이스가 있어야 하는 단점이 있다.</p><h1 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h1><p>바이트 코드를 조작해서 동적으로 클래스를 생성하는 기능.</p><p>JDK 동적 프록시의 <code>InvocationHandler</code> 처럼 <code>MethodInterceptor</code> 에 프록시 로직을 담아서 사용한다.</p><p>CGLIB은 상속을 통해 구현체에서 바로 프록시를 만들기 때문에 부모의 기본 생성자가 필요하고 final 클래스이면 안되며, final 메서드인 경우 프록시가 작동하지 않는다. (스프링의 <code>ProxyFactory</code> 에서 모두 해결한다)</p><p>상황에 따라 JDK 동적 프록시와 CGLIB을 활용한 프록시를 사용할 수 있다. 하지만 상황마다 일일히 관련 클래스를 구현해서 적용해야 되나? 이런 문제를 스프링의 <code>ProxyFactory</code> 가 해결할 수 있다.</p><p>스프링의 <code>ProxyFactory</code> 를 활용할 때 내부에서 CGLIB를 사용한다. 하지만 우리가 CGLIB를 직접 다루진 않는다.</p><h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><p>스프링의 프록시 팩토리는 인터페이스 유무에 따라 JDK Proxy 혹은 CGLIB을 선택해서 프록시를 생성해준다.</p><p>프록시 팩토리는 <code>InvocationHandler</code> 와 <code>MethodInterceptor</code> 를 대신하는 <code>Advice</code> 를 도입한다. 어떤 방식으로 프록시를 만들던 <code>Advice</code> 를 호출하게 되도록 구현됐다.</p><p>즉 <code>AdviceInvocationHandler</code> 와 <code>AdviceMethodInterceptor</code> 를 스프링에서 구현해서 이 객체들이 개발자가 구현한 Advice에게 프록시 로직 실행을 위임하고, Advice는 프록시 로직 수행 후 진짜 객체에게 메시지를 전달한다.</p><h2 id="Advice-구현"><a href="#Advice-구현" class="headerlink" title="Advice 구현"></a>Advice 구현</h2><p><code>org.aopalliance.intercept</code> 패키지의 <code>MethodInterceptor</code> 를 구현하는 방법이 있다. (Advice를 상속한 인터페이스)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAdvice</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;TimeProxy 실행&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">resultTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">        log.info(<span class="string">&quot;TimeProxy 종료 resultTime=&#123;&#125;ms&quot;</span>, resultTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실행-예시"><a href="#실행-예시" class="headerlink" title="실행 예시"></a>실행 예시</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FooService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FooService</span>();</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 인터페이스가 있어도 CGLIB 방식 프록시를 쓰고 싶다면</span></span><br><span class="line">proxyFactory.setProxyFactoryClass(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> <span class="title class_">FooAdvice</span>());</span><br><span class="line"><span class="type">FooService</span> <span class="variable">proxy</span> <span class="operator">=</span> (FooService) proxyFactory.getProxy();</span><br></pre></td></tr></table></figure><h1 id="포인트컷-어드바이스-어드바이저"><a href="#포인트컷-어드바이스-어드바이저" class="headerlink" title="포인트컷, 어드바이스, 어드바이저"></a>포인트컷, 어드바이스, 어드바이저</h1><p>포인트컷 : 어디에 적용할까? (대상 여부 필터)</p><p>어드바이스 : 어떤 내용을 적용할까? (프록시 로직)</p><p>어드바이저 : 포인트컷 + 어드바이스의 조합</p><p>즉 조언자(어드바이저)는 어디에(포인트컷) 조언을(어드바이스) 적용해야 할 지 알고 있다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(Pointcut.TRUE, <span class="keyword">new</span> <span class="title class_">TimeAdvice</span>());</span><br><span class="line">proxyFactory.addAdvisor(advisor);</span><br></pre></td></tr></table></figure><p>ProxyFactory는 어드바이저를 받아서 프록시를 만든다. 어드바이스만 설정하면 항상 참으로 판단하도록 하는 포인트컷을 적용하여 어드바이저를 만든다.</p><p>ProxyFactory는 여러 어드바이스를 적용한 하나의 프록시 객체를 만들 수 있다. 여러 AOP 로직을 적용한다고 여러 프록시 객체가 만들어지는 게 아니다.</p><h2 id="여러-종류의-포인트컷"><a href="#여러-종류의-포인트컷" class="headerlink" title="여러 종류의 포인트컷"></a>여러 종류의 포인트컷</h2><p><code>PointCut</code> 인터페이스는 크게 <code>ClassFilter</code>와 <code>MethodFilter</code> 인터페이스로 필터링한다. 클래스 이름 기준으로 하거나 메서드 이름 기준으로 필터링할 때 사용된다.</p><p>스프링에서는 이런 인터페이스 기반으로 여러 포인트컷을 제공한다.</p><ul><li><code>NameMatchMethodPointcut</code> : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를<br>사용한다.</li><li><code>JdkRegexpMethodPointcut</code> : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.</li><li><code>TruePointcut</code> : 항상 참을 반환한다.</li><li><code>AnnotationMatchingPointcut</code> : 애노테이션으로 매칭한다.</li><li><code>AspectJExpressionPointcut</code> : aspectJ 표현식으로 매칭한다.</li></ul><p>여기서 제일 중요한 건 마지막 AspectJ 기반 포인트컷이다. 실무에서 제일 많이 사용한다.</p><h1 id="빈-후처리기"><a href="#빈-후처리기" class="headerlink" title="빈 후처리기"></a>빈 후처리기</h1><p>스프링의 도움으로 인터페이스 기반과 구현체 기반 신경쓰지 않고 어드바이저로 프록시를 적용할 수 있게 됐다. 하지만 여전히 <code>ProxyFactory</code>로 프록시 객체를 만들어서 빈 등록해줘야 한다. 그리고 컴포넌트 스캔으로 등록되는 빈은 이 방법을 쓸 수 없다.</p><p>이런 문제를 빈 후처리기가 해결한다.<br>빈 후처리기는 빈 객체가 생성되고 스프링 빈 저장소에 등록되기 전에 특정 작업을 실행할 수 있다. 이때 특정 작업은 등록될 객체를 조작하거나 심지어는 아예 다른 객체를 등록시켜버릴 수 있다. 즉 타겟 객체를 빈으로 생성해놓고 빈 후처리기를 통해 타겟 객체를 품고 있는 프록시 객체를 등록시켜버릴 수 있다는 의미이다.</p><p>빈 후처리기를 사용하려면 <code>BeanPostProcessor</code> 인터페이스를 구현하고 스프링 빈으로 등록하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@PostConstruct</code> 같이 초기화 전에 하거나 <code>@PostConstruct</code> 같이 초기화가 일어나고 나서 진행될 수 잇다.</p><p>반환되는 객체가 빈으로 등록된다.</p><p><code>@PostConstruct</code> 를 구현할 때도 빈 후처리기가 활용된다. <code>CommonAnnotationBeanPostProcessor</code> 를 통해 해당 어노테이션이 붙은 메서드를 호출한다.</p><p>컴포넌트 스캔으로 빈 등록되는 객체를 조작하거나 바꾸기 어려웠는데, 빈 후처리기를 통해 조작할 수 있게됐다. 빈 후처리기를 통해 빈 객체를 프록시로 바꿔서 등록할수도 있다는 의미이다!!!! 즉 설정 파일을 통해서 프록시를 하지 않고 빈 후처리기로 바꿔치기하면 된다! 이제 개발자는 프록시 관련 걱정을 안해도 되겟구나~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageLogTracePostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Advisor advisor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PackageLogTracePostProcessor</span><span class="params">(<span class="keyword">final</span> String basePackage, <span class="keyword">final</span> Advisor advisor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">        <span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, <span class="keyword">final</span> String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> bean.getClass().getPackageName();</span><br><span class="line">        <span class="keyword">if</span> (!packageName.startsWith(basePackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(bean);</span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시는 패키지 이름을 주입받아서 프록시 적용을 판단햇지만 advisor의 포인트컷으로 판단할 수 있다.</p><h1 id="스프링이-제공하는-빈-후처리기"><a href="#스프링이-제공하는-빈-후처리기" class="headerlink" title="스프링이 제공하는 빈 후처리기"></a>스프링이 제공하는 빈 후처리기</h1><p><code>spring-boot-start-aop</code> 라이브러리를 추가하고 <code>@EnableAspectJAutoProxy</code> 설정을 해주면(스프링 부트는 생략) AOP 관련 빈을 등록해준다.<br>이 과정에서 <code>AnnotationAwareAspectJAutoProxyCreator</code>라는 빈 후처리기가 스프링 빈으로 등록된다!</p><p>이 빈 후처리기는 스프링 빈으로 등록된 advisor들을 자동으로 찾아와서 프록시가 필요한 곳에 자동으로 프록시를 적용한다.(@Aspect 도 인식해서 프록시를 적용해서 AOP한다)</p><p>즉 모든 어드바이저를 가져와서 그 어드바이저 안에 있는 포인트컷을 통해 각 객체들이 프록시를 만들어야 되는지 확인하고 프록시를 만들어준다.<br>그러면 만들어진 프록시는 포인트컷에 해당하는 어드바이저들과 타겟 객체가 있겟구나! (여러 프록시를 만드는게 아니라 하나의 프록시에 여러 어드바이저를 가진다!!)</p><p>즉 스프링에서 제공하는 빈 후처리기가 프록시를 자동으로 등록해주는 과정은 다음과 같다.<br><code>빈 객체 생성 - 빈 후처리기에 전달 - 빈으로 등록된 모든 어드바이저 조회 - 포인트컷 필터링으로 프록시 객체 필요 여부 확인 - 프록시 생성 - 프록시를 빈 등록</code></p><p>이제 어드바이저만 잘 정의하면 프록시와 관련된 걱정을 하지 않고 추가 기능을 마음껏 구현할 수 있게 됐다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링의 예외 처리</title>
      <link>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/</guid>
      <pubDate>Tue, 14 Feb 2023 13:03:42 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;기본-예외-처리&quot;&gt;&lt;a href=&quot;#기본-예외-처리&quot; class=&quot;headerlink&quot; title=&quot;기본 예외 처리&quot;&gt;&lt;/a&gt;기본 예외 처리&lt;/h1&gt;&lt;p&gt;스프링은 기본적으로 예외가 발생하면 &lt;code&gt;/error&lt;/code&gt;에 매핑된 핸</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="기본-예외-처리"><a href="#기본-예외-처리" class="headerlink" title="기본 예외 처리"></a>기본 예외 처리</h1><p>스프링은 기본적으로 예외가 발생하면 <code>/error</code>에 매핑된 핸들러를 찾는다.<br>만약 <code>/error</code>에 매핑되지 않았다면 우리가 흔히 보게 되는 <code>Whitelabel Error Page</code>를 보여주게 된다.</p><h2 id="스프링-MVC의-요청-흐름"><a href="#스프링-MVC의-요청-흐름" class="headerlink" title="스프링 MVC의 요청 흐름"></a>스프링 MVC의 요청 흐름</h2><p>요청이 오면 <code>필터 -&gt; 서블릿(디스패처 서블릿) -&gt; 인터셉터 -&gt; 핸들러</code> 순으로 진행된다.<br>이때 컨트롤러에서 예외가 처리되지 않고 발생하면 <code>컨트롤러 -&gt; 인터셉터 -&gt; 서블릿(디스패처 서블릿) -&gt; 필터 -&gt; WAS(톰캣)</code> 순으로 예외가 전파된다.</p><h2 id="DispatcherServlet의-예외-처리"><a href="#DispatcherServlet의-예외-처리" class="headerlink" title="DispatcherServlet의 예외 처리"></a>DispatcherServlet의 예외 처리</h2><p>디스패처 서블릿의 application context는 <code>HandlerExceptionResolver</code>를 구현해서 처리되지 않은 예외를 인터셉트해서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC에서는 기본적으로 세가지 예외 리졸버를 만든다.</p><ul><li><code>ExceptionHandlerExceptionResolver</code> : 핸들러나 컨트롤러 어드바이스에서 <code>@ExceptionHandler</code> 가 처리할 수 있는 예외를 처리한다.</li><li><code>ResponseStatusExceptionResolver</code> : <code>@ResponseStatus</code> 가 붙은 예외를 처리한다.</li><li><code>DefaultHandlerExceptionResolver</code> : 스프링의 기본 전략으로 예외를 처리한다.</li></ul><p>이 세가지 리졸버는 순서대로 체인되어 실행된다.</p><h1 id="서블릿에서-예외"><a href="#서블릿에서-예외" class="headerlink" title="서블릿에서 예외"></a>서블릿에서 예외</h1><p>서블릿에서는 크게 두가지 로 예외 처리를 지원한다.</p><ul><li><code>Exception</code></li><li><code>response.sendError(HTTP 상태 코드, 오류 메시지)</code></li></ul><h2 id="예외"><a href="#예외" class="headerlink" title="예외"></a>예외</h2><p>자바에서 직접 실행하는 경우, main 함수를 실행하는 main 스레드가 예외를 만나서 처리하지 못하고 main 메서드를 넘어가게 되면 예외 정보를 남기고 스레드가 종료된다.</p><p>한편 웹 어플리케이션은 요청 별로 스레드가 할당되고 서블릿 컨테이너 안에서 실행된다. 애플리케이션에서 처리하지 못한 예외는 어디로 가는걸까?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WAS(여가까지 전파) &lt;- 필터 &lt;- 서블릿 &lt;- 인터셉터 &lt;- 컨트롤러(예외 발생)</span><br></pre></td></tr></table></figure><p>WAS는 예외를 받으면 상태코드 500으로 처리한다.</p><h2 id="response-sendError-HTTP-상태-코드-오류-메시지"><a href="#response-sendError-HTTP-상태-코드-오류-메시지" class="headerlink" title="response.sendError(HTTP 상태 코드, 오류 메시지)"></a>response.sendError(HTTP 상태 코드, 오류 메시지)</h2><p>이 방식은 당장 예외가 발생한 것은 아니지만 서블릿 컨테이너에게 오류가 발생했음을 알린다.</p><p>이 메서드를 호출하면 response 객체 안에 호출 기록을 남겨두고 WAS가 이를 확인하고 예외로 인식한다.</p><h2 id="서블릿-예외-처리-오류-화면-제공"><a href="#서블릿-예외-처리-오류-화면-제공" class="headerlink" title="서블릿 예외 처리 - 오류 화면 제공"></a>서블릿 예외 처리 - 오류 화면 제공</h2><p>웹서버 팩토리커스터마이저를 통해 상태코드에 따라 주소를 매핑하고, WAS는 상태 코드가 응답하면 매핑된 주소로 진짜 요청을 다시 날린다! WAS가 날린 요청을 처리하기 위해 컨트롤러를 통해 예외 처리된 화면을 보여 줄 수 있다.</p><p>여기서 중요한 점은 WAS가 다시 요청을 날릴 때 필터 → 서블릿 → 인터셉터 를 다 거친다는 사실이다.<br>WAS가 다시 요청을 보낼 때는 요청 객체에 예외 관련 정보를 담아서 요청을 보낸다.</p><h3 id="필터"><a href="#필터" class="headerlink" title="필터"></a>필터</h3><p>서블릿은 <code>DispatcherType</code> 을 통해 지금 보낸 요청이 고객이 요청한 것인지 WAS가 에러로 인한 내부 호출한 내용인지 파악하는데 도움을 준다. 그래서 필터가 인증 인가 같은 로직을 예외 처리를 위한 요청에서 적용하지 않고 넘길 수 있게 된다. (필터의 기본 디스패처타입이 REQUEST라서 적용되지 않는다. 만약 예외 처리 요청을 위한 필터를 만들려면 디스패처 타입을 ERROR로 설정해주면 된다.)</p><h3 id="인터셉터"><a href="#인터셉터" class="headerlink" title="인터셉터"></a>인터셉터</h3><p>예외가 발생하는 요청인 경우, postHandle 메서드가 작동하지 않고 afterCompletion 만 작동한다. 하지만 WAS가 예외 처리를 위해 내부 요청을 보내는  경우는 해당 요청 자체는 예외가 발생하지 않으므로 postHandle도 잘 작동한다.</p><h1 id="스프링-부트의-예외-처리"><a href="#스프링-부트의-예외-처리" class="headerlink" title="스프링 부트의 예외 처리"></a>스프링 부트의 예외 처리</h1><p>서블릿은 귀찮게 경로를 정해주고 그 경로에 맞는 컨트롤러를 만들어줘야 했다.</p><p>스프링 부트는 <code>/error</code> 를 기본으로 에러 페이지를 설정한다. 그리고 <code>BasicErrorController</code> 라는 스프링 컨트롤러를 자동으로 등록한다. 이 일을 <code>ErrorMvcAutoConfiguration</code> 이라는 클래스가 자동으로 등록해준다.</p><p>컨트롤러는 <code>resources/tempalte/error</code> 디렉토리에서 <code>5xx.html, 400.html</code> 와 같은 이름의 파일을 상태코드에 매핑해서 뷰를 보여준다. 그리고 모델로 에러 상황과 관련된 데이터를 전달한다.</p><p>만약 컨트롤러 로직을 확장하고 싶으면 기존의 <code>BasicErrorController</code> 를 상속해서 오버라이딩하면 된다.</p><h1 id="API-예외-처리"><a href="#API-예외-처리" class="headerlink" title="API 예외 처리"></a>API 예외 처리</h1><h2 id="서블릿의-API-예외-처리"><a href="#서블릿의-API-예외-처리" class="headerlink" title="서블릿의 API 예외 처리"></a>서블릿의 API 예외 처리</h2><p>WAS가 예외를 감지하고 내부에서 다시 보낸 요청을 처리하는 컨트롤러에서 HTTP header의 accept를 json으로 해주고 <code>ResponseEntity</code> 를 반환하도록 하면 JSON으로 변환 되서 반환된다.</p><h2 id="스프링-부트의-API-예외-처리"><a href="#스프링-부트의-API-예외-처리" class="headerlink" title="스프링 부트의 API 예외 처리"></a>스프링 부트의 API 예외 처리</h2><p>스프링 부트는 기본적으로 accept를 어떻게 하냐에 따라 JSON을 알아서 반환해줄 수도, 뷰를 반환해줄 수도 있다.</p><h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><p>WAS까지 예외가 전달되면 500으로 처리한다. 이를 바꾸고 싶으면 <code>HandlerExceptionResolver</code>를 사용하자.</p><p><code>HandlerExceptionResolver</code> 가 디스패처 서블릿에 등록되면 디스패처 서블릿에 전달된 예외를 잡아서 <code>response.sendError(status code)</code> 를 호출하고 빈 <code>ModelAndView</code> 을 반환한다. 즉 WAS까지 안가고 요청도 다시 보내지 않는다.</p><p>여기서 빈 <code>ModelAndView</code> 를 반환하면 예외가 처리되고 정상 흐름으로 진행되고 <code>ModelAndView</code>  가 지정되어서 반환되면 해당 내용으로 뷰를 렌더링한다. null을 반환하면 다음 리졸버를 찾는다. 만약 맞는 리졸버가 없으면 WAS까지 예외가 전파된다.</p><h3 id="스프링이-제공하는-ExceptionResolver"><a href="#스프링이-제공하는-ExceptionResolver" class="headerlink" title="스프링이 제공하는 ExceptionResolver"></a>스프링이 제공하는 ExceptionResolver</h3><ol><li>ExceptionHandlerExceptionHandler<ol><li>특정 컨트롤러에서 발생한 예외를 <code>@ExceptionHandler</code> 로 처리.</li><li>참고로 파라미터로 받는 예외를 통해 어떤 예외를 처리할지 선언하는 역할도 한다.</li></ol></li><li>ResponseStatusExceptionHandler<ol><li><code>@ResponseStatus</code> 가 붙은 경우</li><li><code>ResponseStatusException</code> 이 발생시켜서 이미 존재하는 예외를 처리</li></ol></li><li>DefaultHandlerExceptionResolver<ol><li>스프링 내부에서 발생하는 예외를 적절한 상태코드로 처리</li></ol></li></ol><p>1~3까지 해결이 안되면 다음으로 넘기는 방식.</p><h3 id="ControllerAdvice-RestControllerAdvice"><a href="#ControllerAdvice-RestControllerAdvice" class="headerlink" title="@ControllerAdvice, @RestControllerAdvice"></a>@ControllerAdvice, @RestControllerAdvice</h3><p>대상이 되는 여러 컨트롤러에 <code>@InitBinder</code>, <code>@ExceptionHandler</code>  기능을 부여하는 역할을 한다.</p><p>대상을 지정안하는 경우 모든 컨트롤러에 적용된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
