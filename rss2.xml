<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Fri, 08 Apr 2022 15:27:53 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>조합으로 체스 말 이동 범위 검사하기!</title>
      <link>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</guid>
      <pubDate>Fri, 08 Apr 2022 00:31:53 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.&lt;br&gt;이를 따로 분리해서 중복을 제거하고자 했다.&lt;/p&gt;
&lt;h1 id=&quot;도입-배경&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.<br>이를 따로 분리해서 중복을 제거하고자 했다.</p><h1 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h1><h2 id="체스-말-종류-구현하기"><a href="#체스-말-종류-구현하기" class="headerlink" title="체스 말 종류 구현하기"></a>체스 말 종류 구현하기</h2><p>체스 말 객체(Piece)는 자신의 위치와 이동할 위치를 전달받아서 이동할 위치로 이동할 수 있는지 확인한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> MovableStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Piece</span><span class="params">(<span class="keyword">final</span> Color color, <span class="keyword">final</span> MovableStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPointValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;같은 위치로는 이동 불가능합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.movable(source, target, moveType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>체스 말 객체는 여러가지 종류가 있다. (퀸, 킹, 폰, 비숍, 룩, 나이트)<br>Piece를 상속받아서 다양한 종류를 구현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> <span class="keyword">extends</span> <span class="title">Piece</span></span></span><br></pre></td></tr></table></figure><h2 id="체스-말-종류에-따라-달라지는-이동-범위"><a href="#체스-말-종류에-따라-달라지는-이동-범위" class="headerlink" title="체스 말 종류에 따라 달라지는 이동 범위"></a>체스 말 종류에 따라 달라지는 이동 범위</h2><p>체스 말 객체는 종류에 따라 이동 범위가 다르다.</p><p>문제는 각 클래스마다 이동 검증 로직이 중복되는 게 많다는 점이다!</p><h3 id="중복되는-코드"><a href="#중복되는-코드" class="headerlink" title="중복되는 코드"></a>중복되는 코드</h3><p>퀸 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen</span> <span class="keyword">extends</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; QUEEN_DIRECTION</span><br><span class="line">            = List.of(EAST, WEST, SOUTH, NORTH, SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> QUEEN_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반면 이건 룩 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bishop</span> <span class="keyword">extends</span> <span class="title">Piece</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; BISHOP_DIRECTION = List.of(SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bishop</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> BISHOP_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 잘 보면 movable 메서드 안에 로직이 중복됨을 알 수 있다. 이를 해결해보자.</p><h1 id="조합으로-중복-제거하기"><a href="#조합으로-중복-제거하기" class="headerlink" title="조합으로 중복 제거하기"></a>조합으로 중복 제거하기</h1><p>이때 체스 말 객체를 두가지로 나눠서 생각한다.</p><p><strong>이동하는 거리가 제한 없는 경우 VS 이동하는 거리가 제한 있는 경우</strong></p><p>전자는 퀸, 비숍, 룩이 해당한다.<br>후자는 폰, 킹, 나이트가 해당한다.</p><p>그렇다면 거리 제한 없이 이동하는 전략과 거리 제한이 있는 전략을 구분해서 추상화할 수 있지 않을까?</p><h2 id="인터페이스로-전략을-추상화해서-만들기"><a href="#인터페이스로-전략을-추상화해서-만들기" class="headerlink" title="인터페이스로 전략을 추상화해서 만들기"></a>인터페이스로 전략을 추상화해서 만들기</h2><p>모든 종류의 체스 말들이 자신의 이동여부를 확인할 수 있도록하는 인터페이스를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>자신의 위치, 목표 위치, 움직임이 공격인지를 전달받아 해당 목표로 갈 수 있는지 판단한다.</p><h2 id="이동하는-거리가-제한-없는-경우"><a href="#이동하는-거리가-제한-없는-경우" class="headerlink" title="이동하는 거리가 제한 없는 경우"></a>이동하는 거리가 제한 없는 경우</h2><p>인터페이스를 구현해서 먼저 이동하는 거리가 제한이 없는 경우의 전략을 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnlimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnlimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하는 거리가 제한이 없는 전략은 가려는 목표지점의 방향이 내가 갈 수 있는 방향인지만 검사하면 된다.</p><p>즉 룩의 경우 상하좌우로 거리제한없이 이동할 수 있다.<br>룩이 가려는 목표 지점이 상하좌우 방향 중 하나에 있다면, 룩은 그 목표로 갈 수 있다.<br>(이동 경로에 다른 누군가 있는 경우나 목표 지점이 같은 편이 있는 경우는 다른 곳에서 검증한다.)</p><h2 id="이동하는-거리가-제한된-경우"><a href="#이동하는-거리가-제한된-경우" class="headerlink" title="이동하는 거리가 제한된 경우"></a>이동하는 거리가 제한된 경우</h2><p>이동하는 거리가 제한된 경우의 전략을 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> moveLimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections, <span class="keyword">int</span> moveLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">        <span class="keyword">this</span>.moveLimit = moveLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Distance distance = source.getDistance(target);</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction) &amp;&amp; distance.isInRange(moveLimit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하려는 거리 제한이 있으면 두 위치간에 거리를 추가로 확인해주면 된다.</p><h2 id="폰의-이동-전략"><a href="#폰의-이동-전략" class="headerlink" title="폰의 이동 전략"></a>폰의 이동 전략</h2><p>폰의 이동 전략은 꽤 까다롭다.</p><p>첫 위치에서 움직이는 경우 전진을 두칸까지 할 수 있다.<br>공격은 반드시 전진 방향 대각선으로 할 수 있다.</p><p>이를 위해서는 MoveType에 따라 다른 전략을 만들어서 실행해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PawnMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_MOVE_LIMIT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOT_FIRST_MOVE_LIMIT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACK_LIMIT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; nonAttackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; attackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Rank startRank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PawnMovableStrategy</span><span class="params">(List&lt;Direction&gt; nonAttackDirection, List&lt;Direction&gt; attackDirection, Rank startRank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nonAttackDirection = nonAttackDirection;</span><br><span class="line">        <span class="keyword">this</span>.attackDirection = attackDirection;</span><br><span class="line">        <span class="keyword">this</span>.startRank = startRank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (moveType.isAttack()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(attackDirection, ATTACK_LIMIT).movable(source, target, moveType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nonAttackMovable(source, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonAttackMovable</span><span class="params">(Square source, Square target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.isSameRank(startRank)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                    MoveType.MOVE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, NOT_FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                MoveType.MOVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>폰의 이동전략을 수행하기 위해서는 자신의 첫 위치 시점(starkRank), 공격가능 방향(attckDirection), 이동 가능 방향(nonAttackDirection)을 주입받는다.</p><p>현재 이동하려는 것이 공격이면 공격에 맞는 방향과 거리로 검증한다.<br>반면 그냥 이동하려는 경우는 이동에 맞는 방향과 거리로 검증한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java의 Call by Value</title>
      <link>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</guid>
      <pubDate>Sat, 02 Apr 2022 09:11:48 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바에는 Call by Value만 존재한다.&lt;br&gt;Call by Value는 함수의 인자에 값을 전달하는 방식이고,&lt;br&gt;Call by Reference는 함수의 인자에 주소를 </description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>자바에는 Call by Value만 존재한다.<br>Call by Value는 함수의 인자에 값을 전달하는 방식이고,<br>Call by Reference는 함수의 인자에 주소를 전달하는 방식이다.</p><h1 id="Call-by-Value-vs-Call-by-Reference"><a href="#Call-by-Value-vs-Call-by-Reference" class="headerlink" title="Call by Value vs Call by Reference"></a>Call by Value vs Call by Reference</h1><p>프로그래밍 언어에서 함수에 인자로 전달하는 방식에 따라 나뉜다.</p><h2 id="Call-by-Value"><a href="#Call-by-Value" class="headerlink" title="Call by Value"></a>Call by Value</h2><p>Call by Value는 함수 호출시 전달되는 변수의 값을 복사해서 전달한다.<br>이렇게 전달된 인자는 외부에서 있었던 변수와는 달리 함수 내부의 지역 변수로 활용된다.<br>즉 함수 안에서 인자를 변경해도 외부 변수 값은 변경되지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드를 살펴보자.<br>swap 함수는 두 int형 변수의 값을 바꾸는 함수다. 그런데 테스트 결과는 맞지 않게 나온다.<br>원인은 swap 함수에서 변수를 가져오는 과정이 Call by Value이기 때문이다.</p><p>테스트 코드에서 전달한 a와 swap 내부에서의 a는 서로 영향을 주지 않는다.<br>테스트 코드의 a에 저장된 1이라는 값을 복사해서 메서드의 a에 저장한 것일 뿐이다.</p><h2 id="Call-by-Reference"><a href="#Call-by-Reference" class="headerlink" title="Call by Reference"></a>Call by Reference</h2><p>Call by Reference는 함수 호출 시 전달되는 변수의 참조값을 전달하는 방식이다.<br>함수가 인자로 주소값을 전달받고나서 이를 함수 내부에서 접근하여 수정하면,<br>함수 외부의 변수도 변화가 생길 수 있다.</p><h1 id="Java의-Call-by-Value"><a href="#Java의-Call-by-Value" class="headerlink" title="Java의 Call by Value"></a>Java의 Call by Value</h1><blockquote><p>Java는 전달되는 인자의 타입에 따라 약간 다르게 보인다.</p></blockquote><h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2><p>자바는 8가지 원시 타입이 있다.<br>(byte, short, int, long, float, double, char, boolean)</p><p>원시 타입 변수들은 스택 메모리에 그대로 저장된다.<br>그래서 원시 타입이 인자로 전달될 때는 스택에 저장된 값 그대로 복사되어서 전달된다.</p><p>전달된 값은 원래 변수와는 다른 별개의 변수. 즉 Call by Value 방식으로 전달된다.<br>전달된 갑쇼은 해당 메서드가 종료되면 스택에서 제거된다. </p><h4 id="예시로-이해하기"><a href="#예시로-이해하기" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//1단계</span></span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//2단계</span></span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c;</span><br><span class="line">        c = d;</span><br><span class="line">        d = tmp; <span class="comment">//3단계</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까 본 예시로 다시 이해해보자.</p><p>1단계까지 실행하고 나면 스택에는 a = 1, b = 2 라는 정보를 저장하게 된다.<br>2단계를 실행하고 나면 a = 1, b = 2 라는 정보에 새로운 스택 프레임이 생기고 그곳에 c = 1, d = 2가 생긴다.<br>즉 (a =1 , b = 2), (c = 1, d = 2) 이런 식으로 스택에 저장된다.</p><p>이제 3단계까지 실행하면 스택은 (a = 1, b =2), (c = 2, d = 1, tmp = 1) 이렇게 저장된다.<br>swap 메서드가 종료되면 swap 메서드의 프레임이 종료되므로 결국 (a = 1, b = 2)만 스택에 남는다.</p><h2 id="참조-타입"><a href="#참조-타입" class="headerlink" title="참조 타입"></a>참조 타입</h2><p>참조 타입은 쉽게 말해서 객체의 주소를 저장하는 타입이다.<br>보통 기본 타입을 제외한 모든 것을 의미한다.</p><p>참조 타입은 기본 타입과 다르게 값 그 자체를 저장하지 않는다.<br>대신 그 값의 주소 값을 저장한다.</p><p>그렇다면 그 값의 주소는 어디의 주소를 의미하는 걸까?<br>그 주소는 바로 힙 영역에 있는 인스턴스의 주소를 의미한다.</p><p>즉 참조 타입은 객체의 주소를 가지고 스택에 저장되고,<br>그 주소는 힙 영역에 있는 인스턴스의 주소다.</p><p>앞서서 자바는 Call by Value라고 했다.<br>참조 타입도 예외는 아니다. Call by Value다.<br>다만 전달되는 Value가 주소값이라서 기본 타입과는 다르게 작동한다.</p><h4 id="예시로-이해하기-1"><a href="#예시로-이해하기-1" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callByValueObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserAge a = <span class="keyword">new</span> UserAge();</span><br><span class="line">        a.value = <span class="number">1</span>;</span><br><span class="line">        UserAge b = <span class="keyword">new</span> UserAge();</span><br><span class="line">        b.value = <span class="number">2</span>;<span class="comment">//1단계</span></span><br><span class="line">        swap(a, b);<span class="comment">//2단계</span></span><br><span class="line">        assertThat(a.value == <span class="number">2</span> &amp;&amp; b.value == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(UserAge c, UserAge d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c.value;</span><br><span class="line">        c.value = d.value;</span><br><span class="line">        d.value = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAge는 int 형 데이터를 저장하는 클래스다.<br>이제 두개의 UserAge를 만들어서 값을 변경하는 swap 메서드에 전달해보자.</p><p>1단계까지 오면 스택에 a = UserAge 주소값1, b = UserAge 주소값2 이 오게된다.<br>우리가 만든 실제 객체는 힙 영역에 있고 스택의 주소값은 힙 영역을 가르키는 값이다.</p><p>2단계까지 오면 이제 새로운 스택 프레임이 생긴다.<br>c와 d에 a, b가 가진 값(즉 주소값)을 복사해서 넣어준다. 즉 Call by Value 방식으로 전달한다.</p><p>스택에는 (a = UserAge주소1, b = UserAge주소2), (c = UserAge주소1, d = UserAge주소2) 이렇게 저장된다.</p><p>이때 주목할 점은 a와 c가 같은 주소값을 저장하고 있고, b와 d가 같은 값을 저장하고 있다는 점이다.<br>이제 c를 통해 힙에 있는 인스턴스를 변경하면 나중에 a를 통해 인스턴스에 접근했을 때 값이 변경되어 있게 된다.<br>(b와 d도 같은 관계다.)</p><blockquote><p>정리</p></blockquote><p>자바는 모두 Call by Value이다.<br>다만 원시 타입은 값 자체를 복사해서 전달하고,<br>참조 타입은 참조하는 객체의 주소를 복사해서 전달한다.</p><p><em>참고</em></p><p><a href="https://deveric.tistory.com/92">https://deveric.tistory.com/92</a><br><a href="https://www.baeldung.com/java-pass-by-value-or-pass-by-reference">https://www.baeldung.com/java-pass-by-value-or-pass-by-reference</a><br><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a><br><a href="https://kingpodo.tistory.com/54">https://kingpodo.tistory.com/54</a><br><a href="https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame">https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame</a><br><a href="https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference">https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>오브젝트</title>
      <link>https://yangdongjue5510.github.io/2022/03/27/java/object/post/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/27/java/object/post/</guid>
      <pubDate>Sun, 27 Mar 2022 07:09:39 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;사용하는 입장에서 예상 가능한 코드&lt;/p&gt;
&lt;p&gt;의존성이 적절한 코드(결합도가 낮은 코드)&lt;/p&gt;
&lt;p&gt;너무 세세한 부분까지 알지 못하도록 정보를 차단&lt;/p&gt;
&lt;p&gt;객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하자.&lt;/p&gt;
&lt;p&gt;불필요한 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>사용하는 입장에서 예상 가능한 코드</p><p>의존성이 적절한 코드(결합도가 낮은 코드)</p><p>너무 세세한 부분까지 알지 못하도록 정보를 차단</p><p>객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하자.</p><p>불필요한 세부사항을 객체 내부로 캡슐화하는 것 -&gt; 객체의 자율성 + 응집도가 높은 객체</p><p>단순 타입보다는 객체를 선언해서 의미를 전달하는게 좋다. (관련 로직이 한곳에 모이는 효과도 있다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/27/java/object/post/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>상속과 조합</title>
      <link>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</guid>
      <pubDate>Sat, 12 Mar 2022 04:28:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;상속의-위험성&quot;&gt;&lt;a href=&quot;#상속의-위험성&quot; class=&quot;headerlink&quot; title=&quot;상속의 위험성&quot;&gt;&lt;/a&gt;상속의 위험성&lt;/h1&gt;&lt;p&gt;상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.&lt;br&gt;내가 필요로 하는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="상속의-위험성"><a href="#상속의-위험성" class="headerlink" title="상속의 위험성"></a>상속의 위험성</h1><p>상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.<br>내가 필요로 하는 클래스와 매우 유사한 클래스가 있다면 해당 클래스를 상속하면 같은 코드를 여러번 쓸 필요가 줄어든다.</p><p>상속은 코드 재사용을 위해 캡슐화를 희생시킨다. 부모 클래스의 코드를 재활용하기 위해 자식 클래스도 재활용할 코드를 모두 공개되기 때문이다.</p><blockquote><p>경고 1. 자식 클래스 메서드 안에서 super 참조로 부모 클래스의 메서드를 직접 호출하면 두 클래스의 결합도가 높아진다. (super 참조를 제거하라.)</p></blockquote><p>상속을 염두해두고 설계하지 않은 클래스를 상속하기 어렵다.<br>기존의 코드를 다른 상황에 재사용하기 위해서는 개발자가 나름의 해석을 하고 가정한다.<br>그러나 개발자의 가정을 이해해야 하는 코드는 읽기가 어려워진다.</p><p>실제 요구사항과 구현이 다르면 우리는 기존의 구현을 요구사항과 같은 결과를 나타내도록 많은 가정을 하게된다.</p><p>상속을 하려면 부모 클래스의 가정과 추론 과정을 정확하게 이해해야 한다.<br>상속은 부모 클래스의 구체적인 구현을 이해해야 할 가능성이 높다. 그래서 결합도(다른 모듈에 대해 알고 있어야할 지식의 수준)가 높다.</p><p>자식 클래스가 부모 클래스의 변경이 취약해진다. 취약한 기반 클래스 문제.<br>만약 부모 클래스의 변경된 부분이 자식 클래스에 파생되는 행동이라면, 자식 클래스의 행동이 예상과 다르게 작동 될 수 있다. </p><p>상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만든다.<br>상속은 부모 클래스의 퍼블릭 인터페이스가 아닌 다른 곳을 고쳐도 영향을 받는다. 이게 캡슐화를 약화시킨다는 증거다.</p><blockquote><p>경고 2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.</p></blockquote><p>코드 재활용을 하기 위해 부모 클래스를 상속 할 경우, 부모에서 공개 됐던 메서드들이 자식 클래스의 내부 규칙을 깨트릴 수 있다.</p><p>오브젝트에서 제시한 예시는 Vector를 상속받는 Stack이다.<br>Stack은 push와 pop으로만 데이터를 수정할 수 있다. 그러나 Vector는 퍼블릭 인터페이스로 다양한 인덱스에 add할 수 있게한다. 이는 Stack의 규칙을 깨트리는 방식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line"></span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>); <span class="comment">//이건 Vector의 퍼블릭 인터페이스. 스택의 규칙에 어긋난 행동</span></span><br></pre></td></tr></table></figure><blockquote><p>경고 3. 자식이 부모의 메서드를 오버라이딩하면 부모의 다른 메서드가 자식의 메서드를 결합하게 될 수 있다.</p></blockquote><p>부모 클래스의 특정 메서드를 자식 클래스가 오버라이딩 하게 되면, 부모 클래스에서 해당 클래스를 원래의 메서드(즉 오버라이딩 되기 전 메서드)를 예상하고 사용했던 부분에서 예기치 못한 작동(오버라이딩 된 메서드)를 수행할 수 있다.</p><blockquote><p> 경고 4. 부모 클래스에 변화가 생기면 자식도 같이 변해야 되는 일이 생길 수 있다. 상속은 결합도가 높아서, 부모와 자식이 같이 변하거나, 자식과 부모를 변경하지 않거나 두가지 선택지 밖에 없다.</p></blockquote><p>부모 클래스를 오버라이딩 하지 않고 불필요한 퍼블릭 인터페이스를 상속받지 않아도 부모의 중요한 부분이 변경되면 자식 클래스도 같이 변경될 수 밖에 없다.</p><h1 id="상속을-보다-안전하게-사용하기"><a href="#상속을-보다-안전하게-사용하기" class="headerlink" title="상속을 보다 안전하게 사용하기"></a>상속을 보다 안전하게 사용하기</h1><h2 id="추상화에-의존"><a href="#추상화에-의존" class="headerlink" title="추상화에 의존"></a>추상화에 의존</h2><p>자식 클래스가 부모 클래스의 구현이 아닌 부모 클래스의 추상화에 의존해야 한다.<br>더 정확하게 말하면 부모와 자식 모두 추상화에 의존해야 한다.</p><h3 id="달라지는-부분을-찾아-메서드로-분리"><a href="#달라지는-부분을-찾아-메서드로-분리" class="headerlink" title="달라지는 부분을 찾아 메서드로 분리"></a>달라지는 부분을 찾아 메서드로 분리</h3><p>비슷해보이는 클래스 간에 서로 다른 부분을 메서드를 추출한다.<br>그러면 다른 부분을 제외하면 나머지 메서드들은 동일하게 된다.<br>그러면 이제 중복 코드를 부모 클래스로 올린다.<br>그리고 달라지는 부분은 부모의 추상 메서드로, 각 클래스들이 구현하도록 하면 된다.</p><p>이제 자식 클래스들은 부모의 추상 메서드에만 의존하게 되므로 느슨하게 결합된다.</p><p>하지만 이런 추상 클래스를 활용한 추상화에 의존하는 방법도 문제가 있다.<br>객체 행동만 변하면 각 클래스를 독립적으로 변경시키면 되겠지만, 인스턴스 변수가 추가되는 경우는 다르다.<br>부모 클래스에 인스턴스 변수가 추가되어 객체 생성때 초기화해줘야 하는 경우, 상속되는 모든 클래스는 수정을 해줘야 한다.</p><h1 id="합성을-활용하기"><a href="#합성을-활용하기" class="headerlink" title="합성을 활용하기"></a>합성을 활용하기</h1><p>상속은 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 방법.<br>합성은 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.</p><p>합성은 구현에 의존하지 않는다.<br>합성은 내부 부분 객체의 퍼블릭 인터페이스에 의존한다. 즉 구현에 의존하는 것이 아닌 인터페이스에 의존하도록 할 수 있다.<br>합성은 내부 부분 객체의 구현 방식이 변경되어도 전체 객체는 영향이 적다.</p><p>상속은 정적인 관계인데 합성은 동적인 관계이다.<br>코드 작성 때 정해진 상속 관계를 실행 시점에서 변경이 불가능하다.<br>반면 합성 관계는 코드 작성 때 정해진 관계를 실행 시점에서 변경이 가능하다.</p><p>상속을 합성으로 바꾸는 방법은 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p><h2 id="합성의-안전성"><a href="#합성의-안전성" class="headerlink" title="합성의 안전성"></a>합성의 안전성</h2><p>불필요한 인터페이스 상속 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 규칙에 맞게 인스턴스의 퍼블릭 인터페이스를 활용하면 된다.</p><p>메서드 오버라이딩 오작동 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 메서드가 부모 인스턴스의 메서드를 오버라이딩해서 부모 인스턴스의 퍼블릭 인터페이스와 협력하면 된다.<br>(이때 오버라이딩한 인스턴스 메서드가 인스턴스에게 동일한 메서드 호출을 전달하는 메서드를 포워딩 메서드라고 한다.)</p><p>부모 클래스와 자식 클래스의 동시 수정 문제<br>합성이 이 문제를 완전히 해결하지는 못한다. 하지만 조합된 내부 인스턴스의 변경사항을 최대한 캡슐화 시킬 수 있다.</p><h2 id="합성의-유연성"><a href="#합성의-유연성" class="headerlink" title="합성의 유연성"></a>합성의 유연성</h2><p>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함.</p><p>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많이 늘어날 수 있다.</p><p>추상 메서드와 훅 메서드<br>추상 메서드 : 개방 - 폐쇄 원칙을 만족하기 위한 설계. 하위 계층이 오버라이딩해서 구현<br>훅 메서드 : 추상 메서드는 반드시 모두가 구현해야 해서 불편하다. 대부분의 하위 계층이 똑같이 구현하면 중복 코드가 많이 생기기 때문에 기본 구현을 해놓고 달라지는 경우에만 오버라이딩하는 메서드</p><p>기능 추가를 할 때 상속을 남용하면 필요 이상으로 클래스가 만들어진다.(클래스 폭발, 조합의 폭발)<br>이런 문제는 자식 클래스와 부모 클래스의 다양한 조합이 필요한데 상속은 컴파일 타임에 관계가 결정되어 버려서 모든 조합을 미리 만들어놓으면서 생기는 문제다.</p><p>합성을 사용하면 컴파일 타임에서 정한 관계를 런타임에서 수정할 수 있다.<br>상속은 조합의 결과를 개별의 클래스에 밀어넣는 방법이고, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 다음 런타임에서 인스턴스를 조립하는 방식이다.</p><h1 id="그러면-상속은-언제-사용하는가"><a href="#그러면-상속은-언제-사용하는가" class="headerlink" title="그러면 상속은 언제 사용하는가"></a>그러면 상속은 언제 사용하는가</h1><p>코드 재활용을 목적으로 상속하면 변경하기 어렵고 유연하지 못하게 된다.<br>만약 상속을 사용하려고 할 때 스스로에게 물어보자.<br>내가 상속을 이용하는게 코드 재사용을 위한 것인가? 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위한 것인가? (코드 재사용을 위한 것이면 상속을 피해야 한다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 함수</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</guid>
      <pubDate>Fri, 04 Mar 2022 08:37:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;함수는-한-가지만-해라&quot;&gt;&lt;a href=&quot;#함수는-한-가지만-해라&quot; class=&quot;headerlink&quot; title=&quot;함수는 한 가지만 해라!&quot;&gt;&lt;/a&gt;함수는 한 가지만 해라!&lt;/h3&gt;&lt;p&gt;함수에 적힌 코드들의 추상화 수준이 같은 단계로 통</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="함수는-한-가지만-해라"><a href="#함수는-한-가지만-해라" class="headerlink" title="함수는 한 가지만 해라!"></a>함수는 한 가지만 해라!</h3><p>함수에 적힌 코드들의 추상화 수준이 같은 단계로 통일시켜라는 의미다.<br>혹은 함수 내에서 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 셈이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parseInt(token));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">        lottoNumbers.add(<span class="keyword">new</span> LottoNumber(number));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(lottoNumbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 크게 추상화 단계가 두가지이다.</p><ul><li>문자열을 숫자로 바꾸는 단계 (추상화 단계 낮음)</li><li>숫자를 LottoNumber로 바꾸는 단계 (추상화 단계 중간)</li><li>LottoNumber를 Lotto로 바꾸는 단계 (추상화 단계 높음)</li></ul><p>이제 이 작업들을 나눠서 리팩토링 해보자.<br>자연스럽게 내려가기 규칙이 적용되서 다음에 오는 함수는 추상화 단계가 하나씩 줄어드는 걸 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(createLottoNumbers(tokens));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;LottoNumber&gt; <span class="title">createLottoNumbers</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : parseAll(tokens)) &#123;</span><br><span class="line">        lottoNumbers.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lottoNumbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">parseAll</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parse(token));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="함수-인수"><a href="#함수-인수" class="headerlink" title="함수 인수"></a>함수 인수</h3><p>함수에 전달되는 인수는 0개가 제일 좋다.<br>3개 이상은 되도록 피해야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 의미 있는 이름</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</guid>
      <pubDate>Fri, 04 Mar 2022 05:44:23 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;의도를-분명히-밝혀라&quot;&gt;&lt;a href=&quot;#의도를-분명히-밝혀라&quot; class=&quot;headerlink&quot; title=&quot;의도를 분명히 밝혀라&quot;&gt;&lt;/a&gt;의도를 분명히 밝혀라&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="의도를-분명히-밝혀라"><a href="#의도를-분명히-밝혀라" class="headerlink" title="의도를 분명히 밝혀라"></a>의도를 분명히 밝혀라</h3><ol><li>변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</li><li>어떤 일을 수행하는가?</li><li>어떻게 사용하는가?</li></ol><p>이름으로 위 세가지가 표현이 안된다면 문제가 있다.</p><h4 id="변수의-이름은-범위-크기에-비례해야-한다"><a href="#변수의-이름은-범위-크기에-비례해야-한다" class="headerlink" title="변수의 이름은 범위 크기에 비례해야 한다."></a>변수의 이름은 범위 크기에 비례해야 한다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pricePerLotto = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> Prizesum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Lotto lotto : lottos) &#123;</span><br><span class="line">    prizeSum += pricePerLotto * lotto.getPrize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이름이 길수록 사용되는 범위가 넓다고 생각하자.<br>예를 들면 for 문의 i는 해당 루프에서만 사용되서 짧아도 된다.<br>이름이 길수록 검색도 용이하다.</p><h4 id="맥락을-추가하라"><a href="#맥락을-추가하라" class="headerlink" title="맥락을 추가하라"></a>맥락을 추가하라</h4><p>이름 그 자체로 의미를 분명히 보여주는 변수는 없다.<br>함수나 클래스에서 맥락을 부여하면 이름을 더 자연스럽게 읽힐 수 있다.<br>이마저도 힘들면 접두사를 붙일 수 있다. (stateName, 이런 식으로..)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">(String name, String position)</span> </span>&#123;</span><br><span class="line">    System.out.println(name + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name는 어떤 이름을 의미하고, positon는 어떤 위치를 표시하는 건지 도저히 알 수 없다.</p><p>이름과 포지션은 사실 자동차의 이름과 자동차의 위치를 말해주는 변수들이다.<br>그럼 이를 더 잘 알려주기 위해 맥락을 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Car라는 맥락 안에서 이름과 위치를 파악하면 좀 더 의미있게 파악할 수 있다.</p><h4 id="불필요한-맥락-제거"><a href="#불필요한-맥락-제거" class="headerlink" title="불필요한 맥락 제거"></a>불필요한 맥락 제거</h4><p>그렇다고 불필요하게 맥락을 이름에 붙여주는건 불필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carPosition;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 Car라는 맥락 안에서 쓰이는 이름에 굳이 car를 붙이지 않아도 되지않을까?</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</guid>
      <pubDate>Thu, 03 Mar 2022 15:47:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.&lt;br&gt;이런 영향력이 있는 자원을</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.<br>이런 영향력이 있는 자원을 클래스 내부에서 만들면 안된다.<br>대신 이 자원(혹은 자원을 만드는 팩토리)을 해당 클래스를 인스턴스화 할 때 넘겨주자.</p><h3 id="자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴"><a href="#자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴" class="headerlink" title="자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴"></a>자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴</h3><p>맞춤법 검사기가 사전을 자원으로 가진다고 가정하자.<br>만약 사전을 직접 명시한다는 건 어떤 얘기일까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정적 유틸리티를 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 방지</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//싱글톤을 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SpellChecker INSTANCE = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두 예시 모두 자원인 사전을  final로 직접 명시하고 있다. </p><ul><li>나중에 다른 사전을 사용하고 싶을 때 변경이 힘들어진다.</li><li>final을 제거하고 사전을 교체하는 메서드를 추가하는 방식은 멀티스레드 환경에 쓸 수 없음.</li></ul><p><strong>즉 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식을 사용하면 안된다!</strong></p><h3 id="의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기"><a href="#의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기" class="headerlink" title="의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기"></a>의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Dictionary dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>자원이 많거나 의존 관계가 어떻든 잘 작동</li><li>불변성을 지원</li><li>생성자, 정적 팩터리, 빌더 모두에 적용 가능</li></ul><h3 id="자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt"><a href="#자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt" class="headerlink" title="자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;"></a>자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Supplier&lt;? extends Dictionary&gt; dictionaryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionaryFactory.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자원 팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.<br>자바에서는 Supplier&lt;T&gt;가 해당한다.</p><p>위처럼 생성자(정적 팩토리 메서드나 빌더)에 팩토리를 넘겨받으면 다음같이 활용 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpellChecker englishChecker = <span class="keyword">new</span> SpellChecker(() -&gt; <span class="keyword">new</span> Dictionary(Language.ENGLISH));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인스턴스화를 막으려거든 private 생성자를 사용해라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</guid>
      <pubDate>Thu, 03 Mar 2022 15:04:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;인스턴스화하지-않으려는-클래스&quot;&gt;&lt;a href=&quot;#인스턴스화하지-않으려는-클래스&quot; class=&quot;headerlink&quot; title=&quot;인스턴스화하지 않으려는 클래스?&quot;&gt;&lt;/a&gt;인스턴스화하지 않으려는 클래스?&lt;/h3&gt;&lt;p&gt;객체지향적이지 않지만 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="인스턴스화하지-않으려는-클래스"><a href="#인스턴스화하지-않으려는-클래스" class="headerlink" title="인스턴스화하지 않으려는 클래스?"></a>인스턴스화하지 않으려는 클래스?</h3><p>객체지향적이지 않지만 필요할 때가 있다.<br>java.lang.Math, java.util.Array 같이 기본 타입 값이나 배열 관련 메서드를 모아둔 곳<br>java.util.Collections와 같이 특정 인터페이스를 구현한 객체를 생성하는 정적 메서드를 모아둔 곳.<br>final 클래스와 관련된 메서드를 모아놓을 때. (final 클래스를 상속해서 하위 클래스에 메서드를 못넣음)</p><h3 id="인스턴스화-하지-않으려면-private-생성자를-사용"><a href="#인스턴스화-하지-않으려면-private-생성자를-사용" class="headerlink" title="인스턴스화 하지 않으려면 private 생성자를 사용"></a>인스턴스화 하지 않으려면 private 생성자를 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NotInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private로 기본 생성자를 해놓으면 외부에서 인스턴스화를 막을 수 있다.<br>Private 기본 생성자를 해놓으면 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문이다.</p><p>Private 기본 생성자는 상속도 못하게 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super(); 가 생략되어 있음. </span></span><br><span class="line"><span class="comment">//부모 객체의 생성자가 private면 이 과정이 안되니 상속이 안된다.      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>추상 클래스의 위험성</p></blockquote><p>추상 클래스 그 자체는 인스턴스화할 수 없다.</p><p>하지만, 추상 클래스는 상속한 클래스를 통해 인스턴스화 할 수 있다.<br>게다가 사용자가 추상 클래스를 보면 인스턴스화 하지 말라고 이해하지 않고, 상속받아서 사용하라고 이해하기 때문에 더 위험하다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 제네릭과 와일드카드 튜토리얼</title>
      <link>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/</guid>
      <pubDate>Fri, 25 Feb 2022 07:26:32 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.&lt;br&gt;JDK 8 기반으로 작성됐다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.<br>JDK 8 기반으로 작성됐다.</p><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/why.html">https://docs.oracle.com/javase/tutorial/java/generics/why.html</a></p><h2 id="제네릭은-왜-쓰는가"><a href="#제네릭은-왜-쓰는가" class="headerlink" title="제네릭은 왜 쓰는가"></a>제네릭은 왜 쓰는가</h2><p>제네릭은 클래스, 인터페이스, 메서드를 선언할 때 타입(클래스, 인터페이스)도 매개변수로 만들 수 있다.<br>전통적인 매개변수와 마찬가지로 타입 매개변수도 다양한 인풋을 받을 수 있게한다.</p><ol><li><p>타입 체크를 컴파일 타임에 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정수를 리스트에 담아서 사용하려고 했는데 실수로 문자열을 넣는 상황</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//제네릭이 아닌 경우</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">//컴파일 에러가 발생하지 않는다.</span></span><br><span class="line"><span class="keyword">int</span> hello = (<span class="keyword">int</span>) list.get(<span class="number">0</span>); <span class="comment">//나중에 실행하면 여기서 ClassCastException이 발생한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//제네릭인 경우</span></span><br><span class="line">List&lt;Integer&gt; genericList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">genericList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">//컴파일 에러</span></span><br></pre></td></tr></table></figure></li><li><p>캐스팅 할 필요 없어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//제네릭 없는 경우</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;하이&quot;</span>);</span><br><span class="line">String hi = (String) list.get(<span class="number">0</span>); <span class="comment">//제네릭을 전달하지 않으면 Object를 반환</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;하이&quot;</span>);</span><br><span class="line">String hello = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="제네릭-간단하게-사용해보자"><a href="#제네릭-간단하게-사용해보자" class="headerlink" title="제네릭 간단하게 사용해보자"></a>제네릭 간단하게 사용해보자</h2><p>아무 타입이나 저장할 수 있는 Box 클래스를 구현하고자 한다.<br>제네릭 없이 구현하자면 다음과 같을 것 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectBox</span> </span>&#123;</span><br><span class="line">        Object content;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(Object content)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우, get할 때마다 casting을 해줘야 된다.<br>그리고 담겨진 내용물을 잘못 파악해 casting해도 컴파일 타임에 알 수 없고 런타임 때 ClassCastException이 발생한다.</p><h4 id="제네릭을-사용"><a href="#제네릭을-사용" class="headerlink" title="제네릭을 사용"></a>제네릭을 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBox</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T content;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>제네릭을 사용하면 캐스팅이 필요없고 casting도 필요 없다.</p><h4 id="타입-파라미터-네이밍-컨벤션"><a href="#타입-파라미터-네이밍-컨벤션" class="headerlink" title="타입 파라미터 네이밍 컨벤션"></a>타입 파라미터 네이밍 컨벤션</h4><p>위에서 T는 타입 파라미터라고 한다.</p><ul><li>E - Element</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li><li>S, U, V - 2, 3, 4번째 타입</li></ul><p>이렇게 지칭한다.</p><h4 id="제네릭-타입-인보킹과-인스턴스화"><a href="#제네릭-타입-인보킹과-인스턴스화" class="headerlink" title="제네릭 타입 인보킹과 인스턴스화"></a>제네릭 타입 인보킹과 인스턴스화</h4><p>제네릭 타입 인보킹은 위에서 적은 T와 같은 매개변수를 우리가 의도한 실제 타입으로 변환하는 행위를 말한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox;</span><br></pre></td></tr></table></figure><p>참조변수를 통해 타입 인보킹을 해줄 수 있다.<br>이때 조심해야 할 것은 T는 타입 매개변수이고, Integer는 타입인자이다. 이 두가지는 다르다.</p><p>제네릭을 사용하는 클래스를 인스턴스화하려면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//타입 추론도 된다.</span></span><br><span class="line">Box&lt;Integer&gt; integerBox2 = <span class="keyword">new</span> Box&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Enum에서 메서드 참조와 BiFunction 사용하기</title>
      <link>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/</guid>
      <pubDate>Thu, 24 Feb 2022 14:12:58 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;문제 배경 (안</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다.</p><blockquote><p>문제 배경 (안좋은 사례 모음)</p></blockquote><p>로또 순위를 Enum LottoRank로 등수와 상금을 관리하고자 한다.<br>LottoRank가 맞춘 번호 갯수와 보너스 번호 맞춤여부를 전달받아 등수를 판별해야 한다.</p><ol><li><p>LottoRank에 맞춘 번호 갯수와 보너스 번호 맞춤여부를 추가로 저장하면 된다?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), <span class="number">6</span>, <span class="keyword">false</span>),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>),<span class="number">5</span>, <span class="keyword">true</span>),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), <span class="number">5</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">false</span>),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">false</span>),</span><br><span class="line">    NOTHING(Money.ZERO, <span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//이하 생략...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>그런데 문제가 있다. 4등, 5등은 보너스 맞춤여부가 false이든 true이든 상관없이 맞춘 갯수만 중요하다.<br>그리고 꽝인 경우, 맞춘 갯수가 2개 뿐만 아니라 1개, 0개여도 꽝이다. 그리고 꽝도 4등 5등의 경우와 마찬가지로 보너스 맞춤여부가 상관없다.<br>이런 경우도 전부 알맞은 상금을 가진 열거형 객체를 반환해줘야 한다.</p></li><li><p>좀 더 순위가 나오는 경우를 구체화한다?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), <span class="number">6</span>, <span class="keyword">false</span>),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>),<span class="number">5</span>, <span class="keyword">true</span>),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), <span class="number">5</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH_WITH_BONUS(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">true</span>),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">false</span>),</span><br><span class="line">    FIFTH_WITH_BONUS(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">true</span>),</span><br><span class="line">    NOTHING_TWO(Money.ZERO, <span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_TWO_WITH_BONUS(Money.ZERO, <span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">    NOTHING_ONE(Money.ZERO, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_ONE_WITH_BONUS(Money.ZERO, <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">    NOTHING_(Money.ZERO, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_WITH_BONUS(Money.ZERO, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//이하 생략...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>음…이렇게 하면 당연히 안된다!!!!!!!<br>물론 보너스 번호 일치여부를 또 다른 열거형으로 도입하면 보너스 맞춤여부가 상관없는 경우 BONUS_MATCH.NOT_NEED 이런 식으로 처리하면 되긴 할 것이다.<br>그렇지만 NOTHING의 맞춘 갯수가 0 ~ 2개를 모두 적용되어야 된다.</p></li></ol><h3 id="BiFunction-도입하기"><a href="#BiFunction-도입하기" class="headerlink" title="BiFunction 도입하기"></a>BiFunction 도입하기</h3><p>이제 생각을 좀 바꿔보자.<br>열거형 객체가 순위를 정하는 기준을 메서드참조로 저장하고 있다면 어떨까?</p><h4 id="1-일단-등수를-구별하는-기준을-메서드로-만들어주자"><a href="#1-일단-등수를-구별하는-기준을-메서드로-만들어주자" class="headerlink" title="1. 일단 등수를 구별하는 기준을 메서드로 만들어주자"></a>1. 일단 등수를 구별하는 기준을 메서드로 만들어주자</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFirstPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSecondPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">5</span> &amp;&amp; bonusMatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isThirdPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">5</span> &amp;&amp; !bonusMatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFourthPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFifthPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNothingPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= matchCount &amp;&amp; matchCount &lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 각 등수를 구분하는 기준을 정해준다.<br>물론 bonusMatch를 사용하지 않는 경우도 있다. 하지만 나중에 메서드 참조를 위해서 넣어줬다.</p><h4 id="2-BiFunction을-메서드-참조를-통해-열거형의-필드로-보내준다"><a href="#2-BiFunction을-메서드-참조를-통해-열거형의-필드로-보내준다" class="headerlink" title="2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다."></a>2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), LottoRank::isFirstPrize),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>), LottoRank::isSecondPrize),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), LottoRank::isThirdPrize),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), LottoRank::isFourthPrize),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), LottoRank::isFifthPrize),</span><br><span class="line">    NOTHING(Money.ZERO, LottoRank::isNothingPrize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Money prize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;Integer, Boolean, Boolean&gt; predicate;</span><br><span class="line"></span><br><span class="line">    LottoRank(Money prize, BiFunction&lt;Integer, Boolean, Boolean&gt; predicate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prize = prize;</span><br><span class="line">        <span class="keyword">this</span>.predicate = predicate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 이하 생략</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>두가지 객체를 받아서 한가지로 결과를 반환하는 BiFunction 인터페이스를 필드로 가지고, 생성자로 초기화해주자.<br>그리고 우리가 만들었던 메서드들이 메서드 참조로 BiFunction을 구현하게 된다!!</p><h4 id="3-각-객체의-BiFunction을-통해-적절한-순위-객체를-반환한다"><a href="#3-각-객체의-BiFunction을-통해-적절한-순위-객체를-반환한다" class="headerlink" title="3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다."></a>3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//열거형의 필드와 생성자는 위에 나와있으니 생략.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LottoRank <span class="title">of</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(values())</span><br><span class="line">                .filter(rank -&gt; rank.isMatched(matchCount, bonusMatch))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElseThrow(InvalidMatchCountException::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//등수 기준 구현 메서드는 위에 나와있으니 생략.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">(<span class="keyword">int</span> matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.apply(matchCount, bonusMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LottoRank의 모든 객체들을 순회하면서 그 객체의 BiFunction에 판별에 필요한 정보를 전달해줘서 적절한 순위를 찾아낸다!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Junit으로 parameterized test</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/</guid>
      <pubDate>Mon, 21 Feb 2022 12:16:22 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다.&lt;/p&gt;
&lt;h3 id</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>@ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다.</p><h3 id="MethodSource"><a href="#MethodSource" class="headerlink" title="@MethodSource"></a>@MethodSource</h3><blockquote><p>도입 배경</p></blockquote><p>자동차 이름의 글자 갯수가 5개 이하여야 하고, 자동차 이름이 빈 문자열이면 안되고 등등 다양한 제약 사항을 테스트해보고 싶다고 하자.<br>근데 테스트 코드를 작성하다보니 다음과 같이 메서드가 비슷비슷하게 나올 때 이를 리팩토링해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;NonAsciiCharacters&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_글자수_테스트() &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(<span class="string">&quot;다섯글자이상&quot;</span>))</span><br><span class="line">                .isInstanceOf(RuntimeException.class)</span><br><span class="line">                .hasMessageContaining(<span class="string">&quot;자동차 이름은 5자 이하여야 합니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름이_존재하지_않는_경우_테스트() &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                .isInstanceOf(RuntimeException.class)</span><br><span class="line">                .hasMessageContaining(<span class="string">&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 등등...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>해결하기</p></blockquote><p>주목할 점은 한 테스트 메서드에 여러개의 인자를 여러 케이스로 보낼 수 있다는 점이다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title">provideCarNameAndExceptionMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">                Arguments.of(<span class="keyword">null</span>, <span class="string">&quot;자동차 이름을 찾을 수 없습니다!&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;다섯글자이상&quot;</span>, <span class="string">&quot;자동차 이름은 5자 이하여야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;&quot;</span>, <span class="string">&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot; &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;    &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_예외_테스트(String carName, String message) &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(carName))</span><br><span class="line">                .isInstanceOf(CarNameException.class)</span><br><span class="line">                .hasMessageContaining(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음같이 @ParameterizedTest해서 @MethodSource로 해결할 수 있다!</p><h3 id="ValueSource"><a href="#ValueSource" class="headerlink" title="@ValueSource"></a>@ValueSource</h3><blockquote><p>도입 배경</p></blockquote><p>한가지 메서드에 여러가지 경우의 수를 넣어 실험하고 싶은데 어떻게 할까?<br>예를 들어 자동차 이름에 여러가지 이름을 넣어보고 실제로 들어갔는지 테스트해보고 싶으면 어떻게 할지 고민해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_테스트() &#123;</span><br><span class="line">  Car klayCar = <span class="keyword">new</span> Car(<span class="string">&quot;klay&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(klayCar.getName()).isEqualTo(<span class="string">&quot;klay&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Car eveCar = <span class="keyword">new</span> Car(<span class="string">&quot;eve&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(eveCar.getName()).isEqualTo(<span class="string">&quot;eve&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Car pobiCar = <span class="keyword">new</span> Car(<span class="string">&quot;pobi&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(pobiCar.getName()).isEqualTo(<span class="string">&quot;pobi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 무식하게 하면 당연히 뚜들겨 맞는다.</p><blockquote><p>해결하기</p></blockquote><p>주목할점은 전달될 인자의 자료형에 따라 strings, ints 등 필드값을 바꿔주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;클레이&quot;, &quot;이브&quot;, &quot;포비&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_테스트(String carName) &#123;</span><br><span class="line">  Car car = <span class="keyword">new</span> Car(carName, <span class="number">0</span>);</span><br><span class="line">  assertThat(car.getName()).isEqualTo(carName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnumSource"><a href="#EnumSource" class="headerlink" title="@EnumSource"></a>@EnumSource</h3><p>열거형도 파라미터로 전달해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = CardFace.class)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore &gt; <span class="number">0</span> &amp;&amp; cardScore &lt; <span class="number">11</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>names 필드를 통해 열거형에서 일부만 골라서 넘겨줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore == <span class="number">10</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode 필드를 사용하면 일부를 제외하고 넘겨줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(</span></span><br><span class="line"><span class="meta">    value = CardFace.class, </span></span><br><span class="line"><span class="meta">    names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;,</span></span><br><span class="line"><span class="meta">    mode = EnumSource.Mode.EXCLUDE)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore != <span class="number">10</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CsvSource"><a href="#CsvSource" class="headerlink" title="@CsvSource"></a>@CsvSource</h3><p>CsvSource는 여러 값을 문자열로 작성해주면 알아서 맞는 매개변수로 바꿔서 가져온다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(value = &#123;&quot;ACE,FIVE,true&quot;, &quot;ACE,SIX,false&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">canReceiveCard</span><span class="params">(CardFace face1, CardFace face2, <span class="keyword">boolean</span> expected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Participator dealer = <span class="keyword">new</span> Dealer();</span><br><span class="line">    <span class="keyword">final</span> Card firstCard = <span class="keyword">new</span> Card(SPADE, face1);</span><br><span class="line">    <span class="keyword">final</span> Card secondCard = <span class="keyword">new</span> Card(SPADE, face2);</span><br><span class="line"></span><br><span class="line">    dealer.receiveCard(firstCard);</span><br><span class="line">    dealer.receiveCard(secondCard);</span><br><span class="line"></span><br><span class="line">    assertThat(dealer.canReceiveCard()).isEqualTo(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>파라미터 테스트 이름 설정하기</p></blockquote><p>@ParameterizedTest의 name 필드에 {매개변수인덱스}를 넘겨주면 해당 인자가 테스트 이름에 포함된다.</p><p>{매개변수 인덱스} 말고도 다양한 템플릿을 사용할 수 있다.<br>{displayName} : 테스트 메서드 이름<br>{arguments} : 모든 인자를 쉼표로 구분해서 모두 표현<br>{argumentsWithNames} : 모든 인자를 이름과 함께 보여줌.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest(name = &quot;&#123;0&#125; vs &#123;1&#125; is &#123;2&#125;&quot;)</span></span><br><span class="line"><span class="meta">@CsvSource(value = &#123;&quot;BLACKJACK,BUST,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BLACKJACK,STAND,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,BUST,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BLACKJACK,BLACKJACK,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,STAND,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BUST,BUST,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BUST,STAND,LOSE&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,BLACKJACK,LOSE&quot;,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getResultFromStatus</span><span class="params">(Status status1, Status status2, Result expected)</span> </span>&#123;</span><br><span class="line">    Result actual = Result.of(status1, status2);</span><br><span class="line"></span><br><span class="line">    assertThat(actual).isEqualTo(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>더 알아보기</p></blockquote><p><a href="https://www.baeldung.com/parameterized-tests-junit-5">https://www.baeldung.com/parameterized-tests-junit-5</a></p><p><a href="https://www.arhohuttunen.com/junit-5-parameterized-tests/">https://www.arhohuttunen.com/junit-5-parameterized-tests/</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한테크코스 자동차 경주 미션 회고</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/</guid>
      <pubDate>Mon, 21 Feb 2022 09:37:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.&lt;br&gt;같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다.&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.<br>같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다.</p><p>페어 프로그래밍으로 같이 하면서, 처음엔 나 혼자하는게 더 빠르지 않을까 싶기도 했었는데,<br>같이하는 페어의 독특한 생각을 많이 느낄 수 있어서 나 혼자하는 것보다 더 괜찮은 결과물을 얻을 수 있었던 것 같다.</p><p>미션을 마무리한 날, 같은 데일리 미팅 크루들과 자신의 코드를 설명하는 시간을 가졌다.<br>역시 각 크루들의 코드가 나와 다른 부분도 많았는데, 그 부분을 잘 설득하는 크루를 보며 감탄했다.<br>반면 나는 아직 설명도 제대로 못하고, 내가 왜 그렇게 짰는지 설득도 잘 못하는 것 같아 아쉽다…!</p><p>부족한 게 많으면 나아질 부분도 많다는 뜻. 이제 더 열심히 공부해서 다른 크루에게 도움이 되는 크루가 되자.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바의 예외 Throwable, Error, Exception</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/java-basic/java-exception/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/java-basic/java-exception/</guid>
      <pubDate>Mon, 21 Feb 2022 01:34:05 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Throwable -&amp;gt; Exception -&amp;gt; RuntimeException 등 다양한 예외&lt;br&gt;Throwable은 stackTrace 생성 등 예외에 필요한 다양한 </description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>Throwable -&gt; Exception -&gt; RuntimeException 등 다양한 예외<br>Throwable은 stackTrace 생성 등 예외에 필요한 다양한 일을 함<br>Exception은 예외 메시지를 받아 초기화할 수 있다<br>RuntimeException은 치명적이진 않은 예외를 뜻함.<br>RuntimeException은 치명적일 수 있는 에외로 반드시 처리를 해줘야 함.</p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>모든 에러와 예외의 부모 클래스다.<br>Throwable의 인스턴스만 JVM이나 throw 키워드를 통해 예외나 에러를 thrown 될 수 있다.<br>마찬가지로 catch문에 Throwable의 인스턴스만 올 수 있다.</p><p>Throwable 객체는 생성될 때 해당 예외가 발생하던 수행 스택의 스냅샷을 가지게 된다.<br>또한 다른 Throwable에 의해 생성된 경우 cause를 통해 알 수 있다.<br>cause는 상위 Exception가 throw 될 때 굳이 하위 레이어의 내용까지 전파하지 않기 위함이다.</p><p>사실 개발하는 입장에서는 자주 사용하진 않는다.</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Throwable을 상속받는 클래스로,<br>Try catch로 처리되어선 안될 정도로 심각한 문제를 일으킬 수 있는 문제들을 Error 클래스로 표현한다.<br>일반적으로 비정상적인 상태를 나타낼 때 주로 사용된다.</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Throwable을 상속받는 클래스로,<br>Try catch 되어야할 이유가 있는 문제들을 Exception으로 표현한다.<br>이때 Checked Exception과 RuntimeException 두가지로 구분된다.</p><p>Checked Exception은 반드시 try catch 되거나 throws 되어야 컴파일 되는 예외이다.<br>RuntimeException은 try catch 되거나 throws 되지 않아도 되는 예외이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/java-basic/java-exception/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 사용자 정의 예외 만들기</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/java-custom-exception/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/java-custom-exception/</guid>
      <pubDate>Sun, 20 Feb 2022 23:37:58 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예외를 상속하는 클래스를 통해 예외를 만들 수 있다.&lt;br&gt;생성자를 통해 에러 메시지를 초기화 할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;배경&lt;/p&gt;
&lt;/blockquote</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>예외를 상속하는 클래스를 통해 예외를 만들 수 있다.<br>생성자를 통해 에러 메시지를 초기화 할 수 있다.</p><blockquote><p>배경</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkCarNameEmpty</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (carName == <span class="keyword">null</span> || carName.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;자동차 이름이 입력되지 않았습니다!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음같이 작성하면 자동차 이름이 빈 문자열이거나 null인 경우 런타임예외를 발생시킨다.</p><p>RuntimeException은 너무 포괄적인 의미이니 도메인에 적합한 예외를 만들어보자.</p><h3 id="예외-클래스-만들기"><a href="#예외-클래스-만들기" class="headerlink" title="예외 클래스 만들기"></a>예외 클래스 만들기</h3><h4 id="1-생성자를-그대로-사용하기"><a href="#1-생성자를-그대로-사용하기" class="headerlink" title="1. 생성자를 그대로 사용하기"></a>1. 생성자를 그대로 사용하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyCarNameException</span> <span class="keyword">extends</span> <span class="title">RuntimeExecption</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EmptyCarNameException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EmptyCarNameException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EmptyCarNameException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 예외를 상속한 클래스를 만들고, 생성자들을 만들면 커스텀 예외로 활용할 수 있다.</p><h4 id="2-좀-더-활용하기"><a href="#2-좀-더-활용하기" class="headerlink" title="2. 좀 더 활용하기"></a>2. 좀 더 활용하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarNameException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 자동차 이름에 관련된 예외들이 모두 상속하는 수퍼클래스를 만들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyCarNameException</span> <span class="keyword">extends</span> <span class="title">CarNameException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmptyCarNameException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;빈 문자열을 자동차 이름으로 입력할 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자동차 이름 예외를 상속받도록 하였고,<br>이미 특정 도메인 상황을 예외로 만들고 싶어서 사용자 정의 예외를 만들었기 때문에, 굳이 매번 에러메시지를 입력받아 생성할 필요가 없다고 생각했다.<br>그래서 예외 클래스에 정해진 에러 메시지로 초기화하도록 만들었다.</p><h3 id="실제-코드에-적용시켜보기"><a href="#실제-코드에-적용시켜보기" class="headerlink" title="실제 코드에 적용시켜보기"></a>실제 코드에 적용시켜보기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_CAR_NAME_LENGTH = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String EMPTY_STRING = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String carName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarName</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        checkCarName(carName);</span><br><span class="line">        <span class="keyword">this</span>.carName = carName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarName</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        checkCarNameNotNull(input);</span><br><span class="line">        checkCarNameLength(input);</span><br><span class="line">        checkCarNameExists(input);</span><br><span class="line">        checkCarNameIsNotSpace(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarNameNotNull</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarNameNullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarNameLength</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carName.length() &gt; MAX_CAR_NAME_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarNameLengthOverException(carName.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarNameExists</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carName.equals(EMPTY_STRING)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarNameNotExistsException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarNameIsNotSpace</span><span class="params">(String carName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carName.trim().equals(EMPTY_STRING)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarNameSpaceException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 도메인에서 우리가 만든 사용자 예외를 검증해보자.<br>도메인 객체가 만들어지기 전에 예외를 모두 검증한다.</p><h3 id="테스트해보기"><a href="#테스트해보기" class="headerlink" title="테스트해보기"></a>테스트해보기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title">provideCarNameAndExceptionMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">                Arguments.of(<span class="keyword">null</span>, <span class="string">&quot;자동차 이름을 찾을 수 없습니다!&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;다섯글자이상&quot;</span>, <span class="string">&quot;자동차 이름은 5자 이하여야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;&quot;</span>, <span class="string">&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot; &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;    &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이릅_예외_테스트(String carName, String message) &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(carName))</span><br><span class="line">                .isInstanceOf(CarNameException.class)</span><br><span class="line">                .hasMessageContaining(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다양한 예외 상황마다 예외 객체와 예외 메시지를 통해 테스트를 할 수 있다!</p><h3 id="사용자-예외의-장단점"><a href="#사용자-예외의-장단점" class="headerlink" title="사용자 예외의 장단점"></a>사용자 예외의 장단점</h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ol><li><p>클래스의 이름으로 어떤 예외인지 가늠가능하다.</p><p>CarNameEmtpyException이면 어떤 상황인지 바로 이해가능하다!</p></li><li><p>상세한 예외 정보를 제공할 수 있다.</p><p>자동차의 이름 길이가 5를 넘기면 예외를 발생시키고자 한다. 이때 사용자가 입력한 이름의 길이도 함께 알려주고 싶다면?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameLengthOverException</span> <span class="keyword">extends</span> <span class="title">CarNameException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarNameLengthOverException</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;자동차 이름은 5자 이하여야 합니다. 입력된 글자 수 : &quot;</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>예외 핸들링이 용이하다.</p></li><li><p>해당 예외 상황에 관련된 정보를 한 곳에 관리 가능하다.</p></li></ol><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ol><li><p>새로운 클래스를 작성해줘야 된다.</p><p>굳이 이미 있는 예외 클래스로도 처리 가능한데, 굳이 새로운 클래스를 작성해야 될 지 고민해야한다.</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/java-custom-exception/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 일급 컬렉션 활용해보기</title>
      <link>https://yangdongjue5510.github.io/2022/02/16/java/woowa-tech-course/java-first-collection/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/16/java/woowa-tech-course/java-first-collection/</guid>
      <pubDate>Wed, 16 Feb 2022 12:10:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일급 컬렉션은 컬렉션 객체를 감싸는 객체를 말한다.&lt;br&gt;일급 컬렉션은 객체를 만들 때 검증해야 할 로직을 모아 둘 수 있다.&lt;br&gt;일급 컬렉션은 해당 컬렉션이 행해야 할 책임을 </description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>일급 컬렉션은 컬렉션 객체를 감싸는 객체를 말한다.<br>일급 컬렉션은 객체를 만들 때 검증해야 할 로직을 모아 둘 수 있다.<br>일급 컬렉션은 해당 컬렉션이 행해야 할 책임을 모아 둘 수 있다.</p><p>불변성을 지키기 위해서는 </p><ol><li><p>setter 금지. </p></li><li><p>일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당</p></li><li><p>getter 할 때 불변 객체 반환.</p></li></ol><h1 id="일급-컬렉션이란"><a href="#일급-컬렉션이란" class="headerlink" title="일급 컬렉션이란"></a>일급 컬렉션이란</h1><p>일급 컬렉션은 컬렉션 객체를 감싸는 객체다.<br>일급 컬렉션은 멤버 변수로 감싸고자 하는 컬렉션만 갖는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipatedCars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_POSITION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Car&gt; cars;</span><br><span class="line"></span><br><span class="line"><span class="comment">//이하 생략...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="일급-컬렉션의-강점"><a href="#일급-컬렉션의-강점" class="headerlink" title="일급 컬렉션의 강점"></a>일급 컬렉션의 강점</h1><h4 id="1-일급-컬렉션은-해당-컬렉션의-검증-로직을-한-곳에-모을-수-있다"><a href="#1-일급-컬렉션은-해당-컬렉션의-검증-로직을-한-곳에-모을-수-있다" class="headerlink" title="1. 일급 컬렉션은 해당 컬렉션의 검증 로직을 한 곳에 모을 수 있다."></a>1. 일급 컬렉션은 해당 컬렉션의 검증 로직을 한 곳에 모을 수 있다.</h4><p>예를 들어 자동차 경주에 참가할 자동차 리스트를 관리한다고 가정하자.<br>이때 참가할 자동차들의 이름은 중복되면 안된다.</p><p>일급 컬렉션을 활용하면 참가할 자동차를 생성할 때 다음 같이 검증할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipatedCars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_POSITION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Car&gt; cars;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParticipatedCars</span><span class="params">(List&lt;String&gt; carNames)</span> </span>&#123;</span><br><span class="line">        checkCarNameDuplicated(carNames);</span><br><span class="line">        <span class="keyword">this</span>.cars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String carName : carNames) &#123;</span><br><span class="line">            cars.add(<span class="keyword">new</span> Car(carName, START_POSITION));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCarNameDuplicated</span><span class="params">(List&lt;String&gt; carNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = carNames.stream().distinct().count();</span><br><span class="line">        <span class="keyword">if</span> (count != carNames.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarNameDuplicationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//이하 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 일급 컬렉션 객체의 생성자에 검증 로직을 넣어두면 참여중인 자동차 객체는 반드시 중복되지 않은 이름들을 가진다고 확신할 수 있다.</p><p>일급 컬렉션을 사용하지 않는다면 이런 검증 로직은 서비스 메서드로 처리하게 된다.<br>그러면 매번 참여중 인 자동차를 만들 때 마다 서비스 메서드를 호출해줘야 되는 번거로움이 생긴다.</p><h4 id="2-상태와-행동을-한-곳에서-관리-할-수-있다"><a href="#2-상태와-행동을-한-곳에서-관리-할-수-있다" class="headerlink" title="2. 상태와 행동을 한 곳에서 관리 할 수 있다."></a>2. 상태와 행동을 한 곳에서 관리 할 수 있다.</h4><p>참여한 자동차들은 모두 레이싱을 시도하는 역할을 할 수 있다.</p><p>다음 같이 일급 컬렉션에 행동을 추가해서 관리할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipatedCars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_POSITION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Car&gt; cars;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParticipatedCars</span><span class="params">(List&lt;String&gt; carNames)</span> </span>&#123;</span><br><span class="line">        checkCarNameDuplicated(carNames);</span><br><span class="line">        <span class="keyword">this</span>.cars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String carName : carNames) &#123;</span><br><span class="line">            cars.add(<span class="keyword">new</span> Car(carName, START_POSITION));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCarRacing</span><span class="params">(RandomNumberGenerator randomNumberGenerator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Car car : cars) &#123;</span><br><span class="line">            car.tryToMoveBy(randomNumberGenerator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>일급 컬렉션을 통해 이 객체가 어떤 행동을 하는지도 한눈에 볼 수 있게됐다.</p><h1 id="일급-컬렉션과-불변성"><a href="#일급-컬렉션과-불변성" class="headerlink" title="일급 컬렉션과 불변성"></a>일급 컬렉션과 불변성</h1><p>일급 컬렉션이 불변하다는 특징을 가졌다고 알려졌는데, 사실 그렇지 않을 수 있다는 포스트도 있다.</p><p><a href="https://tecoble.techcourse.co.kr/post/2020-05-08-First-Class-Collection/">관련 포스트</a></p><p>불변성을 지키고 싶다면 다음 세가지를 지켜주자</p><ol><li>setter를 사용하지 않는다.</li><li>일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당하자.</li><li>getter를 할 때 불변한 콜렉션으로 반환하자.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipatedCars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_POSITION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Car&gt; cars;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParticipatedCars</span><span class="params">(List&lt;String&gt; carNames)</span> </span>&#123;</span><br><span class="line">        checkCarNameDuplicated(carNames);</span><br><span class="line">        <span class="keyword">this</span>.cars = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// &lt;- 새로운 주소가 할당된다.</span></span><br><span class="line">        <span class="keyword">for</span> (String carName : carNames) &#123;</span><br><span class="line">            cars.add(<span class="keyword">new</span> Car(carName, START_POSITION));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Car&gt; <span class="title">getCars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.cars); <span class="comment">//&lt;- getter할 때 불변된 리스트가 반환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="여전히-궁금한-것들"><a href="#여전히-궁금한-것들" class="headerlink" title="여전히 궁금한 것들"></a>여전히 궁금한 것들</h3><ol><li>왜 일급 컬렉션은 </li></ol>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/16/java/woowa-tech-course/java-first-collection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>구글 자바 컨벤션 및 우테코 컨벤션에서 자주 틀리는 내용 모음!</title>
      <link>https://yangdongjue5510.github.io/2022/02/15/java/woowa-tech-course/java-convention/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/15/java/woowa-tech-course/java-convention/</guid>
      <pubDate>Tue, 15 Feb 2022 14:42:53 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;static import를 하지 않는다.&lt;br&gt;구현 순서는 상수 -&amp;gt; 클래스 변수 -&amp;gt; 인스턴스 변수 -&amp;gt; 생성자 -&amp;gt; 메서드 순이다.&lt;br&gt;변수 이름에 자료</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>static import를 하지 않는다.<br>구현 순서는 상수 -&gt; 클래스 변수 -&gt; 인스턴스 변수 -&gt; 생성자 -&gt; 메서드 순이다.<br>변수 이름에 자료형을 사용하지 말라<br>인스턴스 변수의 수를 최소화 한다.<br>오버로드한 메서드(생성자)들 사이에 다른 코드를 넣지말라.<br>비할당 연산자에서 줄바꿈하는 경우, 기호 앞에서 끊어짐(. :: &lt;<del>&amp;</del>&gt; 등…)<br>할당 연산자에서 줄바꿈하는 경우 기호 뒤에서 끊어짐(사실 어느쪽도 허용)</p><h3 id="static-import-하지-않는다"><a href="#static-import-하지-않는다" class="headerlink" title="static import 하지 않는다"></a>static import 하지 않는다</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//안좋은 예시</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> somepackage.SomeClass.doMethod;</span><br><span class="line"><span class="keyword">import</span> otherpackage.OtherClass;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doMethod();</span><br><span class="line">        OtherClass otherClass = <span class="keyword">new</span> OtherClass();</span><br><span class="line">        otherClass.doMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doMethod가 메서드가 두개다. 그래서 혼동이 온다.</p><h3 id="구현-순서는-상수-gt-클래스-변수-gt-인스턴스-변수-gt-생성자-gt-메서드-순"><a href="#구현-순서는-상수-gt-클래스-변수-gt-인스턴스-변수-gt-생성자-gt-메서드-순" class="headerlink" title="구현 순서는 상수 -&gt; 클래스 변수 -&gt; 인스턴스 변수 -&gt; 생성자 -&gt; 메서드 순"></a>구현 순서는 상수 -&gt; 클래스 변수 -&gt; 인스턴스 변수 -&gt; 생성자 -&gt; 메서드 순</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_INT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> classVariable = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> instanceVariable = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="변수-이름에-자료형을-사용하지-말라"><a href="#변수-이름에-자료형을-사용하지-말라" class="headerlink" title="변수 이름에 자료형을 사용하지 말라"></a>변수 이름에 자료형을 사용하지 말라</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//이런 변수이름들은 곤란하다.</span></span><br><span class="line">String carString = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line">List&lt;Integer&gt; intList;</span><br></pre></td></tr></table></figure><h3 id="인스턴스-변수의-수를-최소화-한다"><a href="#인스턴스-변수의-수를-최소화-한다" class="headerlink" title="인스턴스 변수의 수를 최소화 한다."></a>인스턴스 변수의 수를 최소화 한다.</h3><h3 id="오버로드한-메서드-생성자-들-사이에-다른-코드를-넣지말라"><a href="#오버로드한-메서드-생성자-들-사이에-다른-코드를-넣지말라" class="headerlink" title="오버로드한 메서드(생성자)들 사이에 다른 코드를 넣지말라."></a>오버로드한 메서드(생성자)들 사이에 다른 코드를 넣지말라.</h3><h3 id="비할당-연산자에서-줄바꿈하는-경우-기호-앞에서-끊어짐-lt-amp-gt-등…"><a href="#비할당-연산자에서-줄바꿈하는-경우-기호-앞에서-끊어짐-lt-amp-gt-등…" class="headerlink" title="비할당 연산자에서 줄바꿈하는 경우, 기호 앞에서 끊어짐(. :: &lt;&amp;&gt; 등…)"></a>비할당 연산자에서 줄바꿈하는 경우, 기호 앞에서 끊어짐(. :: &lt;<del>&amp;</del>&gt; 등…)</h3><h3 id="할당-연산자에서-줄바꿈하는-경우-기호-뒤에서-끊어짐-사실-어느쪽도-허용"><a href="#할당-연산자에서-줄바꿈하는-경우-기호-뒤에서-끊어짐-사실-어느쪽도-허용" class="headerlink" title="할당 연산자에서 줄바꿈하는 경우 기호 뒤에서 끊어짐(사실 어느쪽도 허용)"></a>할당 연산자에서 줄바꿈하는 경우 기호 뒤에서 끊어짐(사실 어느쪽도 허용)</h3>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/15/java/woowa-tech-course/java-convention/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바에서 정규 표현식 잘 활용하기</title>
      <link>https://yangdongjue5510.github.io/2022/02/09/java/woowa-tech-course/java-regex/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/09/java/woowa-tech-course/java-regex/</guid>
      <pubDate>Wed, 09 Feb 2022 14:45:29 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pattern 클래스와 Matcher 클래스를 활용해서 자바 정규 표현식을 잘 표현한다.&lt;/p&gt;
&lt;p&gt;특히 Matcher클래스에 정규 표현식을 compile(String)하고, m</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>Pattern 클래스와 Matcher 클래스를 활용해서 자바 정규 표현식을 잘 표현한다.</p><p>특히 Matcher클래스에 정규 표현식을 compile(String)하고, matcher(String)으로 대상 문자열을 전달해준다.<br>이때 find()메서드를 반드시 실행해줘야 정상적으로 Matcher 객체에 관련 내용이 할당된다!!</p><h1 id="Pattern-클래스로-정규-표현식-통과-여부-확인하기"><a href="#Pattern-클래스로-정규-표현식-통과-여부-확인하기" class="headerlink" title="Pattern 클래스로 정규 표현식 통과 여부 확인하기"></a>Pattern 클래스로 정규 표현식 통과 여부 확인하기</h1><p>주어진 문자열이 input이고, 정규식이 REGEX라는 변수에 할당됐을 때,<br>Pattern 클래스로 여부를 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatches</span><span class="params">(String input)</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> Pattern.matches(REGEX, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Matcher-클래스로-정규-표현식에-해당하는-문자열-부분-가져오기"><a href="#Matcher-클래스로-정규-표현식에-해당하는-문자열-부분-가져오기" class="headerlink" title="Matcher 클래스로 정규 표현식에 해당하는 문자열 부분 가져오기"></a>Matcher 클래스로 정규 표현식에 해당하는 문자열 부분 가져오기</h1><p>Pattern 클래스로 정규 표현식을 compile 메서드로 넘겨주고, 검사할 문자열을 matcher 메서드로 전달해주면 해당 문자열에 대한 Matcher 객체를 생성할 수 있다.<br>이때 중요한 건! 해당 객체의 find 함수를 실행해야 group 메서드로 입력된 문자열 중 정규 표현식에 해당하는 부분을 가져올 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">findRegexPart</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    Matcher matcher = Pattern.compile(REGEX).matcher(input);</span><br><span class="line">    matcher.find();</span><br><span class="line">    <span class="keyword">return</span> matcher.group();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/09/java/woowa-tech-course/java-regex/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA에서 @Embedded로 복합키 매핑하기</title>
      <link>https://yangdongjue5510.github.io/2022/02/03/spring/JPA/compositekey/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/03/spring/JPA/compositekey/</guid>
      <pubDate>Thu, 03 Feb 2022 08:11:16 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;@Embeddable를 붙인 복합키 클래스를 만든다&lt;/li&gt;
&lt;li&gt;엔티티 클래스에 @EmbeddedId를 통해 복합키 필드를 만든다.&lt;/li&gt;
&lt;li&gt;이때 엔티티 클래</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><ol><li>@Embeddable를 붙인 복합키 클래스를 만든다</li><li>엔티티 클래스에 @EmbeddedId를 통해 복합키 필드를 만든다.</li><li>이때 엔티티 클래스의 모든 매개변수를 받는 생성자를 만든다.<br>이때 복합키 필드는 new로 객체를 초기화해준다.</li></ol><h1 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h1><p>챌린지 테이블과 태그 테이블이 다대다 관계인 상황이다.<br>이때 태그 테이블은 이름이 기본키이고, 챌린지 테이블은 챌린지 ID가 기본키로 가진다.</p><p>우리는 챌린지 테이블과 태그 테이블 사이에 매핑 테이블을 도입해서 다대일 관계 두 개로 분리해서 사용하기로 했다.<br>챌린지 -(일대다)- 매핑 테이블 -(다대일)- 태그</p><p>이때 매핑 테이블은 기본키로 태그의 이름과 챌린지의 챌린지아이디를 가진다.(즉 복합키이다.)<br>이를 어떻게 JPA로 표현할까?</p><h1 id="관련-코드"><a href="#관련-코드" class="headerlink" title="관련 코드"></a>관련 코드</h1><blockquote><p>해결방법</p></blockquote><p>@EmbeddedId를 도입해서 복합키를 모은 클래스를 따로 만들어서 해결한다.</p><h2 id="ChallengeTag-매핑-테이블"><a href="#ChallengeTag-매핑-테이블" class="headerlink" title="ChallengeTag(매핑 테이블)"></a>ChallengeTag(매핑 테이블)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChallengeTag</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EmbeddedId</span></span><br><span class="line">    <span class="keyword">private</span> ChallengeTagPK challengeTagPK;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;challenge_id&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT))</span></span><br><span class="line">    <span class="meta">@MapsId(&quot;challengeId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Challenge challenge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;name&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT))</span></span><br><span class="line">    <span class="meta">@MapsId(&quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Tag tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChallengeTag</span><span class="params">(ChallengeTagPK challengeTagPK, Challenge challenge, Tag tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.challengeTagPK = <span class="keyword">new</span> ChallengeTagPK();</span><br><span class="line">        <span class="keyword">this</span>.challenge = challenge;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChallengeTagPK라는 필드를 만들어서 @EmbeddedId를 붙여줬다. 이러면 기본키를 복합키를 필드로 가지는 객체로 설정 할 수 있다.</p><p>이때 주의할 점 몇가지 알아보자.</p><h3 id="1-복합키에-따른-객체를-선언해줘야-한다"><a href="#1-복합키에-따른-객체를-선언해줘야-한다" class="headerlink" title="1. 복합키에 따른 객체를 선언해줘야 한다."></a><strong>1. 복합키에 따른 객체를 선언해줘야 한다.</strong></h3><ul><li>challengeId와 name을 복합키로 가지므로, Challenge 객체와 Tag 객체를 멤버로 가져야 한다.</li><li>각 객체는 @MapsId(“필드명”)으로 연결해줘야 한다. (괄호 안 이름은 ChallengeTagPK의 필드명이다.)</li></ul><h2 id="2-모든-필드를-매개변수로-받는-생성자를-선언해야-한다"><a href="#2-모든-필드를-매개변수로-받는-생성자를-선언해야-한다" class="headerlink" title="2. 모든 필드를 매개변수로 받는 생성자를 선언해야 한다."></a><strong>2. 모든 필드를 매개변수로 받는 생성자를 선언해야 한다.</strong></h2><ul><li>이때 기본키를 담당하는 객체는 new로 초기화 한다!</li><li>@AllArgsConstructor로 하지 않는다.</li></ul><h2 id="ChallengeTagPK-기본키-클래스"><a href="#ChallengeTagPK-기본키-클래스" class="headerlink" title="ChallengeTagPK(기본키 클래스)"></a>ChallengeTagPK(기본키 클래스)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChallengeTagPK</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long challengeId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Embeddable을 붙이면 복합키를 표현하는 클래스이다.</p><p>몇 가지 중요한 점을 살펴보자.</p><h3 id="1-Setter-메서드를-선언해줘야-한다"><a href="#1-Setter-메서드를-선언해줘야-한다" class="headerlink" title="1. Setter 메서드를 선언해줘야 한다."></a>1. Setter 메서드를 선언해줘야 한다.</h3><ul><li>나중에 이 클래스의 필드를 challenge와 tag의 기본키를 가져와 초기화한다.</li></ul><h3 id="2-Serializable을-구현해야-한다"><a href="#2-Serializable을-구현해야-한다" class="headerlink" title="2. Serializable을 구현해야 한다."></a>2. Serializable을 구현해야 한다.</h3><ul><li>Serializable은 직렬화가 가능하다는 의미이다.<ul><li>자바 객체를 외부 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는게 직렬화이다.<br>(자바 객체를 바이트로 만들면 다른 자바 시스템에서 Reader로 읽어들일 수 있다.)</li></ul></li></ul><h3 id="3-equals와-hashcode를-오버라이딩-해줘야-한다"><a href="#3-equals와-hashcode를-오버라이딩-해줘야-한다" class="headerlink" title="3. equals와 hashcode를 오버라이딩 해줘야 한다."></a>3. equals와 hashcode를 오버라이딩 해줘야 한다.</h3><ul><li>기본키는 식별할 수 있도록 해주는 역할이다.</li><li>@Embeddable이 붙은 객체는 각 객체들과 구분되는 기준이 명확해야 한다.<br>이 기준을 equals와 hashcode를 오버라이딩해서 해결한다.</li><li>롬복으로 @EqualsAndHashCode 를 붙여주면 쉽게 해결 가능하다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/jpa/">JPA</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/sable-project/">sable project</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/03/spring/JPA/compositekey/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>데이터베이스 설계 프로세스</title>
      <link>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/</link>
      <guid>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/</guid>
      <pubDate>Thu, 06 Jan 2022 13:35:42 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;데이터베이스 설계 과정을 배운다.&lt;/p&gt;
&lt;p&gt;실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다.&lt;/p&gt;
&lt;h1 id=&quot;임무-목표와-임무-명세</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>데이터베이스 설계 과정을 배운다.</p><p>실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다.</p><h1 id="임무-목표와-임무-명세-정의"><a href="#임무-목표와-임무-명세-정의" class="headerlink" title="임무 목표와 임무 명세 정의"></a>임무 목표와 임무 명세 정의</h1><p>임무 명세 : 이 데이터베이스의 존재 이유나 목적을 단순한 한 문장으로 정리</p><p>임무 목표 : 이 데이터베이스가 수행해야 할 작업을 정리.</p><p>이렇게 작성된 목표와 임무 명세는 사용자와 관리자에게 타당해야 한다.<br>각 임무 목표는 하나의 작업을 너무 디테일하지 않을 정도로 기술한다.</p><blockquote><p>예시</p></blockquote><p>임무 명세 : 함께 모으기 데이터베이스는 Sable의 함께모으기(저축 챌린지)에 필요한 데이터를 관리한다.</p><p>임무 1. 챌린지의 정보를 완전히 관리한다.<br>임무 2. 사용자의 정보를 완전히 관리한다.<br>임무 3. 챌린지마다 사용자가 작성한 리뷰를 관리한다.<br>임무 4. 사용자의 계좌를 관리한다.<br>임무 5. 챌린지의 계좌를 관리한다.</p><h1 id="기존-데이터베이스-분석"><a href="#기존-데이터베이스-분석" class="headerlink" title="기존 데이터베이스 분석"></a>기존 데이터베이스 분석</h1><p>해당 데이터베이스의 사용자와 관리자의 요구사항을 인터뷰. 기존의 데이터베이스 분석.</p><p>인터뷰를 통해 대상과 사건을 특정할 수 있다.<br>(<strong>사용자</strong>는 <strong>챌린지</strong>에 참여해서 <strong>규칙</strong>에 따라 <strong>저축</strong> 을 한다.)<br>여기서 대상은 사용자, 챌린지, 규칙, 저축이다.</p><p>대상을 정리했으면, 각 대상에 대한 특징을 찾아낼 수 있다.</p><p>이 과정에서 예상되는 필드를 구성할 수 있다.</p><ul><li>어떤 대상이, 어떤 특징을 가지는 지 분석</li><li>특정 대상의 특징을 설명하는게 필드다.</li><li>값 목록(특별한 값의 집합을 나타내는 특성)은 따로 표시한다.</li><li>계산된 필드는 따로 정리한다.</li><li>중복된 특성은 하나의 필드로 정리한다.(혹은 여러개로 나눠야 할 특성은 분해한다.)</li></ul><blockquote><p>예시</p></blockquote><h4 id="일단-우리-서비스에-요구사항을-정리해본다"><a href="#일단-우리-서비스에-요구사항을-정리해본다" class="headerlink" title="일단 우리 서비스에 요구사항을 정리해본다."></a>일단 우리 서비스에 요구사항을 정리해본다.</h4><p>사용자는 이름, 이메일, 생년월일, 닉네임, 성별, 비밀번호, 하나의 사용자 계좌와 여러 개의 챌린지 계좌를 가진다.<br>챌린지는 챌린지 호스트, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표 금액,  챌린지 성공한 사람들의 리뷰를 가진다.<br>챌린지는 챌린지 모드와 자유 모드가 있다.<br>챌린지 모드는 패널티 금액을 가진다.<br>자유 모드는 패널티 금액이 없다.<br>챌린지는 정해진 시간 전에 모집을 시작해서 시작일이 되면 모집을 마감한다.<br>사용자는 각 챌린지에서 자신이 원할 때 원하는 금액을 사용자 계좌에서 빼서 챌린지 계좌에 저축할 수 있다.<br>각 챌린지 계좌에 사용자가 저금한 내용은 저장된다.<br>….</p><h4 id="이제-대상을-정리해본다-대상은-사람-장소-물건-사건-등…"><a href="#이제-대상을-정리해본다-대상은-사람-장소-물건-사건-등…" class="headerlink" title="이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)"></a>이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)</h4><p>사용자, 챌린지, 호스트, 리뷰, 사용자 계좌, 챌린지 계좌</p><h4 id="이제-대상마다-특징을-정리해본다-계산된-필드와-값-목록-필드를-구분한다"><a href="#이제-대상마다-특징을-정리해본다-계산된-필드와-값-목록-필드를-구분한다" class="headerlink" title="이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.)"></a>이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.)</h4><p> 특징(필드) : 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표금액, 챌린지 패널티 금액, 챌린지 공식 여부, 챌린지 모드</p><p>값 목록 필드 : 사용자가 가지는 챌린지 계좌들, 챌린지에 참여한 사용자들, 사용자가 한 챌린지에 저금한 내용들, 사용자가 참여한 챌린지들, 사용자가 만든 챌린지들</p><p>계산된 필드 : 사용자의 미션 달성율, 사용자의 챌린지 예금 합, 사용자의 챌린지 저축액 / 챌린지 목표 금액, 챌린지의 참여 사용자 합</p><h1 id="데이터-구조-생성"><a href="#데이터-구조-생성" class="headerlink" title="데이터 구조 생성"></a>데이터 구조 생성</h1><ol><li>예비 필드 목록이 존재하면 이를 기반으로 대상에 할당해본다.(대상을 잘 설명하는 것 같은 필드를 할당)<ul><li>예비 필드 목록을 검토하는 중 새로운 대상이 필요하면 추가한다.</li></ul></li><li>앞 단계들을 통해 표현할 다양한 대상를 선정하여 테이블들에 할당한다.<br>(<em>처음 테이블을 만들면 모든 테이블은 데이터 테이블이 된다.</em>)<ol><li>데이터 테이블 : 조직에 중요한 주제를 나타냄</li><li>연결 테이블 : 다대다 관계의 두테이블의 연결 설정</li><li>부분 집합 테이블 : 특정 데이터 테이블과 관계. 특정 주제를 구체적으로 설명.<br>부분 집합 테이블은 데이터들이 해당 필드를 모두 사용하지 않은 경우가 많은 경우를 말한다.<br>(재고 테이블은 책 테이블과 장비 테이블을 하위 테이블로 만들 수 있다. (이는 서로 1대1 관계를 가진다.))</li><li>검증 테이블 : 데이터 무결성을 제공하는 중요한 테이블</li></ol></li><li>각 테이블의 필드들 할당하고 검토<ul><li><strong>좋은 필드의 조건</strong>을 따르는지 확인</li><li>필드들이 단독 값을 저장.</li><li>다중 구조나 다중값 필드는 개선</li><li>부분 집합 테이블을 구성한다.</li></ul></li><li>각 테이블 키 설정<ul><li>각 키는 데이터베이스에서 유일하게 식별할 수 있는 값이어야 한다.<br>(부분 집합 테이블을 제외하면 동일한 기본키를 가지면 안된다.)</li><li>만약 마땅한 키가 없는 경우, 인위적인 키를 만들어줄 수 있다.</li></ul></li><li>데이터베이스 각 필드의 필드 명세 설정<ul><li>일반적 요소 : 필드 이름, 소속 테이블 등…</li><li>물리적 요소 : 데이터 타입, 길이, 문자 지원 등..</li><li>논리적 요소 : 키 종류, 유일성, 널 지원, 기본값 등..</li></ul></li></ol><h5 id="좋은-필드의-조건"><a href="#좋은-필드의-조건" class="headerlink" title="좋은 필드의 조건"></a>좋은 필드의 조건</h5><ul><li>테이블의 대상의 특성을 잘 설명하는 필드가 되도록 한다.</li><li>필드는 단 하나의 값을 포함한다</li><li>더 작은 구성요소로 해체 될 수 없다.</li><li>계산되거나 연결된 값은 포함하지 않는다.</li><li>전체 데이터베이스에서 해당 필드는 유일하다.(연결되는 필드 외에..)</li><li>다중 부분 필드는 여러 필드로 나눠준다. (이름 -&gt; 성 , 이름)</li><li>다중값 필드는 새로운 테이블로 분리해서 사용한다.</li></ul><blockquote><p>예시</p></blockquote><h4 id="예비-필드-목록을-대상에-할당"><a href="#예비-필드-목록을-대상에-할당" class="headerlink" title="예비 필드 목록을 대상에 할당"></a>예비 필드 목록을 대상에 할당</h4><p>사용자 - 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부</p><p>챌린지 - 챌린지 식별아이디, 챌린지 이름, 시작일, 종료일, 내용, 주기, 목표금액, 패널티 금액, 챌린지 공식여부, 챌린지 모드, 챌린지 유효 여부</p><p>사용자 계좌 - 계좌 소유자, 계좌 잔고</p><p>챌린지 계좌 - 계좌 소유자, 계좌 잔고, 소속 챌린지 아이디</p><p>리뷰 - 리뷰 작성자 이메일, 리뷰 내용, 리뷰 작성 날짜, 리뷰의 챌린지 아이디</p><h4 id="값-목록-필드는-다른-테이블로-분리하고-종속되는-주제는-부분-집합-테이블로-만든다"><a href="#값-목록-필드는-다른-테이블로-분리하고-종속되는-주제는-부분-집합-테이블로-만든다" class="headerlink" title="값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다"></a>값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다</h4><p>챌린지의 태그는 따로 일대다 관계를 가지는 태그 테이블로 따로 빼서 만들고,</p><p>계좌 - 사용자 입출금 계좌 &amp; 챌린지 계좌 구조는 종속되는 주제인 사용자 계좌와 챌린지 계좌를 따로 부분집합 테이블로 만든다.</p><h1 id="테이블-관계-연결-및-결정"><a href="#테이블-관계-연결-및-결정" class="headerlink" title="테이블 관계  연결 및 결정"></a>테이블 관계  연결 및 결정</h1><p>테이블은 1대1, 1대다, 다대다 관계가 있다.<br>다만 다대다 관계는 주의해야 한다.</p><h5 id="다대다-관계의-문제"><a href="#다대다-관계의-문제" class="headerlink" title="다대다 관계의 문제"></a>다대다 관계의 문제</h5><p>다대다 관계로 외래키를 도입하면 그 외래키가 중복 데이터가 많이 발생한다.<br>그리고 만약 하나만 관계를 맺는 튜플을 삭제하면, 그 관계를 맺는 다른 테이블의 해당 튜플이 삭제될 수 있다.</p><p>학생과 수업 테이블이 다대다이고 서로 id을 외래키로 연결한다고 하면,<br>학생 테이블의 수업id가 중복되는 데이터가 많아진다.<br>한 학생만 듣는 수업이 있다고 했을 때, 그 학생을 삭제하면 그 수업이 삭제될 수 있다.</p><ol><li>테이블 관계와 관계의 특징을 확인</li><li>기본 키나 연결 테이블을 통해 각 관계에 있는 테이블 간의 논리적인 연결 설정.</li><li>각 테이블에 대한 참여의 유형과 정도를 결정</li></ol><h1 id="업무-규칙-정의-및-결정"><a href="#업무-규칙-정의-및-결정" class="headerlink" title="업무 규칙 정의 및 결정"></a>업무 규칙 정의 및 결정</h1><ol><li>데이터베이스의 다양한 측면에서 제약사항 확인</li><li>업무 규칙 설정</li><li>검증 테이블을 정의, 구현</li></ol><h1 id="뷰의-정의-및-결정"><a href="#뷰의-정의-및-결정" class="headerlink" title="뷰의 정의 및 결정"></a>뷰의 정의 및 결정</h1><ol><li>데이터로 작업하는 다양한 방법을 확인 (상세 정보 조회, 요약 조회 등..)</li><li>적당한 테이블과 필드를 활용해서 뷰를 정의(뷰의 표준을 정할 수 있음.)</li></ol><h1 id="데이터-무결성-재확인"><a href="#데이터-무결성-재확인" class="headerlink" title="데이터 무결성 재확인"></a>데이터 무결성 재확인</h1><ol><li>설계된 테이블이 잘 설계된 테이블인지 확인</li><li>필드가 적절한 구조인지 확인</li><li>테이블 수준 무결성 확인</li><li>필드 명세 점검, 무결성 점검</li><li>관계 유효성 점검, 각 테이블 참여 특징 명확히 결정.</li><li>데이터베이스의 다양한 측면에 있는 제약사항 결정</li></ol>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/database/">Database</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한테크코스 4기 최종 코딩테스트 후기</title>
      <link>https://yangdongjue5510.github.io/2021/12/19/java/woowa-tech-course/utecoprecourse4/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/19/java/woowa-tech-course/utecoprecourse4/</guid>
      <pubDate>Sun, 19 Dec 2021 12:39:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;최종-코딩테스트-문제-링크&quot;&gt;&lt;a href=&quot;#최종-코딩테스트-문제-링크&quot; class=&quot;headerlink&quot; title=&quot;최종 코딩테스트 문제 링크&quot;&gt;&lt;/a&gt;최종 코딩테스트 문제 링크&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://githu</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="최종-코딩테스트-문제-링크"><a href="#최종-코딩테스트-문제-링크" class="headerlink" title="최종 코딩테스트 문제 링크"></a>최종 코딩테스트 문제 링크</h1><p><a href="https://github.com/woowacourse/java-pairmatching-precourse">https://github.com/woowacourse/java-pairmatching-precourse</a></p><h1 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h1><h2 id="검증-로직-중복"><a href="#검증-로직-중복" class="headerlink" title="검증 로직 중복"></a>검증 로직 중복</h2><p>과정, 레벨, 미션을 입력받을 때, 해당 과정, 레벨, 미션이 존재하는지 검증해야 된다.<br>나는 이를 검사하는 메서드를 각 열거형 객체가 가지고 있도록 하고 findByName메서드로 이름에 맞는 객체를 가져오도록 했다.</p><p>과정을 예를 들면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">BACKEND(<span class="string">&quot;백엔드&quot;</span>),</span><br><span class="line">FRONTEND(<span class="string">&quot;프론트엔드&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">Course(String name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Course <span class="title">findByName</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">exceptionNotContain(input);</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(Course.values()).filter(course -&gt; course.name.equals(input)).findFirst().get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionNotContain</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Arrays.stream(Course.values()).anyMatch(course -&gt; course.name.equals(input))) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(NO_EXIST_COURSE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 exceptionNotContain(String input)이 입력값이 존재하는 지 검증하고 예외를 출력한다.<br>만약 외부에서 과정 객체를 가져오고 싶다면, findByName(String input)을 호출하면 된다.<br>없는 경우는 예외를 일으키고, 있는 경우 해당 객체를 반환할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchingInformation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Course course;</span><br><span class="line"><span class="keyword">private</span> Level level;</span><br><span class="line"><span class="keyword">private</span> Mission mission;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MatchingInformation</span><span class="params">(Course course, Level level, Mission mission)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.course = course;</span><br><span class="line"><span class="keyword">this</span>.level = level;</span><br><span class="line"><span class="keyword">this</span>.mission = mission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MatchingInformation <span class="title">of</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; information = split(line);</span><br><span class="line">Course course = Course.findByName(information.get(COURSE_INDEX));</span><br><span class="line">Level level = Level.findByName(information.get(LEVEL_INDEX));</span><br><span class="line">Mission mission = Mission.findByName(information.get(MISSION_INDEX));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MatchingInformation(course, level, mission);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>매칭 정보 일급컬렉션을 생성할 때, 입력받은 이름을 토대로 findByName메서드를 호출하는 것을 볼 수 있다.</p><p>문제는 과정, 레벨, 미션 이 세가지 열거형 모두 이 메서드를 가지고 있는데, 모두 중복되는 코드로 작성했다.<br>인터페이스를 도입하자니 검증 메서드가 static이라서 힘들었다.</p><h2 id="과정-레벨-출력"><a href="#과정-레벨-출력" class="headerlink" title="과정, 레벨 출력"></a>과정, 레벨 출력</h2><p>과정, 레벨, 미션을 도입하기 전에 항상 과정, 레벨, 미션을 출력해야 한다.</p><p>나는 마음이 급해서 그냥 바로 문자열로 만들어서 매번 출력하도록 처리했다.<br>근데 다른 PR을 보니, 과정, 레벨, 미션을 저장하고, 저장된 정보를 토대로 출력하는 사람들이 많았다.(대단..)</p><h2 id="묻지-말고-시키기"><a href="#묻지-말고-시키기" class="headerlink" title="묻지 말고 시키기"></a>묻지 말고 시키기</h2><p>객체가 가진 데이터를 가져오지 말고, 객체에게 책임을 전달해야 되는데, 기능 구현에 급급하다보니, getter 메서드로 객체에게 묻는 로직이 상당히 많았다.<br>프리코스에서 가장 인상깊게 생각한 피드백이고, 지키기 위해서 노력했는데 막상 시험에서 지키지 못하니 아쉽다.</p><h2 id="구현하지-못한-기능"><a href="#구현하지-못한-기능" class="headerlink" title="구현하지 못한 기능"></a>구현하지 못한 기능</h2><p>페어를 만들 수 없는 상황을 예외 처리해줘야 했는데, 시험을 풀 당시 페어를 만들 수 없는 상황이 뭔지 몰라서 구현을 못했다…</p><p>알고보니 크루가 2명보다 적으면 페어를 못만드는 상황이 생긴다는 것……<br>생각해보니 쉬운 로직인데 너무 긴장해서 구현하지 못한 거 같다. 시간이 부족하기도 했고.</p><h1 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h1><p>돌이켜보면 믿기지 않는 한달이었다.<br>설마 되겠냐는 생각으로 서류 지원했는데 덜컥 붙어서 정신없이 프리코스를 진행한 것 같다.<br>다른 지원자들의 PR을 보니 내가 우물 속 개구리 인걸 깨달았다.</p><p>3주 동안 정말 많은 걸 배웠다.<br>의식있는 노력을 통해 익숙함을 벗어나서 더 좋은 코드를 추구하는 마음가짐을 배웠다.<br>평소 잘 모르는 걸 알면서 방치했던 git 사용법도 이번 기회로 정리해서 배웠다.<br>하드코딩을 제거해서 다른 사람들이 봐도 이해할 수 있는 코드를 작성할 수 있음을 배웠다.<br>한 메서드가 한 역할을 수행하라는 원칙도 알고는 있었는데, 실천을 통해 더 자세히 체화했다.<br>예외가 발생하는 상황을 처리해서 프로그램이 다시 입력할 수 있도록 하는 방법을 배웠다.<br>객체지향 설계를 직접 실천해보고 객체 지향의 기본 개념들을 배웠다.</p><p>프리코스를 해보니, 우아한 테크코스에 가고 싶은 생각이 더 깊어졌다.<br>혹시 내가 자격이 있을까 고민하는 개발 지망생들이 있다면, 꼭 지원해서 프리코스까지 체험해보길 적극 추천한다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/19/java/woowa-tech-course/utecoprecourse4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
