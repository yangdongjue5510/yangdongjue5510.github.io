<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Thu, 19 Jan 2023 08:12:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>람다로 프로그래밍</title>
      <link>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/</guid>
      <pubDate>Tue, 17 Jan 2023 10:21:40 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;람다-식과-멤버-참조&quot;&gt;&lt;a href=&quot;#람다-식과-멤버-참조&quot; class=&quot;headerlink&quot; title=&quot;람다 식과 멤버 참조&quot;&gt;&lt;/a&gt;람다 식과 멤버 참조&lt;/h1&gt;&lt;h2 id=&quot;람다-식의-문법&quot;&gt;&lt;a href=&quot;#람다-식의-문법&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="람다-식과-멤버-참조"><a href="#람다-식과-멤버-참조" class="headerlink" title="람다 식과 멤버 참조"></a>람다 식과 멤버 참조</h1><h2 id="람다-식의-문법"><a href="#람다-식의-문법" class="headerlink" title="람다 식의 문법"></a>람다 식의 문법</h2><p>코틀린의 람다 식은 항상 중괄호로 둘러 쌓여 있다. 그리고 인자 목록을 괄호로 싸지 않는다. 람다를 변수에 저장하고 함수처럼 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125;</span><br><span class="line"></span><br><span class="line">println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>실행 시점에서 코틀린 람다 호출에는 아무 부가 비굥이 들지 않으며 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.</p><p>사람 목록에서 가장 연장자를 찾는 예제를 작성해본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">10</span>), Person(<span class="string">&quot;Rob&quot;</span>, <span class="number">11</span>))</span><br><span class="line">println(people.maxBy &#123; it.age &#125;)</span><br></pre></td></tr></table></figure><p><code>maxBy</code> 함수에 나이를 반환하는 람다를 전달했다. 이때 <code>maxBy</code> 부분을 최대한 풀어서 쓰면 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy(&#123; p:Person -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure><p>하지말 이렇게 쓰면 너무 번잡하다. 어떻게 간편하게 개선되는지 알아보자.</p><p>먼저 함수의 맨 마지막 인자가 람다면 괄호 밖으로 뺄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy() &#123; p:Person -&gt; p.age &#125;</span><br></pre></td></tr></table></figure><p>그리고 람다만 가지고 있는 함수에서 람다를 밖으로 빼면 빈 괄호를 생략할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p:Person -&gt; p.age&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 람다 파라미터를 컴파일러가 예상할 수 있어서 생략할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p.age &#125;</span><br></pre></td></tr></table></figure><p>하지만 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아서 파라미터 타입을 명시해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> getAge = &#123; p: Person -&gt; p.age &#125;</span><br><span class="line">people.maxBy(getAge)</span><br></pre></td></tr></table></figure><p>코틀린에서 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 <code>it</code> 키워드를 통해 파라미터를 표현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; it.age &#125;</span><br></pre></td></tr></table></figure><p>람다의 본문에 여러 줄이 될 수 있다. 그럴 때는 마지막 줄이 해당 람다의 반환값이 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$x</span> and <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="현재-영역에-있는-변수에-접근"><a href="#현재-영역에-있는-변수에-접근" class="headerlink" title="현재 영역에 있는 변수에 접근"></a>현재 영역에 있는 변수에 접근</h2><p>람다는 함수 파라미터를 람다 안에서 사용하 ㄹ수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMessageWithPrefix</span><span class="params">(messages: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;, prefix: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    messages.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$prefix</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바와 다르게 코틀린의 람다는 파이널 변수가 아닌 변수에 접근할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProblemCounts</span><span class="params">(responses: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clientErrors = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> serverError = <span class="number">0</span></span><br><span class="line">    responses.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;4&quot;</span>)) &#123;</span><br><span class="line">            clientErrors++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;5&quot;</span>)) &#123;</span><br><span class="line">            serverError++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$clientErrors</span> and <span class="variable">$serverError</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 만약 함수가 변수를 포획한 람다를 반환한다면 변수의 생명 주기는 함수와 달라지게 된다. 함수가 종료되어도 변수를 포획한 람다를 실행하면 해당 변수를 일고 쓸 수 있다. 파이널 변수를 포획한 경우 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수는 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.</p><p>다만, 람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryToCountButtonClick</span><span class="params">(button: <span class="type">Button</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clicks = <span class="number">0</span></span><br><span class="line">    button.onClick &#123; clicks++&#125;</span><br><span class="line">    <span class="keyword">return</span> clicks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 함수에서 로컬변수를 반환해서 변수의 변화를 볼 수 없다.</p><h3 id="멤버-참조"><a href="#멤버-참조" class="headerlink" title="멤버 참조"></a>멤버 참조</h3><p>자바 8의 메서드 참조와 동일한 기능을 코틀린의 멤버 참조로 할 수 있다. 코틀린은 메서드뿐만 아니라 프로퍼티도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy(Person::age)</span><br></pre></td></tr></table></figure><p>그리고 최상위로 선언된 함수나 프로퍼티를 참조할 수 있다. 또한 생성자를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">salute</span><span class="params">()</span></span> = pritnln(<span class="string">&quot;Salute!&quot;</span>)</span><br><span class="line">run(::salute)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> createPerson = ::Person</span><br><span class="line"><span class="keyword">val</span> person = createPerson(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><h3 id="바운드-멤버-참조"><a href="#바운드-멤버-참조" class="headerlink" title="바운드 멤버 참조"></a>바운드 멤버 참조</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunc = Person::age</span><br><span class="line">println(personAgeFunc(p))</span><br></pre></td></tr></table></figure><p>코틀린 1.0에서는 클래스의 메서드나 프로퍼티에 참조를 얻고 클래스 인스턴스를 전달해줘야 가능했다. 하지만 코틀린 1.1부터는 바운드 멤버 참조를 지원한다. 바운드 멤버 참조는 클래스 인스턴스를 함께 저장한 다음 그 인스턴스에 대해 멤버를 호출한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunc = p::age</span><br><span class="line">println(personAgeFunc())</span><br></pre></td></tr></table></figure><h1 id="컬렉션-함수형-API"><a href="#컬렉션-함수형-API" class="headerlink" title="컬렉션 함수형 API"></a>컬렉션 함수형 API</h1><h2 id="필수적인-함수-filter-map"><a href="#필수적인-함수-filter-map" class="headerlink" title="필수적인 함수: filter, map"></a>필수적인 함수: filter, map</h2><p>filter는 특정 조건에 해당하는 원소만 남길 수 있다.<br>map은 원소를 바꾸어서 새 컬렉션을 만든다.</p><h2 id="all-any-count-find-컬렉션에-술어-적용"><a href="#all-any-count-find-컬렉션에-술어-적용" class="headerlink" title="all, any, count, find: 컬렉션에 술어 적용"></a>all, any, count, find: 컬렉션에 술어 적용</h2><p>count는 조건을 만족하는 원소의 갯수를 반환한다. 참고로 filter를 한 컬렉션의 size를 측정하는 것보다 count를 사용하는 것이 결과 컬렉션을 만들지 않아서 더 효과적이다.<br>find는 조건을 만족하는 원소의 첫번째 원소를 반환한다.<br>all은 모든 원소가 조건에 만족하는 지 반환한다.<br>any는 조건에 만족하는 원소가 하나라도 존재하는 지 확인한다.</p><h2 id="groupBy-리스트를-여러-그룹으로-이뤄진-맵으로-변경"><a href="#groupBy-리스트를-여러-그룹으로-이뤄진-맵으로-변경" class="headerlink" title="groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경"></a>groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(list.groupBy(String::first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map&lt;Int, List&lt;String&gt;&gt;</code>을 만들어서 반환한다. 위 예시는 <code>&#123;a=[a, ab], b=[b]&#125;</code></p><h2 id="flatMap과-flatten-중첩된-컬렉션-안의-원소-처리"><a href="#flatMap과-flatten-중첩된-컬렉션-안의-원소-처리" class="headerlink" title="flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리"></a>flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리</h2><p>flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(map) 결과로 얻어지는 여러 리스트를 한 리스트로 모은다(flat).</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>)</span><br><span class="line">println(strings.flatMap &#123; it.toList() &#125;)</span><br></pre></td></tr></table></figure><p>문자열을 list로 매핑하고, 각 매핑된 컬렉션들을 하나의 컬렉션으로 모은다.<br>중첩된 리스트이 원소를 한 리스트로 단순히 모아야 하는 경우 flatten 함수를 사용할 수 있다.</p><h1 id="지연-계산-lazy-컬렉션-연산"><a href="#지연-계산-lazy-컬렉션-연산" class="headerlink" title="지연 계산(lazy) 컬렉션 연산"></a>지연 계산(lazy) 컬렉션 연산</h1><p>map, filter 같은 컬렉션 함수는 컬렉션을 즉시 생성해서 반환한다. 즉 컬렉션 함수를 연쇄적으로 사용하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;A&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>이 경우에 map과 filter의 결과를 리스트로 만들어 저장한다. 즉 중간 계산 결과가 두번 저장된다. 중간 게산 결과값이 크면 중간 계산 결과 저장이 비효율적일 것이다.</p><p>코틀린에서는 시퀀스를 통해 중간 임시 컬렉션을 사용하지 않도록 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>코틀린 지연 연산 시퀀스는 <code>Sequence</code> 인터페이스에서 시작한다. 이 인터페이스는 iterator라는 메서드를 통해 원소값을 얻어 낸다. 하지만 하나씩 접근하는 것 외에 인덱스로 접근이나 다른 API를 사용하려면 시퀀스를 다른 컬렉션으로 다시 바꿔주자.</p><h2 id="시퀀스-연산-실행-중간-연산과-최종-연산"><a href="#시퀀스-연산-실행-중간-연산과-최종-연산" class="headerlink" title="시퀀스 연산 실행: 중간 연산과 최종 연산"></a>시퀀스 연산 실행: 중간 연산과 최종 연산</h2><p>시퀀스에 적용되는 함수는 일반적인 컬렉션 함수와 다르게 작동한다. 컬렉션 함수는 적용 즉시 컬렉션을 반환하지만, 시퀀스 함수에는 중간 연산과 최종 연산을 나눠서 생각해야 한다. 중간 연산은 최초 시퀀스에서 중간 연산을 적용할 줄 아는 시퀀스이다. 최종 연산은 연산들을 모두 적용한 결과를 반환한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>이 예시는 중간 연산만 적용되어 있어서 아직 연산이 적용된 결과 값이 만들어지지 않았다. 하지만 다음 예시처럼 최종 연산이 들어가면 비로소 모든 연산이 적용되고 결과값이 반환된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map(Person::name)</span><br><span class="line">    .filter &#123; it.startsWith(<span class="string">&quot;B&quot;</span>) &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>여기서 컬렉션과 시퀀스의 연산 적용 방식에 차이를 알아보자.<br>컬렉션은 하나의 연산마다 모든 컬렉션에 적용을 한다. 반면 시퀀스는 하나의 원소에 모든 연산을 모아서 한번에 적용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).asSequence()</span><br><span class="line">    .map &#123; it*it &#125;</span><br><span class="line">    .find &#123; it &gt; <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>위와 같은 예시에서 컬렉션으로 연산했다면, 1 2 3 4 모두 map해야 한다. 그 다음 find를 진행한다.<br>하지만 시퀀스의 경우 1 2만 모든 연산이 적용된다. 왜? 마지막 find는 최초 원소를 찾는데 2에 모든 연산을 적용하고 나서 조건을 만족함을 확인했기 때문에 3 4에 연산을 적용하지 않는 것이다.</p><blockquote><p>자바 스트림과 코틀린 시퀀스의 차이<br>사실 스트림과 매우 비슷하나 스트림의 병렬 처리를 시퀀스에서 제공하지 않는다. 다만 시퀀스는 자바 8보다 낮은 버전에서도 활용할 수 있다.</p></blockquote><h3 id="시퀀스-만들기"><a href="#시퀀스-만들기" class="headerlink" title="시퀀스 만들기"></a>시퀀스 만들기</h3><p><code>asSequence</code>함수와 <code>generateSequence</code> 함수를 통해 시퀀스를 만들 수 있다.<br><code>generateSequence</code> 함수는 첫 원소를 인자로 받고 다음 원소들을 계산하는 법을 람다로 받아서 만든다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> printZeroTo100 = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span>&#125;</span><br><span class="line">    .takeWhile &#123; it &lt;= <span class="number">100</span> &#125;</span><br><span class="line">    .forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h1 id="자바-함수형-인터페이스-적용"><a href="#자바-함수형-인터페이스-적용" class="headerlink" title="자바 함수형 인터페이스 적용"></a>자바 함수형 인터페이스 적용</h1><h2 id="자바-메소드에-람다로-인자-전달"><a href="#자바-메소드에-람다로-인자-전달" class="headerlink" title="자바 메소드에 람다로 인자 전달"></a>자바 메소드에 람다로 인자 전달</h2><p>함수형 인터페이스를 인자로 요구하는 자바 메서드에 코틀린 람다를 전달해줄 수 있다. 이 경우 컴파일러가 자동으로 람다를 해당 인터페이스의 인스턴스로 변환해준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void compute(Runnable computation); 이란 자바코드가 있다고 가정</span></span><br><span class="line">compute &#123; println(<span class="string">&quot;hi&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>물론 무명 객체를 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compute(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">       println(<span class="string">&quot;hi&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>하지만 람다를 전달하는 것과 무명 객체를 전달하는 것은 차이가 있다. 객체를 명시적으로 선언하면 메서드를 호출할 때마다 새로운 객체가 생성된다. 반면 람다는 람다에 대응하는 무명 객체를 메서드가 호출 할때마다 반복 사용한다. (하지만 함수의 변수에 접근하는 람다는 제외)</p><blockquote><p>람다와 무명 클래스 객체의 this 차이<br>무명 클래스 객체의 this는 자기 자신을 가리킨다. 반면 람다는 컴파일 타임에 아직 인스턴스가 없으므로 자기 자신을 가르킬 방법이 없다. 람다에서 this를 가르킬 경우 람다를 감싼 클래스 객체를 가리키게 된다. 만약 자기 자신을 가르켜야 되는 경우는 람다 대신 무명 객체를 활용하자.</p></blockquote><blockquote><p>람다를 무명 클래스의 인스턴스로 변환하는 것은 함수형 인터페이스를 받는 자바 메서드의 경우에만 그렇다.<br>컬렉션 확장 함수 (inline 표시된 코틀린 함수)에게 람다를 전달해도 무명 클래스가 만들어지지 않는다.</p></blockquote><h2 id="SAM-생성자-람다를-함수형-인터페이스로-명시적-변경"><a href="#SAM-생성자-람다를-함수형-인터페이스로-명시적-변경" class="headerlink" title="SAM 생성자: 람다를 함수형 인터페이스로 명시적 변경"></a>SAM 생성자: 람다를 함수형 인터페이스로 명시적 변경</h2><p>SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동 생성한 함수다. 컴파일러가 자동으로 람다를 함수형 인터페이스의 무명 클래스 인스턴스로 변환하지 못할 때 사용한다. 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 경우 람다로 반환하지 못한다.<br>SAM 생성자는 함수형 인터페이스의 이름과 람다식을 전달해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createAllRunnable</span><span class="params">()</span></span> : Runnable &#123;</span><br><span class="line">    <span class="comment">//람다는 안됨 return &#123; println(&quot;GOOD!&quot;)&#125;</span></span><br><span class="line">    <span class="keyword">return</span> Runnable &#123; println(<span class="string">&quot;GOOD!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="수신-객체-지정-람다-with-amp-apply"><a href="#수신-객체-지정-람다-with-amp-apply" class="headerlink" title="수신 객체 지정 람다 : with &amp; apply"></a>수신 객체 지정 람다 : with &amp; apply</h1><p>수신 객체를 명시하지 않고 람다에서 다른 객체의 메서드를 호출하는 기능을 수신 객체 지정 람다라고 한다.</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with의 힘을 느껴보기 위해 하나의 예시를 들어보고 with로 리팩토링 해보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        result.append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">&quot;\n alphabet end~\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 StringBuilder를 with로 처리하면 다음과 같다. with에 수신 객체를 적어두면 람다 내부에서 수신 객체를 적는 대신 this로 접근할 수 있다. 이렇게 하면 다양한 StringBuilder에서 해당 로직을 재활용 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>)</span><br><span class="line">        <span class="keyword">this</span>.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 this를 생략할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> with(StringBuilder()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>메서드 이름 충돌<br>만약 위 예시의 toString이 StringBuilder가 아닌 해당 함수를 감싼 클래스의 toString을 호출하고 싶다면 어떻게 해야되나? <code>this@OuterClass.toString()</code>와 같은 방식으로 적어주면 된다.</p></blockquote><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply는 with와 같다. 다만 항상 수신 객체를 반환한다. 그리고 확장함수로 정의되어 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet3</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> StringBuilder().apply &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            append(letter)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;\n alphabet end~ \n&quot;</span>) </span><br><span class="line">    &#125;.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 수신 객체 지정 람다를 사용하는 더 구체적인 예시로 buildString 같은 함수가 있다. 인자로 수신 객체 지정 람다를 받으며(매번 수신 객체는 StringBuilder로 고정), StringBuilder 객체 생성과 toString 호출을 알아서 해주는 녀석이다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>구글 엔지니어는 이렇게 일한다. 문화 편</title>
      <link>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/</guid>
      <pubDate>Thu, 12 Jan 2023 12:37:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;구글 엔지니어는 이렇게 일한다&lt;/code&gt; 라는 책에서 필요한 부분을 읽고 기록해두는 포스트다. 많은 부분이 생략되어 있다.&lt;/p&gt;
&lt;h1 id=&quot;혼자-일하지-말라&quot;&gt;&lt;a href=&quot;#혼자-일하지-말라&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>구글 엔지니어는 이렇게 일한다</code> 라는 책에서 필요한 부분을 읽고 기록해두는 포스트다. 많은 부분이 생략되어 있다.</p><h1 id="혼자-일하지-말라"><a href="#혼자-일하지-말라" class="headerlink" title="혼자 일하지 말라"></a>혼자 일하지 말라</h1><p>초기 설계에는 근본적인 실수가 있을 수 있다. 바퀴를 재발명하려는 실수를 범할 수 있다. 우리가 올바른 일을 하고 있는지, 제대로 하고 있는지, 그리고 다른 누군가가 이미 해놓은 일을 아닌지를 확인해봐야 한다.</p><blockquote><p>가능한 일찍 피드백받고, 가능한 일찍 테스트하자.</p></blockquote><p>코드 뿐만 아니라 계획이나 설계 변경이 필요한 시점을 즉시 알려줄 피드백 루프를 팀 플레이를 통해 달성할 수 있다.</p><h1 id="모든-건-팀에-달렸다"><a href="#모든-건-팀에-달렸다" class="headerlink" title="모든 건 팀에 달렸다."></a>모든 건 팀에 달렸다.</h1><h2 id="중요한-소프트-스킬-세가지"><a href="#중요한-소프트-스킬-세가지" class="headerlink" title="중요한 소프트 스킬 세가지"></a>중요한 소프트 스킬 세가지</h2><ol><li>겸손 : 모든 것을 알고있다고 생각하지말고 배움에 열려있어야 한다.</li><li>존중 : 함께 일하는 동료를 진심으로 생각한다.</li><li>신뢰 : 동료들이 유능하고 올바른 일을 하리라 믿는다.</li></ol><p>이 세가지를 바탕으로 사회적 관계에 힘을 써라.</p><h2 id="자존심-버리기"><a href="#자존심-버리기" class="headerlink" title="자존심 버리기"></a>자존심 버리기</h2><p>자신이 팀에서 제일 중요한 사람을 드러내지 말라. 모든 걸 다 아는 듯 행동하지 말라. 집단적 자존심을 찾아라. 팀의 성취와 단체의 자부심을 높이려 노력하라.</p><h2 id="비평하고-비평받는-법-배우기"><a href="#비평하고-비평받는-법-배우기" class="headerlink" title="비평하고 비평받는 법 배우기"></a>비평하고 비평받는 법 배우기</h2><p>상대방을 존중하고 건설적이고 공손하게 비평해라. 우리의 자존감을 우리가 작성한 코드와 동일시 해서 비평을 거부하지 말라.</p><h2 id="빠르게-실패하고-반복하기"><a href="#빠르게-실패하고-반복하기" class="headerlink" title="빠르게 실패하고 반복하기"></a>빠르게 실패하고 반복하기</h2><p>실패하지 않는다면 충분히 혁신적이지 않거나 위험을 충분히 감수하지 않은 것이다.<br>실패를 <code>배우고 다음 단계로 넘어갈 수 있는 절호의 기회</code>라고 생각하자.</p><h2 id="비난-없는-포스트모템-문화"><a href="#비난-없는-포스트모템-문화" class="headerlink" title="비난 없는 포스트모템 문화"></a>비난 없는 포스트모템 문화</h2><p>실패의 원인을 분석해 문서로 남기는 것이 중요하다. 이를 포스트모템이라고 한다.<br>포스트모템은 쓸모 없는 사죄, 변명, 지적으로 채워지지 않고 무엇을 배웠는지 앞으로 어떻게 바꿀지가 담겨야 한다.</p><h3 id="훌륭한-포스트모템"><a href="#훌륭한-포스트모템" class="headerlink" title="훌륭한 포스트모템"></a>훌륭한 포스트모템</h3><ul><li>사건의 개요</li><li>사건을 인지하고 이를 해결하기 까지 타임라인</li><li>사건 근본 원인 파악</li><li>영향과 피해 평가</li><li>문제를 즉시 해결하기 위한 조치 항목(소유자 명시)</li><li>재발 방지를 위한 조치 항목</li><li>해당 경험에서 얻은 교훈</li></ul><h1 id="지식-공유"><a href="#지식-공유" class="headerlink" title="지식 공유"></a>지식 공유</h1><h2 id="심리적-안전"><a href="#심리적-안전" class="headerlink" title="심리적 안전"></a>심리적 안전</h2><p>자신이 이해하지 못한 게 있음을 인정해야 무언가를 배울 수 있다. 모르는 것을 인정하는 사람을 질책하지 말고 반겨야 한다. 배움에는 시도해서 실패해도 안전하다는 인식이 중요하다. 질문을 던지고, 틀리고, 새로운 지식을 얻는 걸 편안하게 생각해야 한다.</p><h2 id="질문하기"><a href="#질문하기" class="headerlink" title="질문하기"></a>질문하기</h2><p>항상 배우고 항상 질문하기를 잊지마라. 잘 모르겠으면 주위 동료들에게 질문하는게 내가 성장하는게 도움이 된다. 아무리 잘하는 사람이라도 모르는 분야가 반드시 있다. 이를 두려워 말고 도움을 청해본다.<br>특히 상급자라고 모든 것을 안다는 인식이 생겨나지 않도록 하라. 사소한 질문이더라도 친절하게 답변해주자. 적절한 도움은 개인과 팀 생산력에 큰 도움이 된다.<br>특히 일대일로 무언가를 배울 때는 기록해두는 습관을 가지자.</p><h1 id="좋은-리더가-되기-위해서"><a href="#좋은-리더가-되기-위해서" class="headerlink" title="좋은 리더가 되기 위해서"></a>좋은 리더가 되기 위해서</h1><h2 id="섬기는-리더십"><a href="#섬기는-리더십" class="headerlink" title="섬기는 리더십"></a>섬기는 리더십</h2><p>내가 누군가를 관리하는 것이 아닌 팀을 떠받드는 것이 중요하다. 겸손, 존중, 신뢰의 분위기를 조성하는 데 힘써야 한다. 혼자서 제거하기 힘든 관료적 장애물을 치워주고, 합의에 이르도록 이끄는 등 팀이 앞으로 나아가는데 필요한 기술적, 사회적 건강 관리를 한다.</p><h2 id="오늘날의-엔지니어링-관리자"><a href="#오늘날의-엔지니어링-관리자" class="headerlink" title="오늘날의 엔지니어링 관리자"></a>오늘날의 엔지니어링 관리자</h2><blockquote><p>전통적인 관리자는 일을 어떻게 처리해야지를 고민하는 반면 훌륭한 관리자는 무슨 일을 처리할지를 고민한다.</p></blockquote><p>관리자는 팀원을 아이처럼 대하지 말고 직원들을 신뢰하자. 직원들은 그 신뢰에 부응해야한다는 긍정적인 압박을 느낀다.</p><h3 id="자존심-버리기-1"><a href="#자존심-버리기-1" class="headerlink" title="자존심 버리기"></a>자존심 버리기</h3><p>겸손과 자신감 결여는 구분하자. 자만하지 않아도 자신감과 의견을 가질 수 있다. 팀을 하나로 모으고 방향을 정하게 도와주는게 리더의 역할이다. 구체적인 방법은 실무자들에게 맡기는 게 그들의 주인의식과 책임감 향상에 더 도움이 된다.<br>리더가 모든 걸 알아야 된다는 강박에서 벗어나자. 완벽한 듯 행동하면 오히려 팀원들의 존경을 빠르게 잃어가고 자리 지키기에만 급급할 것이다.<br>팀의 최종 목표를 명심하고 피드백을 수용하고 비판에 마음을 열자.<br>실수했다면 인정하고 사과하자. 리더가 실수했다는 사실을 언젠간 팀원들이 반드시 알게 된다. 이를 사과할 줄 아는 리더를 팀원들은 존경한다.</p><h3 id="마음-다스리기"><a href="#마음-다스리기" class="headerlink" title="마음 다스리기"></a>마음 다스리기</h3><p>리더는 항상 무대 위에 있다고 생각하는 방법이 좋다. 리더는 주변 사람들이 리더의 일거수일투족을 항시 두 눈 똑바로 뜨고 쳐다보고 있다는 뜻이다. 리더의 몸짓, 사소한 이야기에 돌아오는 반응, 점심식사를 하며 보내는 미묘한 신호들로부터 단서들을 얻어간다. 아무리 사소한 것이라도 리더가 내비치는 거의 모든 것이 무의식적으로 알려지고 팀에 전염된다.</p><h3 id="촉매자-되기"><a href="#촉매자-되기" class="headerlink" title="촉매자 되기"></a>촉매자 되기</h3><p>리더는 합의를 이끌어 낼 줄 알아야 한다. 시작부터 끝까지 과정을 주도할 수 있고 올바른 방향으로 가속이 붙도록 조금만 관여할 수도 있다. 팀이 가야할 방향에 대한 합의를 이끌어내야 하는게 리더의 역할이고 이 과정에서 팀원들이 모두 합의할 수 있도록 촉매자가 되보자.</p><h3 id="장애물-치우기"><a href="#장애물-치우기" class="headerlink" title="장애물 치우기"></a>장애물 치우기</h3><p>리더는 해야할 일에 대한 합의를 이끌어냈지만, 장애물 때문에 진행이 안될 수 있다. 이런 장애물을 해결하는 것도 리더의 역할이다. 이때 리더가 모든 장애물을 직접 해결해야 한다는 의미는 아니다. 다만 해당 장애물을 해결할 줄 아는 사람을 알고 있는 게 바람직하다.</p><h3 id="선생이자-멘토-되기"><a href="#선생이자-멘토-되기" class="headerlink" title="선생이자 멘토 되기"></a>선생이자 멘토 되기</h3><p>내가 하면 더 빨리 될 일이더라도 팀원의 성장을 위해 그 일을 팀원에게 맡기는 일을 감수할 수 있어야 한다. 멘토는 팀의 프로세스와 체계에 대한 경험, 설명하는 능력, 멘티에게 도움이 얼마나 필요한지를 측정하는 능력이 필요하다.</p><h3 id="명확한-목표-세우기"><a href="#명확한-목표-세우기" class="headerlink" title="명확한 목표 세우기"></a>명확한 목표 세우기</h3><p>목표를 명확히 세우고 팀이 제품을 한 방향으로 끌게 해야 한다. 가장 쉬운 방법은 팀이 이루어야 할 임무를 구체적인 문장으로 적어놓는 것이다. 목표를 정하고 나면 팀원들이 각자 책임을 가지고 리더는 잘 가고 있는지 주기적으로 확인하자.</p><h3 id="정직하기"><a href="#정직하기" class="headerlink" title="정직하기"></a>정직하기</h3><p>리던느 팀원에게 모든 것을 알려줄 수 없는 상황에 있는 상황인 경우가 많다. 만약 그런 부분을 묻는다면 차마 말해줄 수 없다 라고 솔직하게 말하자. 그리고 모르는 사실은 모른다고 사실대로 말하자.<br>팀원에게 곤란한 피드백을 줘야 하는 경우는 존중을 담아서 솔직하게 전달하자. 칭찬으로 피드백을 둘러 쌓아서 하지 않도록 하자.</p><h3 id="행복한지-확인하기"><a href="#행복한지-확인하기" class="headerlink" title="행복한지 확인하기"></a>행복한지 확인하기</h3><p>팀원들의 행복을 위해서 일대일 면담을 하거나 다음 업무를 수행하는 데 어려운 점은 없는 지 확인하는 방식을 선택할 수 있다. “더 필요한 것은 없나?”라고 물어보자.</p><h3 id="파도를-일으켜야-할-타이밍을-알자"><a href="#파도를-일으켜야-할-타이밍을-알자" class="headerlink" title="파도를 일으켜야 할 타이밍을 알자"></a>파도를 일으켜야 할 타이밍을 알자</h3><p>문제가 생긴 상황을 지켜보기만 하지 말자. 너무 방치하지 않고 적절한 조치를 찾아 실행시켜라.</p><h3 id="혼란으로부터-팀을-보호하자"><a href="#혼란으로부터-팀을-보호하자" class="headerlink" title="혼란으로부터 팀을 보호하자"></a>혼란으로부터 팀을 보호하자</h3><p>혼란과 불확실성으로 가득 찬 상황을 팀원들이 영향 받지 않도록 보호해야 한다. 다만 회사 위쪽에서 어떤 일이 일어나는 지 공유해주는 것도 중요하다. 다만 팀에 영양가가 없는 조직 차원의 광기로 팀 업무가 방해받지 않도록 하자.</p><h3 id="내적-동기-일으키기"><a href="#내적-동기-일으키기" class="headerlink" title="내적 동기 일으키기"></a>내적 동기 일으키기</h3><p>금전적 보상과 같은 외적 동기와 안에서부터 샘솟는 내적 동기가 있다. 사람들을 행복하게 하는 것은 내적 동기이다. 내적 동기는 자율성, 숙련, 목적이 키워준다.</p><ol><li>자율성 : 스스로 행동할 수 있는 것. 제품과의 관계가 더 끈끈해진다. 제품에 대한 주인 의식이 커진다.</li><li>숙련 : 기술 수준을 높이고 새로운 것을 배울 기회를 제공하는 것.</li><li>목적 : 팀원들의 노력에서 의미를 찾고 그 의미를 분명하게 인식시켜주는 형태로 동기를 부여하자.</li></ol><h1 id="성장하는-조직-이끌기"><a href="#성장하는-조직-이끌기" class="headerlink" title="성장하는 조직 이끌기"></a>성장하는 조직 이끌기</h1><p>하나의 팀이 아닌 여러 팀을 이끌기 위한 행동 지침을 알아보자.</p><h2 id="늘-결정하라"><a href="#늘-결정하라" class="headerlink" title="늘 결정하라"></a>늘 결정하라</h2><p>리더는 팀이 매주 무엇을 해야 하는지 결정해야 한다. 트레이드오프가 명확할 때가 있지만 때로는 시간이 한참 지나야 피해를 주는 예상치 못한 결과를 가져다오기도 한다.<br>리더는 어렵고 명확한 해법이 보이지 않는 문제를 풀게 사람들을 이끄는 것이다. 어느 경우든 문제를 탐구하고 훑어보고 뜯어보면서 통제할 수 있는 상태로 만들어야 한다.<br>이 과정은 세 단계로 나뉜다.</p><ol><li>눈가리개를 찾아내고</li><li>트레이드오프를 파악한다</li><li>해법을 결정하고 반복해야 한다.</li></ol><h3 id="눈가리개-찾기"><a href="#눈가리개-찾기" class="headerlink" title="눈가리개 찾기"></a>눈가리개 찾기</h3><p>항상 그래왔다는 문제에 대해 질문을 던지고, 현재 방식에 대해 문제가 있을 수 있는지 확인해본다.</p><h3 id="핵심-트레이드오프-파악하기"><a href="#핵심-트레이드오프-파악하기" class="headerlink" title="핵심 트레이드오프 파악하기"></a>핵심 트레이드오프 파악하기</h3><p>모든 트레이드오프를 테이블 위에 올려놓고 모두에게 설명한 다음 어떻게 균형을 맞출지를 결정하도록 도와야 한다.</p><h3 id="결정하고-반복하기"><a href="#결정하고-반복하기" class="headerlink" title="결정하고 반복하기"></a>결정하고 반복하기</h3><p>트레이드오프를 파악하고 특정 방법을 결정할 수 있다. 그러나 이 방법에 계속 유지하지 말고 상황이 변하면 트레이드오프를 다시 평가하고 새로운 방법을 결정하도록 하자. 이게 늘 결정한다라는 말의 의미이다.<br>트레이드오프의 지속적인 재조정을 프로세스에 녹여야 한다. 지금 선택한 방법이 계속 유지되지 않을 수 있음을 공유하자.</p><h2 id="늘-떠나라"><a href="#늘-떠나라" class="headerlink" title="늘 떠나라"></a>늘 떠나라</h2><p>리더는 모호한 문제를 풀어줄 뿐만 아니라 맡은 조직이 리더 없이도 스스로 문제를 풀 수 있게 유도해야 한다. 리더가 SPOF가 되면 안된다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/software-engineering-at-google/">Software Engineering At Google</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린의 클래스, 객체, 인터페이스</title>
      <link>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/</guid>
      <pubDate>Tue, 10 Jan 2023 14:52:43 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4&quot;&gt;코틀린 인터페이스&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#open-f</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약<br><a href="#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">코틀린 인터페이스</a><br><a href="#open-final-abstract-%EB%B3%80%EA%B2%BD%EC%9E%90-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-final">open, final, abstact</a><br><a href="#%EA%B0%80%EC%8B%9C%EC%84%B1-%EB%B3%80%EA%B2%BD%EC%9E%90-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EA%B0%9C">가시성 변경자</a><br><a href="#%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%A4%91%EC%B2%A9%EB%90%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A4%91%EC%B2%A9-%ED%81%B4%EB%9E%98%EC%8A%A4">중첩 클래스와 봉인된 클래스</a><br><a href="#%EB%BB%94%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EA%B0%96%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8">뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</a><br><a href="#%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EC%83%9D%EC%84%B1%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9C%84%EC%9E%84">데이터 클래스와 클래스 위임</a><br><a href="#object-%ED%82%A4%EC%9B%8C%EB%93%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8%EA%B3%BC-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1">object 키워드</a></p></blockquote><h1 id="클래스-계층-정의"><a href="#클래스-계층-정의" class="headerlink" title="클래스 계층 정의"></a>클래스 계층 정의</h1><h2 id="코틀린-인터페이스"><a href="#코틀린-인터페이스" class="headerlink" title="코틀린 인터페이스"></a>코틀린 인터페이스</h2><p>코틀린의 인터페이스는 자바와 매우 유사하다. 상태를 가질 수 없지만 구현된 메서드(마치 디폴트 메서드)를 가질 수 있다.</p><p>인터페이스를 구현하는 쪽에서는 <code>:</code>을 통해 나타낸다. 코틀린에서는 클래스의 상속과 인터페이스의 구현 모두 <code>:</code>를 사용한다. 자바와 마찬가지로 코틀린에서 인터페이스는 무제한으로 구현할 수 있지만, 클래스는 하나만 가능하다.</p><p>자바의 <code>@Override</code>와 비슷한 <code>override</code> 변경자가 있다. 코틀린에서는 <code>override</code> 변경자를 반드시 적어줘야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> =</span><br><span class="line">        println(<span class="string">&quot;implemented Method in interface.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> :<span class="type">Clickable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="만약-여러-인터페이스를-구현할-때-각-인터페이스에서-구현된-메서드의-시그니처가-중복되는-경우"><a href="#만약-여러-인터페이스를-구현할-때-각-인터페이스에서-구현된-메서드의-시그니처가-중복되는-경우" class="headerlink" title="만약 여러 인터페이스를 구현할 때 각 인터페이스에서 구현된 메서드의 시그니처가 중복되는 경우"></a>만약 여러 인터페이스를 구현할 때 각 인터페이스에서 구현된 메서드의 시그니처가 중복되는 경우</h3><p>위 예시에서 기존의 인터페이스에서 구현된 메서드와 같은 시그니처를 갖는 인터페이스를 만들고 이 또한 클래스에서 구현해보려고 한다면 문제가 생긴다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> = println(<span class="string">&quot;implemented too!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> :<span class="type">Clickable</span>, <span class="type">Focusable &#123; // 컴파일 에러가 생길 것이다!</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span> = println(<span class="string">&quot;focus!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우 구현하는 클래스에서 충돌되는 구현 메서드를 새롭게 오버라이딩해서 재정의 해줘야 한다.<br>이때 상위 타입의 구현을 사용하려면 다음 코드블럭을 지켜보자. <code>super&lt;상위타입&gt;.메서드()</code> 이런 문법으로 상위 타입의 메서드를 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clicker</span> : <span class="type">Clickable</span>, <span class="type">Focusable &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;click!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">focus</span><span class="params">()</span></span> = println(<span class="string">&quot;focus!&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">methodImpl</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Focusable&gt;.methodImpl()</span><br><span class="line">        <span class="keyword">super</span>&lt;Clickable&gt;.methodImpl()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>사실 코틀린에서는 아직 자바의 디폴트 메서드를 지원하지 않는다.<br>코틀린은 자바의 디폴트 메서드가 등장하기 전인 자바 6에 호환되도록 설계됐다. 그래서 자바 인터페이스에 디폴드 메서드가 있으면 코틀린에는 해당 메서드를 추상 메서드로 인터페이스에 해놓고 따로 클래스를 만들어서 디폴트 메서드의 구현을 정적 메서드로 놓는다. 이렇게 되면 자바 클래스가 디폴트 인터페이스가 포함된 코틀린 인터페이스를 구현하려고 하면 디폴트 메서드도 자바 클래스에서 구현해줘야 한다. 왜냐면 자바에서는 코틀린의 디폴트 메서드 구현(정적 메서드)를 의존하지 않기 때문이다.</p></blockquote><h2 id="open-final-abstract-변경자-기본적으로-final"><a href="#open-final-abstract-변경자-기본적으로-final" class="headerlink" title="open, final, abstract 변경자: 기본적으로 final"></a>open, final, abstract 변경자: 기본적으로 final</h2><h3 id="open-final"><a href="#open-final" class="headerlink" title="open, final"></a>open, final</h3><p>자바에서는 final 선언되지 않은 클래스를 상속해서 사용할 수 있다.<br>문제는 상속은 부모 클래스의 가정을 이해하지 않고 자식 클래스에서 가정을 깨는 구현을 했을 때, 부모 클래스가 약간의 변경이 생겨도 자식 클래스가 예상과 다르게 작동할 수 있다. (취약한 기반 클래스 문제)<br>코틀린에서는 상속을 제한적으로 쓰고자 기본적으로 모두 final 선언되어 있는 셈이다. 만약 상속을 하고 싶으면 부모 클래스에 <code>open</code> 키워드를 붙여야 한다. 그와 더불어 자식 클래스에서 오버라이딩이 가능한 메서드나 프로퍼티에도 <code>open</code>을 붙여야 오버라이딩이 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RichButton</span>: <span class="type">Clickable &#123;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cannotOverride</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = print(<span class="string">&quot;rich click&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>override</code> 된 메서드는 당연히 오버라이딩에 열려있다. 하지만 이런 메서드도 앞에 <code>final</code>을 붙이면 하위에서 오버라이딩을 막을 수 있다.</p><blockquote><p>열린 클래스와 스마트 캐스트<br>기본적으로 클래스를 final로 상속을 막으면 스마트 캐스트하기에 유리하다. 스마트 캐스트는 타입 검사 뒤 변경될 수 없는 변수에만 적용된다. 즉 <code>val</code> 이면서 커스텀 접근자가 있어서는 안된다. 여기에 더 나아가 프로퍼티가 <code>final</code>이어야 한다는 조건이 필요하다. 왜냐면 다른 클래스가 상속해서 커스텀 접근자를 정의할 수 있음을 막아야 하기 때문이다.</p></blockquote><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><code>abstract</code>는 자바와 거의 비슷하다. 추상 메서드나 추상 클래스를 정의할 때 사용된다.</p><h2 id="가시성-변경자-기본적으로-공개"><a href="#가시성-변경자-기본적으로-공개" class="headerlink" title="가시성 변경자: 기본적으로 공개"></a>가시성 변경자: 기본적으로 공개</h2><p>가시성 변경자는 클래스 외부 접근을 제어한다. 자바와 다르게 코틀린은 아무 가시성 변경자를 안 적으면 <code>public</code>으로 취급한다.<br>코틀린에는 자바처럼 패키지 전용이 없다. 코틀린에서 패키지는 네임 스페이스를 관리하기 위함이지 가시성을 제어하기 위함이 아니다.</p><h3 id="internal-패키지-전용-가시성을-대체"><a href="#internal-패키지-전용-가시성을-대체" class="headerlink" title="internal: 패키지 전용 가시성을 대체"></a>internal: 패키지 전용 가시성을 대체</h3><p>패키지 전용 가시성를 대신하는 <code>internal</code>이 있다. <code>internal</code>은 모듈 내부에서만 볼 수 있는 변경자이다. 모듈은 같이 컴파일 되는 단위를 말한다. 패키지 기준은 다른 프로젝트더라도 같은 패키지에 클래스를 선언해서 접근 할 수 있게 되는 단점이 있다.</p><blockquote><p>그 외 차이점<br><code>private</code>는 내부에서만 접근 가능한 변경자인데 코틀린은 최상위 선언(클래스, 프로퍼티, 함수)에도 사용할 수 있다.<br><code>protected</code>는 코틀린에서 패키지 전용 가시성이 아닌 하위 클래스 가시성을 제공할 때 쓰인다. 다만 최상위 선언에는 사용할 수 없다.</p></blockquote><h3 id="의존하려면-더-엄한-가시성을-가져야-한다"><a href="#의존하려면-더-엄한-가시성을-가져야-한다" class="headerlink" title="의존하려면 더 엄한 가시성을 가져야 한다."></a>의존하려면 더 엄한 가시성을 가져야 한다.</h3><p>다음 예제를 보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">bye</span><span class="params">()</span></span> = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">doSomething</span><span class="params">()</span></span> &#123; <span class="comment">// public한 확장함수는 internal 클래스에 사용할 수 없다.</span></span><br><span class="line">    hello() <span class="comment">// public한 확장함수는 private 메서드에 접근할 수 없다.</span></span><br><span class="line">    bye() <span class="comment">// public한 확장함수는 protected 메서드에 접근할 수 없다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 다른 클래스에 의존해서 사용하려는 경우 해당 함수나 클래스의 가시성이 사용하려는 클래스의 가시성과 같거나 더 엄해야 한다. 위 경우는 확장함수의 가시성을 internal로 바꾸거나 수신 객체 타입의 가시성을 public으로 올리는 방법이 있다.<br>그리고 private나 protected 조건을 만족하지 않으므로 확장 함수의 메서드 호출이 안된다.</p><h3 id="코틀린-가시성-변경자와-자바"><a href="#코틀린-가시성-변경자와-자바" class="headerlink" title="코틀린 가시성 변경자와 자바"></a>코틀린 가시성 변경자와 자바</h3><p>코틀린의 public, protected, private 변경자는 자바 바이트 코드에도 그대로 들어간다. 다만 private 클래스는 다르게 처리된다. 자바에서는 private 클래스가 안되기 때문인데, 이 경우 코틀린에서 private 클래스를 protected 클래스로 변환해서 컴파일한다.<br>코틀린의 internal은 자바에서 public이 된다. 모듈의 특성 상 어쩔 수 없는 부분이다.<br>이렇게 더 열리게 되면 의도하지 않은 접근이 가능해지는데 코틀린 컴파일러가 internal 멤버 이름을 보기 나쁘게 바꾼다. 이는 예상치 못한 상속에서 생기는 우연한 오버라이딩을 피하고 internal 클래스를 외부에서 사용하지 않도록 하기 위함이다.</p><h2 id="내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스"><a href="#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" class="headerlink" title="내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스"></a>내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스</h2><p>코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근을 할 수 없다. 자바에서는 클래슨 내부에서 클래스를 선언하면 묵시적으로 내부 클래스가 된다. 즉 외부 클래스에 대한 참조를 묵시적으로 포함한다. 자바에서 이런 보이지 않는 참조를 제거하려면 중첩된 클래스에 static을 붙여주면 된다.</p><p>코틀린은 반대다. 기본적으로 외부 클래스에 대한 참조가 끊긴 중첩 클래스로 취급하고 만약 내부 클래스로 만들려면 안쪽 클래스에 <code>inner</code> 변경자를 붙여야 한다. 만약 내부 클래스에서 외부 클래스 참조를 접근하려면 <code>this@외부클래스이름</code> 으로 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getOuterReference</span><span class="params">()</span></span> : Outer = <span class="keyword">this</span><span class="symbol">@Outer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="봉인된-클래스-클래스-계층-정의-시-계층-확장-제한"><a href="#봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" class="headerlink" title="봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한"></a>봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한</h2><p><code>sealed</code> 변경자를 통해 자신의 상속해줄 수 있는 자식 클래스를 제한 할 수 있다. 이때 적용되는 클래스는 코틀린 1.0에는 부모의 중첩 클래스로만 해야하고, 1.1에는 같은 파일 안에 있기만 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Num</span> : <span class="type">Expr</span></span>()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> : <span class="type">Expr</span></span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 정해놓으면 유리한 점이 분기 처리할 때가 유리하다. 자식이 무한하게 허용되면 <code>when</code> 식으로 처리할 때 <code>else</code>로 그 외 처리를 해줘야 한다. 그리고 자식이 생길 때 분기로 처리하기를 놓칠 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>하지만 <code>sealed</code> 되어 있으면 자식이 한정적이라 정해진 자식들만 체크하면 된다. 만약 놓친 자식이 있으면 컴파일 에러가 나서 미리 알 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span> : <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Expr.Num -&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">is</span> Expr.Sum -&gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언"><a href="#뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" class="headerlink" title="뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언"></a>뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</h1><p>코틀린은 주 생성자와 부 생성자가 있다. 주 생성자는 클래스를 초기화할 때 쓰이고 클래스 본문 밖에서 정의된다. 부 생성자는 클래스 본문 안에서 사용되는 생성자이다.<br>또한 코틀린에서는 초기화 블록을 지원해서 초기화 로직을 모을 수 있다.</p><h2 id="클래스-초기화-주-생성자와-초기화-블록"><a href="#클래스-초기화-주-생성자와-초기화-블록" class="headerlink" title="클래스 초기화: 주 생성자와 초기화 블록"></a>클래스 초기화: 주 생성자와 초기화 블록</h2><p>코틀린에서 주 생성자는 다음과 같이 쓰인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String)</span><br></pre></td></tr></table></figure><p>클래스 이름뒤에 괄호로 둘러 쌓인 내용을 주 생성자라고 한다.</p><p>이를 최대한 명시적으로 풀어쓰면 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickName: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nickName = _nickName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여전히 주 생성자는 존재하는데 이때 <code>constructor</code>는 생성자의 정의를 시작함을 의미한다.<br>그리고 <code>init</code>은 클래스의 객체가 만들어질 때 실행되는 초기화 로직을 모은 초기화 블록을 선언한다. 초기화 블록은 별도의 코드를 포함할 수 없는 주 생성자와 함께 많이 쓰인다.<br>그리고 생성자 파라미터 앞 <code>_</code>는 프로퍼티와 파라미터를 구분하기 위해서 적었는데 기존 자바의 <code>this.nickName = nickName</code> 이렇게 해도 된다.</p><p>위 예시를 좀 더 개선하면, 일단 주 생성자 앞에 별도의 어노테이션이나 가시성 변경자가 없다면 <code>constructor</code>를 생략해도 된다. 그리고 프로퍼티 초기화는 굳이 초기화 블록에서 할 필요가 없고 프로퍼티 선언에서 해도 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(_nickName: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> nickName = _nickName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위 예시도 굳이 val 파리미터를 본문에서 하지말고 주 생성자 안에서 해버리면 간단하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String)</span><br></pre></td></tr></table></figure><p>참고로 주 생성자에서 디폴트 값과 이름 있는 선언도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickName: String = <span class="string">&quot;untitled&quot;</span>)</span><br><span class="line"></span><br><span class="line">User().nickName <span class="comment">// untitled</span></span><br><span class="line">User(nickName = <span class="string">&quot;Klay&quot;</span>) <span class="comment">// Klay</span></span><br></pre></td></tr></table></figure><blockquote><p>모든 파라미터에 디폴트값이 있으면 자동으로 파라미터가 없는 생성자를 만들어준다.<br>DI 프레임워크 중 기본 생성자가 반드시 필요한 경우에 이런 기능이 유리하다고 한다.</p></blockquote><p>만약 기반 클래스가 있다면 다음과 같이 기반 클래스에 파라미터를 넘겨줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodUser</span></span>(<span class="keyword">val</span> nickName: String) : User(nickname)</span><br></pre></td></tr></table></figure><p>참고로 만약 기반 클래스가 기본 생성자만 있다하더라도 하위 클래스는 생성자 (괄호) 를 적어줘야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodBook</span> : <span class="type">Book</span></span>()</span><br></pre></td></tr></table></figure><p>인터페이스는 생성자가 없으니 하위 클래스가 구현할 때 괄호를 써주지 않는다.</p><p>마지막으로 private 한 생성자를 만드는 방법이다.<br>이는 동반 객체에 유용하다고 한다. (반면 유틸 클래스나 싱글턴에는 이렇게 하지 않느다. 확장 함수나 객체 선언하는 방식을 한다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CannotConstructUser</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()</span><br></pre></td></tr></table></figure><h2 id="부-생성자"><a href="#부-생성자" class="headerlink" title="부 생성자"></a>부 생성자</h2><p>일반 적으로 코틀린에서는 디폴트 값을 지원해서 여러 생성자를 만들 일이 없다.<br>그래도 여러 생성자가 필요한 경우가 있다면 부 생성자를 이용한다.<br><code>super</code>를 통해 기반 클래스의 생성자에 인자 전달도 되고, this를 통해 자신의 다른 생성자에게 생성을 위임할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(s: String) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(i:<span class="built_in">Int</span>) : <span class="keyword">this</span>(i.toString()) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(s: String) : <span class="keyword">super</span>(s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="인터페이스에-선언된-프로퍼티-구현"><a href="#인터페이스에-선언된-프로퍼티-구현" class="headerlink" title="인터페이스에 선언된 프로퍼티 구현"></a>인터페이스에 선언된 프로퍼티 구현</h2><h3 id="추상-프로퍼티"><a href="#추상-프로퍼티" class="headerlink" title="추상 프로퍼티"></a>추상 프로퍼티</h3><p>코틀린에서는 인터페이스에 추상 프로퍼티를 선언할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 해당 인터페이스를 구현하는 쪽은 nickName을 접근할 수 있는 방법을 제공해야 함을 의미한다. 인터페이스가 실제 상태를 가지는 것은 아니다.</p><p>추상 프로퍼티를 구현하는 세가지 예시를 보자</p><p><strong>1. 주 생성자로 프로퍼티 구현</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickName: String) : User5</span><br></pre></td></tr></table></figure><p>간단하다 override만 붙여주면 된다.</p><p><strong>2. 커스텀 게터</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailUser</span></span>(<span class="keyword">val</span> email: String) : User5 &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickName: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>역시 override가 붙은 프로퍼티에 커스텀 게터를 구현하면 된다. 다만 커스텀 게터는 호출때마다 구현된 내용이 실행된다.</p><p><strong>3. 프로퍼티 초기화 식</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) : User5 &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> nickName = getFacebookName(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFacebookName</span><span class="params">(id: <span class="type">Int</span>)</span></span> = id.toString()</span><br></pre></td></tr></table></figure><p>프로퍼티 초기화 식은 프로퍼티에 접근할 때마다 구현된 내요을 실행하지 않는다. 초기화 할 때 한번만 한다. 이 점이 2번과 가장 큰 차이다. 만약 <code>getFacebookName</code>이 비용이 큰 메서드라고 상상해보면 프로퍼티에 접근할 때마다 호출되는 커스텀 게터 방식이 많이 불리햇을 것이다.</p><p>마지막으로 인터페이스에는 커스텀 게터와 세터가 있는 프로퍼티를 추가할 수 있다. 물론 실제 값이 있는 건 아니니까 참조할 수 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nickName: String</span><br><span class="line">    <span class="keyword">val</span> email: String</span><br><span class="line">        <span class="keyword">get</span>() = email.substringBefore(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="게터와-세터에서-뒷받침하는-필드에-접근"><a href="#게터와-세터에서-뒷받침하는-필드에-접근" class="headerlink" title="게터와 세터에서 뒷받침하는 필드에 접근"></a>게터와 세터에서 뒷받침하는 필드에 접근</h2><p>프로퍼티에 저장된 값을 변경할 때 특정 문자열을 출력하려고 한다고 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> address = <span class="string">&quot;undefined&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(_address) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$field</span> -&gt; <span class="variable">$_address</span>&quot;</span>)</span><br><span class="line">            field = _address</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흠 세터를 직접 구현해줬다. 그런데 <code>field</code>는 무엇인가? <code>field</code>는 현재 접근자에 해당하는 필드에 접근할 수 있게 한다. <code>field</code>를 사용하지 않는 커스텀 접근자는 뒷받침 하는 필드가 생기지 않는다.</p><h2 id="접근자의-가시성-변경"><a href="#접근자의-가시성-변경" class="headerlink" title="접근자의 가시성 변경"></a>접근자의 가시성 변경</h2><p>접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 <code>get</code>이나 <code>set</code>앞에 접근자를 선언해서 가시성을 변경할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;hi&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임"><a href="#컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임" class="headerlink" title="컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임"></a>컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임</h1><h2 id="모든-클래스가-정의해야-하는-메서드"><a href="#모든-클래스가-정의해야-하는-메서드" class="headerlink" title="모든 클래스가 정의해야 하는 메서드"></a>모든 클래스가 정의해야 하는 메서드</h2><p>모든 코틀린 클래스는 <code>toString</code>, <code>equals</code>, <code>hashCode</code> 등을 오버라이딩해야 한다.<br>코틀린은 이런 메서드 구현을 자동으로 생성해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>다음과 같은 클래스를 예시로 오버라이딩 해보자.</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;client&quot;</span></span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>참고로 코틀린은 <code>==</code> 연산자가 내부적으로 <code>equals</code>메서드를 호출해서 객체를 비교한다. 참조 비교를 위해서는 <code>===</code> 연산자를 호출해서 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> Client)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; postalCode == other.postalCode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>자바에서 <code>equals</code>를 재정의할 때는 반드시 <code>hashCode</code>도 재정의해야 한다. JVM 언어에서는 <code>equals</code>가 true를 반환하는 두 객체를 반드시 같은 <code>hashCode</code>를 반환해야 한다. <code>Hash</code>를 활용하는 자료구조에서는 원소 비교 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 같은 경우에만 실제 값을 비교한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span> : <span class="built_in">Int</span> = name.hashCode() * <span class="number">31</span> + postalCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성"><a href="#데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성" class="headerlink" title="데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성"></a>데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성</h2><p>코틀린은 이런 메서드를 컴파일러가 생성해준다.<br><code>data</code> 변경자를 붙여주기만 하면 된다. <code>data</code> 변경자가 붙은 클래스를 데이터 클래스라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>이때 주의할 점은 <code>equals</code>와 <code>hashCode</code>는 주 생성자에서 선언된 모든 프로퍼티를 기준으로 만들어진다. 주 생성자 외부에서 선언된 프로퍼티는 고려되지 않는다.</p><p>데이터 클래스는 <code>equals</code>, <code>hashCode</code>, <code>toString</code> 외에도 유용한 메서드 몇 개를 더 만들어준다.</p><h3 id="불변한-데이터-클래스를-쉽게-복사-copy"><a href="#불변한-데이터-클래스를-쉽게-복사-copy" class="headerlink" title="불변한 데이터 클래스를 쉽게 복사: copy"></a>불변한 데이터 클래스를 쉽게 복사: copy</h3><p>데이터 클래스를 쉽게 복제하는 메서드를 제공해준다. 밑은 <code>copy</code> 메서드를 이해를 돕기위해 직접 구현한 예시이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, postalCode = this.postalCode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Client(name, postalCode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용법</span></span><br><span class="line"><span class="keyword">val</span> client = Client(<span class="string">&quot;Klay&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> copiedClient = client.copy(<span class="string">&quot;Curry&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="클래스-위임-by-키워드-사용"><a href="#클래스-위임-by-키워드-사용" class="headerlink" title="클래스 위임: by 키워드 사용"></a>클래스 위임: by 키워드 사용</h2><p>어떤 클래스에 기능을 추가해야 할 때 데코레이터 패턴을 사용한다고 해보자. 데코레이터 패턴은 기존 클래스의 인터페이스를 데코레이터가 제공하되 데코레이터 내부에 기존 클래스 인스턴스를 필드로 갖고 메서드 호출시 기존 클래스에게 메시지를 전달하는 것이다. 그리고 데코레이터에 추가하고자 하는 메서드를 구현하면 된다. 이때 새로운 기능에 기존 클래스의 메서드를 활용할 수 있다.</p><p>하지만 이런 방법은 지나치게 준비 코드가 많다. 코틀린에서는 인터페이스를 구현할 때 <code>by</code> 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에게 위임 중이라는 사실을 명시할 수 있다.</p><p>예를 들어 ArrayList를 감싸는 클래스를 만들어보자. Collection의 인터페이스를 내부 리스트에게 위임하도록 구현해야 했다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingCollection</span>&lt;<span class="type">T</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerList = arrayListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = innerList.size</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span> = innerList.containsAll(elements)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span> = innerList.contains(element)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = innerList.isEmpty()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; = innerList.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 코틀린의 <code>by</code>를 써보자. Set에서 추가된 원소를 카운팅하는 기능을 추가해보자.<br>구현한 인터페이스 뒤에 <code>by</code>와 함께 프로퍼티 이름을 적어준 것을 확인할 수 있다. 이러면 위임 메서드를 컴파일러가 알아서 만들어준다. 다만 여기서 자동으로 만들어진 메서드 대신 개발자가 직접 구현하고 싶으면 override 붙여서 구현해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    <span class="keyword">val</span> innerSet :MutableCollection&lt;T&gt; = HashSet()</span><br><span class="line">) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> addCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        addCount++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       addCount += elements.size</span><br><span class="line">       <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="object-키워드-클래스-선언과-인스턴스-생성"><a href="#object-키워드-클래스-선언과-인스턴스-생성" class="headerlink" title="object 키워드: 클래스 선언과 인스턴스 생성"></a>object 키워드: 클래스 선언과 인스턴스 생성</h1><p>코틀린에서 <code>object</code> 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다. 다양한 상황에 대해서 알아보자.</p><h2 id="객체-선언-싱글턴을-쉽게-만들기"><a href="#객체-선언-싱글턴을-쉽게-만들기" class="headerlink" title="객체 선언: 싱글턴을 쉽게 만들기"></a>객체 선언: 싱글턴을 쉽게 만들기</h2><p>코틀린은 <strong>객체 선언</strong> 기능을 통해 싱글턴을 언어에서 기본 지원한다. 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.</p><p>모든 직원의 급여 대장을 관리하는 객체가 필요하다고 해보자. 이 객체가 굳이 여러개일 필요는 없으니 객체 선언으로 싱글턴 객체로 만들어보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll &#123;</span><br><span class="line">    <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 선언은 <code>object</code> 키워드를 사용하면 된다.객체 선언은 그 클래스를 정의하고 해당 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.<br>하지만 생성자는 객체 선언에 사용할 수 없다. 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문이다.</p><p>객체 선언도 클래스나 인스턴스를 상속받을 수 있다. 예를 들어 특정 클래스를 위해 <code>Comparator</code>를 구현한 객체는 여러 개가 필요없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> FileComparator : Comparator&lt;File&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">File</span>, o2: <span class="type">File</span>)</span></span></span><br><span class="line">       = o1.path.compareTo(o2.path, ignoreCase = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>싱글톤과 의존관계 주입<br>싱글턴 패턴과 마찬가지로 객체 선언은 대규모 시스템에서 안좋은 경우가 있다.<br>객체 생성을 제어할 수 없고 파라미터를 지정할 수 없기 때문이다.<br>그래서 단위 테스트하거나 시스템 설정이 바뀔 때 의존 객체를 바꿔줄 수 없다. 만약 이런 기능이 필요하다면 의존 관계 주입 프레임워크를 사용해보자.</p></blockquote><h3 id="클래스-안에-객체-선언"><a href="#클래스-안에-객체-선언" class="headerlink" title="클래스 안에 객체 선언"></a>클래스 안에 객체 선언</h3><p>클래스 안에 객체 선언을 해도 그 객체는 싱글톤이다. 외부 클래스가 인스턴스화 된다고 객체 선언이 여러번 객체로 만들어지는게 아니다!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> InnerObject &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    OuterClass.InnerObject.hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>자바에서 코틀린 객체 선언된 객체를 접근하기<br>코틀린 객체 선언은 자바에서 정적 필드를 가진 클래스로 컴파일된다. 이때 정적 필드 이름은 항상 <code>INSTANCE</code>다.<br><code>OuterClass.InnerObject.INSTANCE.hello()</code></p></blockquote><h2 id="동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소"><a href="#동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소" class="headerlink" title="동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소"></a>동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소</h2><p>코틀린 클래스 안에는 정적인 멤버가 없다. 코틀린은 <code>static</code> 키워드를 지원하지 않는다. 대신 최상위 함수와 객체 선언을 사용한다. 일반적으로 최상위 함수를 추천하지만 특정 클래스 내부의 private 프로퍼티나 메서드에 접근하지 못하는 경우는 해당 클래스 안에서 객체 선언을 통해 접근하기도 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedPerson</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> InnerObject &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>) <span class="comment">// 접근하지 못한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 <code>companion</code> 키워드를 통해 중첩된 객체 선언에서 클래스 이름을 제거할 수 있다.(물론 이름을 붙여줄 수도 있다.) 마치 자바의 정적 멤버 처럼 활용할 수 있게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedPerson2</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(namedPerson: <span class="type">NamedPerson2</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;hello <span class="subst">$&#123;namedPerson.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NamedPerson2.hello(NamedPerson2(<span class="string">&quot;Klay&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="동반-객체를-통해-private-생성자-호출-팩토리-메서드"><a href="#동반-객체를-통해-private-생성자-호출-팩토리-메서드" class="headerlink" title="동반 객체를 통해 private 생성자 호출: 팩토리 메서드"></a>동반 객체를 통해 private 생성자 호출: 팩토리 메서드</h3><p>동반 객체는 외부 클래스의 private 프로퍼티, 메서드, 생성자에 접근할 수 있다. 그래서 팩토리 패턴을 사용하기 좋은 조건을 가졌다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>)</span></span> = Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Man.create(<span class="string">&quot;Klay&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>팩터리 패턴이냐 여러 부 생성자냐<br>상황에 따라 여라가지 부 생성자로 객체를 만들어주도록 할 수 있다. 이를 동반 객체를 통한 팩토리 패턴을 활용해서 이름 있는 메서드로 가독성을 높일 수 있는데, 문제는 클래스를 확장해야 할 경우 동반 객체 멤버를 오버라이딩 할 수 없으므로 여러 생성자를 사용하는 편이 낫다.</p></blockquote><h3 id="동반-객체를-일반-객체처럼-사용"><a href="#동반-객체를-일반-객체처럼-사용" class="headerlink" title="동반 객체를 일반 객체처럼 사용"></a>동반 객체를 일반 객체처럼 사용</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Creatable</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">of</span><span class="params">(name: <span class="type">String</span>)</span></span> : T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Creatable&lt;Boy&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">of</span><span class="params">(name: <span class="type">String</span>)</span></span> = Boy(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">createSomething</span><span class="params">(name:<span class="type">String</span>, creatable: <span class="type">Creatable</span>&lt;<span class="type">T</span>&gt;)</span></span> = creatable.of(name)</span><br></pre></td></tr></table></figure><p>동반 객체도 인터페이스를 구현할 수 있으며, 만들어진 동반 객체가 매개변수로 사용됐음을 주목하라. 이때 동반 객체의 이름이 없어서 <code>Boy</code>로 인자를 전달해줬음을 주목하자.</p><blockquote><p>자바에서 코틀린 동반 객체<br>자바에서 코틀린 동반 객체는 이름이 있으면 해당 이름으로 정적 멤버 접근하면 되고 이름이 없는 경우는 <code>Companion</code>이라는 이름의 정적 멤버로 접근하면 된다.</p></blockquote><h3 id="동반-객체-확장"><a href="#동반-객체-확장" class="headerlink" title="동반 객체 확장"></a>동반 객체 확장</h3><p>이름 없는 동반 객체를 만들어서 비즈니스 객체에서 보고 싶지 않은 코드를 분리할 수 있다. 예를 들어 JSON으로부터 역직렬화 함수를 만들어서 제공하고 싶은데 이를 비즈니스 클래스 내부에 위치하고 싶지 않을 때 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비즈니스 모듈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클라이언트 서버 통신 모듈</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Human.Companion.<span class="title">fromJson</span><span class="params">(jsonValue: <span class="type">String</span>)</span></span> : Human &#123;</span><br><span class="line">    <span class="keyword">return</span> Human(jsonValue.toInt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="객체-식-무명-내부-클래스를-다른-방식으로-작성"><a href="#객체-식-무명-내부-클래스를-다른-방식으로-작성" class="headerlink" title="객체 식: 무명 내부 클래스를 다른 방식으로 작성"></a>객체 식: 무명 내부 클래스를 다른 방식으로 작성</h3><p>무명 객체를 정의할 때도 <code>object</code> 키워드를 사용한다. 무명 객체는 자바의 무명 내부 클래스를 대신한다.<br>이때 중요한 점은 무명 객체로 <code>object</code> 키워드를 사용하면 싱글톤이 아님을 명심하자. 무명 객체와 동반 객체나 객체 선언과 다르다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = <span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// logic...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mousePressed</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 무명 객체(객체 식)은 그 식이 포함된 함수의 변수에 접근할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickAmount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>?)</span></span> &#123;</span><br><span class="line">           clickAmount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린 함수 정의와 호출</title>
      <link>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/</guid>
      <pubDate>Mon, 09 Jan 2023 07:52:10 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번 포스트에서는 코틀린의 컬렉션, 문자열, 정규식 영역에서 함수 정의와 호출을 알아보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 코틀린의 컬렉션, 문자열, 정규식 영역에서 함수 정의와 호출을 알아보자.</p><blockquote><p>요약<br><a href="#%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0">함수를 사용하기 쉽게 만들기</a><br><a href="#%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98">확장 함수</a><br><a href="#%ED%99%95%EC%9E%A5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">확장 프로퍼티</a><br><a href="#%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EA%B0%80%EB%B3%80-%EA%B8%B8%EC%9D%B4-%EC%9D%B8%EC%9E%90-%EC%A4%91%EC%9C%84-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%A7%80%EC%9B%90">가변인자, 중위 호출</a><br><a href="#%EC%BD%94%EB%93%9C-%EB%8B%A4%EB%93%AC%EA%B8%B0-%EB%A1%9C%EC%BB%AC-%ED%95%A8%EC%88%98%EC%99%80-%ED%99%95%EC%9E%A5">로컬 함수</a></p></blockquote><h1 id="코틀린에서-컬렉션-만들기"><a href="#코틀린에서-컬렉션-만들기" class="headerlink" title="코틀린에서 컬렉션 만들기"></a>코틀린에서 컬렉션 만들기</h1><p>코틀린에서는 <code>&#123;컬렉션 종류&#125;Of(~)</code> 이런 형태로 쉽게 컬렉션을 만들 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">&quot;hi&quot;</span>, <span class="number">2</span> to <span class="string">&quot;ho&quot;</span>)</span><br></pre></td></tr></table></figure><p>코틀린은 자기만의 컬렉션 객체를 가지지 않고 자바의 컬렉션 프레임워크를 사용한다. 자바에서 사용하던 컬렉션을 코틀린에서도 그대로 사용하므로 특별한 변환 작업이 필요없다.</p><h1 id="함수를-호출하기-쉽게-만들기"><a href="#함수를-호출하기-쉽게-만들기" class="headerlink" title="함수를 호출하기 쉽게 만들기"></a>함수를 호출하기 쉽게 만들기</h1><p>자바에서 <code>toString</code> 메서드를 커스텀하게 구현해본 경험이 있을 것이다. 코틀린에서는 이를 어떻게 쉽게 해결하는 지 체험해보자!</p><p>우리는 리스트의 원소들을 다양한 구분자와 접두사, 접미사를 추가해서 문자열을 만드는 함수를 만들어 볼 것이다!</p><h2 id="무식하게-구현하기"><a href="#무식하게-구현하기" class="headerlink" title="무식하게 구현하기"></a>무식하게 구현하기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>제네릭을 활용해서 확장성이 좋은 함수를 만들었다. 만든 함수를 사용하는 코드도 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(joinToString(list, <span class="string">&quot;:&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><p>흠.. 호출하는 쪽은 조금 난잡하다. 함수를 호출할 때 인자 4개를 모두 전달하지 않는 방법은 없을까??</p><h2 id="이름-붙인-인자"><a href="#이름-붙인-인자" class="headerlink" title="이름 붙인 인자"></a>이름 붙인 인자</h2><p>코틀린에서는 함수를 호출할 때 매개변수의 이름을 통해 인자를 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(joinToString(prefix = <span class="string">&quot;&#123;&quot;</span>, collection = list, separator = <span class="string">&quot;:&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><p>이름을 붙인 인자를 활용할 때는 이름이 붙은 첫 인자 뒤로 모든 인자들에게 이름을 붙여줘야 한다. 왜냐면 이름을 명시하면 순서가 의미가 없어지기 때문에 이름을 붙여주지 않으면 혼동이 올 수 있다.<br>함수 호출하는 코드에서 인자들의 역할이 명확해졌다. 하지만 여전히 난잡한 느낌을 지울 수 없다.</p><h2 id="디폴트-파라미터-값"><a href="#디폴트-파라미터-값" class="headerlink" title="디폴트 파라미터 값"></a>디폴트 파라미터 값</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(joinToString(prefix = <span class="string">&quot;&#123;&quot;</span>, collection = list, postfix= <span class="string">&quot;&#125;&quot;</span>));</span><br></pre></td></tr></table></figure><p>이렇게 매개변수 선언부에 디폴트값을 할당해서 적어줄 수 있다. 이렇게 디폴트값을 활용하면 비효율적인 생상자 오버로딩을 대폭 줄일 수 있다.</p><blockquote><p>자바 메서드를 코틀린에서 디폴트 값 적용해서 사용하기<br>매개변수의 디폴트값을 지원하지 않는 자바 메서드를 코틀린에서 디폴트 값으로 활용하기 까다롭다는게 문제다. 이를 위해서 자바 메서드에 <code>@JvmOverloads</code> 어노테이션을 붙이면 맨 뒤 매개변수부터 하나씩 빼서 오버로딩된 메서드가 만들어진다.</p></blockquote><h2 id="정적인-유틸리티-클래스-없애기-최상위-함수와-프로퍼티"><a href="#정적인-유틸리티-클래스-없애기-최상위-함수와-프로퍼티" class="headerlink" title="정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티"></a>정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티</h2><h3 id="최상위-함수"><a href="#최상위-함수" class="headerlink" title="최상위 함수"></a>최상위 함수</h3><p>자바의 경우 모든 메서드는 클래스 안에 있어야 했다. 그래서 우리가 원하는 건 작동하는 함수 하나여도 클래스를 선언해서 해당 메서드를 포함해야 했다. 하지만 코틀린은 그럴 필요가 없다.<br>코틀린은 함수를 최상위 수준으로 위치할 수 있다. 다음과 같이 특정 패키지 바로 다음에 함수가 올 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 최상위 함수는 컴파일 될 때 새로운 클래스를 정의해서 컴파일한다. 코틀린만 사용하면 그냥 특정 클래스가 생기나보다 하고 넘기면 되지만, 자바에서 코틀린의 최상위 함수를 호출해야 할 경우에는 코틀린의 최상위 함수를 위한 클래스가 어떤 모양인지 알아야 한다.</p><p>최상위 함수를 위한 클래스는 최상위 함수를 포함하는 파일 이름에 따라 달라진다. 예를 들어 <code>join.kt</code>파일에 <code>joinToString</code>메서드를 구현한 경우에는 다음과 같이 자바 클래스가 만들어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinKt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> &lt;T&gt; joinToString(...) &#123;</span><br><span class="line">        ... 생략</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line">JoinKt.joinToString(...);</span><br></pre></td></tr></table></figure><blockquote><p>최상위 함수를 위한 클래스 명 바꾸기<br><code>@file:JvmName(&quot;ClassName&quot;)</code>을 패키지 선언문 위에 적으면 클래스 이름도 바꿀 수 있다.</p></blockquote><h3 id="최상위-프로퍼티"><a href="#최상위-프로퍼티" class="headerlink" title="최상위 프로퍼티"></a>최상위 프로퍼티</h3><p>프로퍼티도 최상위에 둘 수 있다. 연산 수행 횟수를 재는 프로퍼티 같은 경우 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blahBlah</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>이런 경우 프로퍼티는 정적 필드에 저장된다. 이때 특이한 점은 최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 제공하는데 만약 최상위 프로퍼티를 상수처럼 보이는 데 실제로는 접근자 메서드를 통해 접근하는 것이 어색할 수 있다. 그렇다면 <code>const</code> 키워드를 사용해서 <code>public static final</code> 필드로 컴파일 되게 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티"><a href="#메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티" class="headerlink" title="메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티"></a>메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티</h1><h2 id="확장-함수"><a href="#확장-함수" class="headerlink" title="확장 함수"></a>확장 함수</h2><p>확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다. 확장 함수는 기존 자바 API에 코틀린의 추가 기능을 쉽게 제공할 수 있도록 돕기 위해 등장했다.</p><p>확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장하려는 클래스 이름을 덧붙이면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>[<span class="keyword">this</span>.length - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용하는 코드</span></span><br><span class="line">println(<span class="string">&quot;hello&quot;</span>.lastChar()) <span class="comment">// o</span></span><br></pre></td></tr></table></figure><p>위 예시는 <code>String</code> 클래스에 마지막 문자를 찾아 반환하는 확장 함수를 추가했다.<br>확장 함수에서 붙여진 클래스 이름을 수신 객체 타입(receiver type) 이라고 부르며 확장 함수가 호출되는 대상이 되는 값을 수신 객체(receiver object)라고 부른다.<br><code>fun String.lastChar(): Char = this.get(this.length - 1)</code><br>위 확장 함수에서는 <code>String</code>이 수신 객체 타입이고, <code>this</code>가 수신 객체가 된다.<br>확장 함수는 자바 클래스로 컴파일한 클래스 파일이 있는 한 원하는대로 확장할 수 있다. 그리고 멤버 메서드와 확장 함수를 통틀어 메서드라고 부르겠다.</p><p>하지만 멤버 메서드와 가장 큰 차이점은 private나 protected 멤버는 확장 함수가 접근할 수 없다.<br>그리고 확장 함수를 사용할 때는 임포트를 해야 한다. (다른 함수와 동일한 이름을 가져서 충돌할 수 있으므로.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;패키지&#125;.&#123;확장함수 명&#125;</span><br><span class="line"><span class="keyword">import</span> &#123;패키지&#125;.&#123;확장함수 명&#125; <span class="keyword">as</span> &#123;다른 이름&#125;</span><br></pre></td></tr></table></figure><blockquote><p>자바에서 확장 함수 활용하기<br>확장 함수는 내부적으로 수신 객체를 첫 매개변수로 가지는 정적 메서드다. 위 예시에서 자바는 다음과 같이 작성하면 된다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = StringUtilKt.lastChar(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>이제 <code>joinToString</code> 메서드를 확장 함수로 리팩토링 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span> = <span class="string">&quot;:&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 호출 코드</span></span><br><span class="line">println(list.joinToString2(prefix = <span class="string">&quot;&#123;&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>확장 함수를 더 엄격하게 사용<br>확장 함수 수신 타입 객체를 더 엄격한 타입을 사용하면 확장 함수를 사용하는 수신 객체를 제한할 수 있다.<br><code>fun &lt;T&gt; Collection&lt;String&gt;.joinToString(...) &#123;...&#125;</code><br>이런 식으로 구현하면 문자열 리스트만 확장 함수를 사용할 수 있게 된다.</p></blockquote><h3 id="확장-함수는-오버라이드-할-수-없다"><a href="#확장-함수는-오버라이드-할-수-없다" class="headerlink" title="확장 함수는 오버라이드 할 수 없다."></a>확장 함수는 오버라이드 할 수 없다.</h3><p>오버라이드는 변수에 저장된 객체의 동적인 타입에 따라 호출할 메서드가 달라지는 기능이다.<br>왜 확장 함수는 오버라이드 할 수 없을까? 확장 함수는 정적으로 선언된 메서드이기 때문이다. 확장 함수는 인스턴스 메서드가 아닌 인스턴스를 매개변수로 받는 정적 메서드이므로 오버라이딩이 불가능하다.</p><blockquote><p>멤버 함수와 확장 함수의 시그니처가 같으면 멤버 함수가 우선한다.</p></blockquote><h2 id="확장-프로퍼티"><a href="#확장-프로퍼티" class="headerlink" title="확장 프로퍼티"></a>확장 프로퍼티</h2><p>확장 프로퍼티를 사용하면 기존 클래스 객체에 프로퍼티 형식의 구문을 사용할 수 있는 API를 추가할 수 있다. 이때 중요한 점은 확장 프로퍼티는 아무 상태도 가질 수 없다. 기존 클래스의 인스턴스 객체에 필드를 추가할 방법이 없기 때문이다. 하지만 프로퍼티 문법으로 더 짧게 코드를 작성할 수 있다.<br>확장 프로퍼티는 마치 프로퍼티 접근 방식과 유사하게 API를 제공하는 것이지 실제로 필드를 가져서 접근자 메서드를 제공하는 것이 아님을 명심하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sb = StringBuilder(<span class="string">&quot;Kotlin?&quot;</span>)</span><br><span class="line">sb.lastChar2 = <span class="string">&#x27;!&#x27;</span></span><br><span class="line">println(sb)</span><br></pre></td></tr></table></figure><p>만약 자바에서 사용하려면 다음과 같을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Char lastChar = StringUtilKt.getLastChar();</span><br></pre></td></tr></table></figure><h1 id="컬렉션-처리-가변-길이-인자-중위-함수-호출-라이브러리-지원"><a href="#컬렉션-처리-가변-길이-인자-중위-함수-호출-라이브러리-지원" class="headerlink" title="컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원"></a>컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원</h1><h2 id="가변-인자-함수-인자의-개수가-달라질-수-있는-함수-정의"><a href="#가변-인자-함수-인자의-개수가-달라질-수-있는-함수-정의" class="headerlink" title="가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의"></a>가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의</h2><p>자바에서는 <code>...</code>으로 가변 인자를 표현할 수 있었다. 코틀린에서는 <code>vararg</code> 변경자를 앞에 붙여주면 된다.<br>대표적인 가변 인자 함수인 <code>listOf</code> 함수의 경우를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> listOf<span class="type">&lt;T&gt;</span><span class="params">(varargs values: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>코틀린은 자바처럼 배열을 바로 가변 인자로 넘겨줄 수 없다. 배열의 원소를 풀어서 각 원소가 인자로 전달되게 해야한다.<br>이 역할을 스프레드 연산자 <code>*</code>가 한다. 스프레드 연산자를 활용하면 배열과 함께 다른 인자들도 같이 전달해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;args &quot;</span>, *args)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="값의-쌍-다루기-중위-호출과-구조-분해-선언"><a href="#값의-쌍-다루기-중위-호출과-구조-분해-선언" class="headerlink" title="값의 쌍 다루기: 중위 호출과 구조 분해 선언"></a>값의 쌍 다루기: 중위 호출과 구조 분해 선언</h2><p>대표적인 중위 호출인 <code>map</code>에서 <code>to</code> 메서드 호출을 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">2</span> to <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>중위 호출은 수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣는다. 다음 두 호출은 동일하다!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>to(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure><p>중위 호출은 수신 객체의 메서드 중 매개변수가 하나뿐인 경우에 사용할 수 있다.</p><p>실제 <code>to</code> 메서드의 구현을 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure><p>일단 <code>infix</code> 키워드를 통해 중위 호출을 사용할 수 있도록 했다. 제네릭을 활용해서 <code>A</code> 수신 객체 타입에 확장 함수로 구현했다.</p><h3 id="구조-분해-선언"><a href="#구조-분해-선언" class="headerlink" title="구조 분해 선언"></a>구조 분해 선언</h3><p><code>to</code> 메서드는 <code>Pair</code> 인스턴스를 반환하는데 <code>Pair</code> 인스턴스로 두 변수를 즉시 초기화 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (number, name) = <span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure><p>이렇게 <code>number</code> 와 <code>name</code> 두 변수를 <code>Pair</code>를 구조 분해해서 할당했다.</p><p>이런 구조 분해 선언은 루프에서도 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h1 id="문자열과-정규식-다루기"><a href="#문자열과-정규식-다루기" class="headerlink" title="문자열과 정규식 다루기"></a>문자열과 정규식 다루기</h1><p>코틀린 문자열은 자바 문자열과 같다. 다만 코틀린은 확장 함수로 더 다양한 기능을 제공한다.</p><h3 id="문자열-나누기"><a href="#문자열-나누기" class="headerlink" title="문자열 나누기"></a>문자열 나누기</h3><p>코틀린의 <code>split</code>은 정규식으로 나눠야 하는 경우 <code>Regex</code> 객체를 요구한다. 이로써 개발자가 혼동하는 일이 없도록 한다.<br>또한 여러 구분 문자열을 지정할 수 있도록 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> line = <span class="string">&quot;12.345-6.A&quot;</span></span><br><span class="line">println(line.split(<span class="string">&quot;\\.|-&quot;</span>.toRegex()))</span><br><span class="line">println(line.split(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;-&quot;</span>))</span><br></pre></td></tr></table></figure><h1 id="코드-다듬기-로컬-함수와-확장"><a href="#코드-다듬기-로컬-함수와-확장" class="headerlink" title="코드 다듬기: 로컬 함수와 확장"></a>코드 다듬기: 로컬 함수와 확장</h1><p>코드 중복을 줄이기 위해서 메서드 추출을 통해 작은 메서드로 분리하기 시작하면 메서드가 너무 많아져서 코드가 파악하기 어려워진다.<br>코틀린은 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.</p><p>먼저 중복되는 예시를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty name&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty email&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>보면 비슷한 검증로직이 존재한다.</p><p>이를 로컬 함수로 개선해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(user: <span class="type">User</span>, value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user, user.name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(user, user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 안에 함수를 만들어서 중복 코드를 줄였다. 하지만 <code>User</code> 객체를 로컬 함수에게 일일히 전달하는게 아쉽다.<br>사실 그러지 않아도 된다. 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;user.id&#125;</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user.name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아재 곰중 로직을 확장 함수로 추출해보자. 이렇게 하면 외부에서 사용되지 않는 로직은  도메인 클래스에서 제거할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="variable">$id</span> empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser4</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateBeforeSave()</span><br><span class="line">    <span class="comment">// save logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 식의 결과 타입</title>
      <link>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/</guid>
      <pubDate>Mon, 09 Jan 2023 04:39:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;10^6 개 중 중복 없이 2개를 조합하는 경우의 수를 계산하는 코드를 다음과 같이 작성했다.&lt;br&gt;하지만 실행해보면 완전 엉뚱한 값이 반환된다.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</description>
        
      
      
      
      <content:encoded><![CDATA[<p>10^6 개 중 중복 없이 2개를 조합하는 경우의 수를 계산하는 코드를 다음과 같이 작성했다.<br>하지만 실행해보면 완전 엉뚱한 값이 반환된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Math.pow(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">long</span> b = a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">System.out.println(b); <span class="comment">//-364189984라는 값이 나온다.</span></span><br></pre></td></tr></table></figure><p>음수가 나오는 것으로 봐서는 타입에서 감당할 수 있는 범위를 벗어난 값을 표현하려고 해서 오버플로우가 발생했음을 추측할 수 있다.<br>하지만 <code>10^6 * (10^6 - 1) / 2</code>는 499999500000이다.<br><code>long</code>은 8바이트(64비트)로 최대 2^63까지 저장할 수 있다. 즉 <code>b</code>에는 충분히 계산값을 저장할 수 있어야 한다.</p><p>하지만 왜 오버플로우가 발생했을까?<br>이를 위해서는 자바의 식 결과 타입을 어떻게 결정하는 지 알아야 한다.</p><p>일단 식 (expression)은 하나의 결과 값을 반환하는 코드로 변수, 연산자, 함수 호출 등으로 이뤄져있다.<br><code>1 + 2</code>, <code>int a = 1</code> 이런 코드들이 모두 식이다.<br>식의 반환 타입은 식의 구성 요소들에 따라 달라진다.</p><p>여기서 우리가 작성했던 코드를 다시 보자.<br>문제가 됐었던 부분은 바로 이 부분이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>여기서 코드는 한 줄이지만 여러 식으로 분해할 수 있다.</p><ol><li><code>a * (a - 1)</code> -&gt; 이 식도 여러 식으로 나눌 수 있겠지만 생략.</li><li><code>&#123;결과 값&#125; / 2</code></li><li><code>long b = &#123;결과 값&#125;</code></li></ol><p>여기서 1번식은 어떤 타입을 반환할까? 산술 연산은 서로 다른 타입이 연산될 경우 피연산자를 일반적인 타입으로 변환하고 연산을 진행한다.<br>하지면 1번식은 모두 int 타입만 사용되고 있다. 즉 1번 식의 반환 값은 int 타입이다.<br>int형은 4바이트(32비트)로 최대 20억의 값만 저장할 수 있다. 그러나 1번식의 결과값은 999999000000이다. 그래서 식의 결과를 제대로 저장하지 못하고 오버플로우가 발생했다.</p><p>이런 문제를 해결하려면 식의 피연산자의 타입을 <code>long</code>으로 캐스팅하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>) a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> b = a * (<span class="keyword">long</span>) (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>하지만 다음과 같이 식 밖에서 캐스팅을 하면 안된다. 이미 식이 수행되고 나서 캐스팅은 의미가 없기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>) (a * (a - <span class="number">1</span>)) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린 기초</title>
      <link>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/</guid>
      <pubDate>Mon, 02 Jan 2023 01:32:24 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;br&gt;&lt;a href=&quot;#%EA%B8%B0%EB%B3%B8_%EC%9A%94%EC%86%8C:_%ED%95%A8%EC%88%98%EC%99%80_%EB%B3%80%EC%88%98&quot;&gt;함수와 변수&lt;/a&gt;&lt;br&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약<br><a href="#%EA%B8%B0%EB%B3%B8_%EC%9A%94%EC%86%8C:_%ED%95%A8%EC%88%98%EC%99%80_%EB%B3%80%EC%88%98">함수와 변수</a><br><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">클래스와 프로퍼티</a><br><a href="#%EC%84%A0%ED%83%9D-%ED%91%9C%ED%98%84%EA%B3%BC-%EC%B2%98%EB%A6%AC-enum%EA%B3%BC-when">enum과 when</a><br><a href="#%EB%8C%80%EC%83%81%EC%9D%84-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-while%EA%B3%BC-for-%EB%A3%A8%ED%94%84">while과 for 루프</a><br><a href="#%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC">예외 처리</a></p></blockquote><h1 id="기본-요소-함수와-변수"><a href="#기본-요소-함수와-변수" class="headerlink" title="기본 요소: 함수와 변수"></a>기본 요소: 함수와 변수</h1><h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> &#123;함수이름&#125;<span class="params">(&#123;매개변수 이름&#125;: &#123;매개변수 타입&#125;)</span></span> : &#123;반환값 타입&#125; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>반환값이 없는 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반환값이 있는 함수 예시</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>문(statement)과 식(expression)의 구분<br>코틀린의 <code>if</code>는 식이지 문이 아니다. 반환값이 있는 함수 예시를 보면 반환값에 if식이 들어 간 것을 확인할 수 있다. 식은 값을 만들어내며 다른 식의 하위 요소로 계싼에 참여할 수 있다. 반면 문은 자신이 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 자바는 모든 제어 구조가 문인 반면, 코틀린은 루프를 제외한 모든 제어 구조가 식이다.</p></blockquote><h3 id="식이-본문인-함수"><a href="#식이-본문인-함수" class="headerlink" title="식이 본문인 함수"></a>식이 본문인 함수</h3><p><code>max</code> 함수를 좀 더 간결하게 줄여보자.<br>먼저 본문이 식 하나인 블록으로 구성되어 있어서 이를 식으로 대체할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>위 처럼 등호와 식으로 이뤄진 함수를 <strong>식이 본문인 함수</strong>라고 하고, 본문이 중괄호로 쌓인 함수를 <strong>블록이 본문인 함수</strong>라고 한다.</p><p>그리고 식이 본문인 함수인 경우 반환 타입을 생략할 수 있다. 식이 본문인 경우 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다. 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 <strong>타입추론</strong> 이라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><p>코틀린에서는 변수를 초기화할 때 타입을 생략할 수 있다. 타입을 생략하는 경우 타입추론을 활용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> statement = <span class="string">&quot;중요한 문장입니다.&quot;</span></span><br><span class="line"><span class="keyword">val</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> numberWithType: <span class="built_in">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>초기화 식을 사용하지 않고 변수를 선언하려면 반드시 타입을 적어줘야 한다. 변수에 저장될 값에 대한 정보가 없어서 타입추론을 할 수 없기 때문이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value : <span class="built_in">Int</span></span><br><span class="line">value = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="변경-가능한-변수와-변경-불가능한-변수"><a href="#변경-가능한-변수와-변경-불가능한-변수" class="headerlink" title="변경 가능한 변수와 변경 불가능한 변수"></a>변경 가능한 변수와 변경 불가능한 변수</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 값을 뜻하는 value - 초기화 이후 변경 불가</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수를 뜻하는 variable - 초기화 이후 변경 가능</span></span><br><span class="line"><span class="keyword">var</span> variable = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>이때 재밌는 점은 자바 final은 선언과 동시에 초기화해줘야 하지만 코틀린의 <code>val</code>은 한번만 초기화된다. 즉 다음과 같은 제어 구조를 구성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doMessage</span><span class="params">(input : <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> message : String</span><br><span class="line">    <span class="keyword">if</span> (input.length == <span class="number">0</span>) &#123;</span><br><span class="line">        message = <span class="string">&quot;빈 문자열 전달받음.&quot;</span></span><br><span class="line">        <span class="comment">// 연산...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        message = input + <span class="string">&quot; 전달받음&quot;</span></span><br><span class="line">        <span class="comment">// 연산...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="문자열-템플릿"><a href="#문자열-템플릿" class="headerlink" title="문자열 템플릿"></a>문자열 템플릿</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringTemplate</span><span class="params">(input: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = input.ifEmpty &#123; <span class="string">&quot;Kotlin&quot;</span> &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;HELLO <span class="subst">$&#123;name.uppercase()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문자열 리터럴 안에서 변수를 사용할 수 있도록 하는 방법이다. <code>$</code>를 앞에 붙여주고 변수명을 적어주면 상요할 수 있다.<br>중괄호를 써주면 변수명이 아닌 간단한 식을 넣어줄 수도 있다.</p><h1 id="클래스와-프로퍼티"><a href="#클래스와-프로퍼티" class="headerlink" title="클래스와 프로퍼티"></a>클래스와 프로퍼티</h1><p>자바빈 클래스인 <code>Person</code>을 자바와 코틀린으로 구현해보자.<br>자바</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>와우! 어떻게 이렇게 된 것일까?<br>코틀린에서는 생성자를 통해 필드 대입 로직을 묵시적으로 생략해도 된다. 그리고 가시성 변경자가 public 인 경우 생략할 수 있다.</p><h2 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h2><p>클래스라는 개념의 목적은 데이터를 캡슐화 하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.<br>자바에서는 데이터를 필드에 저장하고 해당 데이터를 접근할 수 있는 접근자 메서드를 제공한다. (보통 게터, 세터)<br>자바에서는 이런 필드와 접근자 메서드를 묶어서 프로퍼티라고 정의한다.<br>코틀린은 프로퍼티를 언어 기본 기능으로 제공한다. 코틀린 프로퍼티는 자바의 필드 + 접근자 메서드를 완전히 대체한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>변수 선언과 비슷하게 <code>val</code>과 <code>var</code> 키워드로 선언할 수 있다. 이때 두 키워드에 따라 프로퍼티 유형이 달라진다.</p><ul><li><code>val</code> : 읽기 전용 프로퍼티, 비공개 필드 + 게터</li><li><code>var</code> : 쓸 수 있는 프로퍼티, 비공개 필드 + 게터 + 세터</li></ul><blockquote><p><code>is</code>가 붙은 변수명의 게터 세터<br><code>isMarried</code>와 같이 변수명이 <code>is</code>로 시작하는 경우 게터가 <code>get</code>이 붙지 않고 원래 이름 그대로 사용한다.<br>그리고 세터는 <code>is</code> 부분을 <code>set</code>으로 바꿔 사용한다. <code>isMarried</code>는 <code>setMarried</code>가 될 것이다.</p></blockquote><p>그렇다면 자바와 코틀린의 클래스 활용법을 비교해보자.<br>자바</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;yang&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(person.getName());</span><br><span class="line">person.setMarried(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(person.isMarried());</span><br></pre></td></tr></table></figure><p>코틀린</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person(<span class="string">&quot;yang&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">println(person.name)</span><br><span class="line">person.isMarried = <span class="literal">true</span></span><br><span class="line">println(person.isMarried)</span><br></pre></td></tr></table></figure><h3 id="커스텀-접근자"><a href="#커스텀-접근자" class="headerlink" title="커스텀 접근자"></a>커스텀 접근자</h3><p>프로퍼티는 그 값을 저장하기 위해 프로퍼티를 뒷받침하는 필드가 존재한다. 그런데 필요하면 프로퍼티 값을 그때그때 계산할 수도 있다. 커스텀 게터를 사용하면 그런 프로퍼티를 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> height == width</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> isSquare2: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = height == width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>직사각형이 정사각형인지를 굳이 필드로 저장하지 않고 커스텀 접근자로 구현한 예시이다. 본문이 식인 경우와 블록인 경우 모두 가능하다. 식이 복잡하면 블록으로 구현할 수 있다.</p><h1 id="선택-표현과-처리-enum과-when"><a href="#선택-표현과-처리-enum과-when" class="headerlink" title="선택 표현과 처리: enum과 when"></a>선택 표현과 처리: enum과 when</h1><h2 id="enum-클래스-정의"><a href="#enum-클래스-정의" class="headerlink" title="enum 클래스 정의"></a>enum 클래스 정의</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, ORANGE, YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린에서 <code>enum</code>은 소프트 키워드이다. 소포트 키워드는 특정 조건에서만 특정한 의미를 갖는 키워드이다. 소프트 키워드는 변수 명 같이 다른 이름으로 사용할 수 있다. 하지만 <code>class</code>는 키워드이고 다른 곳에서 이름으로 사용할 수 없다.</p><p>코틀린 enum도 프로퍼티와 메서드를 추가해줄 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(</span><br><span class="line">    <span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), </span><br><span class="line">    ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>),</span><br><span class="line">    YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>); <span class="comment">// 반드시 끝에 세미콜론</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(Color.YELLOW.rgb())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적인 클래스와 비슷하게 생성자를 통해 프로퍼티를 선언할 수 있다. 각 상수마다 프로퍼티 값을 정의해준다.<br>그리고 중요한 점은 enum에 메서드가 존재하는 경우 마지막 enum 상수 끝에 세미콜론을 넣어줘야 한다!</p><h2 id="when으로-enum-클래스-다루기"><a href="#when으로-enum-클래스-다루기" class="headerlink" title="when으로 enum 클래스 다루기"></a>when으로 enum 클래스 다루기</h2><p>자바의 <code>switch</code>가 있다면 코틀린에는 <code>when</code>이 있다. 각 색깔에 맞는 과일 이름을 반환하는 메서드를 <code>when</code>을 활용해서 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFruitNameOf</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED -&gt; <span class="string">&quot;Apple&quot;</span></span><br><span class="line">        Color.ORANGE -&gt; <span class="string">&quot;Orange&quot;</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">&quot;Banana&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTemperatureOf</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED, Color.ORANGE -&gt; <span class="string">&quot;Hot&quot;</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">&quot;warm&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>코틀린의 <code>when</code>은 <code>if</code>와 마찬가지로 값을 반환하는 식이다. 그래서 식이 본문인 함수로 구현할 수 있다. 자바 <code>switch</code>와는 다르게 매번 <code>break</code>을 넣어주지 않아도 된다.</p><h2 id="when과-임의의-객체를-함께-사용"><a href="#when과-임의의-객체를-함께-사용" class="headerlink" title="when과 임의의 객체를 함께 사용"></a>when과 임의의 객체를 함께 사용</h2><p><code>when</code>은 분기 조건에 임의의 객체도 지원해서 상수(enum 상수나 숫자 리터럴)만 허용하는 <code>switch</code>보다 강력하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mix</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> (setOf(c1, c2)) &#123;</span><br><span class="line">        setOf(RED, YELLOW) -&gt; ORANGE</span><br><span class="line">        setOf(RED, ORANGE) -&gt; RED</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>분기 조건에 두 색을 가진 집합 객체를 받아서 사용할 수 있다. 이때 임의의 객체를 분기 조건으로 사용하면 해당 분기가 맞는지는 동등성을 통해 확인한다.<br>하지만 위 코드는 매번 메서드를 실행할 때마다 여러 Set 객체를 만들어서 비교한다. 메서드 호출이 굉장히 많을 경우 불필요한 가비지 객체가 많아짐을 의미한다.</p><h2 id="인자-없는-when-사용"><a href="#인자-없는-when-사용" class="headerlink" title="인자 없는 when 사용"></a>인자 없는 when 사용</h2><p>인자가 없는 <code>when</code> 식 사용하면 불필요한 객체 생성을 막을 수 있다. 코드는 장황해지만 성능 상의 이점을 얻을 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mixOptimized</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        (c1 == RED &amp;&amp; c2 == YELLOW) ||</span><br><span class="line">                (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE</span><br><span class="line">        (c1 == RED &amp;&amp; c2 == ORANGE) ||</span><br><span class="line">                (c1 == ORANGE &amp;&amp; c2 == RED) -&gt; RED </span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty Color&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>when</code> 식에 인자가 없으려면 매 분기가 참 거짓을 판별하는 식이어야 한다.</p><h2 id="스마트-캐스트-타입-검사와-타입-캐스트를-조합"><a href="#스마트-캐스트-타입-검사와-타입-캐스트를-조합" class="headerlink" title="스마트 캐스트: 타입 검사와 타입 캐스트를 조합"></a>스마트 캐스트: 타입 검사와 타입 캐스트를 조합</h2><p><code>(1 + 2) + 4</code> 와 같이 덧셈을 계산하는 함수를 만들어보자.<br>우선 식을 인코딩하는 방법을 생각해본다. 우리는 식을 트리 구조로 저장한다. 노드는 <code>Num</code>(값)과 <code>Sum</code>(합) 두가지 형식을 가지고, 최하단 노드는 항상 <code>Num</code>이고 <code>Sum</code>은 자식을 가진 중간 노드다.<br><img src="/img/calculatorTreeDiagram.png" alt="트리로 표현한 계산"></p><p><code>Expr</code> 인터페이스를 선언하고 <code>Sum</code>과 <code>Num</code> 모두 구현하도록 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr</span><br></pre></td></tr></table></figure><p>그렇다면 <code>(1 + 2) + 4</code>라는 식은 <code>Sum(Sum(Num(1), Num(2)), Num(4))</code> 이런 객체로 표현할 수 있다.</p><p>그렇다면 해당 <code>Expr</code> 객체의 값을 반환하는 <code>eval</code> 메서드를 통해 값을 구한다고 하면 다음과 같은 코드가 된다.<br><code>println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))</code></p><p><code>Expr</code> 객체가 <code>Sum</code>과 <code>Num</code>에 따라 <code>eval</code>이 다르게 작동해야 한다.</p><ul><li><code>Num</code> : 그 값을 반환</li><li><code>Sum</code> : 좌항과 우항을 계산한 다음 두 값을 합한 값을 반환</li></ul><p>이런 분기를 처리하는 코드를 짜보는데, Java 방식으로 Kotlin 코드를 짜보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">        <span class="keyword">val</span> n = e <span class="keyword">as</span> Num</span><br><span class="line">        <span class="keyword">return</span> n.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">        <span class="keyword">val</span> n = e <span class="keyword">as</span> Sum</span><br><span class="line">        <span class="keyword">return</span> eval(n.left) + eval(n.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>is</code>는 Java의 <code>instancof</code>와 비슷하고, <code>as</code>는 캐스팅하는 역할을 한다.<br>Kotlin에서는 <code>is</code>로 검사하고 나면 해당 변수는 컴파일러가 검사했던 타입으로 캐스팅해준다. 이를 스마트 캐스트라고 부른다.</p><p>스마트 캐스트를 적용하면 캐스팅하던 코드가 사라진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> eval(e.left) + eval(e.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="리팩토링-if를-when으로-변경"><a href="#리팩토링-if를-when으로-변경" class="headerlink" title="리팩토링: if를 when으로 변경"></a>리팩토링: if를 when으로 변경</h3><p>Kotlin의 <code>if</code>는 값을 만들어내는 식임을 더 활용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =  </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) e.value</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) eval(e.left) + eval(e.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br></pre></td></tr></table></figure><p>식이 본문인 함수로 변경됐다. 하지만 <code>if</code>를 <code>when</code>으로 변경해서 더 다듬을 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>분기 조건에 값 동등성 조건 대신 다른 기능을 활용하였다. 이 경우에도 스마트 캐스트가 작동한다.</p><h3 id="if와-when의-분기에서-블록-사용"><a href="#if와-when의-분기에서-블록-사용" class="headerlink" title="if와 when의 분기에서 블록 사용"></a>if와 when의 분기에서 블록 사용</h3><p><code>if</code>와 <code>when</code>의 분기에서 복잡한 로직을 실행하려면 블록을 사용한다. 그리고 각 블록은 반환하려는 값을 맨 마지막에 작성하면 된다. <strong>즉 블록의 마지막 식이 블록의 결과이다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">evalWithLogging</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;num: <span class="subst">$&#123;e.value&#125;</span>&quot;</span>)</span><br><span class="line">            e.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> right = evalWithLogging(e.right)</span><br><span class="line">            <span class="keyword">val</span> left = evalWithLogging(e.left)</span><br><span class="line">            println(<span class="string">&quot;num: <span class="subst">$&#123;left + right&#125;</span>&quot;</span>)</span><br><span class="line">            left + right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;unknown expression&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="대상을-이터레이션-while과-for-루프"><a href="#대상을-이터레이션-while과-for-루프" class="headerlink" title="대상을 이터레이션: while과 for 루프"></a>대상을 이터레이션: while과 for 루프</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>코틀린의 <code>while</code>은 자바와 별반 다르지 않다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span> (조건)</span><br></pre></td></tr></table></figure><h2 id="수에-대한-이터레이션-범위와-수열"><a href="#수에-대한-이터레이션-범위와-수열" class="headerlink" title="수에 대한 이터레이션: 범위와 수열"></a>수에 대한 이터레이션: 범위와 수열</h2><p>전통적인 for문을 코틀린에서 제공하지 않는다. 이를 대신하기 위해 코틀린에서는 범위를 사용한다.<br>범위는 <code>val oneToTen = 1..10</code> 이런 방식으로 만든다. 코틀린의 범위는 폐구간 혹은 양 끝을 포함하는 구간이다.</p><p>이때 역방향으로 수열을 만들고 싶으면 <code>100 downTo 1</code> 이런 식으로 구현할 수 있다. 이때 감소폭을 다루고 싶으면 <code>step</code> 키워드를 붙이면 된다. 즉 <code>100 downTo 1 step 2</code> 이런 식으로 구현할 수 있다.</p><p>코틀린은 기본적으로 개발자가 작성한 마지막 끝 점을 포함한 수열을 만든다. 만약 닫힌 구간을 구현하고 싶으면 <code>until</code> 키워드를 사용하자. <code>0 until 101</code>은 <code>0..100</code>과 같다.</p><h2 id="맵에-대한-이터레이션"><a href="#맵에-대한-이터레이션" class="headerlink" title="맵에 대한 이터레이션"></a>맵에 대한 이터레이션</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> someMap) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$key</span> = <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 형태로 맵 객체를 구조 분해해서 사용할 수 있다.<br>물론 굳이 맵이 아니더라도 구조 분해할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> someList.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$index</span>: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="in으로-컬렉션이나-범위의-원소-검사"><a href="#in으로-컬렉션이나-범위의-원소-검사" class="headerlink" title="in으로 컬렉션이나 범위의 원소 검사"></a>in으로 컬렉션이나 범위의 원소 검사</h2><p>in 연산자로 순회 뿐만아니라 원소가 포함됐는지 검사할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> || c <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c !<span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure><p><code>when</code> 절에서도 분기를 구분할 때 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recognize</span><span class="params">(c: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span>(c) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> -&gt; <span class="string">&quot;is lower case&quot;</span></span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;is upper case&quot;</span></span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="string">&quot;is numeric value&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;don&#x27;t know&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code> 절로 원소 겁사할 수 있는 범위는 비교가 가능한 클래스(<code>Comparable</code>을 구현한 클래스)면 무엇이든 된다.</p><h1 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h1><p>코틀린의 예외 발생은 자바와 거의 비슷하다. 다만 코틀린에서는 <code>throw</code> 키워드가 식을 만든다는 점만 알고 있자. 그래서 다른 식 내부에서 사용될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> percentage =</span><br><span class="line">        <span class="keyword">if</span> (number <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) number</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> Exception()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try, catch, finally"></a>try, catch, finally</h2><p>자바와 마찬가지로 try, catch, finally를 사용한다. 다만 <code>throws IOException</code>이 없다는 점을 주목하자. 자바는 체크 예외를 반드시 어떻게든 처리해줘야 하는데 코틀린은 체크 예외와 언체크드 예외를 구분하지 않는다. 체크 예외가 발생한다고 해서 클라이언트 프로그램이 취할 수 있는 의미있는 동작이 마땅하지 않은 경우가 많기 때문에 의미 없는 예외를 다시 던지거나 예외를 잡고 처리하지 않도록 구현하는 경우가 많기 때문이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span> <span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try를 식으로도 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우 catch 블록을 보면 return 문을 통해 메서드를 종료시키고 있다. 이런 방식은 catch 됐을 때 메서드를 종료시키고 싶은 경우 적절하다. 하지만 다른 값을 반환해야 하는 경우는 다르게 작성할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 마지막줄에 블록의 결과를 넣는 규칙에 따라 null을 결과값으로 반환되도록 구현했다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>널 오브젝트 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/</guid>
      <pubDate>Wed, 28 Dec 2022 07:25:25 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e = DB.getEmployee(<span class="string">&quot;Yang&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.isTimeToPay(today)) &#123;</span><br><span class="line">    e.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식의 코드가 있다고 하자. 데이터베이스에서 조회하는 직원이 존재하지 않으면 null을 반환할 수 있기 때문에 조건문에서 먼저 null 여부를 체크해줬다. 이런 번거로운 작업을 줄이고 로직 코드를 보다 더 깔끔하게 만드는 패턴이 널 오브젝트 패턴이다.</p><h1 id="널-오브젝트-패턴"><a href="#널-오브젝트-패턴" class="headerlink" title="널 오브젝트 패턴"></a>널 오브젝트 패턴</h1><p><img src="/img/nullObjectDiagram.png"><br>널 오브젝트 패턴은 추상화하려는 객체의 인터페이스를 만들고 그 구현체로 null을 의미하는 구현체와 진짜 객체를 의미하는 구현체를 만들어서 활용한다.<br>null을 의미하는 클래스의 메서드는 ‘아무 일’도 하지 않도록 구현한다. ‘아무 일’의 경우 각 메서드에 따라 다르다. <code>isTimeToPay</code> 메서드 같은 경우 null인 객체는 false를 반환하는게 자연스럽다.</p><p>널 오브젝트 패턴으로 코드를 고치면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e = DB.getEmployee(<span class="string">&quot;Yang&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (e.isTimeToPay(today)) &#123;</span><br><span class="line">    e.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 자바 8이후에는 Optional을 사용하면서 이런 문제가 많이 해소되었다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>퍼사드와 미디에이터 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/</guid>
      <pubDate>Fri, 23 Dec 2022 09:43:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;퍼사드-패턴&quot;&gt;&lt;a href=&quot;#퍼사드-패턴&quot; class=&quot;headerlink&quot; title=&quot;퍼사드 패턴&quot;&gt;&lt;/a&gt;퍼사드 패턴&lt;/h1&gt;&lt;p&gt;퍼사드는 외관, 건물의 정면을 의미한다.&lt;br&gt;퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="퍼사드-패턴"><a href="#퍼사드-패턴" class="headerlink" title="퍼사드 패턴"></a>퍼사드 패턴</h1><p>퍼사드는 외관, 건물의 정면을 의미한다.<br>퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 객체 그룹을 간단하고 구체적인 인터페이스를 제공한다.</p><p>DB를 활용하기 위해 <code>java.sql</code> 패키지의 복잡한 인터페이스를 가진 객체들을 상위 모듈에서 사용하기는 어렵다.<br>이를 위해 퍼사드 역할을 하는 객체를 만들 수 있다.<br><img src="/img/facadeDBDiagram.png"></p><p><code>Application</code> 입장에는 <code>java.sql</code>을 알지 못해도 DB에 접근할 수 있게 된다.<br>다만 퍼사드 패턴은 반드시 퍼사드 객체를 통하기를 강요한다.</p><h1 id="미디에이터-패턴"><a href="#미디에이터-패턴" class="headerlink" title="미디에이터 패턴"></a>미디에이터 패턴</h1><p>미디에어터는 중재자라는 뜻을 의미한다. 복잡한 객체들의 관계를 캡슐화해서 관리하는 패턴이다. 미디에이터 패턴은 구성 요소들이 서로 직접 통신하지 말고 중재자를 거쳐서 통신한다.</p><p>간단한 비유를 해보자면, 관제탑과 비행기들의 관계가 미디에이터 패턴에 해당한다. 비행기들은 이착륙할 때 서로 부딪히지 않기 위해 비행기들끼리 직접 통신하지 않는다. 대신 관제탑과 통신하여 수많은 다른 비행기들과 부딪히지 않고 이착륙을 할 수 있게 된다.</p><p>구현은 다음을 참고하자.<br><a href="https://refactoring.guru/design-patterns/mediator/java/example">https://refactoring.guru/design-patterns/mediator/java/example</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/design-pattern/">Design Pattern</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>의존성 분리를 통해 설계 개선하기 2편 (우아한객체지향)</title>
      <link>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/</guid>
      <pubDate>Thu, 22 Dec 2022 13:37:19 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;도메인-컨셉&quot;&gt;&lt;a href=&quot;#도메인-컨셉&quot; class=&quot;headerlink&quot; title=&quot;도메인 컨셉&quot;&gt;&lt;/a&gt;도메인 컨셉&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/storeAndMenuDomainConcept.png&quot; alt=&quot;가게와</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="도메인-컨셉"><a href="#도메인-컨셉" class="headerlink" title="도메인 컨셉"></a>도메인 컨셉</h1><p><img src="/img/storeAndMenuDomainConcept.png" alt="가게와 메뉴"><br><img src="/img/orderDomainConcept.png" alt="주문"></p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>사용자가 가게에서 메뉴 A를 골라서 장바구니에 저장해놓은 상태에서 가게 주인이 메뉴 A의 세부 내용을 바꾸면 사용자 장바구니에 있는 메뉴 A와 가게에서 판매 중인 메뉴 A의 불일치가 생긴다.<br>그래서 이제 주문할 때마다 사용자가 주문하려는 메뉴 A가 실제 가게에서 판매 중인 메뉴 A와 일치하는 지 검증하려고 한다.</p><h2 id="주문-검증"><a href="#주문-검증" class="headerlink" title="주문 검증"></a>주문 검증</h2><ol><li>메뉴 이름 &#x3D;&#x3D; 주문 항목의 이름</li><li>옵션 그룹의 이름 &#x3D;&#x3D; 주문 옵션 그룹 이름</li><li>옵션 이름 &#x3D;&#x3D; 주문 옵션 이름</li><li>옵션 가격 &#x3D;&#x3D; 주문 옵션의 가격</li><li>가게가 영업중인지 확인</li><li>주문금액 &gt;&#x3D; 최소 주문 금액</li></ol><p><img src="/img/orderFlow.png" alt="주문 검증 협력 흐름"></p><p>이런 식으로 협력 구조를 잡으면 어떻게든 런타임에서 같은 방향으로 의존성을 가져야 한다.<br>그렇다면 의존성의 방향을 어떤 종류의 의존성으로 구현할 지 선택하면 된다. 협력은 연관관계와 의존관계로 구현할 수 있다.</p><h3 id="연관관계"><a href="#연관관계" class="headerlink" title="연관관계"></a>연관관계</h3><p>연관관계는 영구적인 탐색 구조이다. 매우 빈번하게 협력해야 하는 경우에 사용한다.<br>연관 관계는 탐색 가능성을 의미한다. 즉 객체 A를 알면 객체 B를 탐색할 수 있음을 의미한다.</p><blockquote><p>일반적인 연관관계 구현 방식 : 객체 참조</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderLineItem&gt; orderLineItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">voidrplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getShopId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Money <span class="title">getTotalPrice</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        validate()</span><br><span class="line">        ordered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (OrderLineItem orderLineItem : orderLineItems) &#123;</span><br><span class="line">            orderLineItem.validate(); <span class="comment">// 협력!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로 연관관계는 개념이고 객체 참조는 그 개념의 구현방법이다. 연관관계가 즉 객체 참조는 아니다!</p><p>지금 예시의 도메인 모델에서는 다음과 같이 연관관계를 객체 참조로 가지고 있다<br><img src="/img/orderClassDiagram.png"></p><h1 id="설계-진화시키기"><a href="#설계-진화시키기" class="headerlink" title="설계 진화시키기"></a>설계 진화시키기</h1><p>설계를 개선하기 위해서는 의존성을 그려보자. 의존성이 순환하는 경우는 코드를 잘못 나눴거나 같이 있어야 할 코드를 잘못 위치시킨 것을 판단할 수 있다.</p><h2 id="대표적인-문제"><a href="#대표적인-문제" class="headerlink" title="대표적인 문제"></a>대표적인 문제</h2><ol><li>객체 참조로 결합도 상승</li><li>패키지 의존성 사이클</li></ol><p><img src="/img/orderPackageCycle.png" alt="패키지 의존성 사이클"><br>위 그림을 보면 알 수 있듯이 <code>shop</code> 패키지와 <code>order</code> 패키지가 서로 의존성이 순환되고 있다. 이렇게 되면 의존성 방향이 잘못 됐거나 패키지 분리를 잘못한 것이다.</p><p>자 이제 이런 문제를 해결하는 몇가지 방법을 배워보자</p><h2 id="중간-객체-이용해서-의존성-사이클-끊기"><a href="#중간-객체-이용해서-의존성-사이클-끊기" class="headerlink" title="중간 객체 이용해서 의존성 사이클 끊기"></a>중간 객체 이용해서 의존성 사이클 끊기</h2><p><img src="/img/middleObjectClassDiagram.png" alt="중간 객체를 사용한 예시 클래스 다이어그램"><br>중간 객체를 둬서 두 패키지 간 의존성이 한 방향으로 흐르게 만들었다.<br>이렇게 구현하면 <code>OrderOptionGroup</code>을 통해 <code>OptionGroup</code>을 생성하고 <code>OptionGroupSpecification</code>이 생성된 <code>OptionGroup</code>과 비교하여 데이터 불일치를 검증하는 방식으로 구현한다.</p><h2 id="객체-참조의-문제점"><a href="#객체-참조의-문제점" class="headerlink" title="객체 참조의 문제점."></a>객체 참조의 문제점.</h2><ol><li>성능 문제 : 어디까지 조회 할 것인가?</li><li>수정 시 도메인 규칙을 함께 적용할 경계는? : 즉 트랜잭션의 범위가 어디까지인가?</li></ol><h3 id="수정-시-도메인-규칙을-함께-적용할-경계-문제"><a href="#수정-시-도메인-규칙을-함께-적용할-경계-문제" class="headerlink" title="수정 시 도메인 규칙을 함께 적용할 경계 문제"></a>수정 시 도메인 규칙을 함께 적용할 경계 문제</h3><p>간단한 예시를 들어보자.<br>배달 완료됐음을 알리는 서비스 로직이 있다.</p><ol><li>주문 객체의 상태를 배달 완료로 변경</li><li>가게 객체의 수수료를 부과</li><li>배달 객체의 상태를 배달 완료로 변경</li></ol><p>언뜻 보면 이 세 객체를 한 트랜잭션으로 묶어서 수정하는 게 큰 문제가 없어보인다.<br>그러나 문제는 주문, 가게, 배달 이 세가지 객체의 트랜잭션 주기가 다르다는 사실이다!</p><p>가게는 주인이 가게 정보를 바꾸려고 할 때도 트랜잭션이 걸릴 수 있다.<br>주문은 고객이 주문을 취소할 때도 트랜잭션이 걸릴 수 있다.<br>배달은 배달 성공 실패에 트랜잭션이 걸릴 수 있다.</p><p>즉 만약 개발자가 서비스의 모든 가게 객체의 특정 정보를 일괄 수정하는 트랜잭션을 실행한다고 가정하자.<br>우리가 개발한 배달 완료 로직은 개발자가 수행한 모든 가게 정보 수정 트랜잭션이 완료될 때까지 기다려야 될 것이다!!!<br>이는 트랜잭션 주기가 다른 여러 객체들이 한 트랜잭션에 묶여있어서 생긴 문제이다!</p><blockquote><p>그렇다면 언제 객체 참조를 해야하나?<br>도메인 규칙마다 다르다. 생명 주기가 같은 객체. 즉 같이 생성되고 같이 제거되는 객체는 객체 참조할 법하다.<br>혹은 도메인 제약 사항을 공유하는 객체들을 함께 묶어라! (도메인 제약 사항에 다른 객체가 필요한 경우!)<br>이렇게 객체 참조로 연결된 단위는 트랜잭션&#x2F;조회&#x2F;비즈니스 제약의 단위이다!</p></blockquote><h3 id="객체-참조-문제-해결법-레포지토리를-활용한-간접-참조"><a href="#객체-참조-문제-해결법-레포지토리를-활용한-간접-참조" class="headerlink" title="객체 참조 문제 해결법 : 레포지토리를 활용한 간접 참조"></a>객체 참조 문제 해결법 : 레포지토리를 활용한 간접 참조</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shop shop = shopRepository.findById(order.getShopId());</span><br></pre></td></tr></table></figure><p>이렇게 구현하면 <code>Shop</code>과 <code>Order</code> 사이의 강한 결합이 제거된다!</p><h3 id="검증-로직은-Validator-객체를-만들어서-도입하기"><a href="#검증-로직은-Validator-객체를-만들어서-도입하기" class="headerlink" title="검증 로직은 Validator 객체를 만들어서 도입하기"></a>검증 로직은 Validator 객체를 만들어서 도입하기</h3><p>문제는 이렇게 구현하면 기존에 객체들이 가지고 있던 검증 로직을 도메인 객체에서 수행할 수 없게 된다!<br>Validator라는 객체를 만들어서 주입해서 사용하는 건 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderValidator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShopRepository shopRepository;</span><br><span class="line">    <span class="keyword">private</span> MenuRepository menuRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderValidator</span><span class="params">(ShopRepository shopRepository,</span></span></span><br><span class="line"><span class="params"><span class="function">                          MenuRepository menuRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shopRepository = shopRepository;</span><br><span class="line">        <span class="keyword">this</span>.menuRepository = menuRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        validate(order, getShop(order), getMenus(order));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Order order, Shop shop, Map&lt;Long, Menu&gt; menus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!shop.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;가게가 영업중이 아닙니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (order.getOrderLineItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;주문 항목이 비어 있습니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shop.isValidOrderAmount(order.calculateTotalPrice())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">&quot;최소 주문 금액 %s 이상을 주문해주세요.&quot;</span>, shop.getMinOrderAmount()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderLineItem item : order.getOrderLineItems()) &#123;</span><br><span class="line">            validateOrderLineItem(item, menus.get(item.getMenuId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이런 방식이 낯설 수 있다. 객체가 주도적으로 행동하는 것이 아닌 외부에 따로 객체를 만들어서 검증 책임을 하는 것처럼 보인다. 이런 방식은 객체지향적이지 않은 대신 제약조건을 한 눈에 볼 수 있고, 객체들의 응집도(검증 로직과 비즈니스 로직이 하나의 객체가 아닌 다른 객체로 분리)가 높아진다.</p><h3 id="다른-서비스-객체를-만들어서-도입하기"><a href="#다른-서비스-객체를-만들어서-도입하기" class="headerlink" title="다른 서비스 객체를 만들어서 도입하기"></a>다른 서비스 객체를 만들어서 도입하기</h3><p>그리고 객체 참조를 제거하면 다른 문제가 또 생긴다. 배달 완료 로직에서 객체 참조가 끊겨서 객체 내부에서 협력을 통해 로직을 실행 시킬 수 없다<br>-&gt; 그렇다면 다른 Service를 객체를 추가해서 로직을 절차지향적으로 구성할 수 있다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDeliveredService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverOrder</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">        Order order = orderRepository.findById(orderId);</span><br><span class="line">        Shop shop = shopRepository.findById(order.getShopId());</span><br><span class="line">        Delivery delivery = deliveryRepository.findById(orderId);</span><br><span class="line"></span><br><span class="line">        order.delivered();</span><br><span class="line">        shop.billComissionFee(order.calculateTotalPrice());</span><br><span class="line">        delivery.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 서비스를 주입받아서 사용하면 된다. 이때 서비스를 새로 만들면서 의존성 사이클이 도는 경우는 DIP를 활용한 인터페이스를 추가해서 적용해보자. 이 방법은 객체간의 결합도를 낮추는 대신 로직간의 결합도를 높이는 방법이다.</p><h3 id="도메인-이벤트-퍼블리싱"><a href="#도메인-이벤트-퍼블리싱" class="headerlink" title="도메인 이벤트 퍼블리싱"></a>도메인 이벤트 퍼블리싱</h3><p>위 방법들 외에도 도메인 이벤트 퍼블리싱 방법을 사용할 수 있다. 도메인 이벤트는 객체 간 결합은 최대한 느슨하게 하는 방법이다.<br>도메인 객체가 이벤트 객체를 발행하면 다른 패키지의 이벤트 리스너들이 이를 감지해 해당 패키지의 도메인 객체에게 알리는 방식이다.</p><p>주문 완료의 예시에서는</p><ol><li><code>Order</code> 객체가 배달 완료됐다는 메시지를 받는다.</li><li><code>Order</code>는 <code>OrderDeliveredEvent</code>라는 이벤트를 발행한다</li><li><code>shop</code> 패키지는 발행된 이벤트를 감지해 가게에 수수료를 부과하는 로직을 실행한다.</li><li><code>delivery</code> 패키지도 발행된 이벤트를 감지해 <code>Delivery</code> 객체의 상태를 완료로 변경한다.</li></ol><h3 id="도메인-이벤트-발행-코드로-이해하기"><a href="#도메인-이벤트-발행-코드로-이해하기" class="headerlink" title="도메인 이벤트 발행 코드로 이해하기"></a>도메인 이벤트 발행 코드로 이해하기</h3><p>이런 식으로 <code>Order</code> 객체는 이제 이벤트를 발행하기만 한다. 다른 패키지 도메인 객체에는 관심이 없다.<br>예제는 Spring Data의 <code>AbstractAggregatedRoot</code>를 상속받아서 <code>registerEvent</code> 메서드를 활용해서 이벤트를 등록한다. <code>registerEvent</code> 메서드는 이벤트를 모아놨다가 DB에 커밋될 때 이벤트를 발행한다. 이런 클래스의 도움을 받기 보다는 직접 구현하는 게 낫다고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">extends</span> <span class="title">AbstractAggregatedRoot</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderStatus = OrderStatus.DELIVERED;</span><br><span class="line">        registerEvent(<span class="keyword">new</span> OrderDeliveredEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDeliveredEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getShopId</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getTotalPrice</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트 발행을 받는 쪽(shop 패키지)은 Spring의 이벤트 리스너를 활용해서 이벤트 핸들러를어만들어 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillShopWithOrderDeliveredEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DI 생략...</span></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//비동기로 처리. 동기로도 가능</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 다른 트랜잭션으로 분리해서도 가능</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(OrderDeliveredEvent event)</span> </span>&#123;</span><br><span class="line">        Shop shop = shopRepository.findById(event.getShopId());</span><br><span class="line">        shop.billCommissionFee(event.getTotalPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 이렇게 이벤트와 관련된 객체를 만들고 나서 다시 의존성 사이클이 발생할 수 있다는 사실이다.<br>이벤트를 받아 처리하는 리스너에서 파라미터로 <code>order</code> 패키지의 이벤트를 받도록 했기 때문에 <code>shop</code>과 <code>order</code>가 서로 의존하고 있다.</p><p><img src="/img/orderClassDiagramWithEvents.png"></p><p>이 문제는 <code>order</code>에서 발행한 이벤트를 처리하는 이벤트 핸들러가 <code>shop</code> 패키지에 있기 때문이다!<br>그렇다면 문제가 되는 이벤트 핸들러를 패키지 분리하면 어떨까?</p><p><img src="/img/orderClassDiagramWithEventsAddBilling.png" alt="billing 패키지를 추가해봤다."></p><p>그리고 이벤트 핸들러가 의존하던 수수료 관련 코드를 <code>Shop</code>과 분리하자!</p><p>기존의 <code>Shop</code> 객체는 다음과 같이 수수료 모으는 코드가 존재했었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ratio commissionRate;</span><br><span class="line">    <span class="keyword">private</span> Money commissin = Money.Zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">billCommissionFee</span><span class="params">(Money price)</span> </span>&#123;</span><br><span class="line">        commission = commission.plus(commissionRate.of(price));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 <code>Billing</code> 이란 객체를 도입해서 역할을 분리하자!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Billing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line">    <span class="keyword">private</span> Money commission = Money.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">billCommissionFee</span><span class="params">(Money commission)</span> </span>&#123;</span><br><span class="line">        commission = commission.plus(commission);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ratio commissionRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateCommissionFee</span><span class="params">(Money price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commissionRate.of(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이벤트 핸들러도 <code>shop</code>과 <code>billing</code>을 구분해서 협력하도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillShopWithOrderDeliveredEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DI 생략...</span></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">//비동기로 처리. 동기로도 가능</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 다른 트랜잭션으로 분리해서도 가능</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(OrderDeliveredEvent event)</span> </span>&#123;</span><br><span class="line">        Shop shop = shopRepository.findById(event.getShopId());</span><br><span class="line">        Billing billing = billingRepository.findById(event.getShopId());</span><br><span class="line">        billing.billCommissionFee(shop.calculateCommissionFee(event.getTotalPrice()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러면 패키지끼리 순환하지 않게 된다!<br><img src="/img/billingClassDiagram.png"></p><h3 id="패키지-의존성-사이클-제거하는-세가지-방법-정리"><a href="#패키지-의존성-사이클-제거하는-세가지-방법-정리" class="headerlink" title="패키지 의존성 사이클 제거하는 세가지 방법 정리!"></a>패키지 의존성 사이클 제거하는 세가지 방법 정리!</h3><ol><li>중간 객체 추가!</li><li>의존성 역전 시키기! -&gt; 새로운 서비스 객체를 사용할 때 생긴 의존성 제거에 유용했다.</li><li>새로운 패키지 추가! -&gt; 도메인 이벤트 퍼블리싱을 사용할 때 생긴 의존성 제거에 유용했다.</li></ol><h2 id="의존성과-시스템-분리"><a href="#의존성과-시스템-분리" class="headerlink" title="의존성과 시스템 분리"></a>의존성과 시스템 분리</h2><p>도메인 패키지 간의 의존성 사이클을 제거하면 각 패키지를 분리해서 배포할 수 있게된다!<br>그리고 이벤트는 메시징을 통해 외부 시스템으로 보내줄 수 있다!<br><img src="/img/%08systemDevidedWithEvent.png"></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>의존성 분리를 통해 설계 개선하기 1편 (우아한객체지향)</title>
      <link>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/</guid>
      <pubDate>Thu, 22 Dec 2022 12:41:03 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;의존성&quot;&gt;&lt;a href=&quot;#의존성&quot; class=&quot;headerlink&quot; title=&quot;의존성&quot;&gt;&lt;/a&gt;의존성&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/whatIsDependency.png&quot;&gt;&lt;br&gt;두 클래스 A, B가 있을 때 어느 한 쪽이 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="의존성"><a href="#의존성" class="headerlink" title="의존성"></a>의존성</h1><p><img src="/img/whatIsDependency.png"><br>두 클래스 A, B가 있을 때 어느 한 쪽이 변화가 생길 때 다른 한 쪽도 함께 변경될 가능성이 있는 경우를 의존성이 있다고 말한다.</p><blockquote><p>여기서 변경이란<br>클래스의 이름 변경, 메서드의 이름 변경, 메서드의 구현 변경 등을 의미한다.</p></blockquote><p>의존에는 클래스 간 의존성과 패키지 간 의존성이 존재한다.</p><h2 id="클래스-의존성의-종류"><a href="#클래스-의존성의-종류" class="headerlink" title="클래스 의존성의 종류"></a>클래스 의존성의 종류</h2><h3 id="연관-관계-Association"><a href="#연관-관계-Association" class="headerlink" title="연관 관계 Association"></a>연관 관계 Association</h3><p><img src="/img/whatIsAssociation.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A에서 B로 연결되어 있는 관계를 의미한다. 쉽게 말해 A에서 B의 객체 참조가 있는 경우를 의미한다. A라는 클래스에 B로 가는 영구적인 연결 통로가 생긴다.</p><h3 id="의존-관계-Dependency"><a href="#의존-관계-Dependency" class="headerlink" title="의존 관계 Dependency"></a>의존 관계 Dependency</h3><p><img src="/img/whatIsDependency.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">method</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드 상에서 인자 혹은 리턴 값으로 해당 타입을 사용하거나 메서드 안에서 해당 인스턴스를 생성하면 의존 관계이다. 이 관계는 해당 메서드를 사용할 때 일시적으로 맺어지는 관계이다. (영구적인 관계인 연관 관계와 다르다.)</p><h3 id="상속-관계-Inheritance"><a href="#상속-관계-Inheritance" class="headerlink" title="상속 관계 Inheritance"></a>상속 관계 Inheritance</h3><p><img src="/img/whatIsInheritance.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>상속 관계는 B 클래스의 구현을 그대로 가져와서 재사용하는 방식이다. 그래서 B 클래스의 구현이 변경되면 해당 구현을 사용하고 있던 A 클래스에 영향이 생긴다.</p><h3 id="실체화-관계-Realization"><a href="#실체화-관계-Realization" class="headerlink" title="실체화 관계 Realization"></a>실체화 관계 Realization</h3><p><img src="/img/whatIsRealization.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>실체화 관계는 인터페이스 B의 시그니처만 가져와서 사용하는 방식이다. 상속 관계와는 다르게 시그니처가 변경되지 않는 한 A 클래스에 영향이 생기지 않는다.</p><h2 id="패키지-의존성"><a href="#패키지-의존성" class="headerlink" title="패키지 의존성"></a>패키지 의존성</h2><p>패키지 의존성은 A 패키지의 클래스 중 어느 하나라도 B 패키지의 클래스에 의존하는 경우 A 패키지가 B 패키지에 의존함을 의미한다.</p><h1 id="좋은-설계를-위한-의존성-규칙"><a href="#좋은-설계를-위한-의존성-규칙" class="headerlink" title="좋은 설계를 위한 의존성 규칙"></a>좋은 설계를 위한 의존성 규칙</h1><h2 id="양방향-의존성을-피하라"><a href="#양방향-의존성을-피하라" class="headerlink" title="양방향 의존성을 피하라"></a>양방향 의존성을 피하라</h2><h3 id="양방향-Bi-Directional"><a href="#양방향-Bi-Directional" class="headerlink" title="양방향 Bi-Directional"></a>양방향 Bi-Directional</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b != <span class="keyword">null</span>) &#123; <span class="comment">// 동기화</span></span><br><span class="line">            <span class="keyword">this</span>.b.setA(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.b.setA(<span class="keyword">this</span>); <span class="comment">// 동기화</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123; <span class="comment">// 동기화</span></span><br><span class="line">            <span class="keyword">this</span>.a.setB(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.A = a;</span><br><span class="line">        <span class="keyword">this</span>.A.setB(<span class="keyword">this</span>); <span class="comment">// 동기화</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A와 B가 서로 의존한다는 의미는 A가 변할 때 B가 변할 수 있고, B가 변할 때 A가 변할 수 있다는 의미이다. 이런 경우 원래 이 두 클래스가 하나의 클래스로 묶어야 될 수 있다.</p><blockquote><p>양방향 의존 관계에서는 setter 메서드를 사용할 때 동기화 해줘야 한다.</p></blockquote><p>동기화를 왜 해줘야 하는 지 코드로 간략하게 알아보자.<br>만약 A와 B에서 주석으로 동기화라고 적혀 있는 코드가 없는 상태로 setter를 사용한다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="keyword">new</span> A();</span><br><span class="line">B b1 = <span class="keyword">new</span> B();</span><br><span class="line">B b2 = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// 1. 서로 양방향 의존하도록 설정.</span></span><br><span class="line">a1.setB(b1);</span><br><span class="line">b1.setA(a1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 이때 의존하는 인스턴스를 다른 인스턴스로 바꾸고 싶으면?</span></span><br><span class="line">a1.setB(b1); <span class="comment">// 이렇게 되면 b2는 a1에 연결되지 않은 상태다!!!! 그리고 심지어 b1은 아직 의존하고 있게 된다.</span></span><br></pre></td></tr></table></figure><p>이렇게 양방향은 고려해야 할 부분이 많고 예상하지 못한 버그가 발생할 수 있다.</p><h2 id="다중성이-적은-방향을-선택하라"><a href="#다중성이-적은-방향을-선택하라" class="headerlink" title="다중성이 적은 방향을 선택하라."></a>다중성이 적은 방향을 선택하라.</h2><p>즉 일대다 대신 다대일 관계를 선택하는 게 좋다. 일대다를 JPA를 사용하다보면 N+1 문제에서 큰 성능 저하를 일으키게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일대다 관계 (비추!)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;B&gt; bs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다대일 관계 (추천!)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="패키지-사이의-의존성-사이클을-제거하라"><a href="#패키지-사이의-의존성-사이클을-제거하라" class="headerlink" title="패키지 사이의 의존성 사이클을 제거하라"></a>패키지 사이의 의존성 사이클을 제거하라</h2><p>의존성 사이클은 여러 패키지의 의존성 방향이 결국 연결되는 것을 의미한다. 크게 보면 결국 양방향 의존인 셈이다. 패키지가 양방향 의존하게 되면 하나가 바뀌면 다같이 바뀌게 될 가능성이 존재한다는 의미이다. 즉 원래 같이 묶여야 될 패키지라는 의미일 수 있다.</p><p>구체적인 실습은 2편에서 해보자!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>커맨드와 액티브 오브젝트 패턴</title>
      <link>https://yangdongjue5510.github.io/2022/12/21/java/java-basic/design-pattern/commandAndActiveObjectPattern/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/21/java/java-basic/design-pattern/commandAndActiveObjectPattern/</guid>
      <pubDate>Wed, 21 Dec 2022 05:02:25 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;커맨드-패턴&quot;&gt;&lt;a href=&quot;#커맨드-패턴&quot; class=&quot;headerlink&quot; title=&quot;커맨드 패턴&quot;&gt;&lt;/a&gt;커맨드 패턴&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="커맨드-패턴"><a href="#커맨드-패턴" class="headerlink" title="커맨드 패턴"></a>커맨드 패턴</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/commandPatternUML.png"><br>여러 행동을 호출해야 하는 경우 여러 행동을 커맨드로 추상화하여 사용하는 쪽에서는 커맨드가 어떻게 행동하는 지 관심없이 사용하기만 하도록 구현하는 패턴이다.<br>이 패턴은 커맨드를 사용하는 쪽에서 커맨드를 실행하기 위해서 어떤 객체가 사용되는지 알아지 않아도 되는 장점이 있다. 커맨드 패턴은 명령의 개념을 캡슐화해서 시스템과 연결된 장치의 논리적인 상호 연결을 분리해낼 수 있다.</p><h2 id="물리적-분리"><a href="#물리적-분리" class="headerlink" title="물리적 분리"></a>물리적 분리</h2><p><img src="/img/commandPatternUML2.png"><br>커맨드 패턴을 사용하면 사용자에게서 데이터를 받는 코드와 그 데이터를 검증하고 작업을 하는 코드, 도메인 객체를 분리할 수 있다. 데이터를 받는 코드에서 커맨드의 실행 코드와 검증 코드와 물리적으로 분리 된다.</p><h2 id="시간적-분리"><a href="#시간적-분리" class="headerlink" title="시간적 분리"></a>시간적 분리</h2><p>사용자에게서 데이터를 입력받는 역할과 그 데이터를 검증하고 작업을 하는 코드를 물리적으로 분리할 수 있다고 했다. 이를 다르게 생각해보면 데이터를 입력받았다고 바로 검증과 실행을 하지 않아도 된다는 의미다. 즉 명령을 일단 다 생성해서 모아놓고 특정 시점에 몰아서 명령을 검증하고 실행할 수 있다는 의미이다.</p><h2 id="되돌리기"><a href="#되돌리기" class="headerlink" title="되돌리기"></a>되돌리기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>커맨드에 실행하는 메서드말고 되돌리기 메서드를 선언해놓으면 롤백 기능도 구현할 수 있다. 위처럼 인터페이스로 실행과 실행 취소 메서드를 선언해놓고 각 명령마다 실행과 실행 취소 로직을 구현해놓으면 된다.<br>직원 임금 관리 서비스에서 직원을 추가하는 명령이 있다고 할 때 실행시키는 메서드는 직원 객체를 생성하고 저장소에 저장하는 방식으로 구현된다. 실행 취소 메서드는 저장소에 해당 직원의 데이터를 제거하는 방식으로 구현할 수 있을 것이다.</p><h1 id="액티브-오브젝트-패턴"><a href="#액티브-오브젝트-패턴" class="headerlink" title="액티브 오브젝트 패턴"></a>액티브 오브젝트 패턴</h1><p>액티브 오브젝트 패턴은 커맨드 패턴의 응용된 버전으로 다중 제어 스레드 구현을 위해 등장했다.<br>액티브 오브젝트 패턴은 하나의 스레드로 멀티 스레드가 이벤트 방식으로 작동하는 것처럼 구현할 수 있어서 런타임 스택을 여러개 만들지 않아도 된다. 즉 멀티 스레드를 활용하고 메모리가 부족한 상황에서 사용할 만한 대안이다.</p><p>액티브 오브젝트 패턴은 커맨드를 모아두고 꺼내서 실행하는 엔진과 실행 시킬 커맨드, 마지막으로 실행 시킬 조건을 다루는 커맨드 이렇게 세가지로 구성된다.</p><h2 id="엔진"><a href="#엔진" class="headerlink" title="엔진"></a>엔진</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveObjectEngine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Command&gt; commands = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Command c)</span> </span>&#123;</span><br><span class="line">        commands.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!commands.isEmpty()) &#123;</span><br><span class="line">            commands.pop()</span><br><span class="line">                    .execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔진을 실행시키면 자신이 가진 모든 커맨드를 순차적으로 실행한다.</p><h2 id="실행-조건을-다루는-커맨드"><a href="#실행-조건을-다루는-커맨드" class="headerlink" title="실행 조건을 다루는 커맨드"></a>실행 조건을 다루는 커맨드</h2><p><code>특정 시간만큼 sleep하고 커맨드를 실행</code> 이라는 조건을 달성하기 위해 커맨드를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sleepMilliSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActiveObjectEngine engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Command wakeUpCommand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startedTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepCommand</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> sleepMilliSeconds, <span class="keyword">final</span> ActiveObjectEngine engine, <span class="keyword">final</span> Command wakeUpCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sleepMilliSeconds = sleepMilliSeconds;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.wakeUpCommand = wakeUpCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            startedTime = currentTime;</span><br><span class="line">            engine.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTime - startedTime &lt; sleepMilliSeconds) &#123;</span><br><span class="line">            engine.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        engine.add(wakeUpCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자신이 엔진에 의해 실행된 경우가 없다면 현재 시간을 시작 시각으로 기록하고 다시 엔진에 자신을 집어넣는다.<br>자신이 엔진에 의해 실행된 경우가 있으면 현재 시각과 시작 시각을 비교해서 커맨드 실행 조건에 달성했는 지 체크한다.<br>조건에 달성했다면 <code>wakeUpCommand</code> 즉 우리가 원래 실행하려고 했던 커맨드를 실핸한다.</p><h2 id="실행하려는-커맨드"><a href="#실행하려는-커맨드" class="headerlink" title="실행하려는 커맨드"></a>실행하려는 커맨드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTyper</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActiveObjectEngine engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> itsDelay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> itsChar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTyper</span><span class="params">(<span class="keyword">final</span> ActiveObjectEngine engine, <span class="keyword">final</span> <span class="keyword">long</span> itsDelay, <span class="keyword">final</span> <span class="keyword">char</span> itsChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.itsDelay = itsDelay;</span><br><span class="line">        <span class="keyword">this</span>.itsChar = itsChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.print(itsChar);</span><br><span class="line">        delayAndRepeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayAndRepeat</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        engine.add(<span class="keyword">new</span> SleepCommand(itsDelay, engine, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주어진 글자를 출력하고 특정 시간만큼 sleep 이후 다시 출력하는 커맨드이다.</p><p>마지막으로 이를 실행하는 코드를 통해 실제 결과물을 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ActiveObjectEngine ENGINE = <span class="keyword">new</span> ActiveObjectEngine();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">100</span>, <span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">500</span>, <span class="string">&#x27;5&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> DelayedTyper(ENGINE, <span class="number">700</span>, <span class="string">&#x27;7&#x27;</span>));</span><br><span class="line">        ENGINE.add(<span class="keyword">new</span> SleepCommand(<span class="number">20000</span>, ENGINE, () -&gt; System.exit(<span class="number">0</span>)));</span><br><span class="line">        ENGINE.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/design-pattern/">Design Pattern</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/21/java/java-basic/design-pattern/commandAndActiveObjectPattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Elastic Beanstalk와 Github Actions를 활용해서 CICD 무중단 배포 구현하기</title>
      <link>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/</guid>
      <pubDate>Wed, 14 Dec 2022 03:45:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Elastic-Beanstalk란&quot;&gt;&lt;a href=&quot;#Elastic-Beanstalk란&quot; class=&quot;headerlink&quot; title=&quot;Elastic Beanstalk란&quot;&gt;&lt;/a&gt;Elastic Beanstalk란&lt;/h1&gt;&lt;p&gt;AWS에서는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Elastic-Beanstalk란"><a href="#Elastic-Beanstalk란" class="headerlink" title="Elastic Beanstalk란"></a>Elastic Beanstalk란</h1><p>AWS에서는 인프라에 대한 지식이 없어도 배포 환경을 구축할 수 있는 Elastic Beanstalk(EB)를 제공한다. EB에 어플리케이션을 전달하면 EB에서 용량 프로비저닝, 로드 밸런싱, 조정, 어플리케이션 상태 모니터링을 자동으로 처리한다.</p><p>다음은 EB가 어떻게 어플리케이션을 관리하는 지 보여주는 워크플로우다.<br><img src="/img/EBflow.png" alt="EB workflow"></p><h2 id="Elastic-Beanstalk-구조"><a href="#Elastic-Beanstalk-구조" class="headerlink" title="Elastic Beanstalk 구조"></a>Elastic Beanstalk 구조</h2><p>EB는 여러 종류의 환경을 제공할 수 있다. 웹 서버 환경을 중점적으로 살펴보자.<br><img src="/img/ebWebServerEnv.png" alt="EB web server Env"><br>Auto Scaling Group에 여러 EC2 인스턴스들이 존재한다. 이 인스턴스에서 어플리케이션이 실행되는데 여기서 <code>HM</code>(호스트 매니저) 이라는 개념이 있다. <code>HM</code>는 어플리케이션의 로그를 S3에 개시하거나 서버 인스턴스의 상태를 보고하는 역할을 한다.</p><p>Auto Scaling Group의 EC2들 앞에는 Elastic Load Balancer가 로드 밸런싱을 한다. EB의 ELB는 CNAME(URL)을 가진다. 그리고 EB 환경도 CNAME을 가진다. 이때 환경의 CNAME은 ELB의 CNAME의 별칭으로 지정된다.</p><h1 id="Elastic-Beanstalk-직접-구성해보기"><a href="#Elastic-Beanstalk-직접-구성해보기" class="headerlink" title="Elastic Beanstalk 직접 구성해보기"></a>Elastic Beanstalk 직접 구성해보기</h1><p>EB를 생성할 때 중요한 몇가지 위주로 설명하겠다.</p><h2 id="플랫폼-설정하기-및-추가-옵션-구성"><a href="#플랫폼-설정하기-및-추가-옵션-구성" class="headerlink" title="플랫폼 설정하기 및 추가 옵션 구성"></a>플랫폼 설정하기 및 추가 옵션 구성</h2><p>AWS EB 콘솔에서 새 어플리케이션 만들기를 선택하면 어플리케이션이 어떤 플랫폼인지 그리고 그 플랫폼을 어떤 운영체제에서 실행할지를 정해야 한다.<br>필자의 경우는 Spring Boot 어플리케이션이므로 Java 플랫폼에 Linux 2를 설정했다. 즉 EB 환경의 EC2가 Linux 2 기반으로 생성된다는 의미이다.</p><p>그리고 이때 중요한 건 바로 애플리케이션 생성을 누르지 말고 무중단 배포를 위해 <strong>추가 옵션 구성</strong>을 선택한다.<br><img src="/img/EBPlatformSetting.png" alt="플랫폼 설정화면"></p><p>추가 옵션 구성을 클릭하면 여러가지 설정 가능한 옵션이 나온다. 이때 사전 설정에서 <code>사용자 지정 구성</code>으로 우리 상황에 맞도록 구성할 수 있도록 해보자.<br><img src="/img/EBPreSetting.png" alt="추가 옵션 구성 - 사전 설정"></p><h2 id="인스턴스-보안그룹-설정하기"><a href="#인스턴스-보안그룹-설정하기" class="headerlink" title="인스턴스 보안그룹 설정하기"></a>인스턴스 보안그룹 설정하기</h2><p>Auto Scaling Group의 인스턴스들이 적용되는 보안그룹을 반드시 설정해줘야 한다. 그렇지 않으면 외부에서 인스턴스에 SSH로 접근해서 의도하지 않은 작업을 진행할 수 있다.<br><img src="/img/EBInstanceSG.png" alt="인스턴스 - EC2 인스턴스 보안 그룹"><br>F12-PROD 보안그룹은 80 포트와 8080 포트를 모든 IP가 접근할 수 있도록 했고, SSH는 개발자 IP만 접근 가능하도록 인바운드 규칙을 적용했다.<br>ec2-rds-1 보안그룹은 mysql 포트인 3306 포트를 아웃바운드 규칙으로 적용되어 있다.</p><h2 id="Auto-Scaling-Group-및-로드-밸런싱-설정하기"><a href="#Auto-Scaling-Group-및-로드-밸런싱-설정하기" class="headerlink" title="Auto Scaling Group 및 로드 밸런싱 설정하기"></a>Auto Scaling Group 및 로드 밸런싱 설정하기</h2><p>먼저 Auto Scaling Group에 어떤 인스턴스를 몇 개나 수용할 지를 정해야 한다. 우리는 프리티어 한도 내에서 인프라를 구축해야 하기 때문에 인스턴스를 한 개만 사용하도록 했다.<br><img src="/img/EBAutoScalingGroupSetting.png" alt="용량 - Auto Scaling 그룹"></p><p>다음으로 로드 밸런서를 설정해야 한다. 로드 밸런서는 크게 Classic Load Balancer(ELB)와 Application Load Balancer(ALB)를 선택할 수 있다. ELB가 먼저 출시되어 많은 참고 자료가 존재하지만 갑작스러운 트래픽이 발생할 경우에 대응이 좋지 않다고 한다. 그래서 우리는 ALB를 선택했다.</p><p>그리고 추가로 프론트엔드에서 8080포트로 요청하는 상황이라 로드 밸런서의 리스너를 8080포트도 열어줬다.<br><img src="/img/EBALBSetting.png" alt="로드 밸런서"></p><h2 id="무중단-배포-설정"><a href="#무중단-배포-설정" class="headerlink" title="무중단 배포 설정"></a>무중단 배포 설정</h2><p>이제 EB에서 새 버전을 배포하려고 할 때 무중단 배포가 되도록 설정해야 한다. 롤링 업데이트와 배포 수정에 가서 애플리케이션 배포 방식을 정할 수 있다. 우리는 추가 배치를 사용한 롤링 방식을 선택했다. 만약 새 버전이 배포되면 새 EC2 하나를 만들어서 새 버전을 배포하고 배포가 완료되면 로드 밸런서 설정을 바꾸고 기존의 Auto Scaling은 폐기하는 방식으로 운영된다. 다만 이 방식은 배포가 되고나면 롤백하지 못한다.<br><img src="/img/EBDeploySetting.png" alt="롤링 업데이트와 배포 수정"></p><h2 id="EC2-키-페어-설정"><a href="#EC2-키-페어-설정" class="headerlink" title="EC2 키 페어 설정"></a>EC2 키 페어 설정</h2><p>EB에서 생성된 EC2 인스턴스에 접근할  수 있는 PEM 키를 설정해 줄 수 있다. 우리는 기존에 만들어놨던 PEM 키를 활용했다.<br><img src="/img/EBSecuritySetting.png" alt="보안 수정"></p><p>이제 EB 설정은 어느정도 끝났으니 EB를 생성하면 된다.</p><h1 id="EB-어플리케이션-구성"><a href="#EB-어플리케이션-구성" class="headerlink" title="EB 어플리케이션 구성"></a>EB 어플리케이션 구성</h1><p>EB 어플리케이션을 실행할 때 인스턴스에서 설정해줘야 하는 것들이 있을 수 있다. 예를 들어 EC2의 타임존 설정이나 리버스 프록시 설정이 필요할 수 있다. 그 설정을 EB에서는 <code>.ebextensions</code> 디렉토리, <code>.platform</code> 디렉토리로 설정해줄 수 있다.</p><h2 id="EC2-리버스-프록시-설정하기"><a href="#EC2-리버스-프록시-설정하기" class="headerlink" title="EC2 리버스 프록시 설정하기"></a>EC2 리버스 프록시 설정하기</h2><p>로드 밸런서가 보내는 트래픽을 EC2에서 애플리케이션으로 전달 할 때 리버시 프록시를 설정해줄 수 있다. 우리가 사용하는 Linux 2 플랫폼은 Nginx로 리버스 프록시를 구현할 수 있다. 이때 <code>.platform/nginx/nginx.conf</code> 파일을 통해서 EC2의 Nginx의 설정을 오버라이딩 할 수 있다. <code>.platform/nginx/conf.d/&#123;설정파일이름&#125;.conf</code>에 파일을 만들면 기존의 Nginx 설정 파일에 설정을 추가하는 방식으로 구현할 수 있다.</p><p>우리는 <code>.platform/nginx/nginx.conf</code> 파일을 프로젝트에 추가해서 Nginx 설정을 오버라이딩 하는 방식으로 구현했다. <code>/</code>로 오는 모든 요청은 로컬의 8080포트로 보내도록 구현했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user                    nginx;</span><br><span class="line">error_log               /var/log/nginx/error.log warn;</span><br><span class="line">pid                     /var/run/nginx.pid;</span><br><span class="line">worker_processes        auto;</span><br><span class="line">worker_rlimit_nofile    33282;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">  log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">  include       conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">  map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">      default     &quot;upgrade&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  upstream springboot &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    keepalive 1024;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">      listen        80 default_server;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          proxy_pass          http://springboot;</span><br><span class="line">          proxy_http_version  1.1;</span><br><span class="line">          proxy_set_header    Connection          $connection_upgrade;</span><br><span class="line">          proxy_set_header    Upgrade             $http_upgrade;</span><br><span class="line"></span><br><span class="line">          proxy_set_header    Host                $host;</span><br><span class="line">          proxy_set_header    X-Real-IP           $remote_addr;</span><br><span class="line">          proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      access_log    /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">      client_header_timeout 60;</span><br><span class="line">      client_body_timeout   60;</span><br><span class="line">      keepalive_timeout     60;</span><br><span class="line">      gzip                  off;</span><br><span class="line">      gzip_comp_level       4;</span><br><span class="line"></span><br><span class="line">      # Include the Elastic Beanstalk generated locations</span><br><span class="line">      include conf.d/elasticbeanstalk/healthd.conf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EB-환경-커스텀하기"><a href="#EB-환경-커스텀하기" class="headerlink" title="EB 환경 커스텀하기"></a>EB 환경 커스텀하기</h2><p>EB에서 가동 중인 EC2에 파일을 추가한다던지 커맨드를 실행하고 싶은 경우 <code>.ebextensions</code> 디렉토리에 config 확장자로 파일을 추가하면 된다.</p><p>우리는 JAR 배포 스크립트와 로깅 설정파일을 생성하고 EC2 타임존 설정 커맨드를 실행하도록 구현해보자<br><code>.ebextension/00-makeFiles.config</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">files:</span></span><br><span class="line">    <span class="string">&quot;/sbin/appstart&quot;</span> <span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            #!/usr/bin/env bash</span></span><br><span class="line"><span class="string">            JAR_PATH=/var/app/current/application.jar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="comment"># run app</span></span><br><span class="line">            <span class="string">killall</span> <span class="string">java</span></span><br><span class="line">            <span class="string">java</span> <span class="string">-Dfile.encoding=UTF-8</span> <span class="string">-Dspring.profiles.active=main</span> <span class="string">-jar</span> <span class="string">$JAR_PATH</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/taillogs.d/applogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          /var/app/current/logs/log/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/applogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        /var/app/current/logs/log/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/taillogs.d/dblogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          /var/app/current/logs/db/*.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">&quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/dblogs.conf&quot;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;000755&quot;</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">webapp</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">/var/app/current/logs/db/*.log</span></span><br></pre></td></tr></table></figure><p><code>.ebextension/01-setupKSTTimezone.config</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">commands:</span></span><br><span class="line">  <span class="attr">set_time_zone:</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">ln</span> <span class="string">-f</span> <span class="string">-s</span> <span class="string">/usr/share/zoneinfo/Asia/Seoul</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure><h2 id="Procfile을-사용해서-애플리케이션-프로세스-구성"><a href="#Procfile을-사용해서-애플리케이션-프로세스-구성" class="headerlink" title="Procfile을 사용해서 애플리케이션 프로세스 구성"></a>Procfile을 사용해서 애플리케이션 프로세스 구성</h2><p>애플리케이션이 실행하기 위한 커맨드를 모은 파일이다. Procfile의 프로세스는 계속 실행 될 것으로 기대하고 EB에서 해당 프로세스를 모니터링하고 종료된 프로세스는 재시작한다.</p><p><code>Procfile</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span> <span class="string">appstart</span></span><br></pre></td></tr></table></figure><h1 id="Github-Actions로-CICD-구축하기"><a href="#Github-Actions로-CICD-구축하기" class="headerlink" title="Github Actions로 CICD 구축하기"></a>Github Actions로 CICD 구축하기</h1><h2 id="CI-스크립트-작성"><a href="#CI-스크립트-작성" class="headerlink" title="CI 스크립트 작성"></a>CI 스크립트 작성</h2><p>사실 CI 스크립트는 매우 간단하다. Github Actions에 대한 지식이 있으면 구현할 수 있다.</p><p><code>.github/workflows/backend.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;backend/**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">run:</span></span><br><span class="line">    <span class="attr">working-directory:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gradle</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">comments</span> <span class="string">to</span> <span class="string">a</span> <span class="string">pull</span> <span class="string">request</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">mikepenz/action-junit-report@v3</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">always()</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">report_paths:</span> <span class="string">backend/build/test-results/test/TEST-*.xml</span></span><br></pre></td></tr></table></figure><h2 id="IAM-인증키-발급받아-Github-Actions에서-사용하기"><a href="#IAM-인증키-발급받아-Github-Actions에서-사용하기" class="headerlink" title="IAM 인증키 발급받아 Github Actions에서 사용하기"></a>IAM 인증키 발급받아 Github Actions에서 사용하기</h2><p>외부에서 AWS 리소스에 접근하려면 IAM을 통해 액세스 키가 필요하다. AWS IAM에 가서 사용자를 추가해주자.<br><img src="/img/IAMAddUser.png" alt="IAM 사용자 추가"></p><p>해당 IAM 사용자에게 EB에 접근할 수 있는 권한을 설정해주면 된다.<br><img src="/img/IAMAuthority.png" alt="IAM 권한 추가"></p><p>이렇게 IAM 사용자를 만들면 액세스 키와 시크릿키가 생성된다. 이 두 키를 깃허브 레포지토리에 액션 시크릿으로 추가해준다. 필자는 액세스 키는 <code>AWS_ACCESS_KEY_ID</code>, 시크릿 키는 <code>AWS_SECRET_ACCESS_KEY</code>로 설정했다.<br><img src="/img/githubActionSecret.png" alt="github Action secrets"></p><h2 id="CD-스크립트-작성"><a href="#CD-스크립트-작성" class="headerlink" title="CD 스크립트 작성"></a>CD 스크립트 작성</h2><p>우리는 beanstalk-deploy라는 Github Actions 플러그인을 사용해서 배포 스크립트를 작성해본다.<br>스크립트에 주석으로 각 단계가 어떤 의미 인지 기록해두었다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span> <span class="string">eb</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">run:</span></span><br><span class="line">    <span class="attr">working-directory:</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">        <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="string">&#x27;true&#x27;</span> <span class="comment"># 서브 모듈이 존재하는 경우 반드시 넣어준다.</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Gradle</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">gradle/gradle-build-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">cache-read-only:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="type">!=</span> <span class="string">&#x27;refs/heads/main&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Execute</span> <span class="string">Gradle</span> <span class="string">build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">bootJar</span></span><br><span class="line">          </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">current</span> <span class="string">time</span> <span class="comment"># 현재 시각을 기록해둔다.</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="number">1466587594</span><span class="string">/get-current-time@v2.0.2</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">current-time</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">YYYY-MM-DDTHH-mm-ss</span></span><br><span class="line">        <span class="attr">utcOffset:</span> <span class="string">&quot;+09:00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">deployment</span> <span class="string">package</span> <span class="comment"># JAR 파일과 함께 이전에 만들었던 설정파일을 함께 zip파일로 압축한다.</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p deploy</span></span><br><span class="line"><span class="string">        cp build/libs/f12-0.0.1-SNAPSHOT.jar deploy/application.jar</span></span><br><span class="line"><span class="string">        cp Procfile deploy/Procfile</span></span><br><span class="line"><span class="string">        cp -r .ebextensions deploy/.ebextensions</span></span><br><span class="line"><span class="string">        cp -r .platform deploy/.platform</span></span><br><span class="line"><span class="string">        cd deploy &amp;&amp; zip -r deploy.zip .</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">EB</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">einaregilsson/beanstalk-deploy@v21</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">aws_access_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.AWS_ACCESS_KEY_ID</span> <span class="string">&#125;&#125;</span> <span class="comment"># IAM</span></span><br><span class="line">        <span class="attr">aws_secret_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.AWS_SECRET_ACCESS_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># IAM</span></span><br><span class="line">        <span class="attr">application_name:</span> <span class="string">f12-prod-backend</span></span><br><span class="line">        <span class="attr">environment_name:</span> <span class="string">F12prodbackend-env-2</span></span><br><span class="line">        <span class="attr">version_label:</span> <span class="string">github-action-$&#123;&#123;steps.current-time.outputs.formattedTime&#125;&#125;</span> <span class="comment"># 버전명을 아까 기록한 시간을 토대로 구분하게 했다.</span></span><br><span class="line">        <span class="attr">region:</span> <span class="string">ap-northeast-2</span></span><br><span class="line">        <span class="attr">deployment_package:</span> <span class="string">backend/deploy/deploy.zip</span></span><br><span class="line">        <span class="attr">wait_for_environment_recovery:</span> <span class="number">180</span> <span class="comment"># 배포가 Green으로 돌아오는 시간을 고려해 환경 회복 시간을 180초로 하였다.</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">comments</span> <span class="string">to</span> <span class="string">a</span> <span class="string">pull</span> <span class="string">request</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">mikepenz/action-junit-report@v3</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">always()</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">          <span class="attr">report_paths:</span> <span class="string">backend/build/test-results/test/TEST-*.xml</span></span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html</a><br><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts-webserver.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts-webserver.html</a><br><a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/platforms-linux-extend.html">https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/platforms-linux-extend.html</a><br><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.html">https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.html</a><br><a href="https://techblog.woowahan.com/2539/">https://techblog.woowahan.com/2539/</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS의 Blue-Green 배포 구현 방법 알아보기</title>
      <link>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/</link>
      <guid>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/</guid>
      <pubDate>Tue, 13 Dec 2022 09:55:21 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제-배경&quot;&gt;&lt;a href=&quot;#문제-배경&quot; class=&quot;headerlink&quot; title=&quot;문제 배경&quot;&gt;&lt;/a&gt;문제 배경&lt;/h1&gt;&lt;p&gt;우아한테크코스에서 프로젝트를 진행할 때는 우아한테크코스에 AWS 계정을 제공해줘서 EC2를 비용 걱정없이</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제-배경"><a href="#문제-배경" class="headerlink" title="문제 배경"></a>문제 배경</h1><p>우아한테크코스에서 프로젝트를 진행할 때는 우아한테크코스에 AWS 계정을 제공해줘서 EC2를 비용 걱정없이 갯수 상관없이 사용할 수 있었다. 하지만 우아한테크코스를 수료하고 나서는 AWS 계정 제공이 되지 않아서 팀원들이 자체 AWS 계정을 만들어서 인프라를 구축해야 했다.</p><p>이때 AWS에서는 프리티어로 RDS 인스턴스 한 개와 EC2 인스턴스 한 개를 제공해주는 점을 활용해서 최대한 비용을 줄일 수 있다.<br>하지만 기존 프로젝트는 CD와 무중단 배포를 위해 젠킨스를 EC2로 띄워서 구현했다. 그리고 Nginx를 따로 EC2로 띄워서 리버스 프록시 및 로드밸런싱 기능을 할 수 있도록 구축했다. 그래서 하나의 EC2로는 기존의 인프라 구조를 구현하기 어렵다.</p><h1 id="AWS-무중단-배포를-구현하는-여러-방법들"><a href="#AWS-무중단-배포를-구현하는-여러-방법들" class="headerlink" title="AWS 무중단 배포를 구현하는 여러 방법들"></a>AWS 무중단 배포를 구현하는 여러 방법들</h1><p>기존에는 젠킨스의 스크립트로 Nginx를 조절하는 방식으로 우리가 직접 Blue-Green 무중단 배포를 구현하는 방식이었다.<br>하지만 EC2 사용 갯수가 제한된 상황이기 때문에 AWS에서 제공하는 Blue-Green 무중단 배포 방법들을 참고해서 문제를 해결해보자.</p><h2 id="Route-53으로-DNS-라우팅-업데이트"><a href="#Route-53으로-DNS-라우팅-업데이트" class="headerlink" title="Route 53으로 DNS 라우팅 업데이트"></a>Route 53으로 DNS 라우팅 업데이트</h2><p>AWS의 DNS 서비스인 Route 53을 활용해서 무중단 배포를 구현할 수 있다.</p><p><img src="/img/EBGADeploy-1.png" alt="클래식DNS패턴"></p><p>다음과 같은 가중분포의 경우는 점진적으로 Green 환경으로 트래픽을 분산시킬 수 있다. 트래픽의 일부를 새로운 환경에서 처리해보도록 하는 카나리아 배포를 구현할 수 있다. ELB를 사용하면 Green 환경이 점차적으로 전체 프로덕션 부하를 감당하도록 점진적으로 스케일 아웃 할 수 있다. 다만 ELB에서 스케일 아웃은 즉시 이뤄지지 않으니 스케일 아웃이 잘 작동하는 지 모니터링하고 문제를 감지할 수 있도록 구현하는 게 중요하다.</p><p><img src="/img/EBGADeploy-2.png" alt="클래식DNS패턴"></p><p>Green 환경에서 문제가 발견되면 Route 53의 DNS 레코드를 롤백하는 방식으로 Blue 환경으로 롤백시킨다. 하지만 DNS 라우팅은 DNS TTL(클라이언트가 DNS 쿼리를 어느 시간만큼 캐시)를 고려해야 하고,  심지어는 클라이언트에 따라서는 특정 세션이 이전 환경에 연결되어 있는 경우가 존재할 수 있다.</p><h2 id="Elastic-Load-Balancer-뒤에서-Auto-Scaling-그룹-교체"><a href="#Elastic-Load-Balancer-뒤에서-Auto-Scaling-그룹-교체" class="headerlink" title="Elastic Load Balancer 뒤에서 Auto Scaling 그룹 교체"></a>Elastic Load Balancer 뒤에서 Auto Scaling 그룹 교체</h2><p>DNS 라우팅 업데이트를 활용한 방법이 복잡하다면 ELB와 Auto Scaling 그룹을 활용해서 Blue-Green 배포를 구현할 수 있다.</p><p><img src="/img/EBGADeploy-3.png" alt="Auto Scaling 그룹 바꾸기"></p><p>다음과 같이 Blue 환경을 대기 상태로 만들어 놓고 유사 시에 빠르게 이전 버전으로 롤백할 수 있게 구현할 수도 있다. 만약 그럴 필요가 없는 경우는 이전 Auto Scaling 그룹을 폐기하면 된다.</p><p><img src="/img/EBDGDeploy-4.png" alt="Auto Scaling 그룹 대기 및 폐기"></p><p>이 방식은 DNS 방식만큼 세분하게 구현할 수는 없지만 DNS가 복잡하다면 도입해볼만 하다.</p><h2 id="Elastic-Beanstalk-애플리케이션-환경-교체"><a href="#Elastic-Beanstalk-애플리케이션-환경-교체" class="headerlink" title="Elastic Beanstalk 애플리케이션 환경 교체"></a>Elastic Beanstalk 애플리케이션 환경 교체</h2><p>EB를 활용하면 인프라에 대한 지식이 많지 않아도 쉽게 애플리케이션을 배포할 수 있다. 배포하려는 어플리케이션 번들과 어플리케이션 버전, 멏 가지 정보를 제공하면 EB가 해당 정보를 기반으로 어플리케이션을 배포하고 어플리케이션에 액세스할 수 있는 URL을 제공한다.</p><p><img src="/img/EBGADeploy-5.png" alt="EB 배포 환경"></p><p>EB는 Auto Scaling 그룹을 추가하는 방식이나 일부 인스턴스를 업데이트하는 방식으로 하나의 환경 안에서 롤링 방식으로 무중단 배포를 구현할 수 있다.</p><p><img src="/img/prepare-green-elastic.png" alt="EB Blue-Green 배포"><br>EB를 활용해서 Blue-Green 배포를 할 수도 있다. 배포되고 있던 환경과 동일한 환경을 만들고 해당 환경을 새 버전 어플리케이션으로 교체한 다음 새로운 환경의 URL을 DNS에서 업데이트 하는 방식으로 설계할 수 있다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://docs.aws.amazon.com/whitepapers/latest/blue-green-deployments/implementation-techniques.html">https://docs.aws.amazon.com/whitepapers/latest/blue-green-deployments/implementation-techniques.html</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/infra/">Infra</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java11의 HttpClient로 서버에서 다른 API로 요청 보내기</title>
      <link>https://yangdongjue5510.github.io/2022/10/26/java/woowa-tech-course/howToUseHttpClient/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/26/java/woowa-tech-course/howToUseHttpClient/</guid>
      <pubDate>Wed, 26 Oct 2022 14:47:05 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;도입-배경&quot;&gt;&lt;a href=&quot;#도입-배경&quot; class=&quot;headerlink&quot; title=&quot;도입 배경&quot;&gt;&lt;/a&gt;도입 배경&lt;/h2&gt;&lt;p&gt;Github Oauth를 통해 인증인가를 구현하던 과정에서 깃허브에서 발급된 코드를 통해 Github A</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h2><p>Github Oauth를 통해 인증인가를 구현하던 과정에서 깃허브에서 발급된 코드를 통해 Github API에 Github Access Token을 발급 요청을 보내야했다. 그리고 발급된 Github Access Token을 통해 해당 사용자의 정보를 요청해야 했다.</p><h2 id="선택-가능한-방법들"><a href="#선택-가능한-방법들" class="headerlink" title="선택 가능한 방법들"></a>선택 가능한 방법들</h2><p>서버에서 HTTP 요청을 보낼 수 있는 방법은 여러가지가 있다.</p><ol><li>HTTPClient</li><li>RestTemplate</li><li>WebClient</li></ol><p>간단하게 세가지 방법을 비교하자면 다음과 같다.</p><table><thead><tr><th></th><th>HttpClient</th><th>RestTemplate</th><th>WebClient</th></tr></thead><tbody><tr><td>논블락킹 방식 제공 여부</td><td>제공</td><td>X (블락킹 방식)</td><td>제공</td></tr><tr><td>비동기 방식 제공 여부</td><td>제공</td><td>X (동기 방식)</td><td>제공</td></tr><tr><td>필요한 의존성</td><td>없음(Java 11에 포함)</td><td>spring-boot-starter-web에 포함</td><td>webFlux에 포함</td></tr></tbody></table><p>스프링 부트를 활용해서 프로젝트를 하는 경우 RestTemplate를 사용하는 경우가 많다.</p><p>하지만 스프링 공식문서의 RestTemplate 설명을 보면 작은 버그 수정만 앞으로 진행되고 큰 개선은 진행되지 않을 것이니 WebClient를 사용할 것을 권장한다.<br>(<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html</a>)</p><p>하지만 WebClient를 사용하기 위해서는 webFlux를 의존성에 추가해줘야 한다.</p><p>webFlux는 리액티브 프로그래밍을 스프링에서 제공하기 위한 모듈이다.</p><p>현재 우리 프로젝트는 스프링 MVC 기반 블락킹 동기 기반 어플리케이션인데 WebClient를 사용하기 위해 리액티브 프로그래밍을 지원하는 모듈을 추가해주는 것은 지나치다고 생각했다.</p><p>반면 HttpClient는 Java 11에 포함되어 있기 때문에 자바 버전만 지원된다면 다른 의존성을 추가해주지 않아도 된다.</p><p>그래서 우리 프로젝트에는 HttpClient를 사용하기로 했다.</p><h2 id="HttpClient-간단한-사용법"><a href="#HttpClient-간단한-사용법" class="headerlink" title="HttpClient 간단한 사용법"></a>HttpClient 간단한 사용법</h2><h3 id="동기-방식으로-GET-POST-요청-보내는-예시"><a href="#동기-방식으로-GET-POST-요청-보내는-예시" class="headerlink" title="동기 방식으로 GET, POST 요청 보내는 예시"></a>동기 방식으로 GET, POST 요청 보내는 예시</h3><p>먼저 외부 API 역할을 하게 될 컨트롤러를 간단하게 구현해보자.</p><p>이를 위해서는 HttpCliet를 실행하는 프로젝트와 외부 API 역할을 할 스프링 부트 프로그램을 서로 다른 프로젝트로 분리해서 구현하기로 한다.</p><h4 id="초간단-컨트롤러"><a href="#초간단-컨트롤러" class="headerlink" title="초간단 컨트롤러"></a>초간단 컨트롤러</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sync&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">syncGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;동기 GET 요청 처리 성공!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sync&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">syncPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;동기 POST 요청 처리 성공!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 초간단 컨트롤러의 프로젝트를 로컬에서 구동시킨다.<br>이제 <a href="http://localhost:8080을">http://localhost:8080을</a> 기본으로 작동한다.</p><h4 id="HttpClient를-활용한-HttpClientExample-구현"><a href="#HttpClient를-활용한-HttpClientExample-구현" class="headerlink" title="HttpClient를 활용한 HttpClientExample 구현"></a>HttpClient를 활용한 HttpClientExample 구현</h4><p>이제 외부 API에 요청을 보내는 HttpClient를 구현해보자.<br>일단 동기 방식으로 요청을 처리하는 간단한 예시를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientSyncExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HttpClientSyncExample.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">            .version(Version.HTTP_2)</span><br><span class="line">            .followRedirects(Redirect.NORMAL)</span><br><span class="line">            .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse&lt;String&gt; <span class="title">requestSyncGetApi</span><span class="params">(<span class="keyword">final</span> String uri)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = HttpRequest.newBuilder(URI.create(uri))</span><br><span class="line">                .GET()</span><br><span class="line">                .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString());</span><br><span class="line">        validateSuccess(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">validateSuccess</span><span class="params">(<span class="keyword">final</span> HttpResponse&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HttpStatus status = HttpStatus.resolve(response.statusCode());</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span> || status.isError()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;URI: &#123;&#125;, STATUS: &#123;&#125;&quot;</span>, response.uri(), response.statusCode());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;요청 처리 실패&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;URI: &#123;&#125;, STATUS: &#123;&#125;, BODY : &#123;&#125;, &quot;</span>, response.uri(), response.statusCode(), response.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse&lt;String&gt; <span class="title">requestSyncPostApi</span><span class="params">(<span class="keyword">final</span> String uri, <span class="keyword">final</span> Object requestBody)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String requestBodyString = objectMapper.writeValueAsString(requestBody);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = HttpRequest.newBuilder(URI.create(uri))</span><br><span class="line">                .POST(BodyPublishers.ofString(requestBodyString))</span><br><span class="line">                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString());</span><br><span class="line">        validateSuccess(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpClient 객체를 만들어 놓고, 필요할 때마다 HttpRequest를 만들어서 HttpClient 객체에 send 메서드를 통해 요청을 보낸다.</p><p>그리고 POST 요청을 보낼 때는 Body 값을 Object Mapper로 객체를 문자열로 만들어서 보내줘야 한다.</p><h4 id="테스트-코드로-작동-확인하기"><a href="#테스트-코드로-작동-확인하기" class="headerlink" title="테스트 코드로 작동 확인하기"></a>테스트 코드로 작동 확인하기</h4><p>이제 테스트 메서드 몇 개를 만들어서 동작을 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpClientSyncExample httpClientSyncExample = <span class="keyword">new</span> HttpClientSyncExample();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;동기 방식으로 GET 요청을 보낸다.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">final</span> String uri = <span class="string">&quot;http://localhost:8080/test/sync&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncGetApi(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(response.statusCode()).isEqualTo(<span class="number">200</span>),</span><br><span class="line">                () -&gt; assertThat(response.body()).isEqualTo(<span class="string">&quot;동기 GET 요청 처리 성공!&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;동기 방식으로 POST 요청을 보낸다.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncPost</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">final</span> String uri = <span class="string">&quot;http://localhost:8080/test/sync&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String requestBody = <span class="string">&quot;bodyValue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">final</span> HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncPostApi(uri, requestBody);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertThat(response.statusCode()).isEqualTo(<span class="number">200</span>),</span><br><span class="line">                () -&gt; assertThat(response.body()).isEqualTo(<span class="string">&quot;동기 POST 요청 처리 성공!&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 실행해보면 다음과 같이 모두 잘 작동하는 것을 볼 수 있다.</p><p><img src="/img/howToUseHttpClient-1.png"></p><p>참고</p><p><a href="https://www.baeldung.com/java-9-http-client">https://www.baeldung.com/java-9-http-client</a><br><a href="https://golb.hplar.ch/2019/01/java-11-http-client.html">https://golb.hplar.ch/2019/01/java-11-http-client.html</a><br><a href="https://github.com/yangdongjue5510/http-client">https://github.com/yangdongjue5510/http-client</a></p><p>Java 11의 HttpClient 사용법을 배울 수 있는 레포지토리.<br>동기 방식 뿐만 아니라 비동기 방식도 학습 테스트를 통해 배울 수 있도록 구현해놨다.<br>github.com](<a href="https://github.com/yangdongjue5510/http-client">https://github.com/yangdongjue5510/http-client</a>)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/26/java/woowa-tech-course/howToUseHttpClient/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RestDocs의 Custom Snippet으로 에러코드 쉽게 문서화하기</title>
      <link>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</guid>
      <pubDate>Tue, 25 Oct 2022 08:21:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h1&gt;&lt;p&gt;RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.&lt;br&gt;우리 프로젝트에서는 정상 요청 흐름을 중점으로 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.<br>우리 프로젝트에서는 정상 요청 흐름을 중점으로 API 문서화했다.<br>하지만 해당 API에서 발생 가능한 애외 상황에 대한 응답도 정리해줘야 했다.<br>그래서 우리는 백엔드 단에서 발생하는 예외에 매핑되는 예외 코드를 만들어서 예외 상황 발생 시 해당 예외 코드를 바디에 담아서 반환하도록 해서 대해 API 사용자들이 어떤 문제가 발생해는 지 알 수 있도록 했다.<br>문제는 특정 API에 해당하는 예외 코드들을 어떻게 문서화하는 지 였다.</p><h2 id="코드-예시"><a href="#코드-예시" class="headerlink" title="코드 예시"></a>코드 예시</h2><p>restDocs 환경 설정은 생략했다.</p><h3 id="예시-컨트롤러"><a href="#예시-컨트롤러" class="headerlink" title="예시 컨트롤러"></a>예시 컨트롤러</h3><p>만약 id값이 1보다 작으면 예외를 반환하는 아주 간단한 예시 컨트롤러이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/simple/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">getSimple</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;id값은 무조건 1보다 커야 합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String body = String.format(<span class="string">&quot;simple id is %d&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-에러코드"><a href="#예시-에러코드" class="headerlink" title="예시 에러코드"></a>예시 에러코드</h3><p>사용자에게 알려줄 예외 코드를 enum으로 관리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ILLEGAL_ARGUMENT(<span class="string">&quot;40000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    ErrorCode(<span class="keyword">final</span> String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="예시-테스트"><a href="#예시-테스트" class="headerlink" title="예시 테스트"></a>예시 테스트</h3><p>성공 사례를 확인하는 예시 테스트이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-adoc-파일"><a href="#예시-adoc-파일" class="headerlink" title="예시 adoc 파일"></a>예시 adoc 파일</h3><p>새로운 adoc 파일을 만들어서 다음과 같이 생성된 스니펫을 넣어주고 테스트를 실행시켜서 성공하면 스니펫이 적용된 html을 얻을 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="/img/restDocsErrorCode-1.png"></p><h2 id="에러-코드를-어떻게-문서화할까"><a href="#에러-코드를-어떻게-문서화할까" class="headerlink" title="에러 코드를 어떻게 문서화할까?"></a>에러 코드를 어떻게 문서화할까?</h2><p>초창기 프로젝트에서 각 API에 에러코드를 명시했던 방법은 매우 간단하다.<br>그냥 adoc파일에 에러코드를 같이 적어주는 것이다.(…)</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>40000 (예시)</span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 그대로 API 예시 요청과 응답에 해당하는 예시코드를 문서화 할 수는 있다. 문제는 API를 추가로 개발하거나 에러 상황이 바뀌게 되면 일일히 adoc 파일에 들어가서 해당 에러코드를 수정해줘야 한다. 그리고 예외 코드를 직접 적어줘야 하니 헷갈리는 여지가 많았다.</p><h2 id="RestDocs의-커스텀-스니펫을-활용해보기"><a href="#RestDocs의-커스텀-스니펫을-활용해보기" class="headerlink" title="RestDocs의 커스텀 스니펫을 활용해보기"></a>RestDocs의 커스텀 스니펫을 활용해보기</h2><p>커스텀 스니펫은 사용자가 특정한 데이터를 전달받아서 restDocs에 사용되는 스니펫의 형태를 직접 정해서 렌더링할 수 있게 하는 방법이다.</p><h3 id="스니펫-형식-만들기"><a href="#스니펫-형식-만들기" class="headerlink" title="스니펫 형식 만들기"></a>스니펫 형식 만들기</h3><p>우리가 문서화할 형식을 먼저 만들어보자. 문서에서 에러코드를 어떤 식으로 표현할지를 만들어주면 된다. 우리는 표 형식으로 에러코드를 만들고자 한다.</p><p>이때 mustache 문법을 활용해서 전달받은 error-codes를 순회하면서 표를 만들도록 작성했다.<br>그리고 이 내용을 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor</code> 이 경로에 저장해주면 된다. 우리는 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor/error-code-table.snippet</code> 으로 저장했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|===</span><br><span class="line">|분류|코드</span><br><span class="line">&#123;&#123;#error-codes&#125;&#125;</span><br><span class="line">|&#123;&#123;name&#125;&#125;</span><br><span class="line">|&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;&#123;/error-codes&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><h3 id="TemplateSnippet-정의하기"><a href="#TemplateSnippet-정의하기" class="headerlink" title="TemplateSnippet 정의하기"></a>TemplateSnippet 정의하기</h3><p>이제 커스텀 스니펫에 어떤 데이터를 넣어서 만들 것인지 정의해보자.</p><p>spring framework의 RestDocs에는 TemplatedSnippet이라는 추상 클래스를 지원한다.<br>RestDocs는 TemplatedSnippet을 기본으로 다양한 스니펫을 만들어서 문서화 한다.</p><p>위에서 예시로 봤던 요청 스니펫과 응답 스니펫도 TemplatedSnippet을 상속받은 HttpRequestSnippet이나 HttpResponseSnippet을 통해서 스니펫을 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatedSnippet</span> <span class="keyword">implements</span> <span class="title">Snippet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String snippetName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(snippetName, snippetName, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, String templateName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">        <span class="keyword">this</span>.snippetName = snippetName;</span><br><span class="line">         <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">this</span>.attributes.putAll(attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 우리가 원하는 스니펫을 정의해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCodeSnippet</span> <span class="keyword">extends</span> <span class="title">TemplatedSnippet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorCodeSnippet</span><span class="params">(ErrorCode... errorCodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;error-code-table&quot;</span>, Map.of(<span class="string">&quot;error-codes&quot;</span>, errorCodes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">createModel</span><span class="params">(<span class="keyword">final</span> Operation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation.getAttributes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스니펫을 생성할 때 에러 코드를 가변 인자로 전달해주면 그 가변인자를 생성자를 통해 전달해주고 TemplateSinppet의 생성자를 호출해서 스니펫을 생성한다. 이때 우리가 스니펫의 이름을 전달해주고 해당 스니펫 속성에 해당하는 Map에 담아 전달해준다.</p><h3 id="커스텀-스니펫-적용해보기"><a href="#커스텀-스니펫-적용해보기" class="headerlink" title="커스텀 스니펫 적용해보기"></a>커스텀 스니펫 적용해보기</h3><p>이제 adoc 파일에 직접 에러 코드를 적는 방식을 우리의 커스텀 스니펫으로 개선해보자!</p><p>먼저 기존의 테스트 코드에 우리의 커스텀 스니펫을 생성해서 문서화할 에러 코드를 생성자의 인자로 전달해준다!</p><p>이때 실제 코드가 아닌 자바 enum을 전달해주면 되고 테스트 코드 안에서 문서화 할 내용을 관리해 줄 수 있어서 더 간편한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>, <span class="keyword">new</span> ErrorCodeSnippet(ErrorCode.ILLEGAL_ARGUMENT)));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 adoc에도 우리가 만든 커스텀 스니펫을 쓰겠다고 적어줘야 한다!</p><p>스니펫에 error-code-table이 추가됐음을 확인할 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;error-code-table,http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 해놓고 테스트를 성공시키면 다음과 같이 문서화가 된다.<br><img src="/img/restDocsErrorCode-2.png"></p><h1 id="참고문서"><a href="#참고문서" class="headerlink" title="참고문서"></a><em>참고문서</em></h1><p><a href="https://techblog.woowahan.com/2597/">https://techblog.woowahan.com/2597/</a></p><p><a href="https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing">https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing</a></p><p><a href="https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29">https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/project/">Project</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인증 인가에 사용되는 토큰을 어디에서 관리할까? (이론 편)</title>
      <link>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/</guid>
      <pubDate>Wed, 19 Oct 2022 15:07:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번 포스트에서는 우아한테크코스 팀 프로젝트에서 리프레시 토큰을 적용하게 된 계기를 정리해본다.&lt;/p&gt;
&lt;h1 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h1&gt;&lt;p&gt;우아한기크코스 팀</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 우아한테크코스 팀 프로젝트에서 리프레시 토큰을 적용하게 된 계기를 정리해본다.</p><h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>우아한기크코스 팀 프로젝트 회의 중 현재 우리가 사용하고 있는 인증 인가 방식을 현업에서도 유효한가에 대해 의논한 적이 있다.<br>당시 팀 프로젝트의 인증 인가는 JWT 액세스 토큰을 세션 스토리지에 저장해놓는 방식으로 운영하고 있었다.</p><h2 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h2><p>이 방식에는 크게 두가지 문제가 있다고 생각했다.<br>먼저 세션 스토리지에 저장할 경우 브라우저를 닫으면 저장된 토큰 정보가 날아간다.<br>대부분의 서비스는 탭이나 브라우저를 닫는다고 로그아웃되지 않는다.<br>우리는 세션 스토리지에 사용자 인증 정보를 담아서는 안되겠다고 판단했다.</p><h2 id="대안-비교하기"><a href="#대안-비교하기" class="headerlink" title="대안 비교하기"></a>대안 비교하기</h2><p>브라우저를 닫아도 사용자가 로그인 한 상태가 유지되려면 사용자 인증 정보를 세션 스토리지가 아닌 다른 곳에 저장해야 했다.<br>쿠키나 로컬 스토리지가 가능한 선택지였다</p><h3 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a>쿠키</h3><p>먼저 쿠키에 대해 고민해보자.<br>쿠키의 가장 큰 문제점은 CSRF 공격이 위험하다는 점이다.<br>쿠키는 매번 HTTP 요청에 같이 포함되서 가기 때문에 공격자가 <code>[POST] /review/1</code> 이런 URL을 실행시키도록 유도해서 사용자가 의도하지 않은 행동을 실행시킬 수 있다.<br>서버에서는 같이 온 쿠키로 사용자 정보를 확인에 성공했으니 더 의심하지 않고 요청을 수행하게 되서 문제가 된다.</p><p>반면 쿠키는 <code>httpOnly</code> 속성을 활용하면 xss 공격을 막을 수 있다.<br><code>httpOnly</code> 속성을 사용하면 자바스크립트로 접근이 불가능하기 때문에 xss 공격으로 스크립트를 실행해도 쿠키의 내용을 알지 못한다.</p><h3 id="로컬-스토리지"><a href="#로컬-스토리지" class="headerlink" title="로컬 스토리지"></a>로컬 스토리지</h3><p>반면 로컬 스토리지는 어떨까?<br>로컬 스토리지는 세션 스토리지와 함께 HTML5 스토리지라고 불린다.<br>로컬 스토리지를 사용하게 되면 세션 스토리지와는 다르게 브라우저를 닫아도 정보가 사라지지 않는다.<br>프론트엔드는 로컬 스토리지에 담겨있는 토큰을 꺼내서 <code>Authorization</code> 헤더에 담아 요청을 보낸다.</p><p>이 방법은 CSRF 공격에 비교적 안전하다.<br>왜냐면 쿠키와 다르게 자동으로 요청에 함께 포함되지 않고 자바스크립트로 로컬 스토리지로 꺼내서 <code>Authorization</code> 헤더에 담는 추가적인 행위가 필요하므로 CSRF 공격으로는 하기 어렵다.</p><p>하지만 로컬 스토리지(뿐만 아니라 HTML5 스토리지 모두) XSS 공격에 취약하다는 문제가 있다.<br>쿠키와 다르게 로컬 스토리지는 애초에 자바스크립트에서 사용하기 위해 등장한 개념이라 <code>httpOnly</code>를 적용한 쿠키처럼 자바스크립트의 접근을 막을 수 없다.</p><p>그래서 다음과 같은 HTML 코드를 삽입하는 XSS 공격에 취약할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;access-token&#x27;</span>))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>지금까지 대안을 정리하면 다음과 같다.</p><table><thead><tr><th><strong>비교</strong></th><th><strong>세션 스토리지</strong></th><th><strong>로컬 스토리지</strong></th><th><strong>쿠키</strong></th></tr></thead><tbody><tr><td><strong>회원 정보 유지</strong></td><td>불가능</td><td>가능</td><td>가능</td></tr><tr><td><strong>CSRF 공격</strong></td><td>방어</td><td>방어</td><td>취약</td></tr><tr><td><strong>XSS 공격</strong></td><td>취약</td><td>취약</td><td>httpOnly 사용시 방어</td></tr></tbody></table><h2 id="대안-선택-기준"><a href="#대안-선택-기준" class="headerlink" title="대안 선택 기준"></a>대안 선택 기준</h2><p>우리는 대안을 선택할 때 다음과 같은 기준을 정해두고 생각했다.</p><ol><li>브라우저를 닫아도 회원 정보가 유지될 것</li><li>CSRF 공격과 XSS 공격을 최대한 막아볼 것</li><li>만에 하나 액세스 토큰이 탈취되었더라도 피해를 최소화 할 것</li><li>인증 인가를 통한 DB 부하를 줄일 수 있을 것</li></ol><p>먼저 1번을 고려했을 때 세션 스토리지(기존 방식)은 제외해야 했다.</p><p>2번을 고려하면 로컬 스토리지와 쿠키 모두 각자 다른 곳에서 취약함을 알 수 있었다.<br>다만 로컬 스토리지 XSS 공격은 리액트에서 어느정도 막아줄 수 있다. 하지만 리액트에 의존해서 XSS 공격을 막는 것은 부족하다고 생각했다.</p><p>반면 쿠키의 CSRF 공격은 추가적인 방어 수단을 고려해야 한다.<br>쿠키의 CSRF 공격 취약성은 CSRF 토큰을 도입해서 해결할 수 있다고 한다.<br>CSRF 토큰은 난수를 서버에서 저장하고 매 요청마다 클라이언트가 난수를 같이 보내서 서버에서 난수가 일치하는 지 확인하는 방식이다.<br>문제는 난수를 서버에서 관리하는 비용이 있고 만약 난수를 DB에서 관리할 경우 매 요청마다 DB에 접근해서 난수를 비교해야하는 비용도 존재했다.</p><p>또한 CSRF 공격을 referer 헤더를 체크하는 방식으로 막을 수도 있다.<br>referer는 공격자가 위조할 수 있는 요소라서 referer 체크로는 CSRF 공격을 막기 힘들다고 생각했다.</p><p>3번은 우리가 예상하지 못한 경우를 대비한다.<br>즉 어찌됐건 토큰이 유출됐을 경우 피해를 최소화하기 위해서는 액세스 토큰의 유효 시간을 짧게 설정할 필요가 있었다.<br>하지만 액세스 토큰 유효시간을 짧게 설정하면 너무 빠르게 로그아웃되어버리는 현상이 발생할 수 있었다.</p><p>이럴 때 사용되는 것이 리프레시 토큰이다. 리프레시 토큰은 다른 포스트로 이어서 설명해보겠다.</p><p>4번은 간단하다 보안을 생각하는 것은 좋으나 그렇다고 지나치게 DB 서버에 부하를 주는 방식은 곤란하다. 왜냐면 우리 프로젝트의 서비스가 금융과 관련된 보안에 민감한 서비스는 아니기 때문에 보안 때문에 성능을 포기하면 안된다고 생각했다.</p><p>4번 관점에서는 CSRF 토큰을 사용하기는 어려웠다.</p><h2 id="대안-선택-하기"><a href="#대안-선택-하기" class="headerlink" title="대안 선택 하기"></a>대안 선택 하기</h2><p>우리가 선택한 방법은 리프레시 토큰을 httpOnly 쿠키에 담고 액세스 토큰을 자바스크립트 변수로 관리하는 방식이었다.</p><p>이렇게 하면 우리의 선택 기준을 충족할 수 있었다.</p><ol><li>브라우저를 닫아도 쿠키에 저장된 리프레시 토큰으로 다시 액세스 토큰을 발급받으면 되니 회원 정보를 유지할 수 있었다.</li><li>XSS 공격은 <code>httpOnly</code> 속성으로 방지하고 CSRF 공격은 리프레시 토큰만으로는 액세스 토큰 발급을 제외한 다른 행위를 할 수 없으니 해커의 공격 가능한 범위를 줄이는 방식으로 대응했다.<br>만약 액세스 토큰을 발급하는 데 성공해도 해커는 이 응답값에 접근할 수 없으므로 큰 위협이 되지 않는다.</li><li>액세스 토큰이 만에 하나 갈취되어도 짧은 유효시간을 적용하면 해커가 공격 가능한 시간이 적어져 대응 가능하다고 판단했다.<br>만약 유효시간이 훨씬 긴 리프레시 토큰이 갈취 되었을 경우에는 액세스 토큰을 발급하면 만료시키는 방식으로 대응했다.<br>이렇게 하면 리프레시 토큰이 갈취되어도 액세스 토큰 한 개의 시간 만큼만 공격에 노출된다.</li><li>리프레시 토큰을 통해 액세스 토큰을 발급받을 때 추가적인 DB 접근 비용이 필요했다.<br>하지만 CSRF 토큰을 도입했을 경우처럼 매 요청마다 DB를 접근하는 것이 아닌 액세스 토큰을 발급할 때만 DB에 접근해서 감당 가능하다고 봤다.</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring boot에서 JWT 토큰 발급 구현하기</title>
      <link>https://yangdongjue5510.github.io/2022/09/26/spring/springBootJwt/</link>
      <guid>https://yangdongjue5510.github.io/2022/09/26/spring/springBootJwt/</guid>
      <pubDate>Mon, 26 Sep 2022 14:28:39 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;도입-배경&quot;&gt;&lt;a href=&quot;#도입-배경&quot; class=&quot;headerlink&quot; title=&quot;도입 배경&quot;&gt;&lt;/a&gt;도입 배경&lt;/h2&gt;&lt;p&gt;우아한테크코스에 프로젝트를 진행하는데 사용자의 정보를 기억해야 하는 상황이 필요한 경우가 있다.&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h2><p>우아한테크코스에 프로젝트를 진행하는데 사용자의 정보를 기억해야 하는 상황이 필요한 경우가 있다.</p><p>예를 들면 사용자가 작성한 리뷰를 삭제하거나 수정할 수 있어야 한다. 그러려면 현재 접속한 사용자가 이전에 리뷰를 작성한 사용자임을 알아낼 수 있어야 한다.</p><p>일단 사용자를 구분하기 위해서 로그인을 해서 사용자를 구분해서 관리할 수 있도록 했다.</p><p>이때 사용자 인증하는 역할은 깃허브Oauth를 활용해서 깃허브에서 사용자를 인증하고 사용자의 정보를 반환한다.</p><p>이제 사용자에 대한 정보를 우리 프로젝트 서버로 가져왔다. 이 정보를 어딘가에 기억해놔야 사용자가 다음에 요청을 했을 때 같은 사용자임을 알 수 있다.</p><h2 id="세션-JWT-토큰"><a href="#세션-JWT-토큰" class="headerlink" title="세션, JWT 토큰"></a>세션, JWT 토큰</h2><p>정보를 어디에 저장할 지, 어떻게 저장할 지에 따라 세션, JWT 토큰을 활용하는 방법이 있다.<br>(쿠키에 사용자 정보를 그대로 저장하는 방법도 있지만 보안에 취약해서 제외했다.)</p><h3 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h3><p>세션 방식은 서버의 세션에 사용자의 정보를 저장하고 해당 세션에 저장할 때 발급되는 JSESSIONID를 클라이언트에게 전달해서 클라이언트는 JSESSIONID를 요청 보낼 때 같이 보낸다. 서버는 요청과 함께 온 JSESSIONID를 통해 서버의 세션에 저장된 정보를 찾아 사용자를 식별한다.즉 세션 방식은 사용자의 정보를 서버에 저장하는 방식이다.</p><p>문제는 만약 서버가 다중화가 되는 경우다.</p><p>필자가 사용하는 Spring의 경우 세션을 톰캣 내부에 저장하는 게 기본이다. 그럴 경우 사용자가 다른 서버로 요청을 보내게 되면 해당 서버의 세션에는 사용자 정보가 저장된 적 없으니 문제가 생긴다. 즉 여러 서버의 세션이 동기화를 해줘야 한다.</p><p>그래서 세션을 사용하는 실 서비스에서는 세션을 위한 DB 서버를 따로 관리한다. 세션을 위한 저장소를 따로 관리하는 경우 기존의 API 서버와 IO 비용을 생각해야 한다. 특히 여러 API 서버가 한 세션 서버에 요청을 보낼 경우 세션 서버에 지나친 부하가 생길 수 있다.</p><h3 id="JWT-토큰"><a href="#JWT-토큰" class="headerlink" title="JWT 토큰"></a>JWT 토큰</h3><p>JWT 토큰은 JWT 토큰이라는 것에 사용자의 정보를 인코딩하여 담고 서버가 가진 시크릿키로 서명해서 만든 다음 클라이언트 쪽에서 저장하는 방법이다.</p><p>클라이언트는 자신이 가진 JWT 토큰을 요청을 보낼 때 같이 보내서 서버가 이를 받아 디코딩해서 사용하는 방식이다.</p><p>문제는 JWT 토큰에 담긴 정보는 누구나 디코딩 할 수 있다는 점이다.</p><p>JWT 토큰의 페이로드에 담긴 값은 애초에 암호화한 값을 집어넣는 것이 아니라면 누구나 그 값이 어떤 값인지 디코딩 해서 볼 수 있다.</p><p>그래서 보안에 민감한 값은 JWT 토큰에 담지 않도록 한다.</p><p>더 큰 문제는 시크릿키가 노출되면 공격자가 JWT 토큰을 얼마든지 만들 수 있다는 점이다.</p><p>그래서 JWT 토큰을 사용할 때는 시크릿키를 깃허브같은 곳에 노출되지 않도록 주의해야 한다.</p><h3 id="쿠키에-사용자-정보-그대로-저장-비추천"><a href="#쿠키에-사용자-정보-그대로-저장-비추천" class="headerlink" title="쿠키에 사용자 정보 그대로 저장 (비추천)"></a>쿠키에 사용자 정보 그대로 저장 (비추천)</h3><p>쿠키에 사용자의 정보를 그대로 저장하는 방법은 추천하지 않는다.</p><p>일반적인 쿠키는 JS로 접근해서 내용을 볼 수 있기 때문에 XSS(Cross Site Scripting)을 통해 탈취 될 수 있다.</p><p>또한 스니핑(Sniffing, 서버와 클라이언트의 네트워크 중간에서 패킷을 탈취해서 도청) 공격을 통해 탈취 될 수 있다.</p><p>위 두 문제점은 막으려면</p><p>1. 쿠키의 Http-Only 옵션을 켜서 JS가 접근할 수 없도록 해야 한다.</p><p>2. 서버와 클라이언트의 통신을 HTTPS로 설정해서 중간에 도청해도 알 수 없도록 해야 한다.</p><h2 id="JWT-토큰을-고른-이유"><a href="#JWT-토큰을-고른-이유" class="headerlink" title="JWT 토큰을 고른 이유"></a>JWT 토큰을 고른 이유</h2><p>JWT 토큰은 서버에서 토큰을 어떻게 저장할 지 고민하지 않아도 되는 점이 컸다.</p><p>특히 서비스의 특성에 따라 달라지는데, 우리 서비스는 단순 리뷰 서비스이기 때문에 지금 단계에서는 JWT 토큰으로 간단하게 사용자를 식별해도 괜찮다고 판단했다.</p><p>JWT 토큰에 사용되는 시크릿키는 서브 모듈로 따로 Private 레포지토리를 만들어서 관리하면 해결된다고 판단했다. </p><h2 id="Spring-Boot에서-JWT-토큰-발급하기"><a href="#Spring-Boot에서-JWT-토큰-발급하기" class="headerlink" title="Spring Boot에서 JWT 토큰 발급하기"></a>Spring Boot에서 JWT 토큰 발급하기</h2><p>일단 JWT 토큰에 어떤 값을 저장해서 서버와 클라이언트가 주고 받을 것인지 결정해야 한다.</p><p>우리 서비스는 사용자의 정보를 DB에 저장할 때 생성된 MemberID를 페이로드에 담았다.</p><p>로그인을 할 때 인증 인가 로직 흐름은 다음과 같다.</p><ol><li>클라이언트에서 깃허브에 코드를 요청한다.</li><li>깃허브는 해당 클라이언트가 깃허브의 사용자인지 확인하고 코드를 반환한다.</li><li>클라이언트는 서버에 깃허브에서 받은 코드를 넘겨서 로그인 요청을 날린다.</li><li>서버는 코드를 통해 깃허브 API용 access token을 요청한다.</li><li>깃허브는 코드를 확인하고 깃허브 API에 접근할 수 있는 access token을 발급한다.</li><li>서버는  깃허브 API access token을 통해 사용자의 정보를 요청한다.</li><li>깃허브는 access token을 확인하고 해당 사용자의 정보를 반환한다.</li><li>서버는 사용자의 정보를 받고 이를 DB에 최신화한다. (만약 깃허브 이름이 변했을 경우 반영해주기 위함)</li><li>서버는 DB에 저장된 사용자의 ID를 통해 JWT 토큰을 만들어서 클라이언트에게 반환한다.</li><li>이제 클라이언트는 인가가 필요한 요청에 받은 JWT 토큰을 요청 헤더(Authorization)에 담아서 보낸다.</li><li>서버는 클라이언트의 Authorization 헤더에 저장된 JWT 토큰이 우리 서버가 발급한 것인지, 유효한 것인지 확인하고 요청을 수행한다.</li></ol><p>서버 입장에서는 3, 4, 6, 8, 9, 11을 처리해주면 된다.</p><h2 id="AuthController"><a href="#AuthController" class="headerlink" title="AuthController"></a>AuthController</h2><p>먼저 3번 먼저 구현해보자. 로그인 요청을 받는 AuthController 예시이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v1&quot;)</span><br><span class="line">public class AuthController &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthService authService;</span><br><span class="line"></span><br><span class="line">    public AuthController(final AuthService authService) &#123;</span><br><span class="line">        this.authService = authService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/login&quot;)</span><br><span class="line">    public ResponseEntity&lt;LoginResponse&gt; login(@RequestParam final String code) &#123;</span><br><span class="line">        final LoginResult loginResult = authService.login(code);</span><br><span class="line">        return ResponseEntity.ok(LoginResponse.from(loginResult));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 파라미터로 오는 코드는 깃허브에서 사용자 인증에 성공했을 경우 돌려받는 코드이다.</p><p>AuthService에서 코드를 전달해서 로그인 처리를 위임하고 있다.</p><h2 id="AuthService"><a href="#AuthService" class="headerlink" title="AuthService"></a>AuthService</h2><p>AuthService에서 logIn을 어떻게 처리하는 지 살펴보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional(readOnly = true)</span><br><span class="line">public class AuthService &#123;</span><br><span class="line"></span><br><span class="line">    private final GitHubOauthClient gitHubOauthClient;</span><br><span class="line">    private final MemberRepository memberRepository;</span><br><span class="line">    private final JwtProvider jwtProvider;</span><br><span class="line"></span><br><span class="line">    public AuthService(final GitHubOauthClient gitHubOauthClient, final MemberRepository memberRepository,</span><br><span class="line">                       final JwtProvider jwtProvider) &#123;</span><br><span class="line">        this.gitHubOauthClient = gitHubOauthClient;</span><br><span class="line">        this.memberRepository = memberRepository;</span><br><span class="line">        this.jwtProvider = jwtProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public LoginResult login(final String code) &#123;</span><br><span class="line">        final GitHubProfileResponse gitHubProfileResponse = getGitHubProfileResponse(code);</span><br><span class="line">        final Member member = addOrUpdateMember(gitHubProfileResponse);</span><br><span class="line">        final Long memberId = member.getId();</span><br><span class="line">        final String applicationAccessToken = jwtProvider.createAccessToken(memberId);</span><br><span class="line">        return new LoginResult(applicationAccessToken, member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GitHubProfileResponse getGitHubProfileResponse(final String code) &#123;</span><br><span class="line">        final String gitHubAccessToken = gitHubOauthClient.getAccessToken(code);</span><br><span class="line">        return gitHubOauthClient.getProfile(gitHubAccessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Member addOrUpdateMember(final GitHubProfileResponse gitHubProfileResponse) &#123;</span><br><span class="line">        final Member requestedMember = gitHubProfileResponse.toMember();</span><br><span class="line">        final Member member = memberRepository.findByGitHubId(gitHubProfileResponse.getGitHubId())</span><br><span class="line">                .orElseGet(() -&gt; memberRepository.save(requestedMember));</span><br><span class="line">        member.update(requestedMember);</span><br><span class="line">        return member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthService의 getGitHubProfileResponse 메서드는 4번과 6번을 GithubOauthClient에게 위임하고 있다.</p><p>(GithubOauthClient는 다른 포스트로 더 설명해보고자 한다.)</p><p>AuthService의 addOrUpdateMember 메서드는 8번을 수행하고 있다.</p><p>AuthService의 login 메서드에서 JwtProvider를 통해 9번을 수행하고 있다.</p><p>그리고 LoginResult라는 DTO에 결과를 담아서 컨트롤러로 반환하고 있다.</p><h2 id="JwtProvider"><a href="#JwtProvider" class="headerlink" title="JwtProvider"></a>JwtProvider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_TYPE = <span class="string">&quot;Bearer&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_TOKEN_SUBJECT = <span class="string">&quot;AccessToken&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthTokenExtractor authTokenExtractor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Key secretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> validityInMilliseconds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtProvider</span><span class="params">(<span class="keyword">final</span> AuthTokenExtractor authTokenExtractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@Value(&quot;$&#123;security.jwt.secret-key&#125;&quot;)</span> <span class="keyword">final</span> String secretKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@Value(&quot;$&#123;security.jwt.expire-length&#125;&quot;)</span> <span class="keyword">final</span> <span class="keyword">long</span> validityInMilliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authTokenExtractor = authTokenExtractor;</span><br><span class="line">        <span class="keyword">this</span>.secretKey = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">this</span>.validityInMilliseconds = validityInMilliseconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createAccessToken</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Role role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">final</span> Date validity = <span class="keyword">new</span> Date(now.getTime() + validityInMilliseconds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(ACCESS_TOKEN_SUBJECT)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(validity)</span><br><span class="line">                .claim(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">                .claim(<span class="string">&quot;role&quot;</span>, role)</span><br><span class="line">                .signWith(secretKey, SignatureAlgorithm.HS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidToken</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Jws&lt;Claims&gt; claims = getClaimsJws(token);</span><br><span class="line">            <span class="keyword">return</span> isAccessToken(claims) &amp;&amp; isNotExpired(claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Jws&lt;Claims&gt; <span class="title">getClaimsJws</span><span class="params">(<span class="keyword">final</span> String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parserBuilder()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .build()</span><br><span class="line">                .parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccessToken</span><span class="params">(<span class="keyword">final</span> Jws&lt;Claims&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getSubject()</span><br><span class="line">                .equals(ACCESS_TOKEN_SUBJECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotExpired</span><span class="params">(<span class="keyword">final</span> Jws&lt;Claims&gt; claims)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getExpiration()</span><br><span class="line">                .after(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemberPayload <span class="title">getPayload</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        Claims body = getClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long id = body.get(<span class="string">&quot;id&quot;</span>, Long.class);</span><br><span class="line">            Role role = Role.valueOf(body.get(<span class="string">&quot;role&quot;</span>, String.class));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MemberPayload(id, role);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> claims.getBody()</span><br><span class="line">                .getExpiration()</span><br><span class="line">                .after(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemberPayload <span class="title">getPayload</span><span class="params">(<span class="keyword">final</span> String authorizationHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE);</span><br><span class="line">        Claims body = getClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long id = body.get(<span class="string">&quot;id&quot;</span>, Long.class);</span><br><span class="line">            Role role = Role.valueOf(body.get(<span class="string">&quot;role&quot;</span>, String.class));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MemberPayload(id, role);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtProvider는 Jwt 토큰을 만들고, 검증하는 역할을 한다.</p><p>이때 JwtProvider에는 io.jsonwebtoken 라이브러리를 사용한다.</p><p>이를 위해서는 build.gradle에 다음과 같이 의존성을 추가해주자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">// 생략...</span><br><span class="line"></span><br><span class="line">    // jwt</span><br><span class="line">    implementation &#x27;io.jsonwebtoken:jjwt-api:0.11.5&#x27;</span><br><span class="line">    runtimeOnly &#x27;io.jsonwebtoken:jjwt-impl:0.11.5&#x27;</span><br><span class="line">    runtimeOnly &#x27;io.jsonwebtoken:jjwt-jackson:0.11.5&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtProvider는 생성자로 시크릿키, 만료 시간, AuthTokenExtractor를 주입받는다.</p><p>AuthTokenExtractor는 Authorization 헤더 형식에서 토큰값만 추출하는 책임을 진다.</p><p>(<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization" title="Authorization 헤더에 대하여">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization</a>)</p><p>만료시간은 변경해줘야 할 경우 JwtProvider의 코드를 살펴보면서 바꾸면 위험하기 때문에 따로 주입해주는 방식을 썼다.</p><p>문제는 시크릿키이다.</p><p>시크릿키는 한번 유출되면 누구나 서버가 만든 JWT 토큰과 동일한 서명을 가진 JWT 토큰을 만들어 낼 수 있다.</p><p>그래서 따로 설정파일 (yaml)을 만들어서 보안이 중요한 내용을 관리하도록 했다.</p><p>이런 보안이 중요한 파일들은 .gitignore로 깃에 등록되지 않도록 관리하거나, 서브 모듈을 활용해서 private repository에서 버전 관리를 할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">security:</span><br><span class="line">  jwt:</span><br><span class="line">    secret-key: secretKeyExample</span><br><span class="line">    expire-length: 3600000</span><br></pre></td></tr></table></figure><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a><em>참고</em></h2><p><a href="https://github.com/woowacourse-teams/2022-f12">https://github.com/woowacourse-teams/2022-f12</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/09/26/spring/springBootJwt/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA를 왜 쓰나요?</title>
      <link>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</link>
      <guid>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</guid>
      <pubDate>Wed, 29 Jun 2022 10:21:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.&lt;br&gt;객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.<br>객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스는 데이터 중심으로 설계된다.<br>객체지향은 참조의 방향이 정해져있지만, 데이터베이스는 하나의 외래키로 양쪽 모두 참조 가능하다.<br>동일성 비교를 객체는 인스턴스의 주소값으로 하고 데이터베이스는 기본키로 한다.<br>JPA는 이런 차이를 개발자가 신경쓰지 않게 해준다.<br>JPA는 반복적인 SQL 작성을 줄여준다.</p><h1 id="반복적인-SQL-작성"><a href="#반복적인-SQL-작성" class="headerlink" title="반복적인 SQL 작성"></a>반복적인 SQL 작성</h1><p>JDBC API로 Member 객체를 저장하거나 조회해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">        <span class="keyword">final</span> String sql = <span class="string">&quot;insert into member (id, name) values (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, member.getId());</span><br><span class="line">            statement.setString(<span class="number">2</span>, member.getName());</span><br><span class="line">            statement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Member 객체를 저장하는 데 정말 많은 코드가 많이 필요하다.<br>만약 테이블이 100개이면 저장하는 메서드 100개를 반복해서 만들어줘야 한다.</p><p>만약 데이터베이스를 컬렉션이라고 상상해보면 다음과 같지 않을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">members.add(member);</span><br></pre></td></tr></table></figure><p>JPA를 사용하면 컬렉션처럼 객체를 데이터베이스에 저장시킬 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entityManager.persist(member);</span><br></pre></td></tr></table></figure><p>JPA는 객체와 매핑 정보를 보고 적절한 SQL을 알아서 실행시킨다.<br>개발자는 반복적인 SQL 작성을 하지 않아도 된다.</p><h1 id="상속-구조-구현-문제"><a href="#상속-구조-구현-문제" class="headerlink" title="상속 구조 구현 문제"></a>상속 구조 구현 문제</h1><p><img src="/img/whyUseJpa-1.png"></p><p>데이터베이스는 객체 지향 상속을 지원하지 않으니 위 그림처럼 DTYPE 칼럼을 추가해서 어떤 자식 테이블과 관계가 있는지 확인할 수 있어야 한다.</p><p>문제는 이런 경우 개발자가 Keyboard 객체를 저장하려면</p><ol><li>ITEM 테이블에 insert 하는 쿼리</li><li>KEYBOARD 테이블에 insert 하는 쿼리</li></ol><p>두 개의 쿼리를 작성해야 한다.</p><p>데이터베이스에서 객체를 가져올 때는 ITEM과 KEYBOARD을 조인해서 데이터를 가져온 다음, Keyboard 객체를 생성해야 한다.</p><p>JPA의 경우 그냥 해당 객체를 저장(혹은 조회)하면 적절한 SQL을 실행해서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 저장</span></span><br><span class="line">entityManager.persist(keyboard);</span><br><span class="line"><span class="comment">// 조회</span></span><br><span class="line">Keyboard keyboard = entityManager.find(Keyboard.class, keyboardId);</span><br></pre></td></tr></table></figure><h1 id="연관-관계-문제"><a href="#연관-관계-문제" class="headerlink" title="연관 관계 문제"></a>연관 관계 문제</h1><p>Member 클래스가 Team과 연관 관계가 있다고 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Team team;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 Member를 조회하는 두 개의 SQL이 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> u.id, u.name, t.id, t.name </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">member</span> u </span><br><span class="line"><span class="keyword">JOIN</span> team t <span class="keyword">ON</span> member.team_id <span class="operator">=</span> team.id </span><br><span class="line"><span class="keyword">WHERE</span> u.id <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure><p>만약 굳이 Team 객체를 사용하지 않는 경우에는 첫번째 쿼리를 사용해서 Member 객체를 만드는게 낫다.<br>Team 객체를 사용해야 하는 경우는 두번째 쿼리로 Team 객체를 만들어서 Member 객체를 만들어야 한다.</p><p>문제는 개발자가 Member객체가 Team 객체에 값이 들어와 있는지를 확신할 수 없다는 점이다.</p><p>첫번째 쿼리로 만들어진 Member객체에게 getTeam()을 할 경우 Id만 채워진 객체가 반환되서 문제를 일으키게 된다.</p><p>그리고 만약 Team 객체에도 연관되는 객체가 있으면 쿼리는 더 복잡해질 가능성이 있다.<br>이 경우에도 Team 객체의 연관 객체의 데이터를 채워서 만들어 줄 것인지에 따라 SQL을 다르게 작성해야 한다.<br>다양한 연관관계를 상황에 따라 맞는 쿼리를 작성하는 건 상당히 힘든 작업이다.</p><p>반면 JPA에서는 연관 관계의 객체의 프로퍼티에 접근할 때 쿼리를 실행시켜서 해당 객체를 초기화한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 Team 객체는 id값만 채워져있다.</span></span><br><span class="line">Member member = entityManager.find(Member.class, memberId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이때 Team 객체의 데이터가 채워진다.</span></span><br><span class="line">member.getTeam().getName();</span><br></pre></td></tr></table></figure><h1 id="동일성-보장-문제"><a href="#동일성-보장-문제" class="headerlink" title="동일성 보장 문제"></a>동일성 보장 문제</h1><p>자바는 인스턴스의 주소값이 같으면 같은 객체로 분류하고, 데이터베이스는 기본키 값이 같으면 동일하다고 인식한다.<br>자바 객체를 저장하고 다시 조회했을 때 같은 객체를 반환하기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 Member 객체를 조회하려면 DB에서 조회한 데이터로 새로운 객체를 만들어서 반환하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">    <span class="keyword">final</span> String sql = <span class="string">&quot;select id, name from member where id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        ResultSet resultSet = statement.executeQuery();</span><br><span class="line">        <span class="keyword">if</span> (!resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Member(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 이렇게 되면 객체를 저장하고 해당 객체를 다시 조회했을 때 같은 객체가 반환되지 않는다는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">memberDao.save(member);</span><br><span class="line">Member foundMember = memberDao.findById(<span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//실패!!</span></span><br></pre></td></tr></table></figure><p>분명 논리적으로는 같은 객체인데 DB에 저장하고 찾아온 객체가 자바에서는 다른 객체로 인식하게 된다.</p><p>JPA에서는 객체를 DB에 저장하고 조회해도 같은 객체(인스턴스 주소값이 같은)를 반환해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">entityManager.persist(member);</span><br><span class="line">Member foundMember = entityManager.find(Member.class, <span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//성공!!</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바 ORM 표준 JPA 프로그래밍</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Transactional 어노테이션</title>
      <link>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</guid>
      <pubDate>Mon, 16 May 2022 08:35:14 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;트랜잭션이 무엇인지 알아본다.&lt;br&gt;@Transactional의 Propagation 옵션을 알아본다.&lt;br&gt;@Transactional의 롤백 기준을 알아본다.&lt;br&gt;@Transa</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>트랜잭션이 무엇인지 알아본다.<br>@Transactional의 Propagation 옵션을 알아본다.<br>@Transactional의 롤백 기준을 알아본다.<br>@Transactional 적용 실패하는 경우를 알아본다.</p><h1 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션?"></a>트랜잭션?</h1><p>모두 반드시 성공해야 하는 연속된 작업들을 트랜잭션이라 한다.<br>만약 작업들 중 하나만 실패해도 모든 작업들이 어플리케이션의 상태를 변경시키지 않은 상태로 돌려놔야 한다.</p><p>만약 하나의 지하철 노선에 등록할 때 구간도 같이 저장해야 한다고 가정하자.<br>이때 INSERT 문이 두 번 사용될 것이다.<br>개발자는 이를 하나의 작업 단위로 인식해서 하나의 트랜잭션으로 관리할 수 있다.<br>노선을 등록하는데 성공했더라도 구간이 저장안되면 노선도 저장되서는 안되기 때문이다.</p><p>트랜잭션 진행 중에 문제가 생길 경우 그 작업을 진행하기 이전으로 DB를 롤백시킨다.</p><h1 id="JDBC의-트랜잭션"><a href="#JDBC의-트랜잭션" class="headerlink" title="JDBC의 트랜잭션"></a>JDBC의 트랜잭션</h1><p>JDBC는 statement를 트랜잭션에서 진행할 수 있게한다.<br>JDBC의 한 Connection의 수행마다 auto-commit한다.<br>즉 모든 statement를 하나의 트랜잭션이라 생각하고 수행 이후 자동으로 반영한다.</p><p>만약 여러 statement를 하나의 트랜잭션에서 진행하고 싶다면 connection의 autoCommit을 꺼놓고 트랜잭션을 종료하고 싶을 때 명시적으로 커밋해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// auto-commit 꺼놓음.</span></span><br><span class="line"><span class="comment">// ... 작업들...</span></span><br><span class="line">connection.commit(); <span class="comment">//명시적으로 커밋.</span></span><br></pre></td></tr></table></figure><h1 id="스프링의-트랜잭션"><a href="#스프링의-트랜잭션" class="headerlink" title="스프링의 트랜잭션"></a>스프링의 트랜잭션</h1><p>스프링에서는 여러가지 트랜잭션 관리 기능을 제공한다.</p><h2 id="명시적-트랜잭션"><a href="#명시적-트랜잭션" class="headerlink" title="명시적 트랜잭션"></a>명시적 트랜잭션</h2><p>트랜잭션의 범위를 자세하게 정하고 싶을 땐 명시적 트랜잭션을 사용한다.</p><p>Transaction Template는 개발자가 직접 트랜잭션 범위를 명시적으로 결정할 수 있다.</p><h2 id="선언적-트랜잭션-Transactional"><a href="#선언적-트랜잭션-Transactional" class="headerlink" title="선언적 트랜잭션 @Transactional"></a>선언적 트랜잭션 @Transactional</h2><p>클래스나 메서드에 @Transactional 어노테이션을 붙이면 글로벌 트랜잭션을 정해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 메서드 위에 두면 메서드 실행 중 예외가 발생하면 롤백한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 위에 두면 클래스에 해당하는 메서드들을 @Transactional을 붙인 셈이 된다.</p><h3 id="Transactional의-여러가지-속성"><a href="#Transactional의-여러가지-속성" class="headerlink" title="@Transactional의 여러가지 속성"></a>@Transactional의 여러가지 속성</h3><p>트랜잭션에는 여러가지 속성을 설정해줄 수 있다. 예시코드를 통해 이해해보자.</p><p>일단 하나의 서비스에서 방을 DB에 저장하고 예외를 일으키는 메서드를 트랜잭션으로 처리하고자 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionalService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;other&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>그리고 다른 서비스에서 아까 만든 서비스를 주입받아 예외를 만드는 메서드를 호출하는 메서드를 트랜잭션 처리해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionalService.throwSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 OuterService의 메서드를 실행하기 위한 Runner 클래스를 만들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OuterService outerService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(OuterService outerService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outerService = outerService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        outerService.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 어플리케이션을 실행하면 외부 트랜잭션 메서드가 실행될 것이다.</p><h3 id="1-전파-옵션"><a href="#1-전파-옵션" class="headerlink" title="1. 전파 옵션"></a>1. 전파 옵션</h3><p>트랜잭션 수행 중 다른 트랜잭션을 호출하는 상황에서 어떻게 처리하는지 다루는 옵션.</p><ul><li><p><strong>REQUIRED</strong> : 트랜잭션 수행 중 다른 트랜잭션 호출되면 먼저 수행되던 거에 합쳐서 수행. propagation 기본 설정값.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>다른 설정을 안하면 REQUIRED 옵션으로 설정된다.<br>이 상태로 실행시키면 DB에는 아무 일도 일어나지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>UnexpectedRollbackException은 외부 트랜잭션이 내부 트랜잭션이 롤백됐음을 예상하지 못했다는 의미다.</p><p>외부 트랜잭션은 내부에서 다른 트랜잭션의 성공 여부 상관없이 커밋하려 한다.<br>중간에 내부 트랜잭션이 실패해서 롤백됐으면 이를 외부 트랜잭션에게 알려줘야 해서 생긴 예외다.</p><p>REQUIRED 옵션은 내부 트랜잭션과 외부 트랜잭션의 범위가 논리적으로는 분리되지만 물리적으로는 각 스코프가 같은 물리적 트랜잭션을 갖게 된다. 그래서 외부 트랜잭션은 내부의 트랜잭션의 rollback-only에 따라 영향을 받는다.</p></li><li><p><strong>SUPPORTS</strong> : 만약 트랜잭션이 진행되고 있는 상태에서 호출 시 해당 트랜잭션에 참여, 아닐 경우 트랜잭션 하지 않고 진행.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//외부 메서드가 트랜잭션이 아니면</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 어떻게 될까?</p><p>그 결과 두 메서드의 DB 업데이트가 모두 이뤄진다.(예외를 일으켜도 DB 업데이트가 이뤄졌다.)<br>사실 두 메서드 모두 트랜잭션 처리 되지 않았다.</p></li><li><p><strong>REQUIRED_NEW</strong> : 이미 진행 중인 트랜잭션이 있어도 새로운 트랜잭션 생성해서 진행. 서로 물리적으로 독립된 트랜잭션을 생성.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 외부 트랜잭션만 커밋된다.<br>내부 트랜잭션은 따로 트랜잭션으로 생성되서 예외 탐지하고 롤백됐고 외부 트랜잭션은 내부 트랜잭션의 실패 여부와 상관없이 트랜잭션을 진행해서 커밋했다.</p></li><li><p><strong>NESTED</strong> : 이미 진행 중인 트랜잭션의 중첩된 트랜잭션을 생성. 물리적으로는 하나의 트랜잭션인데 저장점을 추가하는 방식. 중첩된 트랜잭션은 외부 트랜잭션에 영향을 끼치지 못하지만 내부 트랜잭션은 외부 트랜잭션의 롤백에 영향 받는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이러면 내부 트랜잭션은 롤백되지만 외부 트랜잭션은 잘 실행된다.</p><p>반면 내부 트랜잭션은 예외를 던지지 않는데 외부 트랜잭션에서 예외가 발생한 경우는 어떨까?<br>모든 트랜잭션이 롤백된다! 내부가 성공해도 외부가 롤백되면 모두 롤백된다.</p></li></ul><h3 id="2-롤백-조건-옵션"><a href="#2-롤백-조건-옵션" class="headerlink" title="2. 롤백 조건 옵션"></a>2. 롤백 조건 옵션</h3><p>트랜잭션이 롤백되는 조건을 다룬다.<br>선언적 트랜잭션은 기본적으로 <strong>unchecked exception와 Error</strong>가 발생하면 롤백한다.<br>Checked exception은 개발자가 반드시 처리한 예외이니 예상하지 못한 예외인 unchecked exception과 Error가 발생하면 롤백한다.</p><p>@Transactional 어노테이션의 속성을 통해 롤백조건을 다르게 할 수 있다.<br>관련 속성은 다음과 같다.</p><ul><li><strong>rollbackFor</strong> : 추가로 롤백되어야 할 예외를 추가할 수 있다.</li><li><strong>rollbackForClassName</strong> : 추가로 롤백되어야 할 예외 클래스의 이름을 배열로 받아 추가할 수 있다.</li><li><strong>noRollbackFor</strong> : 롤백하지 않으려는 예외를 정할 수 있다.</li><li><strong>noRollbackForClassName</strong> : 롤백하지 않으려는 예외 클래스으 이름을 배열로 받아 정할 수 있다.</li></ul><h3 id="3-readOnly"><a href="#3-readOnly" class="headerlink" title="3. readOnly"></a>3. readOnly</h3><p>데이터를 수정하지 않는 트랜잭션을 데이터를 수정하려고 하는 경우를 막고 싶을 수 있다.<br>이럴 때 사용되는게 readOnly 속성이다.</p><p>readOnly는 읽기 전용일 경우 true로 세팅해주면 읽기 위한 트랜잭션임을 암시한다.<br>다만 readOnly가 붙은 트랜잭션에서 데이터를 수정하려고 할 때 반드시 실패한다는 의미는 아니다.<br>트랜잭션 매니저에 따라 readOnly를 지원하지 않는 경우 readOnly 설정은 무시된다.</p><h3 id="4-그-외-속성들"><a href="#4-그-외-속성들" class="headerlink" title="4. 그 외 속성들"></a>4. 그 외 속성들</h3><p>트랜잭션의 격리 수준을 결정하는 isolation이나 트랜잭션의 제한 시간을 정하는 timeout 속성들도 존재한다.</p><h2 id="Transation과-AOP"><a href="#Transation과-AOP" class="headerlink" title="@Transation과 AOP"></a>@Transation과 AOP</h2><p>선언적 트랜잭션은 AOP 프록시를 통해 활성화 된다.<br>프록시로 구현되다보니 트랜잭션에 수행하는 프록시 객체와 진짜 객체가 서로 다를 수 있다.<br>간략하게 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        transactionalService.throwSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;done! with throw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 예시로 사용했던 서비스는 사실 AOP 프록시를 사용하면 다음과 같이 된다.<br>외부에서 doSomething 메서드를 호출 -&gt; (프록시)트랜잭션 시작! -&gt; (진짜) doSomething 수행! -&gt; (프록시)트랜잭션 끝!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 프록시객체 </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> 진짜객체;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 트랜잭션_붙은_메서드() &#123;</span><br><span class="line">        트랜잭션_시작;</span><br><span class="line">        진짜객체.트랜잭션_붙은_메서드();</span><br><span class="line">        트랜잭션_끝;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 다음과 같은 경우는 어떻게 될까??</p><p>트랜잭션이 적용되지 않은 public 메서드를 통해서 트랜잭션 붙은 메서드를 호출해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 doSomething은 롤백될까? 답은 아니다!!!!</p><p>왜냐면 프록시 객체는 execute 메서드를 실행시킬 때 내부에서 어떤 메서드를 부르는지 모른다. 그래서 트랜잭션을 적용시켜주지 못한다.</p><p>그래서 <strong>private 메서드는 @Transactional을 붙이는 건 의미 없다.</strong> 트랜잭션 처리 해줄 프록시 객체가 해당 메서드에 접근할 수 없기 때문이다.</p><p>그리고 <strong>public이 붙었더라도 트랜잭션이 붙지 않은 메서드를 통해서 호출하면 트랜잭션이 적용되지 않는다</strong>!!!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Bean Validation으로 검증하기</title>
      <link>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</guid>
      <pubDate>Thu, 12 May 2022 11:41:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Bean-Validation&quot;&gt;&lt;a href=&quot;#Bean-Validation&quot; class=&quot;headerlink&quot; title=&quot;Bean Validation&quot;&gt;&lt;/a&gt;Bean Validation&lt;/h1&gt;&lt;h2 id=&quot;일반적인-유효성-검사-로</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h1><h2 id="일반적인-유효성-검사-로직"><a href="#일반적인-유효성-검사-로직" class="headerlink" title="일반적인 유효성 검사 로직"></a>일반적인 유효성 검사 로직</h2><p>지켜져야 할 조건에 맞지 않은 상황에 로직을 진행하려는 경우  예외를 터트려서 의도하지 않은 진행을 막을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.isBlank()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ExceptionMessage.BLANK_LINE_NAME.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자로 전달받은 문자열이 빈값이면 예외를 터지도록 해서 Name 객체는 반드시 이름을 가지도록 만들 수 있다.</p><p>하지만 이런 로직이 비슷하게 여러 클래스에 흩어져 있다면 중복이 많아지고 관리하기도 힘들어진다.</p><p>이런 검증을 각 </p><blockquote><p>Bean Validation과 Hibernate Validator</p></blockquote><p>Bean Validation은 일종의 명세이지 실제 작동하는 코드는 아니다.<br>이 명세를 구현한 것 중 하나가 Hibernate Validator이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/12/spring/validation/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
