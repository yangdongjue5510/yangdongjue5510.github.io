<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Wed, 26 Oct 2022 05:47:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>RestDocs의 Custom Snippet으로 에러코드 쉽게 문서화하기</title>
      <link>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</link>
      <guid>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/</guid>
      <pubDate>Tue, 25 Oct 2022 08:21:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h1&gt;&lt;p&gt;RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.&lt;/p&gt;
&lt;p&gt;우리 프로젝트에서는 정상 요청 흐름을 중</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.</p><p>우리 프로젝트에서는 정상 요청 흐름을 중점으로 API 문서화했다.</p><p>하지만 해당 API에서 발생 가능한 애외 상황에 대한 응답도 정리해줘야 했다.</p><p>그래서 우리는 백엔드 단에서 발생하는 예외에 매핑되는 예외 코드를 만들어서 예외 상황 발생 시 해당 예외 코드를 바디에 담아서 반환하도록 해서 대해 API 사용자들이 어떤 문제가 발생해는 지 알 수 있도록 했다.</p><p>문제는 특정 API에 해당하는 예외 코드들을 어떻게 문서화하는 지 였다.</p><h2 id="코드-예시"><a href="#코드-예시" class="headerlink" title="코드 예시"></a>코드 예시</h2><p>restDocs 환경 설정은 생략했다.</p><h3 id="예시-컨트롤러"><a href="#예시-컨트롤러" class="headerlink" title="예시 컨트롤러"></a>예시 컨트롤러</h3><p>만약 id값이 1보다 작으면 예외를 반환하는 아주 간단한 예시 컨트롤러이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/simple/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">getSimple</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;id값은 무조건 1보다 커야 합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String body = String.format(<span class="string">&quot;simple id is %d&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-에러코드"><a href="#예시-에러코드" class="headerlink" title="예시 에러코드"></a>예시 에러코드</h3><p>사용자에게 알려줄 예외 코드를 enum으로 관리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ILLEGAL_ARGUMENT(<span class="string">&quot;40000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    ErrorCode(<span class="keyword">final</span> String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="예시-테스트"><a href="#예시-테스트" class="headerlink" title="예시 테스트"></a>예시 테스트</h3><p>성공 사례를 확인하는 예시 테스트이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="예시-adoc-파일"><a href="#예시-adoc-파일" class="headerlink" title="예시 adoc 파일"></a>예시 adoc 파일</h3><p>새로운 adoc 파일을 만들어서 다음과 같이 생성된 스니펫을 넣어주고 테스트를 실행시켜서 성공하면 스니펫이 적용된 html을 얻을 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="/img/restDocsErrorCode-1.png"></p><h2 id="에러-코드를-어떻게-문서화할까"><a href="#에러-코드를-어떻게-문서화할까" class="headerlink" title="에러 코드를 어떻게 문서화할까?"></a>에러 코드를 어떻게 문서화할까?</h2><p>초창기 프로젝트에서 각 API에 에러코드를 명시했던 방법은 매우 간단하다.<br>그냥 adoc파일에 에러코드를 같이 적어주는 것이다.(…)</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>40000 (예시)</span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 그대로 API 예시 요청과 응답에 해당하는 예시코드를 문서화 할 수는 있다. 문제는 API를 추가로 개발하거나 에러 상황이 바뀌게 되면 일일히 adoc 파일에 들어가서 해당 에러코드를 수정해줘야 한다. 그리고 예외 코드를 직접 적어줘야 하니 헷갈리는 여지가 많았다.</p><h2 id="RestDocs의-커스텀-스니펫을-활용해보기"><a href="#RestDocs의-커스텀-스니펫을-활용해보기" class="headerlink" title="RestDocs의 커스텀 스니펫을 활용해보기"></a>RestDocs의 커스텀 스니펫을 활용해보기</h2><p>커스텀 스니펫은 사용자가 특정한 데이터를 전달받아서 restDocs에 사용되는 스니펫의 형태를 직접 정해서 렌더링할 수 있게 하는 방법이다.</p><h3 id="스니펫-형식-만들기"><a href="#스니펫-형식-만들기" class="headerlink" title="스니펫 형식 만들기"></a>스니펫 형식 만들기</h3><p>우리가 문서화할 형식을 먼저 만들어보자. 문서에서 에러코드를 어떤 식으로 표현할지를 만들어주면 된다. 우리는 표 형식으로 에러코드를 만들고자 한다.</p><p>이때 mustache 문법을 활용해서 전달받은 error-codes를 순회하면서 표를 만들도록 작성했다.<br>그리고 이 내용을 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor</code> 이 경로에 저장해주면 된다. 우리는 <code>src/test/resources/org/springframework/restdocs/templates/asciidoctor/error-code-table.snippet</code> 으로 저장했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|===</span><br><span class="line">|분류|코드</span><br><span class="line">&#123;&#123;#error-codes&#125;&#125;</span><br><span class="line">|&#123;&#123;name&#125;&#125;</span><br><span class="line">|&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;&#123;/error-codes&#125;&#125;</span><br><span class="line">|===</span><br></pre></td></tr></table></figure><h3 id="TemplateSnippet-정의하기"><a href="#TemplateSnippet-정의하기" class="headerlink" title="TemplateSnippet 정의하기"></a>TemplateSnippet 정의하기</h3><p>이제 커스텀 스니펫에 어떤 데이터를 넣어서 만들 것인지 정의해보자.</p><p>spring framework의 RestDocs에는 TemplatedSnippet이라는 추상 클래스를 지원한다.<br>RestDocs는 TemplatedSnippet을 기본으로 다양한 스니펫을 만들어서 문서화 한다.</p><p>위에서 예시로 봤던 요청 스니펫과 응답 스니펫도 TemplatedSnippet을 상속받은 HttpRequestSnippet이나 HttpResponseSnippet을 통해서 스니펫을 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatedSnippet</span> <span class="keyword">implements</span> <span class="title">Snippet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String snippetName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(snippetName, snippetName, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TemplatedSnippet</span><span class="params">(String snippetName, String templateName, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">        <span class="keyword">this</span>.snippetName = snippetName;</span><br><span class="line">         <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">this</span>.attributes.putAll(attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 우리가 원하는 스니펫을 정의해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCodeSnippet</span> <span class="keyword">extends</span> <span class="title">TemplatedSnippet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorCodeSnippet</span><span class="params">(ErrorCode... errorCodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;error-code-table&quot;</span>, Map.of(<span class="string">&quot;error-codes&quot;</span>, errorCodes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">createModel</span><span class="params">(<span class="keyword">final</span> Operation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation.getAttributes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스니펫을 생성할 때 에러 코드를 가변 인자로 전달해주면 그 가변인자를 생성자를 통해 전달해주고 TemplateSinppet의 생성자를 호출해서 스니펫을 생성한다. 이때 우리가 스니펫의 이름을 전달해주고 해당 스니펫 속성에 해당하는 Map에 담아 전달해준다.</p><h3 id="커스텀-스니펫-적용해보기"><a href="#커스텀-스니펫-적용해보기" class="headerlink" title="커스텀 스니펫 적용해보기"></a>커스텀 스니펫 적용해보기</h3><p>이제 adoc 파일에 직접 에러 코드를 적는 방식을 우리의 커스텀 스니펫으로 개선해보자!</p><p>먼저 기존의 테스트 코드에 우리의 커스텀 스니펫을 생성해서 문서화할 에러 코드를 생성자의 인자로 전달해준다!</p><p>이때 실제 코드가 아닌 자바 enum을 전달해주면 되고 테스트 코드 안에서 문서화 할 내용을 관리해 줄 수 있어서 더 간편한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="meta">@WebMvcTest(SimpleController.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(RestDocumentationExtension.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ResultActions actual = mockMvc.perform(get(<span class="string">&quot;/simple/1&quot;</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andDo(document(<span class="string">&quot;get-simple&quot;</span>, <span class="keyword">new</span> ErrorCodeSnippet(ErrorCode.ILLEGAL_ARGUMENT)));</span><br><span class="line"></span><br><span class="line">        actual.andExpect(jsonPath(<span class="string">&quot;$&quot;</span>).value(<span class="string">&quot;simple id is 1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 adoc에도 우리가 만든 커스텀 스니펫을 쓰겠다고 적어줘야 한다!</p><p>스니펫에 error-code-table이 추가됐음을 확인할 수 있다.</p><figure class="highlight adoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== 발생 가능한 예외</span></span><br><span class="line"></span><br><span class="line">operation::get-simple[snippets=<span class="emphasis">&#x27;error-code-table,http-request,http-response&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이렇게 해놓고 테스트를 성공시키면 다음과 같이 문서화가 된다.<br><img src="/img/restDocsErrorCode-2.png"></p><h1 id="참고문서"><a href="#참고문서" class="headerlink" title="참고문서"></a><em>참고문서</em></h1><p><a href="https://techblog.woowahan.com/2597/">https://techblog.woowahan.com/2597/</a></p><p><a href="https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing">https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing</a></p><p><a href="https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29">https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/project/">Project</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA를 왜 쓰나요?</title>
      <link>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</link>
      <guid>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/</guid>
      <pubDate>Wed, 29 Jun 2022 10:21:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.&lt;br&gt;객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.<br>객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스는 데이터 중심으로 설계된다.<br>객체지향은 참조의 방향이 정해져있지만, 데이터베이스는 하나의 외래키로 양쪽 모두 참조 가능하다.<br>동일성 비교를 객체는 인스턴스의 주소값으로 하고 데이터베이스는 기본키로 한다.<br>JPA는 이런 차이를 개발자가 신경쓰지 않게 해준다.<br>JPA는 반복적인 SQL 작성을 줄여준다.</p><h1 id="반복적인-SQL-작성"><a href="#반복적인-SQL-작성" class="headerlink" title="반복적인 SQL 작성"></a>반복적인 SQL 작성</h1><p>JDBC API로 Member 객체를 저장하거나 조회해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">        <span class="keyword">final</span> String sql = <span class="string">&quot;insert into member (id, name) values (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, member.getId());</span><br><span class="line">            statement.setString(<span class="number">2</span>, member.getName());</span><br><span class="line">            statement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Member 객체를 저장하는 데 정말 많은 코드가 많이 필요하다.<br>만약 테이블이 100개이면 저장하는 메서드 100개를 반복해서 만들어줘야 한다.</p><p>만약 데이터베이스를 컬렉션이라고 상상해보면 다음과 같지 않을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">members.add(member);</span><br></pre></td></tr></table></figure><p>JPA를 사용하면 컬렉션처럼 객체를 데이터베이스에 저장시킬 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entityManager.persist(member);</span><br></pre></td></tr></table></figure><p>JPA는 객체와 매핑 정보를 보고 적절한 SQL을 알아서 실행시킨다.<br>개발자는 반복적인 SQL 작성을 하지 않아도 된다.</p><h1 id="상속-구조-구현-문제"><a href="#상속-구조-구현-문제" class="headerlink" title="상속 구조 구현 문제"></a>상속 구조 구현 문제</h1><p><img src="/img/whyUseJpa-1.png"></p><p>데이터베이스는 객체 지향 상속을 지원하지 않으니 위 그림처럼 DTYPE 칼럼을 추가해서 어떤 자식 테이블과 관계가 있는지 확인할 수 있어야 한다.</p><p>문제는 이런 경우 개발자가 Keyboard 객체를 저장하려면</p><ol><li>ITEM 테이블에 insert 하는 쿼리</li><li>KEYBOARD 테이블에 insert 하는 쿼리</li></ol><p>두 개의 쿼리를 작성해야 한다.</p><p>데이터베이스에서 객체를 가져올 때는 ITEM과 KEYBOARD을 조인해서 데이터를 가져온 다음, Keyboard 객체를 생성해야 한다.</p><p>JPA의 경우 그냥 해당 객체를 저장(혹은 조회)하면 적절한 SQL을 실행해서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 저장</span></span><br><span class="line">entityManager.persist(keyboard);</span><br><span class="line"><span class="comment">// 조회</span></span><br><span class="line">Keyboard keyboard = entityManager.find(Keyboard.class, keyboardId);</span><br></pre></td></tr></table></figure><h1 id="연관-관계-문제"><a href="#연관-관계-문제" class="headerlink" title="연관 관계 문제"></a>연관 관계 문제</h1><p>Member 클래스가 Team과 연관 관계가 있다고 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Team team;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 Member를 조회하는 두 개의 SQL이 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> u.id, u.name, t.id, t.name </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">member</span> u </span><br><span class="line"><span class="keyword">JOIN</span> team t <span class="keyword">ON</span> member.team_id <span class="operator">=</span> team.id </span><br><span class="line"><span class="keyword">WHERE</span> u.id <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure><p>만약 굳이 Team 객체를 사용하지 않는 경우에는 첫번째 쿼리를 사용해서 Member 객체를 만드는게 낫다.<br>Team 객체를 사용해야 하는 경우는 두번째 쿼리로 Team 객체를 만들어서 Member 객체를 만들어야 한다.</p><p>문제는 개발자가 Member객체가 Team 객체에 값이 들어와 있는지를 확신할 수 없다는 점이다.</p><p>첫번째 쿼리로 만들어진 Member객체에게 getTeam()을 할 경우 Id만 채워진 객체가 반환되서 문제를 일으키게 된다.</p><p>그리고 만약 Team 객체에도 연관되는 객체가 있으면 쿼리는 더 복잡해질 가능성이 있다.<br>이 경우에도 Team 객체의 연관 객체의 데이터를 채워서 만들어 줄 것인지에 따라 SQL을 다르게 작성해야 한다.<br>다양한 연관관계를 상황에 따라 맞는 쿼리를 작성하는 건 상당히 힘든 작업이다.</p><p>반면 JPA에서는 연관 관계의 객체의 프로퍼티에 접근할 때 쿼리를 실행시켜서 해당 객체를 초기화한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아직 Team 객체는 id값만 채워져있다.</span></span><br><span class="line">Member member = entityManager.find(Member.class, memberId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이때 Team 객체의 데이터가 채워진다.</span></span><br><span class="line">member.getTeam().getName();</span><br></pre></td></tr></table></figure><h1 id="동일성-보장-문제"><a href="#동일성-보장-문제" class="headerlink" title="동일성 보장 문제"></a>동일성 보장 문제</h1><p>자바는 인스턴스의 주소값이 같으면 같은 객체로 분류하고, 데이터베이스는 기본키 값이 같으면 동일하다고 인식한다.<br>자바 객체를 저장하고 다시 조회했을 때 같은 객체를 반환하기 어렵다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 Member 객체를 조회하려면 DB에서 조회한 데이터로 새로운 객체를 만들어서 반환하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Connection connection = getConnection();</span><br><span class="line">    <span class="keyword">final</span> String sql = <span class="string">&quot;select id, name from member where id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        ResultSet resultSet = statement.executeQuery();</span><br><span class="line">        <span class="keyword">if</span> (!resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Member(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 이렇게 되면 객체를 저장하고 해당 객체를 다시 조회했을 때 같은 객체가 반환되지 않는다는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">memberDao.save(member);</span><br><span class="line">Member foundMember = memberDao.findById(<span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//실패!!</span></span><br></pre></td></tr></table></figure><p>분명 논리적으로는 같은 객체인데 DB에 저장하고 찾아온 객체가 자바에서는 다른 객체로 인식하게 된다.</p><p>JPA에서는 객체를 DB에 저장하고 조회해도 같은 객체(인스턴스 주소값이 같은)를 반환해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> Member(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">entityManager.persist(member);</span><br><span class="line">Member foundMember = entityManager.find(Member.class, <span class="number">1L</span>);</span><br><span class="line">assertThat(member).isEqualTo(foundMember);<span class="comment">//성공!!</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">자바 ORM 표준 JPA 프로그래밍</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/06/29/whyUseJpa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Transactional 어노테이션</title>
      <link>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/</guid>
      <pubDate>Mon, 16 May 2022 08:35:14 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;트랜잭션이 무엇인지 알아본다.&lt;br&gt;@Transactional의 Propagation 옵션을 알아본다.&lt;br&gt;@Transactional의 롤백 기준을 알아본다.&lt;br&gt;@Transa</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>트랜잭션이 무엇인지 알아본다.<br>@Transactional의 Propagation 옵션을 알아본다.<br>@Transactional의 롤백 기준을 알아본다.<br>@Transactional 적용 실패하는 경우를 알아본다.</p><h1 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션?"></a>트랜잭션?</h1><p>모두 반드시 성공해야 하는 연속된 작업들을 트랜잭션이라 한다.<br>만약 작업들 중 하나만 실패해도 모든 작업들이 어플리케이션의 상태를 변경시키지 않은 상태로 돌려놔야 한다.</p><p>만약 하나의 지하철 노선에 등록할 때 구간도 같이 저장해야 한다고 가정하자.<br>이때 INSERT 문이 두 번 사용될 것이다.<br>개발자는 이를 하나의 작업 단위로 인식해서 하나의 트랜잭션으로 관리할 수 있다.<br>노선을 등록하는데 성공했더라도 구간이 저장안되면 노선도 저장되서는 안되기 때문이다.</p><p>트랜잭션 진행 중에 문제가 생길 경우 그 작업을 진행하기 이전으로 DB를 롤백시킨다.</p><h1 id="JDBC의-트랜잭션"><a href="#JDBC의-트랜잭션" class="headerlink" title="JDBC의 트랜잭션"></a>JDBC의 트랜잭션</h1><p>JDBC는 statement를 트랜잭션에서 진행할 수 있게한다.<br>JDBC의 한 Connection의 수행마다 auto-commit한다.<br>즉 모든 statement를 하나의 트랜잭션이라 생각하고 수행 이후 자동으로 반영한다.</p><p>만약 여러 statement를 하나의 트랜잭션에서 진행하고 싶다면 connection의 autoCommit을 꺼놓고 트랜잭션을 종료하고 싶을 때 명시적으로 커밋해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// auto-commit 꺼놓음.</span></span><br><span class="line"><span class="comment">// ... 작업들...</span></span><br><span class="line">connection.commit(); <span class="comment">//명시적으로 커밋.</span></span><br></pre></td></tr></table></figure><h1 id="스프링의-트랜잭션"><a href="#스프링의-트랜잭션" class="headerlink" title="스프링의 트랜잭션"></a>스프링의 트랜잭션</h1><p>스프링에서는 여러가지 트랜잭션 관리 기능을 제공한다.</p><h2 id="명시적-트랜잭션"><a href="#명시적-트랜잭션" class="headerlink" title="명시적 트랜잭션"></a>명시적 트랜잭션</h2><p>트랜잭션의 범위를 자세하게 정하고 싶을 땐 명시적 트랜잭션을 사용한다.</p><p>Transaction Template는 개발자가 직접 트랜잭션 범위를 명시적으로 결정할 수 있다.</p><h2 id="선언적-트랜잭션-Transactional"><a href="#선언적-트랜잭션-Transactional" class="headerlink" title="선언적 트랜잭션 @Transactional"></a>선언적 트랜잭션 @Transactional</h2><p>클래스나 메서드에 @Transactional 어노테이션을 붙이면 글로벌 트랜잭션을 정해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 메서드 위에 두면 메서드 실행 중 예외가 발생하면 롤백한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        lineRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 위에 두면 클래스에 해당하는 메서드들을 @Transactional을 붙인 셈이 된다.</p><h3 id="Transactional의-여러가지-속성"><a href="#Transactional의-여러가지-속성" class="headerlink" title="@Transactional의 여러가지 속성"></a>@Transactional의 여러가지 속성</h3><p>트랜잭션에는 여러가지 속성을 설정해줄 수 있다. 예시코드를 통해 이해해보자.</p><p>일단 하나의 서비스에서 방을 DB에 저장하고 예외를 일으키는 메서드를 트랜잭션으로 처리하고자 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionalService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;other&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>그리고 다른 서비스에서 아까 만든 서비스를 주입받아 예외를 만드는 메서드를 호출하는 메서드를 트랜잭션 처리해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionalService.throwSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 OuterService의 메서드를 실행하기 위한 Runner 클래스를 만들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OuterService outerService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(OuterService outerService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outerService = outerService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        outerService.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이제 어플리케이션을 실행하면 외부 트랜잭션 메서드가 실행될 것이다.</p><h3 id="1-전파-옵션"><a href="#1-전파-옵션" class="headerlink" title="1. 전파 옵션"></a>1. 전파 옵션</h3><p>트랜잭션 수행 중 다른 트랜잭션을 호출하는 상황에서 어떻게 처리하는지 다루는 옵션.</p><ul><li><p><strong>REQUIRED</strong> : 트랜잭션 수행 중 다른 트랜잭션 호출되면 먼저 수행되던 거에 합쳐서 수행. propagation 기본 설정값.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>다른 설정을 안하면 REQUIRED 옵션으로 설정된다.<br>이 상태로 실행시키면 DB에는 아무 일도 일어나지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>UnexpectedRollbackException은 외부 트랜잭션이 내부 트랜잭션이 롤백됐음을 예상하지 못했다는 의미다.</p><p>외부 트랜잭션은 내부에서 다른 트랜잭션의 성공 여부 상관없이 커밋하려 한다.<br>중간에 내부 트랜잭션이 실패해서 롤백됐으면 이를 외부 트랜잭션에게 알려줘야 해서 생긴 예외다.</p><p>REQUIRED 옵션은 내부 트랜잭션과 외부 트랜잭션의 범위가 논리적으로는 분리되지만 물리적으로는 각 스코프가 같은 물리적 트랜잭션을 갖게 된다. 그래서 외부 트랜잭션은 내부의 트랜잭션의 rollback-only에 따라 영향을 받는다.</p></li><li><p><strong>SUPPORTS</strong> : 만약 트랜잭션이 진행되고 있는 상태에서 호출 시 해당 트랜잭션에 참여, 아닐 경우 트랜잭션 하지 않고 진행.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//외부 메서드가 트랜잭션이 아니면</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 어떻게 될까?</p><p>그 결과 두 메서드의 DB 업데이트가 모두 이뤄진다.(예외를 일으켜도 DB 업데이트가 이뤄졌다.)<br>사실 두 메서드 모두 트랜잭션 처리 되지 않았다.</p></li><li><p><strong>REQUIRED_NEW</strong> : 이미 진행 중인 트랜잭션이 있어도 새로운 트랜잭션 생성해서 진행. 서로 물리적으로 독립된 트랜잭션을 생성.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션을 변경하고 실행하면 외부 트랜잭션만 커밋된다.<br>내부 트랜잭션은 따로 트랜잭션으로 생성되서 예외 탐지하고 롤백됐고 외부 트랜잭션은 내부 트랜잭션의 실패 여부와 상관없이 트랜잭션을 진행해서 커밋했다.</p></li><li><p><strong>NESTED</strong> : 이미 진행 중인 트랜잭션의 중첩된 트랜잭션을 생성. 물리적으로는 하나의 트랜잭션인데 저장점을 추가하는 방식. 중첩된 트랜잭션은 외부 트랜잭션에 영향을 끼치지 못하지만 내부 트랜잭션은 외부 트랜잭션의 롤백에 영향 받는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Trasactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이러면 내부 트랜잭션은 롤백되지만 외부 트랜잭션은 잘 실행된다.</p><p>반면 내부 트랜잭션은 예외를 던지지 않는데 외부 트랜잭션에서 예외가 발생한 경우는 어떨까?<br>모든 트랜잭션이 롤백된다! 내부가 성공해도 외부가 롤백되면 모두 롤백된다.</p></li></ul><h3 id="2-롤백-조건-옵션"><a href="#2-롤백-조건-옵션" class="headerlink" title="2. 롤백 조건 옵션"></a>2. 롤백 조건 옵션</h3><p>트랜잭션이 롤백되는 조건을 다룬다.<br>선언적 트랜잭션은 기본적으로 <strong>unchecked exception와 Error</strong>가 발생하면 롤백한다.<br>Checked exception은 개발자가 반드시 처리한 예외이니 예상하지 못한 예외인 unchecked exception과 Error가 발생하면 롤백한다.</p><p>@Transactional 어노테이션의 속성을 통해 롤백조건을 다르게 할 수 있다.<br>관련 속성은 다음과 같다.</p><ul><li><strong>rollbackFor</strong> : 추가로 롤백되어야 할 예외를 추가할 수 있다.</li><li><strong>rollbackForClassName</strong> : 추가로 롤백되어야 할 예외 클래스의 이름을 배열로 받아 추가할 수 있다.</li><li><strong>noRollbackFor</strong> : 롤백하지 않으려는 예외를 정할 수 있다.</li><li><strong>noRollbackForClassName</strong> : 롤백하지 않으려는 예외 클래스으 이름을 배열로 받아 정할 수 있다.</li></ul><h3 id="3-readOnly"><a href="#3-readOnly" class="headerlink" title="3. readOnly"></a>3. readOnly</h3><p>데이터를 수정하지 않는 트랜잭션을 데이터를 수정하려고 하는 경우를 막고 싶을 수 있다.<br>이럴 때 사용되는게 readOnly 속성이다.</p><p>readOnly는 읽기 전용일 경우 true로 세팅해주면 읽기 위한 트랜잭션임을 암시한다.<br>다만 readOnly가 붙은 트랜잭션에서 데이터를 수정하려고 할 때 반드시 실패한다는 의미는 아니다.<br>트랜잭션 매니저에 따라 readOnly를 지원하지 않는 경우 readOnly 설정은 무시된다.</p><h3 id="4-그-외-속성들"><a href="#4-그-외-속성들" class="headerlink" title="4. 그 외 속성들"></a>4. 그 외 속성들</h3><p>트랜잭션의 격리 수준을 결정하는 isolation이나 트랜잭션의 제한 시간을 정하는 timeout 속성들도 존재한다.</p><h2 id="Transation과-AOP"><a href="#Transation과-AOP" class="headerlink" title="@Transation과 AOP"></a>@Transation과 AOP</h2><p>선언적 트랜잭션은 AOP 프록시를 통해 활성화 된다.<br>프록시로 구현되다보니 트랜잭션에 수행하는 프록시 객체와 진짜 객체가 서로 다를 수 있다.<br>간략하게 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalService transactionalService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(TransactionalService transactionalService, RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalService = transactionalService;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        transactionalService.throwSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;done! with throw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 예시로 사용했던 서비스는 사실 AOP 프록시를 사용하면 다음과 같이 된다.<br>외부에서 doSomething 메서드를 호출 -&gt; (프록시)트랜잭션 시작! -&gt; (진짜) doSomething 수행! -&gt; (프록시)트랜잭션 끝!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 프록시객체 </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> 진짜객체;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 트랜잭션_붙은_메서드() &#123;</span><br><span class="line">        트랜잭션_시작;</span><br><span class="line">        진짜객체.트랜잭션_붙은_메서드();</span><br><span class="line">        트랜잭션_끝;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 다음과 같은 경우는 어떻게 될까??</p><p>트랜잭션이 적용되지 않은 public 메서드를 통해서 트랜잭션 붙은 메서드를 호출해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterService</span><span class="params">(RoomRepository roomRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomRepository = roomRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        roomRepository.createRoom(Room.fromPlainPassword(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 doSomething은 롤백될까? 답은 아니다!!!!</p><p>왜냐면 프록시 객체는 execute 메서드를 실행시킬 때 내부에서 어떤 메서드를 부르는지 모른다. 그래서 트랜잭션을 적용시켜주지 못한다.</p><p>그래서 <strong>private 메서드는 @Transactional을 붙이는 건 의미 없다.</strong> 트랜잭션 처리 해줄 프록시 객체가 해당 메서드에 접근할 수 없기 때문이다.</p><p>그리고 <strong>public이 붙었더라도 트랜잭션이 붙지 않은 메서드를 통해서 호출하면 트랜잭션이 적용되지 않는다</strong>!!!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/16/spring/transactional/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Bean Validation으로 검증하기</title>
      <link>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/12/spring/validation/</guid>
      <pubDate>Thu, 12 May 2022 11:41:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Bean-Validation&quot;&gt;&lt;a href=&quot;#Bean-Validation&quot; class=&quot;headerlink&quot; title=&quot;Bean Validation&quot;&gt;&lt;/a&gt;Bean Validation&lt;/h1&gt;&lt;h2 id=&quot;일반적인-유효성-검사-로</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h1><h2 id="일반적인-유효성-검사-로직"><a href="#일반적인-유효성-검사-로직" class="headerlink" title="일반적인 유효성 검사 로직"></a>일반적인 유효성 검사 로직</h2><p>지켜져야 할 조건에 맞지 않은 상황에 로직을 진행하려는 경우  예외를 터트려서 의도하지 않은 진행을 막을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.isBlank()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ExceptionMessage.BLANK_LINE_NAME.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자로 전달받은 문자열이 빈값이면 예외를 터지도록 해서 Name 객체는 반드시 이름을 가지도록 만들 수 있다.</p><p>하지만 이런 로직이 비슷하게 여러 클래스에 흩어져 있다면 중복이 많아지고 관리하기도 힘들어진다.</p><p>이런 검증을 각 </p><blockquote><p>Bean Validation과 Hibernate Validator</p></blockquote><p>Bean Validation은 일종의 명세이지 실제 작동하는 코드는 아니다.<br>이 명세를 구현한 것 중 하나가 Hibernate Validator이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/12/spring/validation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DTO에 대하여</title>
      <link>https://yangdongjue5510.github.io/2022/05/07/java/dto/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/07/java/dto/</guid>
      <pubDate>Sat, 07 May 2022 06:09:22 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DTO가 무엇인지 설명할 수 있다.&lt;/li&gt;
&lt;li&gt;DTO가 어떤 곳에서 활용되는지 설명할 수 있다.&lt;/li&gt;
&lt;li&gt;DTO의 주의점을 설명할 수 있다.&lt;/li&gt;
&lt;/o</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><ol><li>DTO가 무엇인지 설명할 수 있다.</li><li>DTO가 어떤 곳에서 활용되는지 설명할 수 있다.</li><li>DTO의 주의점을 설명할 수 있다.</li></ol><h1 id="DTO가-무엇인가"><a href="#DTO가-무엇인가" class="headerlink" title="DTO가 무엇인가"></a>DTO가 무엇인가</h1><p>외부 UI 계층에 여러 데이터를 전송해야 하는 경우 데이터를 한 객체 모아서 한번에 보내면 원격 호출 횟수를 줄일 수 있다.<br>반대로 외부에서 입력받은 데이터를 한 객체에 모아서 가져오는 것이 효율적이다.</p><p>이처럼 다른 계층에서 필요한 데이터(혹은 내가 필요한 데이터)만 가지고 있는 객체를 데이터 전송 객체 DTO라고 한다.</p><h2 id="DTO를-사용하는-이유"><a href="#DTO를-사용하는-이유" class="headerlink" title="DTO를 사용하는 이유"></a>DTO를 사용하는 이유</h2><p>비즈니스 로직을 수행하던 도매인 객체를 그대로 반환하면 다음과 같은 문제가 생긴다.</p><ol><li>도매인 객체가 비밀번호나 주민번호 같이 감춰야 할 정보를 포함하고 있을 수 있다.<br>도매인 객체를 그대로 반환하면 그 정보가 노출 될 수 있다.<br>-&gt; DTO를 사용하면 보여주고 싶은 정보만 선택해서 보낸다.</li><li>도매인 객체의 모든 정보를 사용하지 않을 수 있다.<br>다른 계층에서 사용하지 않는 데이터까지 모두 전달하는 경우는 불필요한 비용을 만든다.</li><li>도매인 객체가 변경되는 경우 외부 UI로직에도 변경 해줘야 한다.<br>(서로 의존하게 된다.)<br>-&gt; DTO를 사용하면 도매인 객체에 변경이 생겨도 UI 로직까지 영향을 미치지 않을 수 있다.</li><li>도매인 객체의 비즈니스 로직(메서드)까지 전달해주게 된다.<br>UI 계층에서는 사용하지 않는 비즈니스 로직까지 외부에 전달하게 된다.<br>심지어는 UI 계층에서 해당 메서드를 실행시켜 도매인 객체의 상태를 변경 시킬 수 있다.<br>-&gt; DTO에는 비즈니스 로직을 포함하지 않는다.</li></ol><p>어플리케이션의 규모가 크지 않은 경우는 도매인 객체를 그대로 반환하는게 더 나은 선택일 수 있다.<br>UI와 백엔드가 서로 분리되어 있는 경우, 만드는 어플리케이션이 큰 경우는 DTO를 고려해야 한다.</p><p>추가로 DTO가 직렬화되는 로직을 내부에 캡슐화 할 수 있다는 강점도 있다.</p><h2 id="DTO의-예시"><a href="#DTO의-예시" class="headerlink" title="DTO의 예시"></a>DTO의 예시</h2>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/java/">Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/07/java/dto/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring IoC 컨테이너, 컴포넌트 스캔, 빈 생명주기</title>
      <link>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/</link>
      <guid>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/</guid>
      <pubDate>Thu, 05 May 2022 12:21:02 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약 (다음 질문의 정답을 안다면 이 포스트를 읽지 않아도 된다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;IoC 컨테이너와 ApplicationContext는 완전히 같은 개념인가?&lt;/li&gt;
&lt;li&gt;IoC 컨테이</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약 (다음 질문의 정답을 안다면 이 포스트를 읽지 않아도 된다.)</p></blockquote><ol><li>IoC 컨테이너와 ApplicationContext는 완전히 같은 개념인가?</li><li>IoC 컨테이너를 구성하는 방법은 어떤 것이 있는가?</li><li>BeanFactory와 ApplicationContext의 차이를 알고 있는가?</li></ol><h1 id="IoC-컨테이너"><a href="#IoC-컨테이너" class="headerlink" title="IoC 컨테이너"></a>IoC 컨테이너</h1><p>스프링의 IoC 컨테이너는 객체를 인스턴스화하고 구성 및 조합하고 수명주기를 관리하는 역할을 한다.</p><h2 id="스프링이-제공하는-IoC-컨테이너"><a href="#스프링이-제공하는-IoC-컨테이너" class="headerlink" title="스프링이 제공하는 IoC 컨테이너"></a>스프링이 제공하는 IoC 컨테이너</h2><p>스프링의 IoC 컨테이너는 두 가지 유형의 컨테이너를 제공한다.</p><ol><li><strong>BeanFactory 기반 컨테이너</strong></li><li><strong>ApplicationContext 기반 컨테이너</strong></li></ol><p>우리가 가장 흔히 아는 <strong>ApplicationContext는 IoC 컨테이너 중 하나</strong>이다.</p><p>BeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.<br>ApplicationContext는 BeanFactory의 기능을 확장한 버전이다.</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.<br>BeanFactory는 메타데이터를 기반으로 빈 객체를 생성하고 구성한다.</p><p>이때 BeanFactory는 XML 기반으로 메타데이터를 사용한다.<br>BeanFactory는 Lazy Loadaing으로 빈 객체를 등록한다.</p><h4 id="코드로-이해하기"><a href="#코드로-이해하기" class="headerlink" title="코드로 이해하기"></a>코드로 이해하기</h4><p>User라는 POJO 클래스가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 클래스를 XML을 통해 Bean 등록해보자.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>config.xml에 user라는 이름으로 빈 등록을 해줬다.<br>init-method를 통해 빈 객체가 생성될 때 User#setIsBeanInitialized를 실행하도록 했다.</p><p>만약 User가 빈 객체로 생성되면 IS_BEAN_INITIALIZED가 true가 될 것 이다.</p><p>테스트 코드로 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;XML 기반으로 BeanFactory 레이지 로딩 확인하기&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beanFactoryLazyLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        Resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line">        BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">boolean</span> isCreated = User.IS_BEAN_INITIALIZED;</span><br><span class="line">        User user = (User) factory.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        assertThat(isCreated).isFalse();</span><br><span class="line">        assertThat(isCreatedAfterGetBean).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 Lazy Loading을 확인할 수 있다.<br>Lazy Loading은 BeanFactory에서 빈 객체를 가져올 때 해당 객체를 생성한다는 의미다.</p><p>그래서 User.IS_BEAN_INITIALIZED가 빈 객체를 가져올 때 true가 됨을 확인 할 수 있다.</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext는 BeanFactory의 하위 인터페이스다.<br>따라서 BeanFactory의 모든 기능을 제공한다.</p><p>다만 ApplicationContext는 웹 어플리케이션, AOP에 필요한 더 많은 기능을 제공한다.</p><p>ApplicationContext의 선언부를 통해 어떤 기능을 추가로 제공하는 지 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>EnvironmentCapable</strong> 인터페이스 : 프로파일과 프로퍼티를 다루는 Environment를 접근할 수 있게 한다.</li><li><strong>ListableBeanFactory</strong> 인터페이스 : BeanFactory의 기능을 지원하기 위한 인터페이스. 빈 객체를 생성 관리한다.</li><li><strong>HierarachicalBeanFactory</strong> 인터페이스 : BeanFactory 구현체 사이의 계층 구조를 확인할 수 있게 한다.</li><li><strong>MessageSource</strong> 인터페이스 : 국제화(i18n)을 제공하는 인터페이스</li><li><strong>ApplicationEventPublisher</strong> 인터페이스 : 이벤트를 발생시키는 기능을 제공한다.</li><li><strong>ResourcePatternResolver</strong> 인터페이스 : 리소스를 읽어오는 기능을 제공한다.</li></ol><h4 id="ApplicationContext의-메타데이터-설정-방법들"><a href="#ApplicationContext의-메타데이터-설정-방법들" class="headerlink" title="ApplicationContext의 메타데이터 설정 방법들"></a>ApplicationContext의 메타데이터 설정 방법들</h4><p>BeanFactory와 달리 ApplicationContext의 중요한 기능 중 하나는 메타데이터를 다양한 방식으로 할 수 있다.</p><p>BeanFactory는 XML 외부 파일로 컨테이너를 설정해줘야 했다.<br>ApplicationContext는 어노테이션 기반 설정도 지원한다!</p><p>아까 사용했던 User POJO 클래스를 다시 사용하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 @Configuration 어노테이션을 붙인 설정 파일로 Bean 등록해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationUserBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setIsBeanInitialized();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Bean 어노테이션이 붙은 메서드가 실행되면 반환되는 객체를 빈 객체로 컨테이너에 등록한다.<br>그리고 XML의 init-method 대신 메서드 안에 setIsBeanInitialized 메서드를 호출했다.</p><p>테스트로 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@DisplayName(&quot;어노테이션 기반(설정 파일)로 빈 객체 생성 확인하기&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">applicationContextBeanCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// given</span></span><br><span class="line">       ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// when</span></span><br><span class="line">       <span class="keyword">boolean</span> isCreated = User.IS_BEAN_INITIALIZED;</span><br><span class="line">       User user = (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       <span class="keyword">boolean</span> isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// then</span></span><br><span class="line">       assertThat(isCreated).isTrue();</span><br><span class="line">       assertThat(isCreatedAfterGetBean).isTrue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>설정 클래스를 전달해서 ApplicationContext를 생성했다.<br>ApplicationContext는 eager-loading이라 컨테이너가 생성됐을 때 빈 객체를 생성한다!</p><p>그래서 빈 객체를 호출하기 전에도 이미 빈 객체가 생성되어 있다는 의미다!<br>(결국 모든 빈객체를 eager-loading하기 때문에 ApplicationContext는 비교적 무거운 IoC container이다.)</p><h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h1><p>ComponentScan은 특정 패키지에서 @Component가 붙은 클래스를 빈 객체 등록하는 방법이다.<br>일일히 빈 객체를 메서드로 작성하지 않아도 된다는 장점이 있다.</p><p>이전에 @Bean 어노테이션으로 등록했던 방식 대신 ComponentScan을 활용해보자.</p><p>먼저 빈등록하고 싶은 클래스에 @Component 어노테이션을 달아주자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        setIsBeanInitialized();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitializeBean 인터페이스로 해당 클래스가 빈 객체로 만들어지고 나서 setIsBeanInitialized()를 실행하도록 했다.</p><p>이제 설정 파일에 @ComponentScan 어노테이션을 붙여주자!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;nextstep.helloworld.core.componentscan.user&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationUserBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@ComponentScan은 특정 패키지를 기준으로 해당 패키지와 하위 패키지의 @Component 어노테이션이 붙은 클래스를 빈등록한다. (위 예시는 User클래스가 있는 패키지를 기준으로 잡았다.)</p><p>@Bean을 붙여서 빈객체를 생성해줬던 메서드를 제거할 수 있게됐다!</p><blockquote><p>그렇다면 스프링 부트에서는 어떻게 ComponentScan을 하는 걸까??</p></blockquote><p>스프링 부트를 사용하면 @Configuration을 붙인 설정파일 없이도 @Component를 붙인 클래스를 빈등록 해준다.<br>왜 그렇게 되는 건지 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스프링 부트 프로젝트를 만들면 먼저 @SpringBootApplication이 붙은 클래스가 프로젝트 패키지에 생성된다.<br>@SpringBootApplication에 들어가보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 @SpringBootApplication 어노테이션에는 @ComponentScan 어노테이션이 포함되어 있다.<br>basePackages가 따로 설정하지 않았으니 해당 클래스가 속한 패키지를 기준으로 컴포넌트 스캔을 진행하게 된다.<br>그리고 @Filter 어노테이션으로 특정 클래스들을 컴포넌트 스캔에서 제외할 수 있다.</p><h1 id="Bean-생명주기"><a href="#Bean-생명주기" class="headerlink" title="Bean 생명주기"></a>Bean 생명주기</h1><p>Bean 객체의 생명 주기를 이해하기 위해서는 Bean을 생성하고 관리하는 스프링 컨테이너의 생명주기를 이해해야 한다.</p><h2 id="스프링-컨테이너의-생명주기"><a href="#스프링-컨테이너의-생명주기" class="headerlink" title="스프링 컨테이너의 생명주기"></a>스프링 컨테이너의 생명주기</h2><ul><li>컨테이너 초기화</li><li>컨테이너 종료</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@DisplayName(&quot;컨테이너 생명주기&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">applicationContextLifeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 초기화</span></span><br><span class="line">       AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 사용</span></span><br><span class="line">       User user = (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 종료</span></span><br><span class="line">       applicationContext.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="컨테이너-초기화"><a href="#컨테이너-초기화" class="headerlink" title="컨테이너 초기화"></a>컨테이너 초기화</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigurationUserBean.class);</span><br></pre></td></tr></table></figure><p>AppliactionContext 객체를 생성하면 스프링 컨테이너를 초기화한다.<br>이 과정에서 메타데이터를 읽어서 알맞은 빈 객체를 생성하고 각 빈을 연결(주입)하게 된다.</p><h3 id="컨테이너-종료"><a href="#컨테이너-종료" class="headerlink" title="컨테이너 종료"></a>컨테이너 종료</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.close();</span><br></pre></td></tr></table></figure><p>컨테이너를 close 메서드를 통해 종료하면 컨테이너가 관리하던 빈 객체들도 모두 소멸된다.<br>(이때 프로퍼티 스코프인 객체들은 소멸되지 않는다. )</p><h2 id="빈-객체의-생명-주기"><a href="#빈-객체의-생명-주기" class="headerlink" title="빈 객체의 생명 주기"></a>빈 객체의 생명 주기</h2><p>스프링 컨테이너의 생명주기를 보면 짐작할 수 있듯이 일반적인 빈 객체는 컨테이너의 통제에 따라 생명 주기를 진행한다.</p><ul><li><strong>객체 생성</strong> -&gt; ApplicationContext가 생성되면서 빈 객체 생성</li><li><strong>의존 설정</strong> -&gt; ApplicationContext가 메타데이터를 기반으로 의존 주입</li><li><strong>초기화</strong> -&gt; 의존관계가 모두 설정하고 나면 빈 객체의 초기화에 해당하는 메서드를 수행</li><li><strong>소멸</strong> -&gt; ApplicationContext를 종료하면 빈 객체 소멸에 해당하는 메서드를 수행</li></ul><h3 id="초기화와-소멸"><a href="#초기화와-소멸" class="headerlink" title="초기화와 소멸"></a>초기화와 소멸</h3><p>의존관계까지 모두 주입되고 나면 빈 객체가 등록될 때 어떤 행위를 하도록 하고싶거나,<br>특정 빈 객체가 소멸 될 때 어떤 행위를 하기 원할 때가 있다.</p><p>이런 의도를 빈 생명 주기 중 초기화와 소멸에서 수행할 수 있다.</p><h4 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h4><p>빈 객체가 생성되고 나서 어떤 메서드를 실행시키고 싶은 경우 초기화 단계에서 수행한다.<br>이를 설정하기 위해서는 여러가지 방법이 있다.</p><ol><li><strong>@PostConstruct</strong></li><li><strong>InitializingBean</strong> 인터페이스</li><li><strong>init-method</strong></li></ol><p>코드로 이해해보자.<br>User 클래스가 빈 객체로 등록될 때 특정 메서드를 실행하게 만들자.</p><p>먼저 <strong>@PostConstruct</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 빈 객체가 등록되고 나서 수행됐으면 하는 메서드에 @PostConstruct를 붙여주면 된다.</p><p><strong>InitializingBean 인터페이스</strong>를 구현하는 방법도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        setIsBeanInitialized();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterPropertiesSet() 메서드 안에 빈 객체가 등록될 때 수행할 행동을 적어놓으면 된다.</p><p>마지막으로 <strong>xml init-method</strong>를 사용하는 방법이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bean 태그 안에 init-method 속성에 빈 객체 생성 될 때 수행될 메서드 이름을 적어주면 된다.</p><h4 id="소멸"><a href="#소멸" class="headerlink" title="소멸"></a>소멸</h4><p>빈 객체가 사라질 때 특정 행동을 하라고 설정할 수 있다.<br>소멸을 구현하는 데에도 여러 방법이 있다.</p><ol><li><strong>@PreDestroy</strong></li><li><strong>DisposableBean</strong> 인터페이스</li><li><strong>destroy-method</strong></li></ol><p>코드로 이해해보자.<br>User 클래스의 빈 객체가 폐기될 때 특정 메서드를 실행하게 만들자.</p><p><strong>@PreDestory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DisposableBean 인터페이스</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsBeanInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IS_BEAN_INITIALIZED = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XML destroy-method</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nextstep.helloworld.core.componentscan.user.User&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;setIsBeanInitialized&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 빈 객체가 제거 될 때(컨테이너가 종료될 때) 해당 메서드를 실행시킬 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/05/05/spring/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>왜 스프링을 쓰는 걸까??(IoC, DI)</title>
      <link>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/</guid>
      <pubDate>Tue, 26 Apr 2022 10:34:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;의존 역전과 유연함을 위해서 DI하도록 객체를 설계하는 경우,&lt;br&gt;매번 해당 객체를 사용할 때마다 필요한 객체를 찾아서 주입해줘야 한다.&lt;br&gt;스프링 프레임워크는 DI를 대신해주</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>의존 역전과 유연함을 위해서 DI하도록 객체를 설계하는 경우,<br>매번 해당 객체를 사용할 때마다 필요한 객체를 찾아서 주입해줘야 한다.<br>스프링 프레임워크는 DI를 대신해주는 역할을 한다.</p><h1 id="유연한-설계를-위해서"><a href="#유연한-설계를-위해서" class="headerlink" title="유연한 설계를 위해서"></a>유연한 설계를 위해서</h1><p>객체지향 설계 원칙 중 SOLID 원칙이 있다.<br>그 중 D에 해당하는 의존 역전 원칙은 상위 모듈이 하위 모듈의 구현에 의존하지 말고, 상위 모듈이 정한 추상 타입에 하위 모듈들이 의존해야 한다는 규칙이다.</p><p>쉽게 말하면 상위 기능에서 정한 인터페이스나 추상 클래스 타입으로 하위 클래스들이 협력해야 한다는 의미이다.<br>이렇게 하면 상위 모듈은 하위 모듈의 내부 구현이 달라져도 상관하지 않게 되고 기능이 확장에 열리게 된다.</p><h2 id="예시로-좀-더-알아보자"><a href="#예시로-좀-더-알아보자" class="headerlink" title="예시로 좀 더 알아보자."></a>예시로 좀 더 알아보자.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReader에서 파일을 읽어서 문자열을 반환하는 책임을 한다고 하자.<br>이 클래스와 협력하는 NamePrinter를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        System.out.println(fileReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReader 객체를 만들어서 readName을 호출해서 출력한다!</p><blockquote><p>그런데 이름을 읽어오는 방법이 파일만 있을까?</p></blockquote><p>그렇다. 파일만 이름을 저장하라는 법은 없다.<br>이번엔 DBReader를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBReader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DB에서 이름을 읽어오는 로직이 존재한다고 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Names From DB...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 DBReader를 만들었어도 아직 DB에서 읽은 이름을 출력할 수 없다.<br>왜냐면 NamePrinter는 FileReader에 의존하고 있어서 파일에서 읽어온 이름만 출력할 수 있다.<br>그러면 NamePrinter의 FileReader를 DBReader로 바꾸면?<br>읽는 방식이 바뀌었다고 상위 기능인 출력 기능을 담당하는 NamePrinter를 수정해야 되면 문제가 있다.</p><h3 id="변경이-많은-곳을-추상화"><a href="#변경이-많은-곳을-추상화" class="headerlink" title="변경이 많은 곳을 추상화"></a>변경이 많은 곳을 추상화</h3><p>이름을 읽어오는 곳이 경우의 수가 다양하니까 인터페이스로 추상화하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">readNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 FileReader와 DBReader가 해당 인터페이스를 구현해서 의존하도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DB에서 이름을 읽어오는 로직이 존재한다고 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Names From DB...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아직 할 일이 남았다.<br>상위 모듈인 NamePrinter도 추상타입인 NameReader에 의존하도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamePrinter</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 생상자의 인자로 의존하도록 했다.<br>인자로 구현체를 전달해주어서 원하는 방식으로 이름을 읽어들이면 된다!</p><p>물론 의존성 주입은 생성자로만 하는 건 아니다. Setter 메서드로도 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameReader</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 실행해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dependencyInjection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter();</span><br><span class="line">    namePrinter.setNameReader(<span class="keyword">new</span> FileReader());</span><br><span class="line">    namePrinter.printNames(); <span class="comment">//File에서 읽은 이름 출력</span></span><br><span class="line"></span><br><span class="line">    namePrinter.setNameReader(<span class="keyword">new</span> DBReader());</span><br><span class="line">    namePrinter.printNames(); <span class="comment">//DB에서 읽은 이름 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>의존성을 주입하는 방식으로 변경하니, NamePrinter는 어떤 곳에서 이름을 읽어오던 이름을 출력할 수 있게 됐다!</p><h1 id="좋은-설계를-쉽게-사용하기-위해서"><a href="#좋은-설계를-쉽게-사용하기-위해서" class="headerlink" title="좋은 설계를 쉽게 사용하기 위해서"></a>좋은 설계를 쉽게 사용하기 위해서</h1><p>DI를 활용해서 유연하고 확장하기 좋은 설계를 만들었다.<br>그런데 조금 걸리는게 있다.</p><p>클라이언트가 PrintName을 통해 이름을 출력하고 싶으면 의존성을 주입해줘야 한다.<br>setter를 쓰던 생성자를 통해 주입을 해주던 매번 해줘야 된다는 의미다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자 주입을 하는 경우</span></span><br><span class="line">NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter(<span class="keyword">new</span> DBReader());</span><br><span class="line">namePrinter.readNames();</span><br><span class="line"><span class="comment">//세터 주입을 하는 경우</span></span><br><span class="line">NamePrinter namePrinter = <span class="keyword">new</span> NamePrinter();</span><br><span class="line">namePrinter.setNameReader(<span class="keyword">new</span> FileReader());</span><br><span class="line">nameReader.readNames();</span><br></pre></td></tr></table></figure><p>흠. 꽤 번거롭다. 지금은 두개의 객체가 협력하는 책임이라 그나마 봐줄만 하지만,<br>만약 추상화 수준이 높은 객체의 책임을 실행하려면 수많은 객체를 주입해줘야 할 것이다.</p><p>이 문제를 스프링이 해결해줄 수 있다.<br>스프링은 객체를 생성하는 과정을 프로그래머가 아닌 자신이 한다.<br>그리고 만들어진 객체를 스프링이 관리한다.</p><h2 id="예제를-통해-확인하기"><a href="#예제를-통해-확인하기" class="headerlink" title="예제를 통해 확인하기"></a>예제를 통해 확인하기</h2><p>스프링을 통해 객체를 관리하려면 스프링에게 어떤 객체를 관리할 것인지 알려줘야 한다.<br>자세히보면 @Component 어노테이션을 붙였다.<br>이 객체를 만들고 관리하는 일은 스프링이 해달라는 표시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  NameReader nameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamePrinter</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(nameReader.readNames());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameReader</span><span class="params">(NameReader nameReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nameReader = nameReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>근데 잠깐만, 스프링이 객체를 생성하려면 NameReader 객체가 필요하다.(생성자가 그것 뿐이니,,)<br>그러면 NameReader 객체는 어디서 가져오는건가?!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">implements</span> <span class="title">NameReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//여기서 파일을 읽는 로직 작성됐음을 가정</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Read some Files&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 필요했던 NameReader의 구현체에도 @Component 어노테이션을 붙여서 스프링이 이 객체를 생성해서 관리하게 하면 된다!</p><p>즉!</p><p>일단 스프링 어플리케이션을 실행하면 먼저 컴포넌트 스캔을 실행한다.<br>컴포넌트 스캔은 @Component가 붙은 클래스를 객체로 만들어 IoC 컨테이너에 올려둔다.<br>이때 중요한 건! 만약 DI 받는 객체가 있는 경우, 스프링이 IoC 컨테이너에 있는 객체일 경우 자동으로 주입해준다!!</p><p>반면 생성자로 주입받으려는 객체가 IoC 컨테이너에 없는 경우 컴파일에러를 일으킨다.</p><blockquote><p> 한 가지 궁금한 점!</p></blockquote><p>아까 DI를 활용하면 유연하고 확장 가능한 구조를 얻을 수 있다고 했다.<br>하지만 스프링을 통해 아까 예제에 있던 NameReader의 두 구현체 모두에게 @Component를 붙여 관리하도록 하면,<br>컴파일 에러가 생긴다. 즉 NamePrinter가 어떤 구현체를 주입해서 객체를 생성해야 할 지 결정내리지 못하는 문제가 생긴다.</p><p>이 문제는 추후 더 알아보도록 하자!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/26/spring/spring2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>불필요한 객체 생성을 피해라</title>
      <link>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/</guid>
      <pubDate>Fri, 08 Apr 2022 15:29:09 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;변경되지 않는 객체를 사용할 때마다 새로운 객체를 만들지 말자.&lt;/p&gt;
&lt;h1 id=&quot;불필요한-객체-생성을-하는-예시&quot;&gt;&lt;a href=&quot;#불필요한-객체-생성을-하는-예시&quot; clas</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>변경되지 않는 객체를 사용할 때마다 새로운 객체를 만들지 말자.</p><h1 id="불필요한-객체-생성을-하는-예시"><a href="#불필요한-객체-생성을-하는-예시" class="headerlink" title="불필요한 객체 생성을 하는 예시"></a>불필요한 객체 생성을 하는 예시</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String bad = <span class="keyword">new</span> String(<span class="string">&quot;bikini&quot;</span>); <span class="comment">//안좋은 예시</span></span><br><span class="line">String good = <span class="string">&quot;bikini&quot;</span>; <span class="comment">//무난한 예시</span></span><br></pre></td></tr></table></figure><p>new String(“bikini”)로 문자열을 만드는 경우 불필요한 문자열 객체를 만든다.<br>왜? “bikini”라는 코드 자체가 문자열 객체를 만들기 때문이다.</p><p>문자열 객체를 만들고  다시 새로운 객체로 만드는 코드인 셈이다.</p><p>반면 두번째 줄 코드는 가상 머신에서 문자열 리터럴을 하나 만들어서 재사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> String(<span class="string">&quot;bikini&quot;</span>); <span class="comment">//얼마나 많은 문자열 객체가 만들어질까?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반복문에 위처럼 문자열 객체를 만들면 불필요한 객체가 생기게 된다.</p><h2 id="정적-팩터리-메서드로-불변-클래스-효율적으로-만들기"><a href="#정적-팩터리-메서드로-불변-클래스-효율적으로-만들기" class="headerlink" title="정적 팩터리 메서드로 불변 클래스 효율적으로 만들기"></a>정적 팩터리 메서드로 불변 클래스 효율적으로 만들기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean trueBoolean = <span class="keyword">new</span> Boolean(<span class="string">&quot;true&quot;</span>); <span class="comment">//안좋은 예시</span></span><br><span class="line">Boolean falseBoolean = Boolean.of(<span class="string">&quot;false&quot;</span>); <span class="comment">//좋은 예시</span></span><br></pre></td></tr></table></figure><p>Boolean 클래스는 객체 내부가 변경되지 않는 불변 객체이다.<br>불변 객체는 굳이 사용할 때마다 객체를 만들어주지 않아도 된다.</p><p>새로운 객체를 만들기보다는 만들어진 객체를 반환하는 기능을 정적 팩터리 메서드로 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;, <span class="title">Constable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Boolean&gt; TYPE = (Class&lt;Boolean&gt;) Class.getPrimitiveClass(<span class="string">&quot;boolean&quot;</span>);</span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3665804199014368530L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated(since=&quot;9&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">    &#125;</span><br><span class="line">                                          </span><br><span class="line">     <span class="comment">//생략   </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseBoolean(s) ? TRUE : FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Boolean 객체 내부를 보면 자신의 인스턴스들을 내부에서 클래스 변수로 가지고 있다.<br>정적 팩터리 메서드로 전달받은 인수에 맞는 인스턴스를 반환해주면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/09/java/effective-java/effective6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>조합으로 체스 말 이동 범위 검사하기!</title>
      <link>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/</guid>
      <pubDate>Fri, 08 Apr 2022 00:31:53 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.&lt;br&gt;이를 따로 분리해서 중복을 제거하고자 했다.&lt;/p&gt;
&lt;h1 id=&quot;도입-배경&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.<br>이를 따로 분리해서 중복을 제거하고자 했다.</p><h1 id="도입-배경"><a href="#도입-배경" class="headerlink" title="도입 배경"></a>도입 배경</h1><h2 id="체스-말-종류-구현하기"><a href="#체스-말-종류-구현하기" class="headerlink" title="체스 말 종류 구현하기"></a>체스 말 종류 구현하기</h2><p>체스 말 객체(Piece)는 자신의 위치와 이동할 위치를 전달받아서 이동할 위치로 이동할 수 있는지 확인한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> MovableStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Piece</span><span class="params">(<span class="keyword">final</span> Color color, <span class="keyword">final</span> MovableStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPointValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;같은 위치로는 이동 불가능합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.movable(source, target, moveType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>체스 말 객체는 여러가지 종류가 있다. (퀸, 킹, 폰, 비숍, 룩, 나이트)<br>Piece를 상속받아서 다양한 종류를 구현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> <span class="keyword">extends</span> <span class="title">Piece</span></span></span><br></pre></td></tr></table></figure><h2 id="체스-말-종류에-따라-달라지는-이동-범위"><a href="#체스-말-종류에-따라-달라지는-이동-범위" class="headerlink" title="체스 말 종류에 따라 달라지는 이동 범위"></a>체스 말 종류에 따라 달라지는 이동 범위</h2><p>체스 말 객체는 종류에 따라 이동 범위가 다르다.</p><p>문제는 각 클래스마다 이동 검증 로직이 중복되는 게 많다는 점이다!</p><h3 id="중복되는-코드"><a href="#중복되는-코드" class="headerlink" title="중복되는 코드"></a>중복되는 코드</h3><p>퀸 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen</span> <span class="keyword">extends</span> <span class="title">Piece</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; QUEEN_DIRECTION</span><br><span class="line">            = List.of(EAST, WEST, SOUTH, NORTH, SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> QUEEN_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반면 이건 룩 기물의 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bishop</span> <span class="keyword">extends</span> <span class="title">Piece</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Direction&gt; BISHOP_DIRECTION = List.of(SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bishop</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> BISHOP_DIRECTION.contains(direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 잘 보면 movable 메서드 안에 로직이 중복됨을 알 수 있다. 이를 해결해보자.</p><h1 id="조합으로-중복-제거하기"><a href="#조합으로-중복-제거하기" class="headerlink" title="조합으로 중복 제거하기"></a>조합으로 중복 제거하기</h1><p>이때 체스 말 객체를 두가지로 나눠서 생각한다.</p><p><strong>이동하는 거리가 제한 없는 경우 VS 이동하는 거리가 제한 있는 경우</strong></p><p>전자는 퀸, 비숍, 룩이 해당한다.<br>후자는 폰, 킹, 나이트가 해당한다.</p><p>그렇다면 거리 제한 없이 이동하는 전략과 거리 제한이 있는 전략을 구분해서 추상화할 수 있지 않을까?</p><h2 id="인터페이스로-전략을-추상화해서-만들기"><a href="#인터페이스로-전략을-추상화해서-만들기" class="headerlink" title="인터페이스로 전략을 추상화해서 만들기"></a>인터페이스로 전략을 추상화해서 만들기</h2><p>모든 종류의 체스 말들이 자신의 이동여부를 확인할 수 있도록하는 인터페이스를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>자신의 위치, 목표 위치, 움직임이 공격인지를 전달받아 해당 목표로 갈 수 있는지 판단한다.</p><h2 id="이동하는-거리가-제한-없는-경우"><a href="#이동하는-거리가-제한-없는-경우" class="headerlink" title="이동하는 거리가 제한 없는 경우"></a>이동하는 거리가 제한 없는 경우</h2><p>인터페이스를 구현해서 먼저 이동하는 거리가 제한이 없는 경우의 전략을 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnlimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnlimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하는 거리가 제한이 없는 전략은 가려는 목표지점의 방향이 내가 갈 수 있는 방향인지만 검사하면 된다.</p><p>즉 룩의 경우 상하좌우로 거리제한없이 이동할 수 있다.<br>룩이 가려는 목표 지점이 상하좌우 방향 중 하나에 있다면, 룩은 그 목표로 갈 수 있다.<br>(이동 경로에 다른 누군가 있는 경우나 목표 지점이 같은 편이 있는 경우는 다른 곳에서 검증한다.)</p><h2 id="이동하는-거리가-제한된-경우"><a href="#이동하는-거리가-제한된-경우" class="headerlink" title="이동하는 거리가 제한된 경우"></a>이동하는 거리가 제한된 경우</h2><p>이동하는 거리가 제한된 경우의 전략을 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; movableDirections;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> moveLimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitedMovableStrategy</span><span class="params">(List&lt;Direction&gt; movableDirections, <span class="keyword">int</span> moveLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movableDirections = movableDirections;</span><br><span class="line">        <span class="keyword">this</span>.moveLimit = moveLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Distance distance = source.getDistance(target);</span><br><span class="line">            Direction direction = source.findDirection(target);</span><br><span class="line">            <span class="keyword">return</span> movableDirections.contains(direction) &amp;&amp; distance.isInRange(moveLimit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이동하려는 거리 제한이 있으면 두 위치간에 거리를 추가로 확인해주면 된다.</p><h2 id="폰의-이동-전략"><a href="#폰의-이동-전략" class="headerlink" title="폰의 이동 전략"></a>폰의 이동 전략</h2><p>폰의 이동 전략은 꽤 까다롭다.</p><p>첫 위치에서 움직이는 경우 전진을 두칸까지 할 수 있다.<br>공격은 반드시 전진 방향 대각선으로 할 수 있다.</p><p>이를 위해서는 MoveType에 따라 다른 전략을 만들어서 실행해줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PawnMovableStrategy</span> <span class="keyword">implements</span> <span class="title">MovableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_MOVE_LIMIT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOT_FIRST_MOVE_LIMIT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACK_LIMIT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; nonAttackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Direction&gt; attackDirection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Rank startRank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PawnMovableStrategy</span><span class="params">(List&lt;Direction&gt; nonAttackDirection, List&lt;Direction&gt; attackDirection, Rank startRank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nonAttackDirection = nonAttackDirection;</span><br><span class="line">        <span class="keyword">this</span>.attackDirection = attackDirection;</span><br><span class="line">        <span class="keyword">this</span>.startRank = startRank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">movable</span><span class="params">(Square source, Square target, MoveType moveType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (moveType.isAttack()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(attackDirection, ATTACK_LIMIT).movable(source, target, moveType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nonAttackMovable(source, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonAttackMovable</span><span class="params">(Square source, Square target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source.isSameRank(startRank)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                    MoveType.MOVE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LimitedMovableStrategy(nonAttackDirection, NOT_FIRST_MOVE_LIMIT).movable(source, target,</span><br><span class="line">                MoveType.MOVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>폰의 이동전략을 수행하기 위해서는 자신의 첫 위치 시점(starkRank), 공격가능 방향(attckDirection), 이동 가능 방향(nonAttackDirection)을 주입받는다.</p><p>현재 이동하려는 것이 공격이면 공격에 맞는 방향과 거리로 검증한다.<br>반면 그냥 이동하려는 경우는 이동에 맞는 방향과 거리로 검증한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java의 Call by Value</title>
      <link>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</link>
      <guid>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/</guid>
      <pubDate>Sat, 02 Apr 2022 09:11:48 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바에는 Call by Value만 존재한다.&lt;br&gt;Call by Value는 함수의 인자에 값을 전달하는 방식이고,&lt;br&gt;Call by Reference는 함수의 인자에 주소를 </description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>자바에는 Call by Value만 존재한다.<br>Call by Value는 함수의 인자에 값을 전달하는 방식이고,<br>Call by Reference는 함수의 인자에 주소를 전달하는 방식이다.</p><h1 id="Call-by-Value-vs-Call-by-Reference"><a href="#Call-by-Value-vs-Call-by-Reference" class="headerlink" title="Call by Value vs Call by Reference"></a>Call by Value vs Call by Reference</h1><p>프로그래밍 언어에서 함수에 인자로 전달하는 방식에 따라 나뉜다.</p><h2 id="Call-by-Value"><a href="#Call-by-Value" class="headerlink" title="Call by Value"></a>Call by Value</h2><p>Call by Value는 함수 호출시 전달되는 변수의 값을 복사해서 전달한다.<br>이렇게 전달된 인자는 외부에서 있었던 변수와는 달리 함수 내부의 지역 변수로 활용된다.<br>즉 함수 안에서 인자를 변경해도 외부 변수 값은 변경되지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드를 살펴보자.<br>swap 함수는 두 int형 변수의 값을 바꾸는 함수다. 그런데 테스트 결과는 맞지 않게 나온다.<br>원인은 swap 함수에서 변수를 가져오는 과정이 Call by Value이기 때문이다.</p><p>테스트 코드에서 전달한 a와 swap 내부에서의 a는 서로 영향을 주지 않는다.<br>테스트 코드의 a에 저장된 1이라는 값을 복사해서 메서드의 a에 저장한 것일 뿐이다.</p><h2 id="Call-by-Reference"><a href="#Call-by-Reference" class="headerlink" title="Call by Reference"></a>Call by Reference</h2><p>Call by Reference는 함수 호출 시 전달되는 변수의 참조값을 전달하는 방식이다.<br>함수가 인자로 주소값을 전달받고나서 이를 함수 내부에서 접근하여 수정하면,<br>함수 외부의 변수도 변화가 생길 수 있다.</p><h1 id="Java의-Call-by-Value"><a href="#Java의-Call-by-Value" class="headerlink" title="Java의 Call by Value"></a>Java의 Call by Value</h1><blockquote><p>Java는 전달되는 인자의 타입에 따라 약간 다르게 보인다.</p></blockquote><h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2><p>자바는 8가지 원시 타입이 있다.<br>(byte, short, int, long, float, double, char, boolean)</p><p>원시 타입 변수들은 스택 메모리에 그대로 저장된다.<br>그래서 원시 타입이 인자로 전달될 때는 스택에 저장된 값 그대로 복사되어서 전달된다.</p><p>전달된 값은 원래 변수와는 다른 별개의 변수. 즉 Call by Value 방식으로 전달된다.<br>전달된 갑쇼은 해당 메서드가 종료되면 스택에서 제거된다. </p><h4 id="예시로-이해하기"><a href="#예시로-이해하기" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//1단계</span></span><br><span class="line">        swap(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//2단계</span></span><br><span class="line">        assertThat(a == <span class="number">2</span> &amp;&amp; b == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c;</span><br><span class="line">        c = d;</span><br><span class="line">        d = tmp; <span class="comment">//3단계</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까 본 예시로 다시 이해해보자.</p><p>1단계까지 실행하고 나면 스택에는 a &#x3D; 1, b &#x3D; 2 라는 정보를 저장하게 된다.<br>2단계를 실행하고 나면 a &#x3D; 1, b &#x3D; 2 라는 정보에 새로운 스택 프레임이 생기고 그곳에 c &#x3D; 1, d &#x3D; 2가 생긴다.<br>즉 (a &#x3D;1 , b &#x3D; 2), (c &#x3D; 1, d &#x3D; 2) 이런 식으로 스택에 저장된다.</p><p>이제 3단계까지 실행하면 스택은 (a &#x3D; 1, b &#x3D;2), (c &#x3D; 2, d &#x3D; 1, tmp &#x3D; 1) 이렇게 저장된다.<br>swap 메서드가 종료되면 swap 메서드의 프레임이 종료되므로 결국 (a &#x3D; 1, b &#x3D; 2)만 스택에 남는다.</p><h2 id="참조-타입"><a href="#참조-타입" class="headerlink" title="참조 타입"></a>참조 타입</h2><p>참조 타입은 쉽게 말해서 객체의 주소를 저장하는 타입이다.<br>보통 기본 타입을 제외한 모든 것을 의미한다.</p><p>참조 타입은 기본 타입과 다르게 값 그 자체를 저장하지 않는다.<br>대신 그 값의 주소 값을 저장한다.</p><p>그렇다면 그 값의 주소는 어디의 주소를 의미하는 걸까?<br>그 주소는 바로 힙 영역에 있는 인스턴스의 주소를 의미한다.</p><p>즉 참조 타입은 객체의 주소를 가지고 스택에 저장되고,<br>그 주소는 힙 영역에 있는 인스턴스의 주소다.</p><p>앞서서 자바는 Call by Value라고 했다.<br>참조 타입도 예외는 아니다. Call by Value다.<br>다만 전달되는 Value가 주소값이라서 기본 타입과는 다르게 작동한다.</p><h4 id="예시로-이해하기-1"><a href="#예시로-이해하기-1" class="headerlink" title="예시로 이해하기"></a>예시로 이해하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callByValueObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserAge a = <span class="keyword">new</span> UserAge();</span><br><span class="line">        a.value = <span class="number">1</span>;</span><br><span class="line">        UserAge b = <span class="keyword">new</span> UserAge();</span><br><span class="line">        b.value = <span class="number">2</span>;<span class="comment">//1단계</span></span><br><span class="line">        swap(a, b);<span class="comment">//2단계</span></span><br><span class="line">        assertThat(a.value == <span class="number">2</span> &amp;&amp; b.value == <span class="number">1</span>).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(UserAge c, UserAge d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = c.value;</span><br><span class="line">        c.value = d.value;</span><br><span class="line">        d.value = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAge는 int 형 데이터를 저장하는 클래스다.<br>이제 두개의 UserAge를 만들어서 값을 변경하는 swap 메서드에 전달해보자.</p><p>1단계까지 오면 스택에 a &#x3D; UserAge 주소값1, b &#x3D; UserAge 주소값2 이 오게된다.<br>우리가 만든 실제 객체는 힙 영역에 있고 스택의 주소값은 힙 영역을 가르키는 값이다.</p><p>2단계까지 오면 이제 새로운 스택 프레임이 생긴다.<br>c와 d에 a, b가 가진 값(즉 주소값)을 복사해서 넣어준다. 즉 Call by Value 방식으로 전달한다.</p><p>스택에는 (a &#x3D; UserAge주소1, b &#x3D; UserAge주소2), (c &#x3D; UserAge주소1, d &#x3D; UserAge주소2) 이렇게 저장된다.</p><p>이때 주목할 점은 a와 c가 같은 주소값을 저장하고 있고, b와 d가 같은 값을 저장하고 있다는 점이다.<br>이제 c를 통해 힙에 있는 인스턴스를 변경하면 나중에 a를 통해 인스턴스에 접근했을 때 값이 변경되어 있게 된다.<br>(b와 d도 같은 관계다.)</p><blockquote><p>정리</p></blockquote><p>자바는 모두 Call by Value이다.<br>다만 원시 타입은 값 자체를 복사해서 전달하고,<br>참조 타입은 참조하는 객체의 주소를 복사해서 전달한다.</p><p><em>참고</em></p><p><a href="https://deveric.tistory.com/92">https://deveric.tistory.com/92</a><br><a href="https://www.baeldung.com/java-pass-by-value-or-pass-by-reference">https://www.baeldung.com/java-pass-by-value-or-pass-by-reference</a><br><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a><br><a href="https://kingpodo.tistory.com/54">https://kingpodo.tistory.com/54</a><br><a href="https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame">https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-frame</a><br><a href="https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference">https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>오브젝트</title>
      <link>https://yangdongjue5510.github.io/2022/03/27/java/object/post/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/27/java/object/post/</guid>
      <pubDate>Sun, 27 Mar 2022 07:09:39 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;사용하는 입장에서 예상 가능한 코드&lt;/p&gt;
&lt;p&gt;의존성이 적절한 코드(결합도가 낮은 코드)&lt;/p&gt;
&lt;p&gt;너무 세세한 부분까지 알지 못하도록 정보를 차단&lt;/p&gt;
&lt;p&gt;객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하자.&lt;/p&gt;
&lt;p&gt;불필요한 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>사용하는 입장에서 예상 가능한 코드</p><p>의존성이 적절한 코드(결합도가 낮은 코드)</p><p>너무 세세한 부분까지 알지 못하도록 정보를 차단</p><p>객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하자.</p><p>불필요한 세부사항을 객체 내부로 캡슐화하는 것 -&gt; 객체의 자율성 + 응집도가 높은 객체</p><p>단순 타입보다는 객체를 선언해서 의미를 전달하는게 좋다. (관련 로직이 한곳에 모이는 효과도 있다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/27/java/object/post/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>상속과 조합</title>
      <link>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/</guid>
      <pubDate>Sat, 12 Mar 2022 04:28:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;상속의-위험성&quot;&gt;&lt;a href=&quot;#상속의-위험성&quot; class=&quot;headerlink&quot; title=&quot;상속의 위험성&quot;&gt;&lt;/a&gt;상속의 위험성&lt;/h1&gt;&lt;p&gt;상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.&lt;br&gt;내가 필요로 하는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="상속의-위험성"><a href="#상속의-위험성" class="headerlink" title="상속의 위험성"></a>상속의 위험성</h1><p>상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.<br>내가 필요로 하는 클래스와 매우 유사한 클래스가 있다면 해당 클래스를 상속하면 같은 코드를 여러번 쓸 필요가 줄어든다.</p><p>상속은 코드 재사용을 위해 캡슐화를 희생시킨다. 부모 클래스의 코드를 재활용하기 위해 자식 클래스도 재활용할 코드를 모두 공개되기 때문이다.</p><blockquote><p>경고 1. 자식 클래스 메서드 안에서 super 참조로 부모 클래스의 메서드를 직접 호출하면 두 클래스의 결합도가 높아진다. (super 참조를 제거하라.)</p></blockquote><p>상속을 염두해두고 설계하지 않은 클래스를 상속하기 어렵다.<br>기존의 코드를 다른 상황에 재사용하기 위해서는 개발자가 나름의 해석을 하고 가정한다.<br>그러나 개발자의 가정을 이해해야 하는 코드는 읽기가 어려워진다.</p><p>실제 요구사항과 구현이 다르면 우리는 기존의 구현을 요구사항과 같은 결과를 나타내도록 많은 가정을 하게된다.</p><p>상속을 하려면 부모 클래스의 가정과 추론 과정을 정확하게 이해해야 한다.<br>상속은 부모 클래스의 구체적인 구현을 이해해야 할 가능성이 높다. 그래서 결합도(다른 모듈에 대해 알고 있어야할 지식의 수준)가 높다.</p><p>자식 클래스가 부모 클래스의 변경이 취약해진다. 취약한 기반 클래스 문제.<br>만약 부모 클래스의 변경된 부분이 자식 클래스에 파생되는 행동이라면, 자식 클래스의 행동이 예상과 다르게 작동 될 수 있다. </p><p>상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만든다.<br>상속은 부모 클래스의 퍼블릭 인터페이스가 아닌 다른 곳을 고쳐도 영향을 받는다. 이게 캡슐화를 약화시킨다는 증거다.</p><blockquote><p>경고 2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.</p></blockquote><p>코드 재활용을 하기 위해 부모 클래스를 상속 할 경우, 부모에서 공개 됐던 메서드들이 자식 클래스의 내부 규칙을 깨트릴 수 있다.</p><p>오브젝트에서 제시한 예시는 Vector를 상속받는 Stack이다.<br>Stack은 push와 pop으로만 데이터를 수정할 수 있다. 그러나 Vector는 퍼블릭 인터페이스로 다양한 인덱스에 add할 수 있게한다. 이는 Stack의 규칙을 깨트리는 방식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;1st&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;2nd&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;3rd&quot;</span>);</span><br><span class="line"></span><br><span class="line">stack.add(<span class="number">0</span>, <span class="string">&quot;4th&quot;</span>); <span class="comment">//이건 Vector의 퍼블릭 인터페이스. 스택의 규칙에 어긋난 행동</span></span><br></pre></td></tr></table></figure><blockquote><p>경고 3. 자식이 부모의 메서드를 오버라이딩하면 부모의 다른 메서드가 자식의 메서드를 결합하게 될 수 있다.</p></blockquote><p>부모 클래스의 특정 메서드를 자식 클래스가 오버라이딩 하게 되면, 부모 클래스에서 해당 클래스를 원래의 메서드(즉 오버라이딩 되기 전 메서드)를 예상하고 사용했던 부분에서 예기치 못한 작동(오버라이딩 된 메서드)를 수행할 수 있다.</p><blockquote><p> 경고 4. 부모 클래스에 변화가 생기면 자식도 같이 변해야 되는 일이 생길 수 있다. 상속은 결합도가 높아서, 부모와 자식이 같이 변하거나, 자식과 부모를 변경하지 않거나 두가지 선택지 밖에 없다.</p></blockquote><p>부모 클래스를 오버라이딩 하지 않고 불필요한 퍼블릭 인터페이스를 상속받지 않아도 부모의 중요한 부분이 변경되면 자식 클래스도 같이 변경될 수 밖에 없다.</p><h1 id="상속을-보다-안전하게-사용하기"><a href="#상속을-보다-안전하게-사용하기" class="headerlink" title="상속을 보다 안전하게 사용하기"></a>상속을 보다 안전하게 사용하기</h1><h2 id="추상화에-의존"><a href="#추상화에-의존" class="headerlink" title="추상화에 의존"></a>추상화에 의존</h2><p>자식 클래스가 부모 클래스의 구현이 아닌 부모 클래스의 추상화에 의존해야 한다.<br>더 정확하게 말하면 부모와 자식 모두 추상화에 의존해야 한다.</p><h3 id="달라지는-부분을-찾아-메서드로-분리"><a href="#달라지는-부분을-찾아-메서드로-분리" class="headerlink" title="달라지는 부분을 찾아 메서드로 분리"></a>달라지는 부분을 찾아 메서드로 분리</h3><p>비슷해보이는 클래스 간에 서로 다른 부분을 메서드를 추출한다.<br>그러면 다른 부분을 제외하면 나머지 메서드들은 동일하게 된다.<br>그러면 이제 중복 코드를 부모 클래스로 올린다.<br>그리고 달라지는 부분은 부모의 추상 메서드로, 각 클래스들이 구현하도록 하면 된다.</p><p>이제 자식 클래스들은 부모의 추상 메서드에만 의존하게 되므로 느슨하게 결합된다.</p><p>하지만 이런 추상 클래스를 활용한 추상화에 의존하는 방법도 문제가 있다.<br>객체 행동만 변하면 각 클래스를 독립적으로 변경시키면 되겠지만, 인스턴스 변수가 추가되는 경우는 다르다.<br>부모 클래스에 인스턴스 변수가 추가되어 객체 생성때 초기화해줘야 하는 경우, 상속되는 모든 클래스는 수정을 해줘야 한다.</p><h1 id="합성을-활용하기"><a href="#합성을-활용하기" class="headerlink" title="합성을 활용하기"></a>합성을 활용하기</h1><p>상속은 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 방법.<br>합성은 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.</p><p>합성은 구현에 의존하지 않는다.<br>합성은 내부 부분 객체의 퍼블릭 인터페이스에 의존한다. 즉 구현에 의존하는 것이 아닌 인터페이스에 의존하도록 할 수 있다.<br>합성은 내부 부분 객체의 구현 방식이 변경되어도 전체 객체는 영향이 적다.</p><p>상속은 정적인 관계인데 합성은 동적인 관계이다.<br>코드 작성 때 정해진 상속 관계를 실행 시점에서 변경이 불가능하다.<br>반면 합성 관계는 코드 작성 때 정해진 관계를 실행 시점에서 변경이 가능하다.</p><p>상속을 합성으로 바꾸는 방법은 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</p><h2 id="합성의-안전성"><a href="#합성의-안전성" class="headerlink" title="합성의 안전성"></a>합성의 안전성</h2><p>불필요한 인터페이스 상속 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 규칙에 맞게 인스턴스의 퍼블릭 인터페이스를 활용하면 된다.</p><p>메서드 오버라이딩 오작동 문제<br>부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,<br>자식 클래스의 메서드가 부모 인스턴스의 메서드를 오버라이딩해서 부모 인스턴스의 퍼블릭 인터페이스와 협력하면 된다.<br>(이때 오버라이딩한 인스턴스 메서드가 인스턴스에게 동일한 메서드 호출을 전달하는 메서드를 포워딩 메서드라고 한다.)</p><p>부모 클래스와 자식 클래스의 동시 수정 문제<br>합성이 이 문제를 완전히 해결하지는 못한다. 하지만 조합된 내부 인스턴스의 변경사항을 최대한 캡슐화 시킬 수 있다.</p><h2 id="합성의-유연성"><a href="#합성의-유연성" class="headerlink" title="합성의 유연성"></a>합성의 유연성</h2><p>하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함.</p><p>단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많이 늘어날 수 있다.</p><p>추상 메서드와 훅 메서드<br>추상 메서드 : 개방 - 폐쇄 원칙을 만족하기 위한 설계. 하위 계층이 오버라이딩해서 구현<br>훅 메서드 : 추상 메서드는 반드시 모두가 구현해야 해서 불편하다. 대부분의 하위 계층이 똑같이 구현하면 중복 코드가 많이 생기기 때문에 기본 구현을 해놓고 달라지는 경우에만 오버라이딩하는 메서드</p><p>기능 추가를 할 때 상속을 남용하면 필요 이상으로 클래스가 만들어진다.(클래스 폭발, 조합의 폭발)<br>이런 문제는 자식 클래스와 부모 클래스의 다양한 조합이 필요한데 상속은 컴파일 타임에 관계가 결정되어 버려서 모든 조합을 미리 만들어놓으면서 생기는 문제다.</p><p>합성을 사용하면 컴파일 타임에서 정한 관계를 런타임에서 수정할 수 있다.<br>상속은 조합의 결과를 개별의 클래스에 밀어넣는 방법이고, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 다음 런타임에서 인스턴스를 조립하는 방식이다.</p><h1 id="그러면-상속은-언제-사용하는가"><a href="#그러면-상속은-언제-사용하는가" class="headerlink" title="그러면 상속은 언제 사용하는가"></a>그러면 상속은 언제 사용하는가</h1><p>코드 재활용을 목적으로 상속하면 변경하기 어렵고 유연하지 못하게 된다.<br>만약 상속을 사용하려고 할 때 스스로에게 물어보자.<br>내가 상속을 이용하는게 코드 재사용을 위한 것인가? 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위한 것인가? (코드 재사용을 위한 것이면 상속을 피해야 한다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 함수</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/</guid>
      <pubDate>Fri, 04 Mar 2022 08:37:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;함수는-한-가지만-해라&quot;&gt;&lt;a href=&quot;#함수는-한-가지만-해라&quot; class=&quot;headerlink&quot; title=&quot;함수는 한 가지만 해라!&quot;&gt;&lt;/a&gt;함수는 한 가지만 해라!&lt;/h3&gt;&lt;p&gt;함수에 적힌 코드들의 추상화 수준이 같은 단계로 통</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="함수는-한-가지만-해라"><a href="#함수는-한-가지만-해라" class="headerlink" title="함수는 한 가지만 해라!"></a>함수는 한 가지만 해라!</h3><p>함수에 적힌 코드들의 추상화 수준이 같은 단계로 통일시켜라는 의미다.<br>혹은 함수 내에서 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 셈이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parseInt(token));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">        lottoNumbers.add(<span class="keyword">new</span> LottoNumber(number));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(lottoNumbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 크게 추상화 단계가 두가지이다.</p><ul><li>문자열을 숫자로 바꾸는 단계 (추상화 단계 낮음)</li><li>숫자를 LottoNumber로 바꾸는 단계 (추상화 단계 중간)</li><li>LottoNumber를 Lotto로 바꾸는 단계 (추상화 단계 높음)</li></ul><p>이제 이 작업들을 나눠서 리팩토링 해보자.<br>자연스럽게 내려가기 규칙이 적용되서 다음에 오는 함수는 추상화 단계가 하나씩 줄어드는 걸 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lotto <span class="title">createLotto</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Lotto(createLottoNumbers(tokens));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;LottoNumber&gt; <span class="title">createLottoNumbers</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;LottoNumber&gt; lottoNumbers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : parseAll(tokens)) &#123;</span><br><span class="line">        lottoNumbers.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lottoNumbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">parseAll</span><span class="params">(List&lt;String&gt; tokens)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        numbers.add(Integer.parse(token));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="함수-인수"><a href="#함수-인수" class="headerlink" title="함수 인수"></a>함수 인수</h3><p>함수에 전달되는 인수는 0개가 제일 좋다.<br>3개 이상은 되도록 피해야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클린코드를 위한 의미 있는 이름</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/</guid>
      <pubDate>Fri, 04 Mar 2022 05:44:23 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;의도를-분명히-밝혀라&quot;&gt;&lt;a href=&quot;#의도를-분명히-밝혀라&quot; class=&quot;headerlink&quot; title=&quot;의도를 분명히 밝혀라&quot;&gt;&lt;/a&gt;의도를 분명히 밝혀라&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="의도를-분명히-밝혀라"><a href="#의도를-분명히-밝혀라" class="headerlink" title="의도를 분명히 밝혀라"></a>의도를 분명히 밝혀라</h3><ol><li>변수(혹은 함수나 클래스)의 존재 이유가 무엇인가?</li><li>어떤 일을 수행하는가?</li><li>어떻게 사용하는가?</li></ol><p>이름으로 위 세가지가 표현이 안된다면 문제가 있다.</p><h4 id="변수의-이름은-범위-크기에-비례해야-한다"><a href="#변수의-이름은-범위-크기에-비례해야-한다" class="headerlink" title="변수의 이름은 범위 크기에 비례해야 한다."></a>변수의 이름은 범위 크기에 비례해야 한다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pricePerLotto = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> Prizesum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Lotto lotto : lottos) &#123;</span><br><span class="line">    prizeSum += pricePerLotto * lotto.getPrize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이름이 길수록 사용되는 범위가 넓다고 생각하자.<br>예를 들면 for 문의 i는 해당 루프에서만 사용되서 짧아도 된다.<br>이름이 길수록 검색도 용이하다.</p><h4 id="맥락을-추가하라"><a href="#맥락을-추가하라" class="headerlink" title="맥락을 추가하라"></a>맥락을 추가하라</h4><p>이름 그 자체로 의미를 분명히 보여주는 변수는 없다.<br>함수나 클래스에서 맥락을 부여하면 이름을 더 자연스럽게 읽힐 수 있다.<br>이마저도 힘들면 접두사를 붙일 수 있다. (stateName, 이런 식으로..)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">(String name, String position)</span> </span>&#123;</span><br><span class="line">    System.out.println(name + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name는 어떤 이름을 의미하고, positon는 어떤 위치를 표시하는 건지 도저히 알 수 없다.</p><p>이름과 포지션은 사실 자동차의 이름과 자동차의 위치를 말해주는 변수들이다.<br>그럼 이를 더 잘 알려주기 위해 맥락을 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNameAndPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Car라는 맥락 안에서 이름과 위치를 파악하면 좀 더 의미있게 파악할 수 있다.</p><h4 id="불필요한-맥락-제거"><a href="#불필요한-맥락-제거" class="headerlink" title="불필요한 맥락 제거"></a>불필요한 맥락 제거</h4><p>그렇다고 불필요하게 맥락을 이름에 붙여주는건 불필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carPosition;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미 Car라는 맥락 안에서 쓰이는 이름에 굳이 car를 붙이지 않아도 되지않을까?</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/clean-code/">Clean Code</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/</guid>
      <pubDate>Thu, 03 Mar 2022 15:47:28 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.&lt;br&gt;이런 영향력이 있는 자원을</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.<br>이런 영향력이 있는 자원을 클래스 내부에서 만들면 안된다.<br>대신 이 자원(혹은 자원을 만드는 팩토리)을 해당 클래스를 인스턴스화 할 때 넘겨주자.</p><h3 id="자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴"><a href="#자원을-직접-명시하는-잘못된-예시-정적-유틸리티-amp-싱글턴" class="headerlink" title="자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴"></a>자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴</h3><p>맞춤법 검사기가 사전을 자원으로 가진다고 가정하자.<br>만약 사전을 직접 명시한다는 건 어떤 얘기일까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정적 유틸리티를 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//객체 생성 방지</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//싱글톤을 활용한 예제</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(Language.ENGLISH);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SpellChecker INSTANCE = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeSuggestions</span><span class="params">(String typo)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두 예시 모두 자원인 사전을  final로 직접 명시하고 있다. </p><ul><li>나중에 다른 사전을 사용하고 싶을 때 변경이 힘들어진다.</li><li>final을 제거하고 사전을 교체하는 메서드를 추가하는 방식은 멀티스레드 환경에 쓸 수 없음.</li></ul><p><strong>즉 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식을 사용하면 안된다!</strong></p><h3 id="의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기"><a href="#의존-객체-주입-예시-생성할-때-필요한-자원-넘겨주기" class="headerlink" title="의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기"></a>의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Dictionary dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>자원이 많거나 의존 관계가 어떻든 잘 작동</li><li>불변성을 지원</li><li>생성자, 정적 팩터리, 빌더 모두에 적용 가능</li></ul><h3 id="자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt"><a href="#자원-팩터리로-의존-객체-주입-Supplier-lt-T-gt" class="headerlink" title="자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;"></a>자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Supplier&lt;? extends Dictionary&gt; dictionaryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionaryFactory.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//메서드...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자원 팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.<br>자바에서는 Supplier&lt;T&gt;가 해당한다.</p><p>위처럼 생성자(정적 팩토리 메서드나 빌더)에 팩토리를 넘겨받으면 다음같이 활용 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpellChecker englishChecker = <span class="keyword">new</span> SpellChecker(() -&gt; <span class="keyword">new</span> Dictionary(Language.ENGLISH));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>인스턴스화를 막으려거든 private 생성자를 사용해라</title>
      <link>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</link>
      <guid>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/</guid>
      <pubDate>Thu, 03 Mar 2022 15:04:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;인스턴스화하지-않으려는-클래스&quot;&gt;&lt;a href=&quot;#인스턴스화하지-않으려는-클래스&quot; class=&quot;headerlink&quot; title=&quot;인스턴스화하지 않으려는 클래스?&quot;&gt;&lt;/a&gt;인스턴스화하지 않으려는 클래스?&lt;/h3&gt;&lt;p&gt;객체지향적이지 않지만 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="인스턴스화하지-않으려는-클래스"><a href="#인스턴스화하지-않으려는-클래스" class="headerlink" title="인스턴스화하지 않으려는 클래스?"></a>인스턴스화하지 않으려는 클래스?</h3><p>객체지향적이지 않지만 필요할 때가 있다.<br>java.lang.Math, java.util.Array 같이 기본 타입 값이나 배열 관련 메서드를 모아둔 곳<br>java.util.Collections와 같이 특정 인터페이스를 구현한 객체를 생성하는 정적 메서드를 모아둔 곳.<br>final 클래스와 관련된 메서드를 모아놓을 때. (final 클래스를 상속해서 하위 클래스에 메서드를 못넣음)</p><h3 id="인스턴스화-하지-않으려면-private-생성자를-사용"><a href="#인스턴스화-하지-않으려면-private-생성자를-사용" class="headerlink" title="인스턴스화 하지 않으려면 private 생성자를 사용"></a>인스턴스화 하지 않으려면 private 생성자를 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NotInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private로 기본 생성자를 해놓으면 외부에서 인스턴스화를 막을 수 있다.<br>Private 기본 생성자를 해놓으면 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문이다.</p><p>Private 기본 생성자는 상속도 못하게 만든다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super(); 가 생략되어 있음. </span></span><br><span class="line"><span class="comment">//부모 객체의 생성자가 private면 이 과정이 안되니 상속이 안된다.      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>추상 클래스의 위험성</p></blockquote><p>추상 클래스 그 자체는 인스턴스화할 수 없다.</p><p>하지만, 추상 클래스는 상속한 클래스를 통해 인스턴스화 할 수 있다.<br>게다가 사용자가 추상 클래스를 보면 인스턴스화 하지 말라고 이해하지 않고, 상속받아서 사용하라고 이해하기 때문에 더 위험하다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/effective-java/">Effective Java</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 제네릭과 와일드카드 튜토리얼</title>
      <link>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/</guid>
      <pubDate>Fri, 25 Feb 2022 07:26:32 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.&lt;br&gt;JDK 8 기반으로 작성됐다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.<br>JDK 8 기반으로 작성됐다.</p><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/why.html">https://docs.oracle.com/javase/tutorial/java/generics/why.html</a></p><h2 id="제네릭은-왜-쓰는가"><a href="#제네릭은-왜-쓰는가" class="headerlink" title="제네릭은 왜 쓰는가"></a>제네릭은 왜 쓰는가</h2><p>제네릭은 클래스, 인터페이스, 메서드를 선언할 때 타입(클래스, 인터페이스)도 매개변수로 만들 수 있다.<br>전통적인 매개변수와 마찬가지로 타입 매개변수도 다양한 인풋을 받을 수 있게한다.</p><ol><li><p>타입 체크를 컴파일 타임에 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정수를 리스트에 담아서 사용하려고 했는데 실수로 문자열을 넣는 상황</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//제네릭이 아닌 경우</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">//컴파일 에러가 발생하지 않는다.</span></span><br><span class="line"><span class="keyword">int</span> hello = (<span class="keyword">int</span>) list.get(<span class="number">0</span>); <span class="comment">//나중에 실행하면 여기서 ClassCastException이 발생한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//제네릭인 경우</span></span><br><span class="line">List&lt;Integer&gt; genericList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">genericList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">//컴파일 에러</span></span><br></pre></td></tr></table></figure></li><li><p>캐스팅 할 필요 없어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//제네릭 없는 경우</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;하이&quot;</span>);</span><br><span class="line">String hi = (String) list.get(<span class="number">0</span>); <span class="comment">//제네릭을 전달하지 않으면 Object를 반환</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;하이&quot;</span>);</span><br><span class="line">String hello = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="제네릭-간단하게-사용해보자"><a href="#제네릭-간단하게-사용해보자" class="headerlink" title="제네릭 간단하게 사용해보자"></a>제네릭 간단하게 사용해보자</h2><p>아무 타입이나 저장할 수 있는 Box 클래스를 구현하고자 한다.<br>제네릭 없이 구현하자면 다음과 같을 것 이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectBox</span> </span>&#123;</span><br><span class="line">        Object content;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(Object content)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우, get할 때마다 casting을 해줘야 된다.<br>그리고 담겨진 내용물을 잘못 파악해 casting해도 컴파일 타임에 알 수 없고 런타임 때 ClassCastException이 발생한다.</p><h4 id="제네릭을-사용"><a href="#제네릭을-사용" class="headerlink" title="제네릭을 사용"></a>제네릭을 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBox</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T content;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>제네릭을 사용하면 캐스팅이 필요없고 casting도 필요 없다.</p><h4 id="타입-파라미터-네이밍-컨벤션"><a href="#타입-파라미터-네이밍-컨벤션" class="headerlink" title="타입 파라미터 네이밍 컨벤션"></a>타입 파라미터 네이밍 컨벤션</h4><p>위에서 T는 타입 파라미터라고 한다.</p><ul><li>E - Element</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li><li>S, U, V - 2, 3, 4번째 타입</li></ul><p>이렇게 지칭한다.</p><h4 id="제네릭-타입-인보킹과-인스턴스화"><a href="#제네릭-타입-인보킹과-인스턴스화" class="headerlink" title="제네릭 타입 인보킹과 인스턴스화"></a>제네릭 타입 인보킹과 인스턴스화</h4><p>제네릭 타입 인보킹은 위에서 적은 T와 같은 매개변수를 우리가 의도한 실제 타입으로 변환하는 행위를 말한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox;</span><br></pre></td></tr></table></figure><p>참조변수를 통해 타입 인보킹을 해줄 수 있다.<br>이때 조심해야 할 것은 T는 타입 매개변수이고, Integer는 타입인자이다. 이 두가지는 다르다.</p><p>제네릭을 사용하는 클래스를 인스턴스화하려면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//타입 추론도 된다.</span></span><br><span class="line">Box&lt;Integer&gt; integerBox2 = <span class="keyword">new</span> Box&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Enum에서 메서드 참조와 BiFunction 사용하기</title>
      <link>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/</guid>
      <pubDate>Thu, 24 Feb 2022 14:12:58 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;문제 배경 (안</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다.</p><blockquote><p>문제 배경 (안좋은 사례 모음)</p></blockquote><p>로또 순위를 Enum LottoRank로 등수와 상금을 관리하고자 한다.<br>LottoRank가 맞춘 번호 갯수와 보너스 번호 맞춤여부를 전달받아 등수를 판별해야 한다.</p><ol><li><p>LottoRank에 맞춘 번호 갯수와 보너스 번호 맞춤여부를 추가로 저장하면 된다?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), <span class="number">6</span>, <span class="keyword">false</span>),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>),<span class="number">5</span>, <span class="keyword">true</span>),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), <span class="number">5</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">false</span>),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">false</span>),</span><br><span class="line">    NOTHING(Money.ZERO, <span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//이하 생략...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>그런데 문제가 있다. 4등, 5등은 보너스 맞춤여부가 false이든 true이든 상관없이 맞춘 갯수만 중요하다.<br>그리고 꽝인 경우, 맞춘 갯수가 2개 뿐만 아니라 1개, 0개여도 꽝이다. 그리고 꽝도 4등 5등의 경우와 마찬가지로 보너스 맞춤여부가 상관없다.<br>이런 경우도 전부 알맞은 상금을 가진 열거형 객체를 반환해줘야 한다.</p></li><li><p>좀 더 순위가 나오는 경우를 구체화한다?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), <span class="number">6</span>, <span class="keyword">false</span>),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>),<span class="number">5</span>, <span class="keyword">true</span>),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), <span class="number">5</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">false</span>),</span><br><span class="line">    FOURTH_WITH_BONUS(<span class="keyword">new</span> Money(<span class="number">50_000</span>), <span class="number">4</span>, <span class="keyword">true</span>),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">false</span>),</span><br><span class="line">    FIFTH_WITH_BONUS(<span class="keyword">new</span> Money(<span class="number">5_000</span>), <span class="number">3</span>, <span class="keyword">true</span>),</span><br><span class="line">    NOTHING_TWO(Money.ZERO, <span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_TWO_WITH_BONUS(Money.ZERO, <span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">    NOTHING_ONE(Money.ZERO, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_ONE_WITH_BONUS(Money.ZERO, <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">    NOTHING_(Money.ZERO, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    NOTHING_WITH_BONUS(Money.ZERO, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//이하 생략...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>음…이렇게 하면 당연히 안된다!!!!!!!<br>물론 보너스 번호 일치여부를 또 다른 열거형으로 도입하면 보너스 맞춤여부가 상관없는 경우 BONUS_MATCH.NOT_NEED 이런 식으로 처리하면 되긴 할 것이다.<br>그렇지만 NOTHING의 맞춘 갯수가 0 ~ 2개를 모두 적용되어야 된다.</p></li></ol><h3 id="BiFunction-도입하기"><a href="#BiFunction-도입하기" class="headerlink" title="BiFunction 도입하기"></a>BiFunction 도입하기</h3><p>이제 생각을 좀 바꿔보자.<br>열거형 객체가 순위를 정하는 기준을 메서드참조로 저장하고 있다면 어떨까?</p><h4 id="1-일단-등수를-구별하는-기준을-메서드로-만들어주자"><a href="#1-일단-등수를-구별하는-기준을-메서드로-만들어주자" class="headerlink" title="1. 일단 등수를 구별하는 기준을 메서드로 만들어주자"></a>1. 일단 등수를 구별하는 기준을 메서드로 만들어주자</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFirstPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSecondPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">5</span> &amp;&amp; bonusMatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isThirdPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">5</span> &amp;&amp; !bonusMatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFourthPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFifthPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchCount == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNothingPrize</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= matchCount &amp;&amp; matchCount &lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 각 등수를 구분하는 기준을 정해준다.<br>물론 bonusMatch를 사용하지 않는 경우도 있다. 하지만 나중에 메서드 참조를 위해서 넣어줬다.</p><h4 id="2-BiFunction을-메서드-참조를-통해-열거형의-필드로-보내준다"><a href="#2-BiFunction을-메서드-참조를-통해-열거형의-필드로-보내준다" class="headerlink" title="2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다."></a>2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    FIRST(<span class="keyword">new</span> Money(<span class="number">2_000_000_000</span>), LottoRank::isFirstPrize),</span><br><span class="line">    SECOND(<span class="keyword">new</span> Money(<span class="number">30_000_000</span>), LottoRank::isSecondPrize),</span><br><span class="line">    THIRD(<span class="keyword">new</span> Money(<span class="number">1_500_000</span>), LottoRank::isThirdPrize),</span><br><span class="line">    FOURTH(<span class="keyword">new</span> Money(<span class="number">50_000</span>), LottoRank::isFourthPrize),</span><br><span class="line">    FIFTH(<span class="keyword">new</span> Money(<span class="number">5_000</span>), LottoRank::isFifthPrize),</span><br><span class="line">    NOTHING(Money.ZERO, LottoRank::isNothingPrize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Money prize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;Integer, Boolean, Boolean&gt; predicate;</span><br><span class="line"></span><br><span class="line">    LottoRank(Money prize, BiFunction&lt;Integer, Boolean, Boolean&gt; predicate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prize = prize;</span><br><span class="line">        <span class="keyword">this</span>.predicate = predicate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 이하 생략</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>두가지 객체를 받아서 한가지로 결과를 반환하는 BiFunction 인터페이스를 필드로 가지고, 생성자로 초기화해주자.<br>그리고 우리가 만들었던 메서드들이 메서드 참조로 BiFunction을 구현하게 된다!!</p><h4 id="3-각-객체의-BiFunction을-통해-적절한-순위-객체를-반환한다"><a href="#3-각-객체의-BiFunction을-통해-적절한-순위-객체를-반환한다" class="headerlink" title="3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다."></a>3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LottoRank</span> </span>&#123;</span><br><span class="line">    <span class="comment">//열거형의 필드와 생성자는 위에 나와있으니 생략.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LottoRank <span class="title">of</span><span class="params">(Integer matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(values())</span><br><span class="line">                .filter(rank -&gt; rank.isMatched(matchCount, bonusMatch))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElseThrow(InvalidMatchCountException::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//등수 기준 구현 메서드는 위에 나와있으니 생략.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">(<span class="keyword">int</span> matchCount, <span class="keyword">boolean</span> bonusMatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.apply(matchCount, bonusMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LottoRank의 모든 객체들을 순회하면서 그 객체의 BiFunction에 판별에 필요한 정보를 전달해줘서 적절한 순위를 찾아낸다!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Junit으로 parameterized test</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/</guid>
      <pubDate>Mon, 21 Feb 2022 12:16:22 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다.&lt;/p&gt;
&lt;h3 id</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>@ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다.</p><h3 id="MethodSource"><a href="#MethodSource" class="headerlink" title="@MethodSource"></a>@MethodSource</h3><blockquote><p>도입 배경</p></blockquote><p>자동차 이름의 글자 갯수가 5개 이하여야 하고, 자동차 이름이 빈 문자열이면 안되고 등등 다양한 제약 사항을 테스트해보고 싶다고 하자.<br>근데 테스트 코드를 작성하다보니 다음과 같이 메서드가 비슷비슷하게 나올 때 이를 리팩토링해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;NonAsciiCharacters&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_글자수_테스트() &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(<span class="string">&quot;다섯글자이상&quot;</span>))</span><br><span class="line">                .isInstanceOf(RuntimeException.class)</span><br><span class="line">                .hasMessageContaining(<span class="string">&quot;자동차 이름은 5자 이하여야 합니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름이_존재하지_않는_경우_테스트() &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                .isInstanceOf(RuntimeException.class)</span><br><span class="line">                .hasMessageContaining(<span class="string">&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 등등...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>해결하기</p></blockquote><p>주목할 점은 한 테스트 메서드에 여러개의 인자를 여러 케이스로 보낼 수 있다는 점이다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarNameTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title">provideCarNameAndExceptionMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">                Arguments.of(<span class="keyword">null</span>, <span class="string">&quot;자동차 이름을 찾을 수 없습니다!&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;다섯글자이상&quot;</span>, <span class="string">&quot;자동차 이름은 5자 이하여야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;&quot;</span>, <span class="string">&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot; &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>),</span><br><span class="line">                Arguments.of(<span class="string">&quot;    &quot;</span>, <span class="string">&quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_예외_테스트(String carName, String message) &#123;</span><br><span class="line">        assertThatThrownBy(() -&gt; <span class="keyword">new</span> CarName(carName))</span><br><span class="line">                .isInstanceOf(CarNameException.class)</span><br><span class="line">                .hasMessageContaining(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음같이 @ParameterizedTest해서 @MethodSource로 해결할 수 있다!</p><h3 id="ValueSource"><a href="#ValueSource" class="headerlink" title="@ValueSource"></a>@ValueSource</h3><blockquote><p>도입 배경</p></blockquote><p>한가지 메서드에 여러가지 경우의 수를 넣어 실험하고 싶은데 어떻게 할까?<br>예를 들어 자동차 이름에 여러가지 이름을 넣어보고 실제로 들어갔는지 테스트해보고 싶으면 어떻게 할지 고민해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_테스트() &#123;</span><br><span class="line">  Car klayCar = <span class="keyword">new</span> Car(<span class="string">&quot;klay&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(klayCar.getName()).isEqualTo(<span class="string">&quot;klay&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Car eveCar = <span class="keyword">new</span> Car(<span class="string">&quot;eve&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(eveCar.getName()).isEqualTo(<span class="string">&quot;eve&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Car pobiCar = <span class="keyword">new</span> Car(<span class="string">&quot;pobi&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  assertThat(pobiCar.getName()).isEqualTo(<span class="string">&quot;pobi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 무식하게 하면 당연히 뚜들겨 맞는다.</p><blockquote><p>해결하기</p></blockquote><p>주목할점은 전달될 인자의 자료형에 따라 strings, ints 등 필드값을 바꿔주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;클레이&quot;, &quot;이브&quot;, &quot;포비&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 자동차_이름_테스트(String carName) &#123;</span><br><span class="line">  Car car = <span class="keyword">new</span> Car(carName, <span class="number">0</span>);</span><br><span class="line">  assertThat(car.getName()).isEqualTo(carName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnumSource"><a href="#EnumSource" class="headerlink" title="@EnumSource"></a>@EnumSource</h3><p>열거형도 파라미터로 전달해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = CardFace.class)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore &gt; <span class="number">0</span> &amp;&amp; cardScore &lt; <span class="number">11</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>names 필드를 통해 열거형에서 일부만 골라서 넘겨줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore == <span class="number">10</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode 필드를 사용하면 일부를 제외하고 넘겨줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParametherizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(</span></span><br><span class="line"><span class="meta">    value = CardFace.class, </span></span><br><span class="line"><span class="meta">    names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;,</span></span><br><span class="line"><span class="meta">    mode = EnumSource.Mode.EXCLUDE)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAllSuit</span><span class="params">(CardFace face)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cardScore = face.getScore();</span><br><span class="line">    assertThat(cardScore != <span class="number">10</span>).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CsvSource"><a href="#CsvSource" class="headerlink" title="@CsvSource"></a>@CsvSource</h3><p>CsvSource는 여러 값을 문자열로 작성해주면 알아서 맞는 매개변수로 바꿔서 가져온다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(value = &#123;&quot;ACE,FIVE,true&quot;, &quot;ACE,SIX,false&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">canReceiveCard</span><span class="params">(CardFace face1, CardFace face2, <span class="keyword">boolean</span> expected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Participator dealer = <span class="keyword">new</span> Dealer();</span><br><span class="line">    <span class="keyword">final</span> Card firstCard = <span class="keyword">new</span> Card(SPADE, face1);</span><br><span class="line">    <span class="keyword">final</span> Card secondCard = <span class="keyword">new</span> Card(SPADE, face2);</span><br><span class="line"></span><br><span class="line">    dealer.receiveCard(firstCard);</span><br><span class="line">    dealer.receiveCard(secondCard);</span><br><span class="line"></span><br><span class="line">    assertThat(dealer.canReceiveCard()).isEqualTo(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>파라미터 테스트 이름 설정하기</p></blockquote><p>@ParameterizedTest의 name 필드에 {매개변수인덱스}를 넘겨주면 해당 인자가 테스트 이름에 포함된다.</p><p>{매개변수 인덱스} 말고도 다양한 템플릿을 사용할 수 있다.<br>{displayName} : 테스트 메서드 이름<br>{arguments} : 모든 인자를 쉼표로 구분해서 모두 표현<br>{argumentsWithNames} : 모든 인자를 이름과 함께 보여줌.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest(name = &quot;&#123;0&#125; vs &#123;1&#125; is &#123;2&#125;&quot;)</span></span><br><span class="line"><span class="meta">@CsvSource(value = &#123;&quot;BLACKJACK,BUST,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BLACKJACK,STAND,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,BUST,WIN&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BLACKJACK,BLACKJACK,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,STAND,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BUST,BUST,DRAW&quot;,</span></span><br><span class="line"><span class="meta">        &quot;BUST,STAND,LOSE&quot;,</span></span><br><span class="line"><span class="meta">        &quot;STAND,BLACKJACK,LOSE&quot;,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getResultFromStatus</span><span class="params">(Status status1, Status status2, Result expected)</span> </span>&#123;</span><br><span class="line">    Result actual = Result.of(status1, status2);</span><br><span class="line"></span><br><span class="line">    assertThat(actual).isEqualTo(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>더 알아보기</p></blockquote><p><a href="https://www.baeldung.com/parameterized-tests-junit-5">https://www.baeldung.com/parameterized-tests-junit-5</a></p><p><a href="https://www.arhohuttunen.com/junit-5-parameterized-tests/">https://www.arhohuttunen.com/junit-5-parameterized-tests/</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한테크코스 자동차 경주 미션 회고</title>
      <link>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/</link>
      <guid>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/</guid>
      <pubDate>Mon, 21 Feb 2022 09:37:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.&lt;br&gt;같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다.&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.<br>같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다.</p><p>페어 프로그래밍으로 같이 하면서, 처음엔 나 혼자하는게 더 빠르지 않을까 싶기도 했었는데,<br>같이하는 페어의 독특한 생각을 많이 느낄 수 있어서 나 혼자하는 것보다 더 괜찮은 결과물을 얻을 수 있었던 것 같다.</p><p>미션을 마무리한 날, 같은 데일리 미팅 크루들과 자신의 코드를 설명하는 시간을 가졌다.<br>역시 각 크루들의 코드가 나와 다른 부분도 많았는데, 그 부분을 잘 설득하는 크루를 보며 감탄했다.<br>반면 나는 아직 설명도 제대로 못하고, 내가 왜 그렇게 짰는지 설득도 잘 못하는 것 같아 아쉽다…!</p><p>부족한 게 많으면 나아질 부분도 많다는 뜻. 이제 더 열심히 공부해서 다른 크루에게 도움이 되는 크루가 되자.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/">우아한테크코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
