<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Sun, 07 May 2023 12:37:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>클라우드 서비스의 인증과 보안</title>
      <link>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/</link>
      <guid>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/</guid>
      <pubDate>Sun, 07 May 2023 09:26:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h1&gt;&lt;p&gt;API와 통신할 때 사용하는 프로토콜인 HTTP는 통신 내용을 평문으로 전달된다. 그래서 도청하면 내용을</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>API와 통신할 때 사용하는 프로토콜인 HTTP는 통신 내용을 평문으로 전달된다. 그래서 도청하면 내용을 그대로 알 수 있게 된다.<br>HTTPS는 통신 내용에 보안이 중요한 내용을 다룰 때 사용되는 기술이다. HTTP over SSL&#x2F;TLS이라는 의미다. HTTPS는 포트번호로 443을 사용한다.<br>SSL&#x2F;TLS는 OSI 참조모델에서 L4인 전송 계층에서 적용된다.</p><blockquote><p>SSL과 TLS<br>둘다 인터넷 상의 안전한 통신을 위한 프로토콜. SSL은 1990년대에 개발되었지만 3.0까지만 지원하고 보안 취약점이 많다. 그래서 SSL의 후속버전인 TLS이 1999년에 개발됐다. 현재는 TLS가 SSL의 대체제로 널리 사용된다.</p></blockquote><h2 id="인증서"><a href="#인증서" class="headerlink" title="인증서"></a>인증서</h2><p>HTTPS에는 인증서가 사용된다. 인증서는 크게 서버 인증서와 클라이언트 인증서로 분류된다. 기본적으로 HTTPS에서는 서버 인증서로 서버의 신원을 검증한다.<br>필요한 경우에는 클라이언트 신원을 검증하는 클라이언트 인증서를 사용해서 보안 수준을 높일 수 있으나, 서버 인증서만 적용하는 게 일반적이다.<br>클라이언트 검증은 HTTP 헤더의 User-Agent 정보를 활용해서 알아내는 등 다양한 다른 방법으로 검증할 수 있다.</p><h3 id="키"><a href="#키" class="headerlink" title="키"></a>키</h3><p>통신 내용을 암복호화 하려면 키가 필요하다. </p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>오케스트레이션</title>
      <link>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/</link>
      <guid>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/</guid>
      <pubDate>Wed, 05 Apr 2023 11:35:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오케스트레이션과-오토메이션&quot;&gt;&lt;a href=&quot;#오케스트레이션과-오토메이션&quot; class=&quot;headerlink&quot; title=&quot;오케스트레이션과 오토메이션&quot;&gt;&lt;/a&gt;오케스트레이션과 오토메이션&lt;/h1&gt;&lt;p&gt;데브옵스 관점에서 오케스트레이션은 &lt;co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오케스트레이션과-오토메이션"><a href="#오케스트레이션과-오토메이션" class="headerlink" title="오케스트레이션과 오토메이션"></a>오케스트레이션과 오토메이션</h1><p>데브옵스 관점에서 오케스트레이션은 <code>소프트웨어 개발의 자동화를 위해 태스크를 만드는 작업</code>이다.<br>데브옵스 관점에서 오토메이션은 <code>CI 툴을 사용해서 빌드나 소스 코드 정적 검사를 자동화하는 작업</code>이다.</p><p>일반적으로 오케스트레이션 및 오토메이션의 접근 방법은 두가지로 나뉜다.</p><ul><li>프로그래밍 언어처럼 애플리케이션 설치나 설정 순서를 열거하고 절차형 툴을 통해 자동화</li><li>애플리케이션에 최적화된 인프라 상태를 템플릿 형태로 정의하고 이를 관리하는 선언형 기능 사용</li></ul><p>절차형 툴은 앤서블 등이 대표적이다. 절차형 툴은 구성 정보나 설정 정보를 관리하는 서버와 설정을 적용하는 클라이언트로 나뉜다. 서버가 클라이언트의 상태를 모니터링하면서 원하는 상태로 유지되도록 관리한다.<br>선언형 툴은 AWS CloudFormation이 있다. 시스템 리소스들을 하나의 템플릿으로 정의하고 이 템플릿으로 인프라의 프로비저닝을 한다.</p><blockquote><p>절차형 툴과 선언형 툴의 작용 범위<br>절차형 툴과 선연형 툴의 작용 범위가 다르다.<br>선언형 툴은 네트워크 및 블록 스토리지를 준비하고 이미지를 사용한 서버를 기동하는 등 인프라 리소스를 구성할 때 주로 사용된다.<br>절차형 툴은 선언형 툴이 구성한 클라우드 리소스 위에 OS를 설치하고 어플리케이션을 설치할 때 주로 사용된다.<br>이 차이를 잘 알고 충돌하지 않도록 툴을 사용해야 한다.</p></blockquote><h2 id="오케스트레이션과-리소스-집합체의-기본-사상"><a href="#오케스트레이션과-리소스-집합체의-기본-사상" class="headerlink" title="오케스트레이션과 리소스 집합체의 기본 사상"></a>오케스트레이션과 리소스 집합체의 기본 사상</h2><p>클라우드 리소스를 관리할 때 REST API를 활용해서 제어해도 된다. 문제는 관리할 리소스가 매우 많아지거나 의존성 때문에 API 호출 순서가 복잡해지면 리소스 관리가 어려워진다. 그래서 리소스를 그룹으로 묶어서 관리하는 상황에 이르게 된다.<br>오케스트레이션은 궁극적으로 리소스의 집합체를 정의하는 기술이다. 오케스트레이션은 액션에 해당하는 API로 처리하는 방식에서 리소스 그룹으로 처리하는 방식으로 전환함을 의미한다. 리소스의 집합체를 <code>스택</code>으로 지칭하며 스택을 활용하면 개별 리소스마다 액션에 해당하는 API 호출보다 훨씬 적은 API 호출로 다수의 리소스를 관리할 수 있다.</p><h2 id="오케스트레이션의-근간인-템플릿"><a href="#오케스트레이션의-근간인-템플릿" class="headerlink" title="오케스트레이션의 근간인 템플릿"></a>오케스트레이션의 근간인 템플릿</h2><p>템플릿은 리소스를 정의하는 역할을 한다. 템플릿은 클라우드 서비스마다 상이하다. 다만 몇 가지는 공통된다. 리소스, 파라미터, 아웃풋이 공통된다.</p><h3 id="리소스"><a href="#리소스" class="headerlink" title="리소스"></a>리소스</h3><p>템플릿이 오케스트레이션의 근간이면, 리소스는 템플릿의 근간이다. 템플릿에는 다수의 리소스를 정의할 수 있다. 리소스의 이름, 타입, 프로퍼티를 통해 리소스에 대한 정보를 정할 수 있고, 필요하면 다른 리소스와 의존관계를 표현해서 리소스 간 순서를 제어할 수도 있다.(AWS CloudFormation에서 <code>DependsOn</code>) 다른 리소스의 속성 정보를 참조하는 <code>Ref</code>도 활용할 수 있다.</p><p>다음은 시큐리티 그룹에 속한 EC2 인스턴스를 정의하는 AWS CloudFormation의 리소스 부분이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;EC2Instance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;InstanceType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceType&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SecurityGroups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceSecurityGroup&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;KeyName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KeyName&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ImageId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;AWSRegionArch2AMI&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::Region&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;AWSInstanceType2Arch&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceType&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;Arch&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="attr">&quot;InstanceSecurityGroup&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::SecurityGroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;GroupDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable SSH access via port 22&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SecurityGroupIngress&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;IpProtocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;FromPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ToPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;CidrIp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SSHLocation&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="파라미터"><a href="#파라미터" class="headerlink" title="파라미터"></a>파라미터</h3><p>템플릿의 리소스와 프로퍼티 값이 고정되어 있으면 템플릿을 특정 설정에만 사용할 수 있게 된다. 즉 재사용이 안된다. 이를 대응하는 부분이 파라미터다. 파라미터는 템플릿의 가변적인 정보를 입력할 수 있는 부분이다. 파라미터를 통해 템플릿 재사용성을 높일 수 있다.</p><p>파라미터로 입력된 값을 사용하려면 앞서 리소스에서 언급한 <code>Ref</code>로 파라미터의 이름을 입력하면 된다.</p><p>다음은 시큐리티 그룹에 속하는 EC2 인스턴스를 만드는 AWS CloudFormation의 템플릿 중 파라미터 부분이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;KeyName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Name of an existing EC2 KeyPair to enable SSH access to the instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::EC2::KeyPair::KeyName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be the name of an existing EC2 KeyPair.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;InstanceType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebServer EC2 instance type&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t2.small&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;AllowedValues&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;t1.micro&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">//...생략</span></span><br><span class="line">      <span class="string">&quot;cg1.4xlarge&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be a valid EC2 instance type.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;SSHLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The IP address range that can be used to SSH to the EC2 instances&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MinLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MaxLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;AllowedPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)\\.(\\d&#123;1,3&#125;)/(\\d&#123;1,2&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConstraintDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;must be a valid IP CIDR range of the form x.x.x.x/x.&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="아웃풋"><a href="#아웃풋" class="headerlink" title="아웃풋"></a>아웃풋</h3><p>템플릿 처리 과정에서 출력하는 내용을 다룬다.</p><p><code>Fn::GetAtt</code>로 리소스의 프로퍼티 정보를 직접 인용할 수 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;InstanceId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstanceId of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EC2Instance&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AZ&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Availability Zone of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;AvailabilityZone&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PublicDNS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Public DNSName of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;PublicDnsName&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;PublicIP&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Public IP address of the newly created EC2 instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Fn::GetAtt&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;EC2Instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;PublicIp&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>템플릿을 어느 세월에 다만드냐..?<br>일일히 템플릿을 작성하는게 부담되는 경우, 이미 존재하는 리소스를 기반으로 템플릿을 생성할 수 있다.(AWS CloudFormer)</p></blockquote><h1 id="오케스트레이션의-장점"><a href="#오케스트레이션의-장점" class="headerlink" title="오케스트레이션의 장점"></a>오케스트레이션의 장점</h1><h2 id="인프라-환경-구축-단계-관점"><a href="#인프라-환경-구축-단계-관점" class="headerlink" title="인프라 환경 구축 단계 관점"></a>인프라 환경 구축 단계 관점</h2><p>서버, 네트워크, 스토리지를 생성할 때 웹 콘솔을 사용하던지 API를 조합한 CLI를 실행하던지 SDK를 활용한 프로그램을 사용할 수 있다. 다만 이런 방법들은 리소스 종류가 달라지면 수정해줘야 한다.</p><p>오케스트레이션은 템플릿으로 리소스 관계 및 상태를 정의할 수 있게 돕고, 오케스트레이션 엔진이 리소스 배치와 시스템 상태 유지를 자동으로 지원한다.<br>관리자는 리소스마다 상태 확인할 필요 없이 각 스택의 상태를 확인하면 된다. 그리고 템플릿의 상한 값 설정으로 잘못된 값 입력을 방지할 수 있다.</p><h2 id="인프라-환경-운영-단계-관점"><a href="#인프라-환경-운영-단계-관점" class="headerlink" title="인프라 환경 운영 단계 관점"></a>인프라 환경 운영 단계 관점</h2><p>리소스가 생성되고 나서도 오케스트레이션의 장점이 있다. 먼저 리소스 간 의존 관계를 정의해서 리소스 기동 순서를 제어할 수 있다.<br>또한 오토스케일링과 오토 힐링도 구현할 수 있다. 감시서버를 두고 로드 밸런서가 장애를 통보하면 이를 오케스트레이션 API를 통해 오케스트레이션 엔진에게 알려주고 오케스트레이션 엔진이 서버 API를 통해 리소스를 다시 기동하거나 리소스를 추가하는 방식으로 대응할 수 있다. (오토 힐링과 오토스케일링은 굳이 오케스트레이션이 아니어도 가능하다.)</p><h2 id="재사용-템플릿을-활용한-환경-복제-방식-관점"><a href="#재사용-템플릿을-활용한-환경-복제-방식-관점" class="headerlink" title="재사용 템플릿을 활용한 환경 복제 방식 관점"></a>재사용 템플릿을 활용한 환경 복제 방식 관점</h2><p>오케스트레이션은 템플릿을 통해 동일한 인프라 환경 구성을 빠르게 복제할 수 있다. 특히 파라미터를 통해 하나의 템플릿도 동적으로 변화를 줄 수 있다. 예를 들면 어떤 검증을 해야 할 때 하나의 템플릿을 파라미터를 다르게 해서 여러 환경을 만들어서 병렬로 검증을 해볼 수 있다. 또한 리전 정보를 파라미터로 전달하면 특정 리전에 속한 리소스에 문제가 생겼을 경우, 빠르게 파라미터를 바꾸서 새로운 인프라를 구축해서 활용할 수 있다.</p><h2 id="오케스트레이션을-활용한-지속적-통합-관점"><a href="#오케스트레이션을-활용한-지속적-통합-관점" class="headerlink" title="오케스트레이션을 활용한 지속적 통합 관점"></a>오케스트레이션을 활용한 지속적 통합 관점</h2><p>기존의 지속적 통합은 특정 환경에 애플리케이션을 배포하는 용도로 많이 사용했다. 애플리케이션의 변경 사항만 반영해서 릴리즈하고 서버, 스토리지, 네트워크의 구성 변경에는 관여하지 않았다. 하지만 클라우드 환경에서는 오케스트레이션 기능으로 인프라도 코드처럼 제어할 수 있다. 즉 CI 작업에 인프라 변경도 포한할 수 있게 됐다. 스택에 인프라 환경 뿐만 아니라 애플리케이션을 함께 정의하는 방식으로 구현한다.</p><h1 id="오케스트레이션의-주의사항"><a href="#오케스트레이션의-주의사항" class="headerlink" title="오케스트레이션의 주의사항"></a>오케스트레이션의 주의사항</h1><h2 id="스택으로-생성한-리소스는-개별-액션-API로-변경하지-않는다"><a href="#스택으로-생성한-리소스는-개별-액션-API로-변경하지-않는다" class="headerlink" title="스택으로 생성한 리소스는 개별 액션 API로 변경하지 않는다."></a>스택으로 생성한 리소스는 개별 액션 API로 변경하지 않는다.</h2><p>스택으로 생성한 리소스, 즉 오케스트레이션 API로 관리하는 리소스를 개별 액션 API로 변경하면 안된다. 왜냐면 개별 액션 API로 스택 내부의 리소스를 변경하면 템플릿 설정 내용과 변경된 상태에 차이가 생겨 정합성이 깨지게 된다. 그렇다고 사소한 작업 모두 오케스트레이션 API를 활용하면 더 느리고 번거로울 수 있다. 그래서 현업에서는 오케스트레이션 API로 관리되는 리소스와 그렇지 않은 리소스를 나눠서 관리하곤 한다.</p><h2 id="스택-반영-후-각-리소스에-정상-반영됐는-지-확인한다"><a href="#스택-반영-후-각-리소스에-정상-반영됐는-지-확인한다" class="headerlink" title="스택 반영 후 각 리소스에 정상 반영됐는 지 확인한다."></a>스택 반영 후 각 리소스에 정상 반영됐는 지 확인한다.</h2><p>오케스트레이션에는 스택을 갱신하는 기능이 있다. 이 작업을 통해 리소스에 정상 반영됐는 지 모니터링 해야 한다. 특히 일부 리소스는 갱신하는 과정에서 일정 시간동안 서비스를 하지 못하는 다운 타임이 발생할 수 있다. (AWS에서는 <code>Update requires: Replacement</code>로 표시된 리소스가 해당) 이런 경우, 스택을 따로 만들어놓고 바꿔치는 이뮤터블 인프라 스터럭처를 고려해본다.</p><h2 id="오케스트레이션-기능을-지원하지-않는-컴포넌트나-리소스를-미리-식별한다"><a href="#오케스트레이션-기능을-지원하지-않는-컴포넌트나-리소스를-미리-식별한다" class="headerlink" title="오케스트레이션 기능을 지원하지 않는 컴포넌트나 리소스를 미리 식별한다."></a>오케스트레이션 기능을 지원하지 않는 컴포넌트나 리소스를 미리 식별한다.</h2><p>내가 사용할 리소스가 오케스트레이션으로 지원하지 않으면 당연히 문제가 된다. 이를 미리 파악하고 사용하자.</p><h2 id="스택과-템플릿의-적정-크기와-스택-중첩"><a href="#스택과-템플릿의-적정-크기와-스택-중첩" class="headerlink" title="스택과 템플릿의 적정 크기와 스택 중첩"></a>스택과 템플릿의 적정 크기와 스택 중첩</h2><p>한 스택에서 관리하는 리소스의 갯수가 점점 늘어나고 리소스마다 릴리즈의 빈도나 서비스 수준이 달라질 수 있다. 이러면 스택을 분리해야 한다.<br>일반적으로 스택 분리는 공통 요소와 서브 시스템으로 나눈다. 서브 시스템으로 분리하면 서로 의존도가 낮아지고 릴리즈가 더 빨라진다.<br>공통 요소는 AWS CloudFormation에서 다음 예시들이 해당한다.</p><ul><li>공통 운영 서비스</li><li>네트워크(VPC)</li><li>인증(IAM)</li><li>프론트엔드(DMZ)</li><li>데이터스토어(DB, Storage)</li></ul><p>이렇게 스택을 여러개로 나누면 스택 사이의 정보 전달이 필요할 수 있다. 이럴 때 쓰이는게 파라미터와 아웃풋이다. 한 스택의 아웃풋을 다른 스택의 파라미터로 활용하여 분리된 스택이 서로 소통할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드에서 네트워크 리소스를 제어하는 방법</title>
      <link>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/</link>
      <guid>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/</guid>
      <pubDate>Tue, 04 Apr 2023 11:58:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;네트워크-리소스의-기본&quot;&gt;&lt;a href=&quot;#네트워크-리소스의-기본&quot; class=&quot;headerlink&quot; title=&quot;네트워크 리소스의 기본&quot;&gt;&lt;/a&gt;네트워크 리소스의 기본&lt;/h1&gt;&lt;p&gt;네트워크의 기능은 크게 L2 네트워크(OSI 참조 모델</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="네트워크-리소스의-기본"><a href="#네트워크-리소스의-기본" class="headerlink" title="네트워크 리소스의 기본"></a>네트워크 리소스의 기본</h1><p>네트워크의 기능은 크게 L2 네트워크(OSI 참조 모델의 데이터링크 계층)과 L3 네트워크(OSI 참조 모델의 네트워크)로 나눠볼 수 있다.<br>L2 네트워크는 같은 네트워크에 속한 장비를 연결한다. 대표적으로 스위치가 이런 역할을 한다.<br>L3 네트워크는 서로 다른 L2 네트워크를 연결한다. 대표적으로 라우터가 이런 역할을 한다.</p><p>네트워크에서 중요한 포인트는 IP 주소를 잘 다루느냐이다. 클라우드 환경에서는 IP 관리를 기본으로 포함하는 경우가 많다. 클라우드 환경에서는 IP 주소를 DHCP를 통해 할당된다. 다만 클라우드 환경에서는 DNS 확장성이나 오토 스케일링, 오토 힐링 같은 기능을 이용하기 위해서 IP 주소에 종속되지 않도록 해야 한다.</p><h1 id="클라우드-환경의-네트워크-리소스"><a href="#클라우드-환경의-네트워크-리소스" class="headerlink" title="클라우드 환경의 네트워크 리소스"></a>클라우드 환경의 네트워크 리소스</h1><table><thead><tr><th>네트워크 리소스</th><th>AWS VPC</th><th>오픈스택 Neutron</th></tr></thead><tbody><tr><td>네트워크 전체</td><td>없음</td><td>VPC</td></tr><tr><td>스위치</td><td>네트워크</td><td>(서브넷에 포함)</td></tr><tr><td>서브넷</td><td>서브넷</td><td>서브넷</td></tr><tr><td>라우터</td><td>라우터</td><td>게이트웨이, 라우팅 테이블</td></tr><tr><td>포트</td><td>포트</td><td>ENI</td></tr><tr><td>시큐리티 그룹</td><td>시큐리티 그룹</td><td>시큐리티 그룹</td></tr><tr><td>네트워크 접근 제어</td><td>Fwaas</td><td>NACL</td></tr></tbody></table><p>AWS는 한 테넌트가 여러 VPC를 생성할 수 있지만, 오픈스택은 한 테넌트는 하나의 가상 네트워크만 만들 수 있다.<br>두 서비스 모두 가상 네트워크별로 가상 라우터를 배치한다.</p><h1 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h1><p>가상 스위치는 L2 네트워크 기능을 수행한다. 가상 스위치에 연결된 가상 서버는 별도의 라우팅 없이 서로 통신할 수 있다.<br>가상 스위치는 L3 네트워크에서 쓰이는 IP 주소 범위(CIDR)를 서브넷이라는 이름으로 할당 받는다! 서브넷 범위 내의 IP를 사용자가 자유롭게 할당할 수 있다.<br>클라우드 환경에서는 네트워크끼리 직접 연결되어 있지 않으면 같은 IP 주소를 써도 된다. 다만 공인 IP와 중복되지 않도록 사설 IP 주소의 범위에서 할당되는 게 일반적이다.</p><p>AWS VPC에서는 가상 스위치에 대응하는 리소스가 없다. 대신 서브넷에서 가상 스위치의 개념과 기능을 한다. 대부분 가상 스위치와 서브넷이 1대1 관계이고 TCP&#x2F;IP를 사용할 때는 서브넷만 정의해도 충분하기 때문이다.</p><p>IP 주소 범위는 두단계로 지정된다. VPC를 생성할 때 정하고, VPC의 IP 범위 안에서 서브넷에서 사용할 범위를 정할 수 있다. VPC는 한번 할당받은 IP주소 범위를 수정할 수 없기 때문에 애초에 여유있게 정할 필요가 있다.</p><p><img src="https://user-images.githubusercontent.com/87690744/229852310-21903512-9800-4e96-9162-152881101a62.png"></p><h2 id="서브넷"><a href="#서브넷" class="headerlink" title="서브넷"></a>서브넷</h2><p>서브넷에 연결된 서버는 기동 시 DHCP를 통해 IP 주소를 할당받고 그 IP 주소로 통신하게 된다. 다만 DHCP로 IP 주소를 받는다고 해서 매번 기동할 때마다 다른 주소를 받는게 아니다. 이미 IP 주소가 할당된 것을 DHCP가 전달할 뿐이다. 그래서 한번 기동한 서버를 여러번 재기동해도 같은 IP 주소가 부여된다.</p><p>서브넷은 할당된 IP 주소에만 통신을 허용한다. 그래서 사용자가 임의로 IP 주소 설정을 바꿔도 변경된 IP 주소로 통신하지 못한다.</p><p>서브넷은 해당 범위 안에서 통신할 수 있는 폐쇄적인 환경이라 다른 사람의 서브넷이나 IP주소가 중복되도 상관없다.</p><h3 id="IP-주소의-범위-CIDR"><a href="#IP-주소의-범위-CIDR" class="headerlink" title="IP 주소의 범위 (CIDR)"></a>IP 주소의 범위 (CIDR)</h3><p>서브넷을 생성할 때 지정하는 IP 주소 범위를 CIDR(사이더)라고 한다. Classless Inter Domain Routing을 줄인 말으로 직역하면 ‘클래스가 없는 내부 도메인 라우팅’이다.</p><p>CIDR은 IP 주소를 서브넷을 식별하는 네트워크 부분과 서브넷 안에서 개별 통신 장비를 식별하는 호스트 부분으로 나눈다. 그리고 네트워크 부분의 비트 길이를 서브넷 마스크로 표현한다.</p><p>인터넷 초창기에는 IP 주소의 상위 비트 값에 따라 서브넷 마스크가 결정됐다.<br>0으로 시작하면 서브넷 마스크가 8비트로 클래스 A로 부른다. 대략 1600만개 주소가 가능하다.<br>128으로 시작하면 서브넷 마스크가 16비트로 클래스 B로 부른다. 대략 65000개 주소가 가능하다.<br>223으로 시작하면 서브넷 마스크가 24비트로 클래스 C로 부른다. 대략 256개 주소가 가능하다.<br>하지만 1600만개 주소가 필요한 서브넷은 별로 없다. 그래서 클래스 A는 남는 주소가 많아 비효율적이다.</p><p>이런 고정된 서브넷 마스크 대신 가변 길이의 서브넷 마스크를 가진 CIDR를 통해 효율적으로 IP 주소를 할당한다.</p><h1 id="라우터"><a href="#라우터" class="headerlink" title="라우터"></a>라우터</h1><p>라우터는 서로 다른 네트워크를 연결한다.<br>라우터는 다음과 같은 세가지 유형의 연결 방식이 가능하다.</p><ol><li>내부 -&gt; 내부</li><li>내부 -&gt; 외부</li><li>외부 -&gt; 내부<br>여기서 내부는 클라우드 네트워크를 의미한다.</li></ol><h3 id="내부-gt-내부"><a href="#내부-gt-내부" class="headerlink" title="내부 -&gt; 내부"></a>내부 -&gt; 내부</h3><p>서로 다른 네트워크에 속한 서버끼리 통신한다. 기본적으로 VPC 내의 네트워크들을 연결한다. 경우에 따라서는 다른 테넌트의 네트워크를 라우팅해야 할 때가 있다. AWS에서는 VPC Peering, 오픈스택 Neutron에서는 네트워크 공유 기능을 사용한다.</p><h3 id="내부-gt-외부"><a href="#내부-gt-외부" class="headerlink" title="내부 -&gt; 외부"></a>내부 -&gt; 외부</h3><p>가상 네트워크에 속한 서버가 인터넷을 통해 외부로 접속되는 경우를 의미한다. 이때 라우터에서는 내부 네트워크에서 사용하는 사설 IP 주소를 공인 IP 주소로 변환하는 IP 마스커레이드를 하게된다.</p><blockquote><p>IP 마스커레이드는 내부의 호스트들이 하나의 공인 IP로 사용. NAT를 통해 내부 IP에게 전달.</p></blockquote><h3 id="외부-gt-내부"><a href="#외부-gt-내부" class="headerlink" title="외부 -&gt; 내부"></a>외부 -&gt; 내부</h3><p>외부에서 내부 네트워크로 접근하려면 공인 IP가 필요하다. 오픈 스택에서는 플로팅 IP, AWS에서는 EIP가 활용된다. 이런 공인 IP는 리전 별로 관리가 되고 어드레스 풀에서 확보해서 논리포트에 할당한다.</p><h2 id="오픈스택-Neutron의-라우터"><a href="#오픈스택-Neutron의-라우터" class="headerlink" title="오픈스택 Neutron의 라우터"></a>오픈스택 Neutron의 라우터</h2><p>크게 가상 라우터와 서브넷의 연결 관계로 구성된다. 가상 라우터는 논리 포트로 연결된다.<br>연결된 후 가상 라우터의 라우팅 테이블이 갱신되어 이에 따라 전송 트래픽이 흘러간다.<br>만약 외부 네트워크와 통신하되 각 서브넷끼리 통신을 막고 싶으면 서브넷마다 라우터를 만들어서 각 라우터를 외부 네트워크에 연결해서 사용하면 된다.</p><h2 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h2><p>크게 게이트웨이와 라우팅 테이블로 구성된다. AWS에서는 외부로 통신하기 위해 VPC 안에 게이트웨이를 만든다. 그런 다음 서브넷의 라우팅 테이블에서 외부로 통신할 때 만든 게이트웨이를 통과하도록 라우팅 정보를 설정한다.</p><p>게이트웨이는 역할에 따라 여러 종류가 있다.</p><ul><li>인터넷 통신을 위한 인터넷 게이트웨이 (IGW)</li><li>사설 네트워크 통신을 위한 버추얼 게이트웨이 (VGW)</li><li>리전 안에서 VPC끼리 연결하는 피어링 커넥션 (PCX)</li><li>인터넷에 연결된 서비스(S3)를 VPC에서 인터넷을 거치지 않고 연결하는 VPC 엔드포인트</li></ul><p>AWS에서는 실제로 라우터가 리소스로 존재하지 않는다. 대신 라우팅 테이블을 통해 라우팅을 정한다. 라우팅 테이블은 VPC와 서브넷에 설정할 수 있다. VPC에 설정하는 건 메인 라우팅 테이블이고, 서브넷에 설정하는 것은 서브 라우팅 테이블이라 한다.</p><h1 id="포트"><a href="#포트" class="headerlink" title="포트"></a>포트</h1><p>논리 포트는 물리 스위치의 포트를 가상화한 개념이다. Neutron에서는 가상 스위치의 접점 의미가 강하고, AWS에서는 서버와 네트워크의 연결 인터페이스 개념이 강하고 ENI(elastic network interface)라고 부른다.</p><p>논리 포트는 물리적인 포트와 다른 점이 있다. 논리 포트는 생성될 때 자신이 소속된 가상 서브넷으로부터 IP 주소를 할당 받는다. 그리고 해당 포트는 그 IP 주소 외 통신은 차단한다. 논리 포트는 여러개의 IP 주소를 할당 받을 수 있다.</p><h3 id="논리-포트-NIC-로-Failover"><a href="#논리-포트-NIC-로-Failover" class="headerlink" title="논리 포트(NIC)로 Failover"></a>논리 포트(NIC)로 Failover</h3><p>논리 포트를 다른 가상 서버에 옮겨서 할당할 수 있다. 즉 하나의 서버에 문제가 생기면 다른 가상 서버에 논리 포트를 옮겨서 장애에 대응할 수 있다. IP 주소의 변경 없이 사용하는 가상 서버를 교체할 수 있다.</p><h3 id="게이트웨이로써-논리-포트"><a href="#게이트웨이로써-논리-포트" class="headerlink" title="게이트웨이로써 논리 포트"></a>게이트웨이로써 논리 포트</h3><p>논리 포트는 서버와 가상 네트워크 연결에만 사용되지 않는다. 가상 네트워크와 라우터를 연결할 때도 쓰인다. 이런 포트에 할당된 IP 주소는 가상 서브넷의 게이트웨이 역할을 한다. 논리 포트를 통해 서브넷에 연결된 가상 서버는 이 게이트웨이(가상 포트)를 통해 클라우드 외부로 통신할 수 있다.</p><p>플로팅 IP(AWS의 엘라스틱 IP)도 논리 포트에 할당한다. 가상의 NAT에서 플로팅 IP로 온 트래픽을 할당된 논리포트로 라우팅한다.</p><h3 id="논리-포트와-맥-주소"><a href="#논리-포트와-맥-주소" class="headerlink" title="논리 포트와 맥 주소"></a>논리 포트와 맥 주소</h3><p>논리 포트는 IP 주소말고 맥 주소도 가진다. 맥 주소는 물리적인 L2 네트워크 정보로 가상 서버와 연결할 때 가상 서버 NIC의 맥 주소로 활용된다.</p><h1 id="시큐리티-그룹"><a href="#시큐리티-그룹" class="headerlink" title="시큐리티 그룹"></a>시큐리티 그룹</h1><p>시큐리티 그룹은 트래픽을 필터링한다.<br>물리 환경에서는 방화벽 장비로 L2 네트워크 간의 트래픽을 제어한다. 서버 OS에서 제어하거나 스위치 장비에서 제공하는 ACL을 통해 접근 제어할 수 있다. 그러나 유지보수 측면에서 손이 많이 간다.</p><p>클라우드 환경에서는 논리 포트에 시큐리티 그룹을 설정해서 세밀하게 접근 제어를 할 수 있다.<br>기본적으로 모든 트래픽을 폐기하는 암묵적 Deny 정책을 따른다.<br>네트워크에서 접근 제어를 해야 OS나 어플리케이션에 종속되지 않고 보안 정책을 수립할 수 있다.</p><h3 id="시큐리티-그룹-규칙-구성"><a href="#시큐리티-그룹-규칙-구성" class="headerlink" title="시큐리티 그룹 규칙 구성"></a>시큐리티 그룹 규칙 구성</h3><ul><li>입력 혹은 출력에 적용할 지 선택</li><li>허용할 프로토콜 종류 선택</li><li>통신 상대 지정 (통신 상대는 IP 주소 범위나 다른 시큐리티 그룹)</li></ul><h3 id="다른-시큐리티-그룹을-상대로-지정"><a href="#다른-시큐리티-그룹을-상대로-지정" class="headerlink" title="다른 시큐리티 그룹을 상대로 지정"></a>다른 시큐리티 그룹을 상대로 지정</h3><p>서버 대수가 늘어날 때마다 시큐리티 그룹에 대상에 새로 생긴 서버를 추가하면 유지보수에 손이 많이 간다. 대상 서버들이 적용되는 시큐리티 그룹을 대상으로 하면 효율적으로 서버 추가에 대응할 수 있다.</p><h3 id="시큐리티-그룹-활용"><a href="#시큐리티-그룹-활용" class="headerlink" title="시큐리티 그룹 활용"></a>시큐리티 그룹 활용</h3><p>시큐리티 그룹을 웹 서버, DB 서버, 관리용으로 만들어 두고 각 리소스마다 포트에 할당하는 방식으로 운영할 수 있다.</p><h1 id="네트워크-액세스-컨트롤-리스트-NACL"><a href="#네트워크-액세스-컨트롤-리스트-NACL" class="headerlink" title="네트워크 액세스 컨트롤 리스트(NACL)"></a>네트워크 액세스 컨트롤 리스트(NACL)</h1><p>서브넷에 대해 필터링한다. 패캣 필터링 하거나 권한을 분리하는 것이 가능하다.</p><h3 id="시큐리티-그룹과-차이"><a href="#시큐리티-그룹과-차이" class="headerlink" title="시큐리티 그룹과 차이"></a>시큐리티 그룹과 차이</h3><p>상태 관점에서 차이가 있다. 상태는 통신 허용 정보를 생각하면 된다.</p><p>NACL은 Stateless이다. 즉 허용 정보를 관리하지 않는다. 왜냐면 암묵적으로 허용하는 정책을 따르기 때문이다.<br>반면 시큐리티 그룹은 Stateful하다. 즉 허용 정보를 관리한다. 왜냐면 암묵적으로 모두 금지하는 정책을 따르기 때문이다.</p><p>NACL은 서브넷 단위로 적용한다.<br>반면 시큐리티 그룹은 논리 포트 단위로 적용한다.</p><h1 id="네트워크를-구성하기-위한-API-처리-흐름"><a href="#네트워크를-구성하기-위한-API-처리-흐름" class="headerlink" title="네트워크를 구성하기 위한 API 처리 흐름"></a>네트워크를 구성하기 위한 API 처리 흐름</h1><p>오픈스택 Neutron에서 네트워크 리소스를 구성하는 흐름은 다음과 같다.</p><ul><li>가상 네트워크 생성</li><li>가상 네트워크에 서브넷 할당</li><li>논리 포트 생성</li><li>가상 라우터 생성해서 서브넷과 연결</li><li>가상 라우터를 외부 L2 네트워크와 연결</li></ul><p>각 단계마다 JSON 데이터를 포함해서 요청하면 된다. 네트워크의 CIDR 같은 정보를 JSON 형식으로 정의할 수 있다. 일관된 포맷으로 네트워크 정보를 유지할 수 있다.</p><p>한편 AWS에서는 다음과 같다.</p><ul><li>CreateVPC : VPC(가상 네트워크) 생성</li><li>CreateSubnet : 서브넷 생성</li><li>CreateNetworkInterface : ENI(포트) 생성</li></ul><p>이 과정을 마친 뒤, 논리 포트(ENI)를 가상 서버에 연결하면 가상 서버는 즉시 통신 가능한 상태가 된다. 이런 클라우드 API를 활용한 네트워크 구축은 물리 환경에서 구축하기보다 훨씬 간편하다.</p><h1 id="네트워크-리소스의-내부-구성"><a href="#네트워크-리소스의-내부-구성" class="headerlink" title="네트워크 리소스의 내부 구성"></a>네트워크 리소스의 내부 구성</h1><p>클라우드 환경에서 네트워크를 조작할 때 가상 네트워크가 어떻게 만들어지는 지 알아보자.<br>오픈스택인 Neutron을 기준으로 파악해보자.</p><h2 id="가상-네트워크를-제어하는-프로세스"><a href="#가상-네트워크를-제어하는-프로세스" class="headerlink" title="가상 네트워크를 제어하는 프로세스"></a>가상 네트워크를 제어하는 프로세스</h2><p>오픈스택 Neutron에는 두 종류의 호스트가 있다.<br>사용자가 실행한 API를 처리하는 프로세스가 동작할 호스트(컨트롤러 노드)<br>가상 서버가 기동하고 가상 네트워크를 구성하는 호스트(컴퓨트 노드)</p><h2 id="여러-노드를-가진-테넌트의-가상-네트워크"><a href="#여러-노드를-가진-테넌트의-가상-네트워크" class="headerlink" title="여러 노드를 가진 테넌트의 가상 네트워크"></a>여러 노드를 가진 테넌트의 가상 네트워크</h2><p><img src="https://user-images.githubusercontent.com/87690744/230054652-966e9b20-f742-4d38-81a6-48f6cb2b5fee.png"></p><p>위 예시를 보면 하나의 컴퓨트 노드에 동일한 IP 주소를 가진 두개의 가상 서버가 작동하고 있다. 일반적인 환경이나 가상화 환경에서는 불가능한 구성이다. 왜냐면 다른 호스트의 가상 서버와 통신하려면 IP 주소가 같아서 어떤 가상 서버와 통신하는 지 알 수 없기 때문이다.<br>클라우드 환경에서는 이런 충돌이 발생해도 문제가 되지 않도록 한다.</p><h2 id="네트워크-식별"><a href="#네트워크-식별" class="headerlink" title="네트워크 식별"></a>네트워크 식별</h2><p>컴퓨터 노드에는 <code>br-init</code>과 <code>br-turn</code> 이라는 OVS(Open vSwitch) 브릿지가 만들어져 있다.</p><p><code>br-init</code>은 가상 서버와 리눅스의 가상 인터페이스로 연결된다. 이 가상 인터페이스가 논리 포트가 된다.<br><code>br-init</code>은 <code>br-turn</code>과 연결된다. <code>br-turn</code>은 컴퓨트 노드 사이 패킷 전송을 담당한다.</p><p>가상 서버에서 전송되는 패킷은 가상 서버에 연결된 논리 포트(가상 인터페이스)를 통해 가상 서버가 어떤 네트워크에 속한 지 파악한다. 그래서 해당 패킷의 소속 네트워크를 식별하기 위해 <code>VLAN ID</code>를 패킷에 할당한다.<br>즉 하나의 컴퓨트 노드에 분리된 두 네트워크에 각자 속한 같은 IP 주소의 가상 서버는 패킷에 할당된 <code>VLAN ID</code>를 통해 각자의 네트워크를 식별할 수 있게된다.</p><p>두 컴퓨트 노드 사이 패킷 전송은 <code>VXLAN</code>이 사용된다. <code>VXLAN</code>은 이더넷 프레임을 캡슐화해서 L3 네트워크 상에 논리적인 L2 네트워크를 구성하는 터널링 프로토콜이다. </p><p><code>br-turn</code>에서 내부로 패킷을 받아올 때는 <code>VXLAN ID</code>를 꺼내고 <code>VLAN ID</code>로 할당한다. 외부로 패킷을 내보낼 때는 <code>VLAN ID</code>를 꺼내고 <code>VXLAN ID</code>를 할당한다.</p><blockquote><p>VLAN과 VXLAN<br>둘 다 가상 네트워크를 식별하기 위한 네트워크 가상화 기술이다. 두 기술의 차이는 구분 가능한 네트워크 갯수에 있다. VLAN은 4094개, VXLAN은 1600만개를 구분할 수 있다.</p></blockquote><h1 id="클라우드-네트워크와-SDN"><a href="#클라우드-네트워크와-SDN" class="headerlink" title="클라우드 네트워크와 SDN"></a>클라우드 네트워크와 SDN</h1><p>SDN (Software Defined Networking)는 제어와 전송을 분리해서 API로 제어하겠다는 개념이다. 제어하는 부분은 컨트롤러, 전송을 담당하는 부분은 데이터 플랜이라고 한다.</p><p>SDN의 구성요소는</p><ul><li>클라우드 네트워크 컨트롤러 : 클라우드에서 가상 네트워크를 동작시키기 위한 태스크를 실행</li><li>네트워크 오케스트레이터 : 각종 네트워크 장비를 제어하면서 가상 네트워크 기능 구현.</li><li>네트워크 장비 : 실제로 패킷을 다루는 장비. 장비를 제어할 수 있도록 API 제공</li></ul><p>특히 클라우드 네트워크 컨트롤러는 사용자에게 노출되는 API를 담당한다. 즉 내부의 변화가 사용자에게 최대한 영향을 덜 미치도록 해야한다. 사용자들이 사용하기 편하도록 설계되어야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드에서 서버 리소스를 제어하는 방법</title>
      <link>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/</guid>
      <pubDate>Wed, 29 Mar 2023 12:46:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;서버-리소스&quot;&gt;&lt;a href=&quot;#서버-리소스&quot; class=&quot;headerlink&quot; title=&quot;서버 리소스&quot;&gt;&lt;/a&gt;서버 리소스&lt;/h1&gt;&lt;p&gt;서버 리소스는 타입과 이미지로 구성된다.&lt;br&gt;타입은 리소스의 크기나 속성을 유형화한 개념이다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="서버-리소스"><a href="#서버-리소스" class="headerlink" title="서버 리소스"></a>서버 리소스</h1><p>서버 리소스는 타입과 이미지로 구성된다.<br>타입은 리소스의 크기나 속성을 유형화한 개념이다.<br>이미지는 서버의 기동 이미지로 AWS의 AMI가 이에 해당한다.</p><h2 id="서버-리소스-제어-API-흐름"><a href="#서버-리소스-제어-API-흐름" class="headerlink" title="서버 리소스 제어 API 흐름"></a>서버 리소스 제어 API 흐름</h2><h3 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h3><p>서버 리소스를 제어하기 위해서 가장 먼저 인증을 해야 한다.<br>인증 요청은 <code>POST</code>로 회원이름과 암호를 보내고 토큰과 엔드포인트를 받는다.</p><p>이후 요청에서 헤더에 토큰을 포함해서 인증할 수 있다.</p><h3 id="템플릿-이미지-유효성-검증"><a href="#템플릿-이미지-유효성-검증" class="headerlink" title="템플릿 이미지 유효성 검증"></a>템플릿 이미지 유효성 검증</h3><p>서버 리소스에 사용할 템플릿 이미지가 존재하는지, 접근 권한이 있는지 확인하고 템플릿 이미지를 반환하는 API를 거친다.<br>템플릿 이미지 유효성 검증은 굳이 하지 않아도 서버 리소스 제어에 큰 문제가 생기지 않는다. 다만 이 과정을 거치지 않으면 서버 기동 중에 문제가 발생해서 여러 문제점이 함께 발생하는 기동 중에 문제 파악이 오래걸릴 수 있다.</p><h3 id="가상-서버-생성"><a href="#가상-서버-생성" class="headerlink" title="가상 서버 생성"></a>가상 서버 생성</h3><p>생성할 가상 서버의 조건을 요청 바디에 담아서 가상 서버를 생성할 수 있다.<br>가상 서버 조건 정보는 가상 서버 이름, 플레이버(인스턴스 유형), 템플릿 이미지, 접속할 가상 네트워크, 시큐리티 그룹 등 다양하다.<br>생성에 성공하면 서버의 UUID를 응답한다.</p><p>서버 생성 요청에 성공했다고 바로 서버가 생성된 건 아니다. 단지 클라우드 제공자가 서버 생성 요청을 확인한 것이다.<br>실제로 AWS에서 가상 서버를 만들어도 약간의 시간 뒤에 생성된다. 이는 API로 생성 요청을 접수하는 처리와 실제 가상 서버를 만드는 처리가 비동기적으로 분리되어 실행되기 때문이다.</p><h3 id="생성된-가상-서버-상태-확인"><a href="#생성된-가상-서버-상태-확인" class="headerlink" title="생성된 가상 서버 상태 확인"></a>생성된 가상 서버 상태 확인</h3><p>가상 서버 생성 요청의 응답으로 받은 UUID로 가상 서버의 상태를 확인할 수 있다.<br>이때 가상 서버를 만드는 중에도 가상 서버의 상태를 보여줄 수 있다.</p><h2 id="가상-서버의-수명-주기"><a href="#가상-서버의-수명-주기" class="headerlink" title="가상 서버의 수명 주기"></a>가상 서버의 수명 주기</h2><p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/instance_lifecycle.png"></p><p>AWS의 경우 여러 단계로 서버 리소스의 상태를 알려준다.<br>pending : running할 준비하는 중<br>running : 인스턴스 실행 중<br>stopping : 인스턴스 중지 혹은 절전 모드로 전환 준비<br>stopped : 인스턴스 종료됨. 하지만 다시 시작 가능<br>shutting-down : 인스턴스가 종료할 준비<br>terminated : 인스턴스가 영구적으로 삭제</p><h3 id="메타-데이터와-사용자-데이터"><a href="#메타-데이터와-사용자-데이터" class="headerlink" title="메타 데이터와 사용자 데이터"></a>메타 데이터와 사용자 데이터</h3><p>메타 데이터와 사용자 데이터는 가상 서버의 환경 설정에 활용되는 데이터이다.<br>메타 데이터는 서버별로 따로 만들어지고 여러 개의 서버가 같은 메타 데이터를 공유하지 못한다.</p><p>사용자 데이터는 가상 서버에 액션을 실행해야 할 때 사용한다. 대표적으로 쉘 스크립트 같은 데이터가 있다. 만약 실행되야 할 사용자 데이터가 무수히 많으면 Cloud-init 이란 툴을 사용한다.</p><h3 id="이미지-생성과-공유"><a href="#이미지-생성과-공유" class="headerlink" title="이미지 생성과 공유"></a>이미지 생성과 공유</h3><p>이미지는 가상 머신 템플릿 이미지를 의미한다. 이미지 정보에는 디스크 포맷이나 디바이스 매핑과 같은 구성 정보들이 포함되어 있다. 특이한 점은 정보 여부를 결정할 수 있어서 다른 테넨트의 사용자에게 공개 여부를 정할 수 있다.</p><p>AWS <code>CreateImage</code> API로 인스턴스 ID를 통해 서버의 이미지를 만들 수 있다.<br>AWS <code>DescribeImages</code> API로 이미지 정보를 가져올 수 있다.</p><h3 id="VM-이미지-가져오기"><a href="#VM-이미지-가져오기" class="headerlink" title="VM 이미지 가져오기"></a>VM 이미지 가져오기</h3><p>이미지를 임포트하는 API를 지원한다. AWS에서는 <code>ImportImage</code>, <code>ImportInstance</code>,<code>ImportVolume</code> API로 가상 머신 템플릿을 AMI로 등록할 수 있다.<br><code>ImportImage</code>는 가상 머신 템플릿을 AMI로 임포트한다.<br><code>ImportInstance</code>는 AMI를 등록하고 서버 기동까지 한번에 한다.<br><code>ImportVolume</code>는 볼륨이 분할되어 있는 경우 볼륨 단위로 임포트할 때 사용한다.</p><h1 id="서버-리소스의-내부-구성"><a href="#서버-리소스의-내부-구성" class="headerlink" title="서버 리소스의 내부 구성"></a>서버 리소스의 내부 구성</h1><p>가상 서버의 생성 요청을 접수하고 오픈스택 내부에서 벌어지는 처리 내용을 정리해보자.</p><h3 id="가상-서버-생성-요청을-메시지-큐에-넣기"><a href="#가상-서버-생성-요청을-메시지-큐에-넣기" class="headerlink" title="가상 서버 생성 요청을 메시지 큐에 넣기"></a>가상 서버 생성 요청을 메시지 큐에 넣기</h3><p>가상 서버 생성 API가 실행되면 메시지 큐에 메시지를 넣고 비동기로 처리한다.<br>그리고 가상 서버 생성 요청이 큐에 들어가는 시점에 가상 서버의 구성 정보와 상태정보가 구성 관리 데이터베이스에 저장한다.</p><h3 id="스케줄러에-요청-전달"><a href="#스케줄러에-요청-전달" class="headerlink" title="스케줄러에 요청 전달"></a>스케줄러에 요청 전달</h3><p>스케줄러(컨덕터)라고 부르는 프로세스가 큐에 있는 메시지를 꺼내서 처리한다.<br>스케줄러 프로세스를 다중화하면 가용성이 높아진다. 스케줄러는 하나의 요청을 처리한다. 많은 요청이 오는 경우 여러 스케줄러에 분산되어 처리된다.</p><h3 id="가상-서버를-기동할-호스트-결정"><a href="#가상-서버를-기동할-호스트-결정" class="headerlink" title="가상 서버를 기동할 호스트 결정"></a>가상 서버를 기동할 호스트 결정</h3><p>오픈 스택은 상태 관리 데이터베이스에 각 호스트들의 리소스 사용 상태를 기록하고 갱신한다.<br>스케줄러는 메시지를 꺼낸 후 가상 서버에 필요한 리소스를 가진 호스트를 상태 관리 데이터베이스를 기반으로 찾는다.</p><h3 id="호스트에-가상-서버-기동-지시"><a href="#호스트에-가상-서버-기동-지시" class="headerlink" title="호스트에 가상 서버 기동 지시"></a>호스트에 가상 서버 기동 지시</h3><p>스케줄러가 호스트를 결정했으면 그 호스트에 가상 서버를 기동하라는 요청을 메시지 큐에 넣는다.</p><h3 id="메시지-수신과-가상-서버-생성"><a href="#메시지-수신과-가상-서버-생성" class="headerlink" title="메시지 수신과 가상 서버 생성"></a>메시지 수신과 가상 서버 생성</h3><p>메시지 큐에서 메시지를 받은 호스트는 가상 서버를 구축한다.<br>템플릿 이미지 가져오기, IP 주소 할당, 네트워크 접속 준비 등을 진행한다.</p><h3 id="가상-서버-상태-갱신"><a href="#가상-서버-상태-갱신" class="headerlink" title="가상 서버 상태 갱신"></a>가상 서버 상태 갱신</h3><p>기동에 성공하면 구성 관리 데이터베이스의 상태를 ACTIVE로 갱신한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IT 인프라의 진화와 API의 기본 철학</title>
      <link>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/</guid>
      <pubDate>Tue, 28 Mar 2023 09:07:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이&quot;&gt;&lt;a href=&quot;#서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이&quot; class=&quot;headerlink&quot; title=&quot;서버를 추가 구축해야 하는 상</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이"><a href="#서버를-추가-구축해야-하는-상황에서-물리적-장비와-가상화-장비의-차이" class="headerlink" title="서버를 추가 구축해야 하는 상황에서 물리적 장비와 가상화 장비의 차이"></a>서버를 추가 구축해야 하는 상황에서 물리적 장비와 가상화 장비의 차이</h1><h2 id="물리적-장비로-환경-구축하기"><a href="#물리적-장비로-환경-구축하기" class="headerlink" title="물리적 장비로 환경 구축하기"></a>물리적 장비로 환경 구축하기</h2><p>웹 서버 요구사항을 수행할 수 있는 물리 장비를 발주해야 한다.<br>장비가 도착하면 데이터 센터의 랙에 물리 장비를 장착해야 한다.<br>이 과정에서 빈 공간이 있는 지, 네트워크 스위치 포트가 비어 있는 지, 네트워크 스위치까지 배선이 가능한 지, 전원 용량이 허용 범위 안에 있는 지 등,,, 수많은 물리적 요소를 확인해야 한다.</p><p>랙에 장비를 장착하고 나서 OS와 어플리케이션, 환경설정을 한다. 그리고 개발팀에게 계정 권한 정보를 전달한다.</p><p>물리적 장비로 인프라 환경을 구축하면 OS와 어플리케이션을 설치하는 것 외에도 고려할 사항이 많다.</p><h2 id="가상화-장비로-환경-구축하기"><a href="#가상화-장비로-환경-구축하기" class="headerlink" title="가상화 장비로 환경 구축하기"></a>가상화 장비로 환경 구축하기</h2><p>가상화 장비로 환경 구축하면 물리적 요소 고려가 줄어든다.</p><p>어떤 장비를 구입해야 할 지 고민하지 않고 필요한 스펙의 리소스만 가상 서버에 할당하면 된다.<br>장비를 데이터 센터 랙에 설치하는 작업은 가상 서버를 물리 서버에 할당하는 과정으로 대체된다.</p><p>랙 빈 공간을 찾거나, 네트워크 스위치 포트, 배선, 전원 용량 등 물리적 요소 고려를 하지 않아도 된다.<br>대신 가상화 장비로 환경 구축하면 소프트웨어 요구 사항만 고려하면 된다.</p><p>물리적 장비에 OS와 소프트웨어 설치 및 환경 설정할 때도 매번 비슷한 작업을 반복하게 된다.<br>가상화 장비로 환경 설정할 때는 환경 설정이 완료된 템플릿을 복제해오는 방식으로 대체된다.</p><h2 id="서버-가상화의-한계"><a href="#서버-가상화의-한계" class="headerlink" title="서버 가상화의 한계"></a>서버 가상화의 한계</h2><p>가상화 장비로 환경 구축해서 물리적 고려가 줄었다. 하지만 그 외 작업은 여전히 해야 한다.<br>가상 서버 리소스 구성 방식 정하기, 가상 서버를 물리 서버에 할당, IP 주소 확보, 시스템 설계 및 작업 계획서 작성 등 작업들은 가상 장비로 구축해도 동일하다.<br>이런 작업들은 사람이 판단하고 수작업한다는 특성이 있다.<br>시스템이 커지면 위와 같은 작업 때문에 인프라 운영이 번거로워 진다.</p><p>클라우드 API는 이런 작업을 더 쉽게 만든다.</p><h1 id="클라우드-환경에서-인프라-구축-작업"><a href="#클라우드-환경에서-인프라-구축-작업" class="headerlink" title="클라우드 환경에서 인프라 구축 작업"></a>클라우드 환경에서 인프라 구축 작업</h1><p>서버 가상화 환경에서도 줄이지 못한 사람이 수작업해야 하는 작업을 클라우드 환경에서 어떻게 줄이는 지 확인하자</p><h2 id="클라우드로-환경-구축하기"><a href="#클라우드로-환경-구축하기" class="headerlink" title="클라우드로 환경 구축하기"></a>클라우드로 환경 구축하기</h2><p>클라우드(오픈스택, AWS)에서 웹서버 추가는 세가지 단계로 나뉜다.</p><ul><li>인스턴스 유형 선택</li><li>서버 설정 적용</li><li>가상 서버 기동</li></ul><h2 id="클라우드-적용의-장점"><a href="#클라우드-적용의-장점" class="headerlink" title="클라우드 적용의 장점"></a>클라우드 적용의 장점</h2><h3 id="가상-서버-스펙-선택"><a href="#가상-서버-스펙-선택" class="headerlink" title="가상 서버 스펙 선택"></a>가상 서버 스펙 선택</h3><p>클라우드에서는 가상 서버 사양을 인스턴스 유형(플레이버)로 규격화했다.<br>유형이 있으면 재활용하기 쉬워진다. 스펙 결정할 때 고려해야 될 요소를 줄여준다.<br>다만 세밀한 부분까지 설정하지 못할 수 있다. 하지만 리소스 가격은 시간이 갈수록 낮아지고, 사양 고민할 시간을 줄이는 게 더 중요하다.<br>요구사항이 달라졌을 때도 스펙을 처읍부터 다시 정하지 않고 다른 인스턴스 유형을 선택하면 된다.</p><h3 id="가상-서버를-배치할-호스트-결정"><a href="#가상-서버를-배치할-호스트-결정" class="headerlink" title="가상 서버를 배치할 호스트 결정"></a>가상 서버를 배치할 호스트 결정</h3><p>가상화 서버로 환경을 구축하면 가상 서버를 물리 서버에 배치해야 한다.<br>클라우드 환경에서는 가상 서버를 정하고 구축 요청을 하면 프로그램이 자동으로 적절한 물리 서버를 찾아 배치한다.<br>(일반적으로 물리 서버를 정하는 기준은 일반 사용자는 몰라도 된다. 오픈 스택에서는 기준을 사용자화할 수 있다.)<br>사람이 직접 가장 적절한 물리 서버를 찾는 것보다 약간의 리소스 손해를 보더라도 사람이 고민하는 시간을 줄여준다.</p><h3 id="IP-주소-할당"><a href="#IP-주소-할당" class="headerlink" title="IP 주소 할당"></a>IP 주소 할당</h3><p>클라우드 환경에서는 가상 서버가 접속할 네트워크를 정하면 사용 가능한 IP 주소가 자동으로 확보된다.<br>IP 주소는 가상 서버가 기동될 때 할당되고, 가상 서버가 제거되면 IP 주소를 회수한다.</p><p>클라우드에서는 대량의 가상 서버를 생성했다가 제거하기 때문에 수없이 IP 할당하고 제거한다.<br>만약 IP 할당 및 제거를 자동화하지 않았다면 매우 번거로운 수작업이 된다.</p><p>IP 주소가 자동 할당되면 가상 서버의 IP 주소를 예상할 수 없다.<br>대신 클라우드는 동적 DNS로 IP 주소를 추상화 한다.</p><h3 id="설정-스크립트-작성"><a href="#설정-스크립트-작성" class="headerlink" title="설정 스크립트 작성"></a>설정 스크립트 작성</h3><p>가상 서버가 구동될 때 설정을 적용하는 스크립트를 작성하면 실수 없이 여러 서버에 자동으로 적용된다.<br>그리고 클라우드에서는 이런 설정 스크립트가 잘 적용됐는지 검증하는 툴도 제공한다.</p><h3 id="가상-서버-생성의-자동화"><a href="#가상-서버-생성의-자동화" class="headerlink" title="가상 서버 생성의 자동화"></a>가상 서버 생성의 자동화</h3><p>클라우드 환경에서 가상 서버 생성할 때 인스턴스 유형과 설정 스크립트만 준비되어 있다면 수많은 작업이 순서대로 자동 진행된다.<br>템플릿 복제, 스크립트 실행, 가상 서버 배치할 호스트, IP 주소 할당과 같은 일련의 작업을 클라우드 사용자가 고민하지 않아도 된다.</p><p>클라우드 환경에서는 HTTP&#x2F;HTTPS로 통신하는 API를 제공한다. 다만 JSON 형식이 사람이 이해하기 어려워서 CLI나 웹 콘솔을 제공한다.</p><h3 id="스토리지와-네트워크도-효율적으로"><a href="#스토리지와-네트워크도-효율적으로" class="headerlink" title="스토리지와 네트워크도 효율적으로"></a>스토리지와 네트워크도 효율적으로</h3><p>클라우드 환경에서는 스토리지와 네트워크도 웹 서버 추가하는 것과 비슷하게 효율적으로 수행한다.</p><p>스토리지를 추가할 때 디스크 영역을 확보하기 위해 RAID 구성이나 LUN 매핑하는 과정이 필요하다. 이 과정에서 장비나 제조사의 기능이나 설정을 사람이 수작업으로 하게 된다.<br>클라우드 환경은 스토리지 용량과 접속할 서버만 정하면 나머지는 알아서 자동으로 처리한다.</p><p>네트워크를 추가할 때 VLAN을 구성하고 포함되는 물리 호스트의 네트워크 설정과 네트워크 기기 설정 모두 맞춰줘야 하낟.<br>클라우드 환경에서는 사용할 네트워크 세그먼트나 가상 라우터를 정하면 다른 설정은 자동으로 설정된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot에서 잘못된 타입으로 파라미터를 보내면 어떻게 될까?</title>
      <link>https://yangdongjue5510.github.io/2023/03/22/spring-validation/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/22/spring-validation/</guid>
      <pubDate>Wed, 22 Mar 2023 11:01:03 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;목적&quot;&gt;&lt;a href=&quot;#목적&quot; class=&quot;headerlink&quot; title=&quot;목적&quot;&gt;&lt;/a&gt;목적&lt;/h1&gt;&lt;p&gt;스프링 부트에서 잘못된 타입으로 파라미터를 보내는 예외 상황에 어떤 예외가 발생하는 지 확인해보고 이를 검증하는 코드를 만들어</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h1><p>스프링 부트에서 잘못된 타입으로 파라미터를 보내는 예외 상황에 어떤 예외가 발생하는 지 확인해보고 이를 검증하는 코드를 만들어본다!</p><h3 id="컨트롤러-코드"><a href="#컨트롤러-코드" class="headerlink" title="컨트롤러 코드"></a>컨트롤러 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/equipments&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EquipmentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EquipmentService equipmentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EquipmentController</span><span class="params">(<span class="keyword">final</span> EquipmentService equipmentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.equipmentService = equipmentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> EquipmentDetailResponse <span class="title function_">getEquipment</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">final</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> equipmentService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="테스트-코드"><a href="#테스트-코드" class="headerlink" title="테스트 코드"></a>테스트 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(controllers = &#123;EquipmentController.class&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EquipmentControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;id가 문자열이면 400을 응답한다.&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getEquipment_400_idIsNotNumeric</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">invalidId</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when, then</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/api/equipments/&quot;</span> + invalidId))</span><br><span class="line">                .andExpect(status().isBadRequest());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드는 PathVariable이 Long이어야 하는데 문자열이 전달된 경우이다.<br>이 테스트 코드를 실행하고 <code>DispatcherServlet</code>의 <code>doDispatch</code>에 break point를 걸고 디버깅을 해보자.</p><h3 id="디버깅하면서-찾아보기"><a href="#디버깅하면서-찾아보기" class="headerlink" title="디버깅하면서 찾아보기"></a>디버깅하면서 찾아보기</h3><p>디버깅을 하다보면 <code>InvocableHandlerMethod</code> (컨트롤러에서 요청을 처리하는 메서드)라는 객체에서 <code>invokeForRequest</code>라는 메서드를 호출하면서 인자를 <code>Object</code> 배열로 변환한다.<br>이 변환 로직을 각 리졸버에게 위임한다. 리졸버는 <code>Object</code>로 변환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocableHandlerMethod</span> <span class="keyword">extends</span> <span class="title class_">HandlerMethod</span> &#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">        Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">        args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">                <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">                    logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Object</code>로 변환된 인자는 <code>DataBinder</code>가 적절한 타입으로 바꿔준다. 이 과정에서 <code>ConversionException</code>이 발생하고 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataBinder</span> <span class="keyword">implements</span> <span class="title class_">PropertyEditorRegistry</span>, TypeConverter &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> MethodParameter methodParam)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getTypeConverter().convertIfNecessary(value, requiredType, methodParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataBinder</code>에서 시작한 형 변환 로직 중 형 변환에 실패하면 <code>ConversionException</code>이 발생하고 이 예외는 <code>TypeMismatchException</code>이 대신 던져진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TypeConverterSupport</span> <span class="keyword">extends</span> <span class="title class_">PropertyEditorRegistrySupport</span> <span class="keyword">implements</span> <span class="title class_">TypeConverter</span> &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">        Assert.state(<span class="built_in">this</span>.typeConverterDelegate != <span class="literal">null</span>, <span class="string">&quot;No TypeConverterDelegate&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.typeConverterDelegate.convertIfNecessary(<span class="literal">null</span>, <span class="literal">null</span>, value, requiredType, typeDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConversionNotSupportedException</span>(value, requiredType, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ConversionException | IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeMismatchException</span>(value, requiredType, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>TypeMismatchException</code>은 <code>AbstarctNamedValueMethodArgumentResolver</code>에서 <code>MethodArgumentTypeMismatchException</code>으로 바뀌어 던져지게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">            NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">                handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">                        namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">                        namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line">            <span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">                handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결론만 말하자면 타입이 맞지 않으면 <code>MethodArgumentTypeMismatchException</code>이 발생한다.</p><h2 id="예외-처리-코드"><a href="#예외-처리-코드" class="headerlink" title="예외 처리 코드"></a>예외 처리 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentTypeMismatchException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleMethodArgumentTypeMismatch</span><span class="params">(<span class="keyword">final</span> MethodArgumentTypeMismatchException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest()</span><br><span class="line">                .body(String.format(<span class="string">&quot;%s이 잘못된 타입으로 입력됐습니다. 입력값 : %s&quot;</span>,</span><br><span class="line">                        e.getParameter().getParameter().getName(), e.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RestControllerAdvice</code>로 예외를 처리해주면 된다. 파라미터의 이름과 입력값을 가져와서 에러 메시지를 출력하는 코드이다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/boot/">Boot</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/22/spring-validation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드를 제어하는 API의 작동 방식</title>
      <link>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/</guid>
      <pubDate>Mon, 20 Mar 2023 11:24:40 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;클라우드와-API의-관계&quot;&gt;&lt;a href=&quot;#클라우드와-API의-관계&quot; class=&quot;headerlink&quot; title=&quot;클라우드와 API의 관계&quot;&gt;&lt;/a&gt;클라우드와 API의 관계&lt;/h1&gt;&lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="클라우드와-API의-관계"><a href="#클라우드와-API의-관계" class="headerlink" title="클라우드와 API의 관계"></a>클라우드와 API의 관계</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API는 어떤 소프트웨어에서 다른 소프트웨어를 제어하기 위해 미리 약속된 인터페이스나 규약을 의미한다.<br>API를 사용하면 내부 구조를 자세히 몰라도 다른 소프트웨어를 무리 없이 사용할 수 있다.</p><h3 id="웹-API"><a href="#웹-API" class="headerlink" title="웹 API"></a>웹 API</h3><p>클라우드에서는 웹 API를 사용하는 것이 일반적이다.<br>웹 API는 HTTP(HTTPS) 같은 웹 프로토콜을 사용해서 네트워크를 통해 호출하는 API를 말한다.</p><h3 id="아마존에서-시작도니-클라우드-컴퓨팅에서의-웹-API-적용"><a href="#아마존에서-시작도니-클라우드-컴퓨팅에서의-웹-API-적용" class="headerlink" title="아마존에서 시작도니 클라우드 컴퓨팅에서의 웹 API 적용"></a>아마존에서 시작도니 클라우드 컴퓨팅에서의 웹 API 적용</h3><p>아마존은 특정 기간에 사용량이 폭주하는 경향이 있었다. 그래서 많은 서버와 스토리지를 구비해놓고 제어하는 웹 API를 구축했다.<br>아마존의 서버와 스토리지 같은 리소스 관리 방식은 AWS의 EC2와 S3의 기반이 된다.<br>이런 웹 API 기반 리소스 관리는 다음과 같은 이점이 있다.</p><ul><li>인터넷을 통해 서버나 스토리지를 시간제로 임대해서 사용할 수 있다.</li><li>API를 통해 사용자가 원하는 시점에 원하는 만큼 리소스를 할당받을 수 있다.</li></ul><h3 id="가상화-기술과-클라우드-컴퓨팅"><a href="#가상화-기술과-클라우드-컴퓨팅" class="headerlink" title="가상화 기술과 클라우드 컴퓨팅"></a>가상화 기술과 클라우드 컴퓨팅</h3><p>물리적인 서버와 스토리지를 직접 확보하려면 장비를 구하고 설치하는 과정에서 많은 시간이 쓰인다.<br>물리적인 서버를 구하지 않고 가상화된 환경에서 API를 호출해서 필요한 리소스를 바로 구할 수 있다.</p><p>하지만 가상화가 클라우드 컴퓨팅의 본질은 아니다.<br>성능이나 보안이 중요한 경우, 물리적인 리소스를 직접 사용해야 하는 경우도 있기 때문이다.<br>클라우드의 본질은 리소스의 가상화 여부가 아닌 인터넷을 통해 필요한 자원을 제어할 수 있는 API 방식에 있다.</p><h3 id="웹-API의-구성요소"><a href="#웹-API의-구성요소" class="headerlink" title="웹 API의 구성요소"></a>웹 API의 구성요소</h3><p>웹 API에서는 인증 처리, 제어 대상, 제어 행동으로 구성된다.<br>제어 대상은 리소스를 의미하며 URI로 표현된다.<br>제어 행위는 액션에 해당하며 HTTP 메서드로 표현된다.</p><h1 id="리소스와-URI"><a href="#리소스와-URI" class="headerlink" title="리소스와 URI"></a>리소스와 URI</h1><h3 id="도메인-도메인-트리-FQDN"><a href="#도메인-도메인-트리-FQDN" class="headerlink" title="도메인, 도메인 트리, FQDN"></a>도메인, 도메인 트리, FQDN</h3><p>URI는 크게 네트워크 관련 부분과 경로 관련 부분으로 나뉜다.<br>네트워크 부분에 서버 IP 주소를 사용하는 것보다는 도메인 주소를 사용하는 게 편리하다.(<code>www.naver.com</code>)</p><p>EC2 자원의 외부 DNS 호스트 이름인 <code>ec2-54-10-10-10.ap-northeast-2.compute.amazonaws.com</code>은 오른쪽부터 점을 기준으로 계층 구조를 나타낸다.<br>TLD(탑 레벨 도메인)인 <code>com</code><br>2LD(세컨드 레벨 도메인)인 <code>amazonaws</code><br>…</p><p>이런 식으로 상위 도메인에 하위 도메인이 포한되는 방식이다.<br>이런 모습이 마치 트리 구조로 형상화되어서 도메인 트리라고도 한다.<br>그리고 가장 왼쪽에 위치한 부분 <code>ec2-54-10-10-10</code>라는 호스트가 리소스에 해당하게 된다.<br>즉 호스트 명 + 도메인 명을 합친 전체 이름을 FQDN이라고 한다. FQDN은 세상의 수많은 호스트 중 하나를 지정할 수 있게 한다.</p><blockquote><p>클라우드에서 도메인 계층 확장하기</p></blockquote><p>클라우드 리소스에 접속할 때도 계층화된 도메인 명을 사용한다.<br>도메인 명을 정할 때는 일종의 규칙이 있다. AWS의 도메인 예시를 보면, <code>ec2.ap-northeast-2.compute.amazonaws.com</code>에서 <code>ap-northeast-2</code>는 리전을 의미하고, <code>ec2</code>는 서비스(컴포넌트)에 해당한다. (만약 서비스가 리전에 종속되지 않는 경우, 리전 계층에 서비스가 사용될 수 있다.)</p><p>이 규칙을 이해하면 다양한 리전에 다양한 서비스를 도메인 명으로 표현할 수 있다.</p><h3 id="DNS-가상-호스트-레지스트리"><a href="#DNS-가상-호스트-레지스트리" class="headerlink" title="DNS, 가상 호스트, 레지스트리"></a>DNS, 가상 호스트, 레지스트리</h3><p>도메인 명은 사람이 쉽게 식별할 수 있기 위한 내용이라 TCP&#x2F;IP으로 통신하기 위해서는 도메인을 IP 주소로 바꿔야 한다.<br>도메인 주소와 IP 주소를 변환하는 역할을 DNS가 한다.</p><blockquote><p>복수 IP와 가상호스트</p></blockquote><p>일반적으로 FQDN과 IP가 1대1 매핑되지만 필요에 따라서 1:N, N:1 매핑이 가능하다.<br>1:N은 대규모 시스템에 활용된다. 하나의 FQDN으로 많은 요청이 오면 하나의 IP로 대응하지 못할 수 있다.<br>이럴 때 여러 IP를 매핑해서 DNS가 순차적으로 IP를 돌려써서 부하를 줄일 수 있다. (DNS 라운드 로빈)</p><p>클라우드에서는 CDN이나 로드 밸런서에서 DNS 라운드 로빈 기능을 활용하여 대규모 트래픽에 대응할 수 있다.<br>DNS 라운드 로빈은 사용자 입장에서 주소 변경 없이 확장 할 수 있다.</p><p>반면 N:1은 서버 리소스 더 효율적으로 사용하고 싶을 때 사용한다.</p><blockquote><p>도메인과 IP 주소 변환 방법</p></blockquote><p>클라이언트 쪽에서 IP 주소로 변환하려고 하면 스텁 리졸버를 통해 캐시 DNS 서버에 해당 도메인 정보가 있는 지 확인한다.(이 과정을 로컬 쿼리, 재귀적 질의라고 함)<br>만약 없으면 루트 도메인부터 최하위 도메인까지 각 도메인의 네임 스페이스를 관리하는 DNS에게 물어본다. (이를 반복적 질의, 비재귀적 질의라고 함)<br>이렇게 되면 루트 도메인에 상당한 부하가 생기는 데, 이를 방지하기 위한 것이 캐시 DNS 서버이다.<br>(캐시 DNS 서버는 클라이언트 컴퓨터에서 네트워크 설정에서 지정된 DNS 서버이다.)</p><blockquote><p>비재귀적 질의를 많이 사용하는 URL</p></blockquote><p>URL을 설계할 때는 비재귀적 질의가 많이 사용되도록 하는 게 좋다. 비재귀적 질의가 많이 사용되는 URL은 다양한 DNS를 거쳐서 IP 주소를 찾도록 하는 것이다. 즉 서버의 특성에 따라 잘 계층화하면  확정성을 확보할 수 있다. <code>ec2-north-east-amazon.com</code>은 계층화가 잘 이뤄지지 않았고 비재귀적 질의가 적다. (루트DNS - <code>com</code> DNS - <code>ec2...</code> DNS)<br>반면 <code>ec2.north-east.amazon.com</code>과 같이 잘 계층화 된 URL은 비재귀적 질의가 많이 사용됐고 각 DNS가 목적에 따라 확장에 더 유리해졌다. (루트 DNS - <code>com</code> DNS - <code>amazon</code> DNS - <code>north-east</code> DNS - <code>ec2</code> DNS)<br>물론 이런 설계 방법이 성능에는 약간의 손해를 볼 수 있으나 DNS 캐시 서버의 존재 때문에 이런 손해는 줄일 수 있다.</p><blockquote><p>자신이 등록한 도메인 사용하기</p></blockquote><p>자신의 도메인에 CNAME을 등록하면 된다.<br>일반적으로 클라우드 서비스를 제공하는 업체에서는 DNS 서비스를 제공한다. AWS도 Route 53이란 기능을 제공한다.</p><blockquote><p>도메인 레코드</p></blockquote><p>IP 주소와 도메인을 짝 지은 설정정보를 DNS 레코드라고 한다.</p><ul><li><code>A</code> : FQDN에 대한 IPv4 주소 정보</li><li><code>AA</code> : FQDN에 대한 IPv6 주소 정보</li><li><code>CNAME</code> : FQDN 별칭 정보</li><li><code>PTR</code> : FQDN 역방향 질의 정보</li><li><code>SOA</code> : DNS 영역에 대한 권한 정보</li><li><code>NS</code> : DNS 서버 정보</li><li><code>MX</code> : 이메일 서버 정보</li><li><code>SPF</code> : 이메일 발신자 자격 증명 정보</li><li><code>SRV</code> : 프로토콜, 포트 번호 등 ㅈ어보</li><li><code>TXT</code> : 호스트의 부가 정보</li></ul><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>웹 API에서 리소스를 지정하는 식별자를 URI라고 한다. URI에는 URL과 URN이 포함된다.</p><blockquote><p>URL</p></blockquote><p>URL은 네트워크 상에 있는 리소스의 위치를 알려줄 때 사용한다.<br>URL은 네트워크 부분과 경로 부분으로 나눌 수 있다.<br>스키마, 인증정보, FQDN, 포트번호까지 네트워크 경로이고, 네트워크 부분 이후를 경로 부분이라고 한다.</p><h3 id="엔드포인트"><a href="#엔드포인트" class="headerlink" title="엔드포인트"></a>엔드포인트</h3><p>클라이언트가 공개된 API를 실행하기 위해 접속하는 연결 접점을 엔드포인트라고 한다.<br>웹 API에서는 URI가 엔드포인트로 일종의 게이트웨이 역활을 한다. 엔드 포인트 뒤편에는 컨트롤러가 실제 처리를 수행하게 된다.</p><p>물리적인 장비를 사용하는 온프레미스 환경에서는 직접 장비를 설치한 후 장비의 어드레스에 접속해서 제어를 해야 한다.<br>만약 인프라 환경이 커지면 이런 방식은 운영하기 어려워진다. 특히 다른 리전에 있는 리소스를 제어해야 할 경우 어렵다.<br>API의 엔드포인트를 통한 제어는 일관되고 효율적인 작업이 가능하다.</p><blockquote><p>엔드포인트와 도메인</p></blockquote><p>AWS 엔드포인트는 IP가 아닍 도메인으로 접속하게 된다.<br>그 이유는 일단 사람이 알아보기 쉽고, 사용자로부터 IP 주소를 숨길 수 있기 때문이다.</p><p>IP 주소는 데이터 센터 장비를 옮기거나 부하 분산을 위해 변경될 수 있다. 이런 변경이 사용자에게 노출되지 않기 위해 도메인으로 접속하도록 한다.</p><h1 id="ROA-리소스-지향-아키텍쳐"><a href="#ROA-리소스-지향-아키텍쳐" class="headerlink" title="ROA (리소스 지향 아키텍쳐)"></a>ROA (리소스 지향 아키텍쳐)</h1><p>리소스 지향 아키텍처란 REST API의 사상을 기반으로 리소스 중심적인 API를 사용하는 아키텍처를 말한다.</p><h3 id="REST-기반-서비스"><a href="#REST-기반-서비스" class="headerlink" title="REST 기반 서비스"></a>REST 기반 서비스</h3><p>REST는 프로토콜이 아니라 사고방식이다. REST에는 네가지 설계 지침으로 요약될 수 있다.</p><ol><li>상태를 가지지 않는다. : 사태를 가지지 않으므로 구현이 쉽고 캐시를 사용할 수 있고 성능이 우수.</li><li>URI는 디렉터리 구조처럼 계층적 구조를 가진다. : 가독성과 리소스 구조 이해가 쉬움.</li><li>HTTP 메서드를 명시적으로 사용 : 리소스 상태 변화를 HTTP 메서드를 통해 리소스 중심으로 표현.</li><li>응답은 XML이나 JSON 사용 : 데이텨 표현을 정규화해서 다양한 언어와 기술에도 데이터가 활용될 수 있음.</li></ol><blockquote><p>비동기 멱등성, 재시도</p></blockquote><p>클라우드에서 REST API를 사용할 때는 비동기, 멱등성, 재시도 개념을 알아두자.<br>AWS같은 퍼블릭 클라우드 서비스는 인터넷으로 REST API를 제공한다. 수많은 요청을 처리할 때 반드시 순서대로 처리하지 않고 내부에서 비동기로 요청을 처리한다.<br>멱등성은 여러번 동일한 요청을 날려도 리소스에 변경이 없는 특성을 의미한다. 이런 특성은 네트워크 문제로 오류가 발생하더라도 재시도 했을 때 리소스의 정합성에 문제가 생기지 않는다는 사실을 보장하는 근거가 된다.</p><h3 id="클라우드-API-활용-예시"><a href="#클라우드-API-활용-예시" class="headerlink" title="클라우드 API 활용 예시"></a>클라우드 API 활용 예시</h3><blockquote><p>특정 네트워크에 연결된 서버를 기동하되, IP 주소는 공인 IP를 할당하고 해당 IP 주소에 대한 도메인을 DNS에 설정</p></blockquote><ol><li>사설 IP 주소를 확보하기 위해 서브넷을 만듬 -&gt; POST로 서브넷 생성 요청하고 서브넷 ID 반환</li><li>서버에 사설 IP 주소를 할당 -&gt; POST로 서브넷 ID를 함께 사설 IP 할당 요청하고 서버 ID 반환</li><li>서버에 공인 IP 주소를 할당 -&gt; PUT으로 서버 ID를 함께 해당 서버의 퍼블릭 IP 할당 요청하고 공인 IP 주소 반환</li><li>해당 공인 IP 주소에 대한 DNS 레코드를 설정 -&gt; POST로 DNS 레코드에 공인 IP 주소를 A 레코드에 할당.</li></ol><h3 id="API-이력-확인하기"><a href="#API-이력-확인하기" class="headerlink" title="API 이력 확인하기"></a>API 이력 확인하기</h3><p>AWS에서는 AWS CloudTrail로 API 호출 이력을 모니터링할 수 있다.<br>AWS에서는 AWS Config로 리소스의 구성 형태와 설정의 변경 이력을 관리한다.</p><h3 id="독자적인-API-구성하기"><a href="#독자적인-API-구성하기" class="headerlink" title="독자적인 API 구성하기"></a>독자적인 API 구성하기</h3><p>독자적으로 만든 API를 게이트웨이처럼 두어 실제 클라우드 엔드포인트나 API를 외부에서 보이지 않도록 구성할 수 있다.<br>독자적으로 구성한 IaaS 상이나 독자적으로 개발한 애플리케이션과 기존 클라우드를 연계할 때, 여러 다양한 클라우드를 조합해야 할 때 사용한다.</p><p>AWS에서는 Amazon API Gateway를 사용해서 독자적인 API를 구성할 수 있다. 독자적인 API를 정의하고 백엔드에서 오리지널 API를 펑션으로 정의해서 연동할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring MVC의 ArgumentResolver 파헤치기</title>
      <link>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/</guid>
      <pubDate>Thu, 16 Mar 2023 12:28:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;궁금한-점&quot;&gt;&lt;a href=&quot;#궁금한-점&quot; class=&quot;headerlink&quot; title=&quot;궁금한 점&quot;&gt;&lt;/a&gt;궁금한 점&lt;/h1&gt;&lt;p&gt;스프링 MVC로 컨트롤러 코드를 작성하다보면 다음과 같이 컨트롤러 메서드의 파라미터에 다양한 값을 받을 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="궁금한-점"><a href="#궁금한-점" class="headerlink" title="궁금한 점"></a>궁금한 점</h1><p>스프링 MVC로 컨트롤러 코드를 작성하다보면 다음과 같이 컨트롤러 메서드의 파라미터에 다양한 값을 받을 수 있음을 알게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/some&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getSome(<span class="keyword">final</span> Pageable pageable, <span class="meta">@RequestBody</span> <span class="keyword">final</span> String body) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 파리미터 매핑을 스프링에서 해준다!<br>하지만 어떤 경우에는 어노테이션 (<code>@RequestBody</code>, <code>@PathVariable</code>)을 넣어줘야 되는 경우도 있고, 어떤 경우에는 어노테이션을 생략해도 된다.(<code>@ModelAttribute</code>, <code>@RequestParam</code>) 심지어 어느 경우는 어노테이션이 없는 경우도 있다.(<code>Pageable</code>)</p><p>이번 기회에 날잡아서 스프링에서 어떻게 파라미터에 값을 넣어주는지, 어떤 경우에 어노테이션이 필요한 지 살펴보자.</p><h1 id="디스패처-서블릿-부터-시작한다"><a href="#디스패처-서블릿-부터-시작한다" class="headerlink" title="디스패처 서블릿 부터 시작한다"></a>디스패처 서블릿 부터 시작한다</h1><p>스프링 MVC는 프론트 컨트롤러 패턴을 사용한다. 요청을 처리하는 과정에서 중복되는 과정을 프론트 컨트롤러에서 모아서 처리한다.</p><p>우리가 궁금해하는 컨트롤러 메서드의 파라미터 처리도 디스패처 서블릿과 관련된 어디에선가 처리할 것이다!</p><h3 id="doService"><a href="#doService" class="headerlink" title="doService"></a><code>doService</code></h3><p>디스패처 서블릿은 <code>doService</code>라는 메서드를 통해 요청을 처리한다. <code>doService</code>는 <code>doDispatch</code> 메서드로 요청 처리를 넘긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       logRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">                <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                    restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">                ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a><code>doDispatch</code></h3><p><code>doDispatcher</code>는 핸들러에게 요청을 처리하도록 한다. 정확하게 말하면 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code>를 통해 핸들러 어댑터를 통해 핸들러에게 요청을 처리하도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processedRequest = checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">                mappedHandler = getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">                <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">                <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                dispatchException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">                <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">                <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">                dispatchException = <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler dispatch failed: &quot;</span> + err, err);</span><br><span class="line">            &#125;</span><br><span class="line">            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler processing failed: &quot;</span> + err, err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">                <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                    cleanupMultipart(processedRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Handler와-HandlerAdapter"><a href="#Handler와-HandlerAdapter" class="headerlink" title="Handler와 HandlerAdapter"></a>Handler와 HandlerAdapter</h1><p>위 <code>DispatcherServlet</code>의 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code> 코드가 핸들러 어댑터를 활용해서 핸들러에게 요청을 처리하도록 한다.</p><p>여기서 <code>mappedHandler</code>는 <code>HandlerExecutionChain</code>이라는 객체다. <code>HandlerExecutionChain</code>은 핸들러와 같이 실행되는 인터셉터들을 가지고 있다.<br><code>HandlerMapping</code> 인터페이스는 <code>getHandler(HttpServletRequest request)</code>를 통해 해당 요청을 처리해야하는 핸들러와 적용되야 하는 인터셉터를 포함한 <code>HandlerExecutionChain</code>을 반환한다.</p><p>여기서 <code>HandlerExecutionChain</code>은 핸들러를 <code>Object</code>로 저장하고 있다. 즉 요청을 처리할 핸들러가 어떤 메서드를 통해 요청을 처리할 줄 모른다는 뜻이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">interceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결국 <code>Object</code>로 핸들러를 전달받으면 어떤 메서드를 호출해야 할 지 알 수 없다. 특히 스프링에서는 다양한 종류의 핸들러가 존재해서 하나의 타입으로 캐스팅 할 수도 없다.<br>이래서 <code>HandlerAdapter</code>가 존재한다. <code>HandlerAdapter</code>는 전달받은 핸들러가 어떤 객체이든 해당 핸들러를 호출할 수 있는 방법을 추상화한 인터페이스이다!!!</p><h2 id="RequestMappingHandlerAdapter에서-ArgumentResolver를-관리한다"><a href="#RequestMappingHandlerAdapter에서-ArgumentResolver를-관리한다" class="headerlink" title="RequestMappingHandlerAdapter에서 ArgumentResolver를 관리한다."></a>RequestMappingHandlerAdapter에서 ArgumentResolver를 관리한다.</h2><p>그래서 <code>ha.handle(processedRequest, response, mappedHandler.getHandler());</code>를 디버깅을 해보면 <code>AbstractHandlerMethodAdapter</code>의 <code>handle</code>메서드를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>handlerInternal</code>메서드는 <code>AbstractHandlerMethodAdapter</code>를 상속한 <code>RequestMappingHandlerAdapter</code>의 메서드가 호출된다.</p><p><code>RequestMappingHandelrAdapter</code>에 우리가 그렇게 찾던 <code>HandlerMethodArgumentResolver</code>를 관리하고 있다!!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ModelAndViewResolver&gt; modelAndViewResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ContentNegotiationManager</span> <span class="variable">contentNegotiationManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentNegotiationManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; requestResponseBodyAdvice = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestMappingHandlerAdapter</code>에서는 <code>argumentResolver</code>와 <code>customArgumentResolvers</code>를 가지고 있다.</p><p><code>argumentResolver</code>는 <code>getDefaultArgumentResolvers</code>메서드를 통해 초기화된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title function_">getDefaultArgumentResolvers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestPartMethodArgumentResolver</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMapMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionAttributeMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestAttributeMethodArgumentResolver</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletResponseMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RedirectAttributesMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ModelMethodProcessor</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MapMethodProcessor</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ErrorsMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionStatusMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">UriComponentsBuilderMethodArgumentResolver</span>());</span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> <span class="title class_">ContinuationHandlerMethodArgumentResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom arguments</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="literal">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PrincipalMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">true</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 보면 어노테이션을 붙여야 하는 리졸버 -&gt; 타입에 맞춰서 해주는 리졸버 -&gt; 커스텀 리졸버(<code>Pageable</code>리졸버가 해당) -&gt; 그외 모든 대상을 리졸브 대상으로 하는 리졸버 순으로 등록된다!</p><p>다시 <code>handlerInternal</code> 메서드로 돌아오면 결국 <code>invokeHandlerMethod</code>를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeHandlerMethod</code>는 <code>ServletInvocableHandlerMethod</code>를 만들어서 <code>argumentResolver</code>를 세팅해서 <code>invokeAndHandle</code>한다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">    <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">    invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p><code>@RequestMapping</code>으로 매핑된 핸들러(메서드)는 <code>RequestMappingHandlerAdapter</code>에서 처리된다!<br><code>RequestMappingHandlerAdapter</code>에서 핸들러의 인자를 리졸브하는 <code>HandlerMethodArgumentResolver</code>들을 관리한다!<br><code>RequestMappingHandlerAdapter</code>에서는 정해진 우선순위 (어노테이션이 필요한 리졸버 - 타입으로 리졸브하는 리졸버 - 커스텀 리졸버 - 모든 것을 리졸브하려는 리졸버)로 인자를 리졸브한다!<br><code>@PathVariable</code>은 어노테이션이 필요한 리졸버이다.<br><code>ServletRequest</code>나 <code>ServletResponse</code>는 타입 기반으로 리졸브하는 리졸버이다. (그래서 인자에 다른 매개변수가 필요없다!)<br><code>Pageable</code>은 커스텀 리졸버이다!! (Spring Data에서 제공하는 리졸버이다!)<br><code>@ModelAttribute</code>나 <code>@RequestParam</code> 은 어노테이션이 있어도 작동하고, 없어도 작동하는 리졸버이다!!! (가장 우선순위가 낮은 리졸버들이다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드 컴퓨팅과 API의 역할, 대표적인 컴포넌트</title>
      <link>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/</guid>
      <pubDate>Wed, 15 Mar 2023 04:52:36 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;클라우드-컴퓨팅-그게-뭐야&quot;&gt;&lt;a href=&quot;#클라우드-컴퓨팅-그게-뭐야&quot; class=&quot;headerlink&quot; title=&quot;클라우드 컴퓨팅? 그게 뭐야?&quot;&gt;&lt;/a&gt;클라우드 컴퓨팅? 그게 뭐야?&lt;/h1&gt;&lt;p&gt;클라우드 컴퓨팅은 IT 자원이 필</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="클라우드-컴퓨팅-그게-뭐야"><a href="#클라우드-컴퓨팅-그게-뭐야" class="headerlink" title="클라우드 컴퓨팅? 그게 뭐야?"></a>클라우드 컴퓨팅? 그게 뭐야?</h1><p>클라우드 컴퓨팅은 IT 자원이 필요할 때 즉시 사용할 수 있는 환경을 의미한다.</p><h2 id="공용-클라우드와-사설-클라우드를-어떤-차이가-있나"><a href="#공용-클라우드와-사설-클라우드를-어떤-차이가-있나" class="headerlink" title="공용 클라우드와 사설 클라우드를 어떤 차이가 있나?"></a>공용 클라우드와 사설 클라우드를 어떤 차이가 있나?</h2><p>목적이 다르다.<br>공용 클라우드는 IT 리소스를 제공하고 수익을 버는 것!<br>사설 클라우드는 자사에 IT 리소스를 제공하는 것이지만 수익을 위한 것이 아니다.</p><p>비용이 다르다.<br>공용 클라우드는 IT 리소스를 사용하는 만큼만 지불해서 하드웨어와 관련된 비용 문제가 없다.<br>사설 클라우드는 하드웨어 비용이 크게 든다.</p><h2 id="IaaS-PaaS-SaaS가-뭐지"><a href="#IaaS-PaaS-SaaS가-뭐지" class="headerlink" title="IaaS, PaaS, SaaS가 뭐지?"></a>IaaS, PaaS, SaaS가 뭐지?</h2><p>SaaS : 소프트웨어를 제공 -&gt; 바로 사용!<br>PaaS : 플랫폼 (개발 환경, 프레임워크)를 제공 -&gt; 바로 개발!<br>IaaS : 인프라(서버, 네트워크, 스토리지, OS)를 제공 -&gt; 자신만의 서비스 인프라 구성!</p><h2 id="컴포넌트-추상화는-뭐지"><a href="#컴포넌트-추상화는-뭐지" class="headerlink" title="컴포넌트 추상화는 뭐지?"></a>컴포넌트 추상화는 뭐지?</h2><p>클라우드 인프라 서비스는 인프라 리소스를 가상화하여 하드웨어와 분리한다.<br>리소스를 다룰 때 하드웨어 문제를 신경쓰지 않아도 된다.</p><p>컴포넌트 추상화는 하드웨어와 분리되어 사용자의 요구사항을 인프라로 구현하도록 돕는 개념이다.<br>요구사항을 하드웨어를 통해 구축하는 것보다 요구사항 자체를 컴포넌트에 전달하면 실제 구현을 알아서 적용되도록 한다.</p><p>이렇게 요구사항을 컴포넌트를 통해 추상화 해놓으면 컴포넌트를 통해 클라우드 환경에서 시스템 구축 과정을 표준화 할 수 있게 된다.</p><h2 id="클라우드-컴퓨팅을-활용하기"><a href="#클라우드-컴퓨팅을-활용하기" class="headerlink" title="클라우드 컴퓨팅을 활용하기"></a>클라우드 컴퓨팅을 활용하기</h2><p>Iaas에서 컴포넌트를 활용해서 서비스 인프라 구축을 표준화할 수 있게됐다.<br>클라우드는 API를 통해 리소스를 제어할 수 있게 한다. 이를 통해 시스템 구축부터 서버의 설치나 네트워크결 연결까지 자동화할 수 있다.</p><h1 id="클라우드의-대표적인-컴포넌트"><a href="#클라우드의-대표적인-컴포넌트" class="headerlink" title="클라우드의 대표적인 컴포넌트"></a>클라우드의 대표적인 컴포넌트</h1><h2 id="테넌트"><a href="#테넌트" class="headerlink" title="테넌트"></a>테넌트</h2><p>테넨트는 세입자다. AWS로 치면 사용자 계정이 해당된다.<br>하나의 계정에 여러 시스템을 관리할 수 있다.<br>테넨트는 비용 청구의 단위가 된다.<br>테넨트는 가상 네트워크, 가상 머신 인스턴스, 가상 스토리지 끼리만 서로 연결 가능하다.<br>또한 여러 테넌트를 합쳐서 멀티 테넨트를 하나의 테넨트로 쓸 수 있다. (AWS Organization)</p><h2 id="리전"><a href="#리전" class="headerlink" title="리전"></a>리전</h2><p>클라우드 인프라를 지역단위로 묶어서 관리하기 위해 등장한 개념이다.<br>리전은 각각 독립된 환경이라 여러 리전을 걸친 가상 네트워크를 구현할 수 없다.<br>즉 가상 네트워크는 리전별로 독립된 형태로 만들어진다. 이런 가상 네트워크를 VPC라고 한다. 한 리전에 여러 VPC 가능하다.</p><h3 id="다른-리전에-DR"><a href="#다른-리전에-DR" class="headerlink" title="다른 리전에 DR"></a>다른 리전에 DR</h3><p>다만 다른 리전에 DR 환경을 구축할 수는 있다.</p><blockquote><p>DR : disaster recovery 서울에 재난이 생기면 시드니에 동일한 환경을 가진 시스템을 작동시키는 것.</p></blockquote><p>이때 퍼블릭 IP의 범위가 달라질 수 있어서 DNS에 IP를 업데이트 해줘야 할 수 있다.<br>환경 뿐만 아니라 데이터도 다른 리전에 역제해놔야 한다.<br>이때 오브젝트 리소스를 활용한다. 오브젝트 리소스는 리전에 종속되지 않기 때문이다!</p><h2 id="가용영역"><a href="#가용영역" class="headerlink" title="가용영역"></a>가용영역</h2><p>리전이 지역이라면 가용 영역은 그 리전에 속한 데이터 센터라고 이해하자.<br>(AWS의 <code>ap-northeast-2a</code> 같은 것, 오픈 스택에서는 데이터 센터 안에서 가용 영역을 더 나눌 수 있다고 한다.)<br>다른 가용영역에 있는 가상 머신 인스턴스와 블록 스토리지는 서로 연결할 수 없다.<br>(물론 네트워크를 통한 연결은 된다. 블록 스토리지를 마운트 하는 행위 같은 연결이 안된다는 의미다.)</p><h1 id="네트워크-리소스"><a href="#네트워크-리소스" class="headerlink" title="네트워크 리소스"></a>네트워크 리소스</h1><h2 id="라우터-그냥-공유기"><a href="#라우터-그냥-공유기" class="headerlink" title="라우터 (그냥 공유기)"></a>라우터 (그냥 공유기)</h2><p>독립된 가상 네트워크(VPC)는 공유기로 구성한 LAN과 같이 외부의 접근이 차단된 네트워크와 비슷하다.<br>가정용 LAN을 인터넷과 연결하기 위해서는 인터넷 라우터가 필요하다.<br>클라우드 환경에서도 가상 네트워크와 물리적인 외부 네트워크를 연결하는 가상 라우터가 있어야 한다.<br>가상 네트워크에서는 LAN과 같이 프라이빗 IP주소를 사용한다.<br>외부 네트워크와 통신할 때는 가상 라우터의 NAT 기능을 사용해서 Public IP로 변환한다.<br>(NAT는 <a href="https://yangdongjue5510.github.io/2021/11/17/cs/network/network7/">네트워크 계층 포스트</a>를 통해 알아보자.)</p><p>AWS에서 VPC를 만들면 Internet Gateway가 생기는데, Internet Gateway가 라우터 역할을 한다.</p><h2 id="스위치"><a href="#스위치" class="headerlink" title="스위치"></a>스위치</h2><p>가상 스위치는 가상 라우터와 가상 머신 인스턴스의 가상 NIC가 연결되는 지점<br>가상 스위치는 물리 스위치와 다르게 포트 제한이 없다.<br>(물리 스위치는 포트가 부족하면 허브를 두거나 스위치를 더 둔다.)<br>가상 스위치는 가상 NIC를 써서 포트 문제를 해결한다. (AWS에서는 ENI. 인스턴스가 올라갈 때 ENI가 할당된다)<br>가상 인스턴스와 연결해야 할 때 포트가 추가 → 해당 포트에 서브넷 범위 안에서 사용할 수 있는 IP 주소 할당 → DHCP 방식으로 가상 NIC에 연결됨</p><h2 id="서브넷"><a href="#서브넷" class="headerlink" title="서브넷"></a>서브넷</h2><p>가상 스위치에 해당하는 컴포넌트를 서브넷이라고 한다.<br>가용 영역 별로 서브넷을 구성 할 수 있다.<br>가상 스위치에 하나의 서브넷이 할당된다.<br>서브넷은 가상 머신 인스턴스가 사용할 수 있는 사설 IP 주소의 범위</p><p>AWS는 가상 스위치과 서브넷을 합쳐서 서브넷이라고 부른다.<br>AWS에서는 하나의 가상 스위치(서브넷)이 하나의 가용 영있에 할당.</p><p>라우터는 집이고 서브넷은 집안에 방이라고 생각하면 된다.</p><h2 id="공인-IP-주소"><a href="#공인-IP-주소" class="headerlink" title="공인 IP 주소"></a>공인 IP 주소</h2><p>사설 IP주소를 가상 라우터의 NAT 기능을 통해 공인 IP(퍼블릭)로 변환하는 방식<br>이걸 IP 마스커레이딩이라 한다. (외부로 통신할 때 나의 사설 IP를 사설 라우터의 공인 IP로 변환!)<br>이런 마스커레이딩은 내부에서 외부로 통신할 수는 있지만, 외부에서 내부의 서버로 통신은 안된다!!</p><p>결국 모든 사설 IP(private ip)를 같은 공인 IP로 변환하여 외부 네트워크에 통신한다.<br>이 방식은 private ip가 외부 접근은 되지만 외부에서 사설 ip접근은 안된다.</p><h3 id="AWS의-엘라스틱-IP"><a href="#AWS의-엘라스틱-IP" class="headerlink" title="AWS의 엘라스틱 IP"></a>AWS의 엘라스틱 IP</h3><p>미리 개별적으로 확보해둔 퍼블릭 아이피를 라우터가 가상 인스턴스에 할당 (즉 공인 IP를 private ip에 매핑하는 방식)<br>내부 → 외부, 외부 → 내부 모두 가능하다.<br>단 리전마다 따로 확보해야 한다. 다른 리전에서 재사용 불가.</p><h2 id="시큐리티-그룹"><a href="#시큐리티-그룹" class="headerlink" title="시큐리티 그룹"></a>시큐리티 그룹</h2><p>가상 머신 인스턴스가 주고받을 네트워크 패킷을 필터링하는 기능<br>아이피 포트 뿐만 아니라 프로토콜 종류를 통해 필터링도 가능하다.<br>여러개의 가상 스위치에 접속하고 싶으면 여러 가상 NIC가 있어야되고 각 가상 NIC는 스위치 포트에 접속하러 갈 때 시큐리티 그룹을 설정해줄 수 있다.</p><p>시큐리티 그룹과 비슷한 방식으로 라우팅 테이블에서도 필터링을 해줄 수 있다.<br>다만 라이퉁 테이블은 서브넷에 접속하기 전에 작동하고, 시큐리티 그룹은 인스턴스에 접근하기 전에 작동한다.</p><h1 id="서버-리소스"><a href="#서버-리소스" class="headerlink" title="서버 리소스"></a>서버 리소스</h1><h2 id="템플릿-이미지"><a href="#템플릿-이미지" class="headerlink" title="템플릿 이미지"></a>템플릿 이미지</h2><p>가상 머신 인스턴스를 기동하기 위해 게스트 OS가 설치된 기동 디스크가 필요하다.<br>이 기동디스크를 만들어주는 애가 템플릿 이미지.<br>템플릿 이미지가 다운로드 되서 가상 디스크 형태로 만들어지고 가상 머신 인스턴스가 가상 디스크를 연결해서 사용</p><p>루트 디스크와 임시 디스크는 가상 머신 인스턴스를 종료하면 날라간다. (남기고 싶으면 블록 스토리지를 사용할 수 있다.)<br>만약 루트 디스크에 저장된 어플리케이션을 보존하고 싶으면 스냅샷을 남기자. (EC2로 DB를 운영할 경우 매일 데이터베이스의 스냅샷을 남길 수 있다.)<br>스냅샷은 루트 디스크를 복제하고 템플릿 이미지로 만든다.</p><h2 id="네트워크-접속과-시큐리티-그룹"><a href="#네트워크-접속과-시큐리티-그룹" class="headerlink" title="네트워크 접속과 시큐리티 그룹"></a>네트워크 접속과 시큐리티 그룹</h2><p>인스턴스의 가상 NIC가 네트워크와 연결되려면 가상 스위치에 연결되어 있어야 한다! (그래야 가상 스위치가 가상 라우터와 연결이 되니까)</p><p>인스턴스 하나에 여러 NIC를 연결할 수 있다.<br>다만 컨테이너를 인스턴스에 사용할 때는 <a href="https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/container-instance-eni.html">ECS ENI Trunking</a>을 유의하자.</p><p>시큐리티 그룹은 NIC에 적용된다! 즉 한 인스턴스라도 NIC마다 다르게 시큐리티 그룹을 적용할 수 있다.</p><h2 id="로그인-인증과-키페어"><a href="#로그인-인증과-키페어" class="headerlink" title="로그인 인증과 키페어"></a>로그인 인증과 키페어</h2><p>기본적으로 SSH의 공개 키 인증 방식이 사용한다.<br>테넌트 이용자는 접속 전용 키페어를 만든다.<br>공개키는 클라우드 환경에 등록 &amp; 개인 키는 사용자가 다운로드<br>가상 머신 인스턴스에 템플릿 이미지로 게스트 os를 설치할 때 공개키도 같이 설정된다.</p><h2 id="블록-스토리지"><a href="#블록-스토리지" class="headerlink" title="블록 스토리지"></a>블록 스토리지</h2><p>가상 머신 인스턴스가 종료되어도 내용을 보존하는 영속적인 디스크 영역(AWS에서는 EBS라고 부름.)<br>가상 머신 인스턴스는 어플리케이션을 가동하는 가상 컴퓨터.<br>가상 머신 인스턴스에 블록 스토리지를 마운트 해서 보통의 물리적 디스크 디바이스처럼 쓸 수 있게 된다.<br>블록 스토리지는 여러 가상 머신 인스턴스에도 마운트할 수 있다.</p><h3 id="블록-스토리지에-있는-게스트-OS로-가상-머신-인스턴스를-가동하는-방법"><a href="#블록-스토리지에-있는-게스트-OS로-가상-머신-인스턴스를-가동하는-방법" class="headerlink" title="블록 스토리지에 있는 게스트 OS로 가상 머신 인스턴스를 가동하는 방법."></a>블록 스토리지에 있는 게스트 OS로 가상 머신 인스턴스를 가동하는 방법.</h3><p>AWS에서는 EBS Boot<br>미리 볼륨을 만들어 놓고 템플릿 이미지를 복제해서 가상 머신 인스턴스에 연결.<br>다른 가상 머신 인스턴스에 연결해도 이어서 할 수 잇음</p><h2 id="오브젝트-스토리지-리소스"><a href="#오브젝트-스토리지-리소스" class="headerlink" title="오브젝트 스토리지 리소스"></a>오브젝트 스토리지 리소스</h2><p>파일 단위로 데이터를 저장하는 데이터 스토어.<br>HTTP, HTTPS로 사용하는 파일서버<br>테넨트가 생성한 S3 버킷은 모든 리전과 가용영역에서 접근 가능!<br>컨테이너(버킷)은 디렉토리처럼 계층적 구조는 되지 않지만 파일 이름을 디렉토리처럼(abc&#x2F;file) 묘사해서 비슷한 효과를 낼수 잇다.<br>키와 값으로 메타 데이터를 부여할 수도 있다.</p><h3 id="버저닝"><a href="#버저닝" class="headerlink" title="버저닝"></a>버저닝</h3><p>컨테이너에서 관리하는 오브젝트에 버전 번호를 붙여서 관리하는 기능.<br>롤백같은 기능을 수행할 수 있다.</p><h3 id="백업"><a href="#백업" class="headerlink" title="백업"></a>백업</h3><p>블록 스토리지의 볼륨을 여러 블록으로 분할해서 하나의 파일 형태로 간주하여 오브젝트 스토리지에 저장.<br>리전이나 가용영역을 뛰어넘어서 복원할 수 있다.</p><h1 id="웹-애플리케이션-시스템-구축-예시"><a href="#웹-애플리케이션-시스템-구축-예시" class="headerlink" title="웹 애플리케이션 시스템 구축 예시"></a>웹 애플리케이션 시스템 구축 예시</h1><h2 id="여러-가용-영역으로-가용성-확보"><a href="#여러-가용-영역으로-가용성-확보" class="headerlink" title="여러 가용 영역으로 가용성 확보"></a>여러 가용 영역으로 가용성 확보</h2><p>AWS는 VPC별로 가상 네트워크가 만들어지고, 가상 네트워크 속 가용 영역 별로 가상 스위치(서브넷)이 생기고,<br>각 사용 용도에 따라 네트워크를 분리하기 위해 가상 스위치(서브넷)를 만들어서 통신할 수 있다.<br>가상 머신 인스턴스에 해당 스위치(서브넷)를 통해서만 통신할 수 있도록 하면 접근을 제한 할수 잇다.<br>다른 가용영역에 현재 가용영역과 동일한 환경을 구축해놓고 문제가 생기면 해당 가용영역으로 접근하도록 로드밸런싱을 해주거나 DNS 설정을 바꿔줘야 한다.<br><a href="https://aws.amazon.com/ko/builders-library/static-stability-using-availability-zones/">가용 영역을 사용한 정적 안정성</a></p><h2 id="오브젝트-스토리지로-데이터-지키기"><a href="#오브젝트-스토리지로-데이터-지키기" class="headerlink" title="오브젝트 스토리지로 데이터 지키기"></a>오브젝트 스토리지로 데이터 지키기</h2><p>DB 서버가 관리하는 데이터를 블록 스토리지 볼륨에 저장시키면 가상 머신 인스턴스가 잘못되어도 데이터를 지킬 수 있다.<br>근데 블록 스토리지가 잘못될 경우를 예상해서 이마저도 오브젝트 스토리지에 백업해두면 된다.<br>그런데 볼륨 백업은 오브젝트 스토리지로 전송해야 되니까 좀 느릴 순 있다.</p><p>백업하기 전에는 볼륨을 가상 머신 인스턴스에서 분리해야 됨.<br>이때는 당연히 디비 서버가 요청을 처리하지 못한다.<br>그러면 볼륨의 스냅샷을 떠서 백업하도록 하면 된다.<br>스냅샷을 만들때도 인스턴스에서 볼륨을 분리하지만 시간이 적게 든다.</p><p>가상 머신 인스턴스에 블록 스토리지를 연결해두고 오브젝트 스토리지에 백업해둔다.<br>가용 영역 전환할 때 해당 가용 영역의 블록 스토리지에 오브젝트 스토리지의 데이터를 통해 데이터 구축 가능하다.</p><p>다른 방법으로는 데이터베이스가 네트워크를 통해 동기화하는 기능을 사용할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/infra/">Infra</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>F12 서비스 의존성 개선 리팩토링</title>
      <link>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/</link>
      <guid>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/</guid>
      <pubDate>Sun, 12 Mar 2023 12:35:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;F12 서비스 링크(&lt;a href=&quot;https://f12.app/&quot;&gt;https://f12.app/&lt;/a&gt;)&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/87690744/224546124-003</description>
        
      
      
      
      <content:encoded><![CDATA[<p>F12 서비스 링크(<a href="https://f12.app/">https://f12.app/</a>)<br><img src="https://user-images.githubusercontent.com/87690744/224546124-0037780b-5215-4073-a1d4-dcd9dff96703.png"></p><h1 id="기존-상황"><a href="#기존-상황" class="headerlink" title="기존 상황"></a>기존 상황</h1><p>F12 서비스 백엔드 아키텍처는 도메인 개념 별로 의존성을 그려보면 다음과 같다.<br><img src="https://user-images.githubusercontent.com/87690744/224546691-84ff0950-5692-4212-aa7c-bbeaba9e2ee0.png"><br>총 세가지 양방향 의존이 생긴다. 이런 상황이면 Review에 변경이 생기면 Product -&gt; InventoryProduct -&gt; Member -&gt; Following 까지 변경에 따른 영향이 생길 수 있다.</p><h1 id="Member-lt-–-gt-InventoryProduct"><a href="#Member-lt-–-gt-InventoryProduct" class="headerlink" title="Member &lt;–&gt; InventoryProduct"></a>Member &lt;–&gt; InventoryProduct</h1><h3 id="Member의-상황"><a href="#Member의-상황" class="headerlink" title="Member의 상황"></a><code>Member</code>의 상황</h3><p>회원을 의미한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;github_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gitHubId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;image_url&quot;, length = 65535, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;registered&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> registered;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;career_level&quot;)</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> CareerLevel careerLevel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;job_type&quot;)</span></span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> JobType jobType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;follower_count&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> followerCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">InventoryProducts</span> <span class="variable">inventoryProducts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InventoryProducts</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;role&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> Role.USER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Member</code>의 엔티티는 <code>InventoryProduct</code> 도메인에 해당하는 <code>InventoryProducts</code>를 멤버로 가지고 있다. <code>InventoryProducts</code>를 통해 사용자의 프로필 장비를 조회할 수 있다.</p><p>F12 서비스에서 다음과 같은 프로필을 구현할 때 사용자의 회원정보와 그 사용자의 프로필 장비를 같이 보여주기 때문에 멤버 변수로 의존하게 됐다.<br><img src="https://user-images.githubusercontent.com/87690744/224551081-b73bb136-a654-48b5-a30d-330b30853032.png"><br>즉 Member를 조회할 때 InventoryProduct를 함께 조회해서 위와 같은 프로필을 만들기 용이하기 위해 Member가 InventoryProduct에 의존한다.</p><p>그리고 <code>Member</code>의 서비스 로직에서 사용자들의 프로필을 만들 때 해당 회원들의 인벤토리 장비도 조회해와야 한다.아래가 사용자들의 프로필을 만드는 서비스 로직이다. <code>Member</code>를 조회해오고 그에 해당하는 <code>InventoryProduct</code>를 조회해서 조립하고 있다. 이렇게 <code>Member</code>와 <code>InventoryProduct</code>를 따로 조회해서 조립하면 <code>InventoryProductRepository</code>에 의존성이 생긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FollowingRepository followingRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MemberService</span><span class="params">(<span class="keyword">final</span> MemberRepository memberRepository, <span class="keyword">final</span> FollowingRepository followingRepository,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memberRepository = memberRepository;</span><br><span class="line">        <span class="built_in">this</span>.followingRepository = followingRepository;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="keyword">public</span> MemberPageResponse <span class="title function_">findBySearchConditions</span><span class="params">(<span class="meta">@Nullable</span> <span class="keyword">final</span> Long loggedInId,</span></span><br><span class="line"><span class="params">                                                     <span class="keyword">final</span> MemberSearchRequest memberSearchRequest,</span></span><br><span class="line"><span class="params">                                                     <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Slice&lt;Member&gt; slice = findBySearchConditions(memberSearchRequest, pageable);</span><br><span class="line">        <span class="keyword">if</span> (slice.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> MemberPageResponse.ofByFollowingCondition(slice, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setInventoryProductsToMembers(slice);</span><br><span class="line">        <span class="keyword">if</span> (isNotLoggedIn(loggedInId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> MemberPageResponse.ofByFollowingCondition(slice, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Following&gt; followings = followingRepository.findByFollowerIdAndFollowingIdIn(loggedInId,</span><br><span class="line">                extractMemberIds(slice.getContent()));</span><br><span class="line">        <span class="keyword">return</span> MemberPageResponse.of(slice, followings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Slice&lt;Member&gt; <span class="title function_">findBySearchConditions</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest,</span></span><br><span class="line"><span class="params">                                                 <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CareerLevel</span> <span class="variable">careerLevel</span> <span class="operator">=</span> parseCareerLevel(memberSearchRequest);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobType</span> <span class="variable">jobType</span> <span class="operator">=</span> parseJobType(memberSearchRequest);</span><br><span class="line">        <span class="keyword">if</span> (memberSearchRequest.getQuery() == <span class="literal">null</span> &amp;&amp; careerLevel == <span class="literal">null</span> &amp;&amp; jobType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memberRepository.findWithOutSearchConditions(pageable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memberRepository.findWithSearchConditions(memberSearchRequest.getQuery(), careerLevel,</span><br><span class="line">                jobType, pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInventoryProductsToMembers</span><span class="params">(<span class="keyword">final</span> Slice&lt;Member&gt; slice)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;InventoryProduct&gt; mixedInventoryProducts = inventoryProductRepository.findWithProductByMembers(</span><br><span class="line">                slice.getContent());</span><br><span class="line">        <span class="keyword">for</span> (Member member : slice.getContent()) &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;InventoryProduct&gt; memberInventoryProducts = mixedInventoryProducts.stream()</span><br><span class="line">                    .filter(it -&gt; it.getMember().isSameId(member.getId()))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            member.updateInventoryProducts(memberInventoryProducts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JobType <span class="title function_">parseJobType</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobTypeConstant</span> <span class="variable">jobTypeConstant</span> <span class="operator">=</span> memberSearchRequest.getJobType();</span><br><span class="line">        <span class="keyword">if</span> (jobTypeConstant == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jobTypeConstant.toJobType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CareerLevel <span class="title function_">parseCareerLevel</span><span class="params">(<span class="keyword">final</span> MemberSearchRequest memberSearchRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CareerLevelConstant</span> <span class="variable">careerLevelConstant</span> <span class="operator">=</span> memberSearchRequest.getCareerLevel();</span><br><span class="line">        <span class="keyword">if</span> (careerLevelConstant == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> careerLevelConstant.toCareerLevel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; <span class="title function_">extractMemberIds</span><span class="params">(<span class="keyword">final</span> List&lt;Member&gt; members)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> members.stream()</span><br><span class="line">                .map(Member::getId)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 생긴 의존성은 <code>MemberRepository</code>에서 <code>Member</code>를 조회할 때 Left join 기반으로 한 fetch join으로 연관된 엔티티를 한번에 읽어오게 하면 서비스 로직에서 <code>InventoryProductRepository</code>에 의존하지 않고 회원들의 인벤토리 장비를 가져올 수 있다.</p><blockquote><p>여기서 한가지 포인트를 알고가자.<br>fetch join으로 한번에 같이 조회해서 서비스 로직에서 <code>InventoryProduct</code> 의존성을 제거할 수 있다. 하지만 <code>Member</code> 엔티티에서 <code>InventoryProduct</code>를 멤버 변수로 의존하게 된다. 또 <code>MemberRepository</code>에서 <code>InventoryProduct</code>를 알게 된다.<br><code>Member</code> 엔티티에서 <code>InventoryProduct</code> 의존성을 제거하면 <code>MemberService</code>에서 <code>Member</code>를 조회해올 때 <code>InventoryProduct</code>를 한번에 조회할 수 없고 <code>InventoryProductRepository</code>에 의존하게 된다.</p></blockquote><p><code>Member</code> 입장에서 보면 프로필을 만드는 로직 때문에 서비스 레이어 혹은 엔티티에서 <code>InventoryProduct</code>에 의존하게 된다.</p><h3 id="InventoryProduct의-상황"><a href="#InventoryProduct의-상황" class="headerlink" title="InventoryProduct의 상황"></a><code>InventoryProduct</code>의 상황</h3><p>회원이 리뷰를 남긴 제품을 의미한다.인벤토리 장비가 프로필 장비인 지 구분할 수 있다. 리뷰를 남긴 제품은 자동으로 회원의 인벤토리 장비가 된다.<br>InventoryProduct는 DB 테이블로 생각하면 Member와 Product의 다대다 매핑 테이블 역할도 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProduct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;selected&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> selected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 상으로는 <code>Member</code>와 <code>Product</code>에 의존한다. <code>Product</code> 의존성은 <code>InventoryProduct</code>가 대부분 장비의 정보를 함께 조회해서 멤버 변수로 가져도 괜찮다.<br>하지만 <code>Member</code>가 문제다. <code>InventoryProduct</code>는 <code>Member</code>를 사용하지 않는데 멤버 변수로 갖고 있다.<br>이런 불필요한 직접 참조는 id로 간접 참조하면 쉽게 해결할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProduct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;selected&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> selected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;member_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long memberId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 서비스 레이어에서 <code>Member</code>에 의존하고 있다는 점이다. 특정 사용자id로 해당 사용자의 인벤토리 장비를 조회해야 하는 경우 사용자 Id가 유효한 지 확인해야 한다.<br>그래서 다음과 같은 의존이 생긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProductService</span> &#123;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">    <span class="keyword">public</span> InventoryProductsResponse <span class="title function_">findByMemberId</span><span class="params">(<span class="keyword">final</span> Long memberId)</span> &#123;</span><br><span class="line">        validateMember(memberId);</span><br><span class="line">        <span class="keyword">final</span> List&lt;InventoryProduct&gt; inventoryProducts = inventoryProductRepository.findWithProductByMemberId(memberId);</span><br><span class="line">        <span class="keyword">return</span> InventoryProductsResponse.from(inventoryProducts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateMember</span><span class="params">(<span class="keyword">final</span> Long memberId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memberRepository.existsById(memberId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MemberNotFoundException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 의존을 AOP로 분리할 수는 있을 것 같다. 하지만 그렇게 하면 서비스 로직이 여러군데 퍼지는 것 같고 실수할 여지가 많을 것 같다.<br>혹은 DIP를 적용해서 <code>MemberValidator</code>라는 인터페이스를 <code>InventoryProduct</code> 패키지에 두고, <code>MemberValidator</code>의 구현체는 <code>Member</code>에 두고 빈 등록하여 <code>InventoryService</code>는 <code>MemberValidator</code> 인터페이스를 주입받아서 사용하면 <code>Member</code>에게 의존하지 않고 <code>Member</code>가 <code>InventoryProduct</code>에 의존하게 할 수 있다.</p><p>하지만 <code>InventoryProduct</code>이 <code>Member</code>에 의존하는게 잘못된 걸까?<br>의미 상 <code>InventoryProduct</code>는 특정 회원의 인벤토리 장비이다. <code>InventoryProduct</code>의 로직 상 <code>Member</code>에게 의존해서 협력하는 게 자연스럽고, 이 의존을 없애거나 역전하기 위해 복잡도를 높이는 게 오히려 코드를 이해하는 데 어려울 수 있다.</p><h2 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h2><p>현재까지 문제점을 정리하자면 다음과 같다.<br><code>Member</code>는 프로필 관련 기능 때문에 <code>InventoryProduct</code>를 의존할 수 밖에 없다. (서비스 레이어 혹은 엔티티)<br><code>InventoryProduct</code>는 <code>Member</code> 의존성을 다양한 방법으로 제거할 수 는 있지만 의미 상 의존하는게 자연스럽고 의존을 제거하면 복잡도가 높아질 것 같다.</p><p>그렇다면 <code>Member</code>에서 프로필 관련 기능을 아예 다른 패키지로 추출하면 어떨까?<br><code>profile</code> 이라는 새로운 패키지를 도입해서 프로필 관련 기능을 모을 수 있지 않을까?</p><p>프로필 관련 로직을 <code>profile</code>에 모으면 다음과 같이 의존성이 그려진다.<br><img src="https://user-images.githubusercontent.com/87690744/225565744-0291cac3-7079-4033-a0c2-e2675fb6fcc8.png"></p><p>한번 로직을 모아보자!</p><h3 id="도메인"><a href="#도메인" class="headerlink" title="도메인"></a>도메인</h3><p>먼저 프로필 기능에 필요한 도메인 클래스를 만들어보자. 프로필은 특정 대상이 팔로잉하는지 알려줄 수 있어야 하고, 대표장비와 회원정보를 알려줄 수 있어야 한다.</p><p>여기서 중요한 점은 프로필의 의미이다. 프로필은 아래 그림을 보면 알 수 있듯이, 특정 회원의 회원정보와 대표장비 그리고 보는 사람이 팔로우 했는지를 알려주는 개념이다.<br>즉 프로필은 보는 사람에 따라 팔로우 여부를 상대적으로 가지게 된다는 사실을 명심하자.</p><p><img src="https://user-images.githubusercontent.com/87690744/224551081-b73bb136-a654-48b5-a30d-330b30853032.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Profile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Member member;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProducts inventoryProducts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFollowing;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Profiles</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Profile&gt; profiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Profiles</span><span class="params">(<span class="keyword">final</span> List&lt;Profile&gt; profiles)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.profiles = profiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Profiles <span class="title function_">of</span><span class="params">(<span class="keyword">final</span> List&lt;Member&gt; members, <span class="keyword">final</span> List&lt;InventoryProduct&gt; inventoryProductsOfMembers,</span></span><br><span class="line"><span class="params">                              <span class="keyword">final</span> List&lt;Following&gt; followingRelations)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Long, List&lt;InventoryProduct&gt;&gt; inventoryProductsGroups = groupByMemberId(inventoryProductsOfMembers);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Profile&gt; profiles = members.stream()</span><br><span class="line">                .map(member -&gt; createProfile(member, inventoryProductsGroups, followingRelations))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Profiles</span>(profiles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="서비스-코드"><a href="#서비스-코드" class="headerlink" title="서비스 코드"></a>서비스 코드</h3><p>이제 기존에는 <code>MemberService</code>에서 수행하던 프로필 로직(<code>Member</code>조회하고 <code>InventoryProduct</code> 조회해서 합치기)를 <code>ProfileService</code>에서 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FollowingRepository followingRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProfileService</span><span class="params">(<span class="keyword">final</span> MemberRepository memberRepository,</span></span><br><span class="line"><span class="params">                          <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository,</span></span><br><span class="line"><span class="params">                          <span class="keyword">final</span> FollowingRepository followingRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memberRepository = memberRepository;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">        <span class="built_in">this</span>.followingRepository = followingRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PagedProfilesResponse <span class="title function_">findBySearchConditions</span><span class="params">(<span class="meta">@Nullable</span> <span class="keyword">final</span> Long loggedInId,</span></span><br><span class="line"><span class="params">                                                        <span class="keyword">final</span> ProfileSearchRequest profileSearchRequest,</span></span><br><span class="line"><span class="params">                                                        <span class="keyword">final</span> Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Slice&lt;Member&gt; slice = findBySearchConditions(profileSearchRequest, pageable);</span><br><span class="line">        <span class="keyword">if</span> (slice.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> PagedProfilesResponse.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Profiles</span> <span class="variable">profiles</span> <span class="operator">=</span> createProfiles(loggedInId, slice.getContent());</span><br><span class="line">        <span class="keyword">return</span> PagedProfilesResponse.of(slice.hasNext(), profiles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//생략...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="의존성을-정리하고-나면"><a href="#의존성을-정리하고-나면" class="headerlink" title="의존성을 정리하고 나면,,"></a>의존성을 정리하고 나면,,</h3><p>이제 <code>Member</code>는 회원 정보 관리와 팔로우 관련 기능만 수행한다.<br><code>InventoryProduct</code>는 인벤토리 장비 추가, 삭제, 대표장비 수정 관련 기능만 수행하게 된다.<br><code>Profile</code>은 <code>Member</code>와 <code>InventoryProduct</code>를 기반으로 프로필 생성하는 기능을 수행하게 된다.</p><p>이전보다 각 도메인들의 역할이 간단명료해졌다!</p><h1 id="Product-lt-–-gt-InventoryProduct-Review"><a href="#Product-lt-–-gt-InventoryProduct-Review" class="headerlink" title="Product &lt;–&gt; InventoryProduct, Review"></a>Product &lt;–&gt; InventoryProduct, Review</h1><h2 id="Product의-상황"><a href="#Product의-상황" class="headerlink" title="Product의 상황"></a>Product의 상황</h2><p>리뷰 대상인 장비를 의미한다. 엔티티만 살펴보면 특별히 다른 도메인에 의존하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_IMAGE_URL_LENGTH</span> <span class="operator">=</span> <span class="number">15000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;image_url&quot;, nullable = false, length = MAXIMUM_IMAGE_URL_LENGTH)</span></span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;review_count&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> reviewCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;total_rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> totalRating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;avg_rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> rating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;category&quot;, nullable = false, length = 8)</span></span><br><span class="line">    <span class="meta">@Enumerated(value = EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 <code>Product</code> 도메인은 서비스 레이어에서 여러 도메인들에 의존한다.<br>특히 <code>Product</code> 엔티티가 제거되면 해당 장비에 대한 리뷰와 해당 장비를 인벤토리 장비 설정한 내역도 모두 제거해야 된다.<br>그래서 <code>ProductService</code>에서는 다음과 같이 다른 도메인의 레포지토리를 의존한 경우가 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="comment">//... 생략</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Product</span> <span class="variable">target</span> <span class="operator">=</span> productRepository.findById(productId)</span><br><span class="line">                .orElseThrow(ProductNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">        reviewRepository.deleteByProduct(target);</span><br><span class="line">        inventoryProductRepository.deleteByProduct(target);</span><br><span class="line">        productRepository.delete(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InventoryProduct와-Review의-상황"><a href="#InventoryProduct와-Review의-상황" class="headerlink" title="InventoryProduct와 Review의 상황"></a>InventoryProduct와 Review의 상황</h3><p><code>InventoryProduct</code>의 경우, 회원이 리뷰를 남긴 장비라는 의미이기 때문에 항상 제품 정보를 함께 보여줘야 한다. 그래서 엔티티에서 멤버로 <code>Product</code>를 의존하고, 서비스 레이어에서도 <code>Product</code>가 유효한 지 체크하는 로직도 있다.</p><p><code>Review</code>의 경우, 회원이 장비에 남긴 리뷰를 의미한다. 리뷰도 <code>inventoryProduct</code>와 비슷하게 제품 정보를 같이 보여줘야 하는 경우가 많아서 엔티티에서 멤버로 <code>Product</code>를 의존하고, 서비스 레이어에서도 <code>Product</code> 유효성 검증을 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Review</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;content&quot;, nullable = false, length = MAXIMUM_CONTENT_LENGTH)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;rating&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rating;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;product_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;member_id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;created_at&quot;, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdAt;</span><br><span class="line">    <span class="comment">//생략</span></span><br></pre></td></tr></table></figure><h2 id="해결책-1"><a href="#해결책-1" class="headerlink" title="해결책"></a>해결책</h2><p>지금까지 파악한 문제는 <code>InventoryProduct</code>, <code>Review</code>는 <code>Product</code>와 조회되는 일이 많고 <code>Product</code> 검증해야 하는 로직 때문에 <code>Product</code>에 의존하고 있었다. <code>Product</code>는 장비 삭제할 때 해당하는 <code>InvnentoryProduct</code>와 <code>Review</code>를 제거해야 해서 의존성이 생겼었다.</p><p>이런 문제는 <code>Product</code> 삭제 시, 이벤트를 발행해서 해당 이벤트를 처리하는 이벤트 리스너를<code>Review</code>와 <code>InvnetoryProduct</code>에 추가하는 방식으로 해결했다.</p><h3 id="이벤트-구현"><a href="#이벤트-구현" class="headerlink" title="이벤트 구현"></a>이벤트 구현</h3><p><code>product</code> 패키지에 장비가 삭제됐음을 알리는 이벤트를 만들어본다. <code>ApplicationEvent</code>를 상속해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDeletedEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductDeletedEvent</span><span class="params">(<span class="keyword">final</span> Object source, <span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getProductId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>ProductDeletedEvent</code>를 장비 삭제 당시에 발행하도록 해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProductRepository productRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="keyword">final</span> Long productId)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Product</span> <span class="variable">target</span> <span class="operator">=</span> productRepository.findById(productId)</span><br><span class="line">                .orElseThrow(ProductNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">        productRepository.delete(target);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProductDeletedEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductDeletedEvent</span>(<span class="built_in">this</span>, productId);</span><br><span class="line">        eventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationEventPublisher</code>를 주입받고 생성한 이벤트를 발행하도록 한다.</p><h3 id="이벤트-리스너-구현하기"><a href="#이벤트-리스너-구현하기" class="headerlink" title="이벤트 리스너 구현하기"></a>이벤트 리스너 구현하기</h3><p>이제 <code>review</code>와 <code>inventoryProduct</code> 패키지에 <code>ProductDeletedEvent</code>를 처리하는 이벤트 리스너를 구현해보자. <code>@EventListener</code>를 이벤트 처리하는 메서드에 붙여주고, 매개변수를 처리할 이벤트로 해놓는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReviewEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReviewRepository reviewRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReviewEventListener</span><span class="params">(<span class="keyword">final</span> ReviewRepository reviewRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reviewRepository = reviewRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> ProductDeletedEvent event)</span> &#123;</span><br><span class="line">        reviewRepository.deleteByProductId(event.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryProductEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryProductRepository inventoryProductRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InventoryProductEventListener</span><span class="params">(<span class="keyword">final</span> InventoryProductRepository inventoryProductRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inventoryProductRepository = inventoryProductRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> ProductDeletedEvent event)</span> &#123;</span><br><span class="line">        inventoryProductRepository.deleteByProductId(event.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>양방향 의존성을 새로운 개념의 패키지 추가하기, 이벤트 퍼블리싱 방식으로 패키지 양방향 의존을 해결했다.<br>해결한 뒤 의존성을 그려보면 다음과 같다.<br><img src="https://user-images.githubusercontent.com/87690744/225596574-c91abcb4-3a9d-460c-8d77-add194526341.png"></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링의 프록시</title>
      <link>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/</guid>
      <pubDate>Thu, 23 Feb 2023 13:01:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;프록시-패턴의-종류&quot;&gt;&lt;a href=&quot;#프록시-패턴의-종류&quot; class=&quot;headerlink&quot; title=&quot;프록시 패턴의 종류&quot;&gt;&lt;/a&gt;프록시 패턴의 종류&lt;/h1&gt;&lt;p&gt;간단하게 프록시 패턴을 어떻게 구현하는 지 간략하게 알아보자.&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="프록시-패턴의-종류"><a href="#프록시-패턴의-종류" class="headerlink" title="프록시 패턴의 종류"></a>프록시 패턴의 종류</h1><p>간단하게 프록시 패턴을 어떻게 구현하는 지 간략하게 알아보자.</p><h2 id="인터페이스-기반-프록시"><a href="#인터페이스-기반-프록시" class="headerlink" title="인터페이스 기반 프록시"></a>인터페이스 기반 프록시</h2><p>인터페이스가 있고 그 인터페이스를 구현한 구현체가 있는 상황일 때 사용한다. 그 구현체의 프록시는 인터페이스를 구현하여 만든다. 프록시는 타겟으로 구현체를 멤버 변수로 가지며 퍼블릭 메서드를 수행할 때 타겟 객체의 메서드 호출과 함께 프록시 로직을 수행한다.</p><p>클라이언트 코드에서는 인터페이스를 통해 메시지를 던지므로 이때 메시지 수신 객체가 프록시던 원래 구현체건 신경쓰지 않는다.</p><h2 id="구현체-기반-프록시"><a href="#구현체-기반-프록시" class="headerlink" title="구현체 기반 프록시"></a>구현체 기반 프록시</h2><p>인터페이스가 없고 그냥 구현체만 있을 때 사용하는 방식이다. 프록시 클래스가 구현체의 클래스를 상속하도록 하고 멤버 변수로 타겟 구현체를 가진다. 구현체의 퍼블릭 메서드를 오버라이딩 하는데, 프록시 객체의 메서드가 호출 될 때 타겟 객체의 메서드 호출과 함께 프록시 로직도 같이 수행되도록 구현한다.</p><p>클라이언트 코드에서는 구현체의 타입을 통해 메시지를 던지므로 실제 구현체의 객체나 프록시의 객체 모두 해당 메시지를 처리할 수 있게 된다.</p><h2 id="차이"><a href="#차이" class="headerlink" title="차이"></a>차이</h2><p>구현체의 종류가 확장되지 않고, 인터페이스가 굳이 없는 상황이면 구현체 기반 프록시가 낫다.<br>하지만 구현체 기반 프록시는 구현체 클래스가 final이거나 확장하려는 메서드가 final이면 프록시를 적용할 수 없다.</p><h1 id="JDK-동적-프록시"><a href="#JDK-동적-프록시" class="headerlink" title="JDK 동적 프록시"></a>JDK 동적 프록시</h1><p>프록시 객체를 동적으로 만들어주는 기술이다. JDK 동적 프록시는 인터페이스 기반 프록시이기 때문에 인터페이스가 있어야 가능하다.</p><p>JDK 동적 프록시는 프록시에 적용할 로직을 <code>InvocationHandler</code> 인터페이스를 구현해서 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(<span class="keyword">final</span> Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 프록시 로직,,,</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy begin&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 프록시 로직,,,</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리플렉션을 사용해서 호출된 메서드에 프록시 로직을 추가해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FooInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooImpl</span> <span class="keyword">implements</span> <span class="title class_">FooInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FOO~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDKProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">JDKProxyTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FooInterface</span> <span class="variable">fooRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FooImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(fooRef);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FooInterface</span> <span class="variable">proxy</span> <span class="operator">=</span>(FooInterface) Proxy.newProxyInstance(FooInterface.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FooInterface.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인터페이스가 있는 상황에서 <code>Proxy.newProxyInstance</code> 메서드를 통해 ,어떤 클래스 로더에 프록시 클래스를 둘 것인지, 어떤 인터페이스를 구현해야 하는지, 어떤 핸들러(프록시 로직)을 적용할 것인지 정한다.</p><p>생성된 프록시는 메시지를 전달받으면 <code>InvocationHandler</code> 를 호출한다. 이때 프록시 로직과 본 객체의 메서드가 실행된다.</p><p>프록시 로직은 <code>InvocationHandler</code> 하나만 만들고 프록시를 적용해야 할 대상마다 재활용하면 된다.</p><p>하지만 이 방법은 타입 캐스팅을 해줘야 하고 인터페이스가 있어야 하는 단점이 있다.</p><h1 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h1><p>바이트 코드를 조작해서 동적으로 클래스를 생성하는 기능.</p><p>JDK 동적 프록시의 <code>InvocationHandler</code> 처럼 <code>MethodInterceptor</code> 에 프록시 로직을 담아서 사용한다.</p><p>CGLIB은 상속을 통해 구현체에서 바로 프록시를 만들기 때문에 부모의 기본 생성자가 필요하고 final 클래스이면 안되며, final 메서드인 경우 프록시가 작동하지 않는다. (스프링의 <code>ProxyFactory</code> 에서 모두 해결한다)</p><p>상황에 따라 JDK 동적 프록시와 CGLIB을 활용한 프록시를 사용할 수 있다. 하지만 상황마다 일일히 관련 클래스를 구현해서 적용해야 되나? 이런 문제를 스프링의 <code>ProxyFactory</code> 가 해결할 수 있다.</p><p>스프링의 <code>ProxyFactory</code> 를 활용할 때 내부에서 CGLIB를 사용한다. 하지만 우리가 CGLIB를 직접 다루진 않는다.</p><h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><p>스프링의 프록시 팩토리는 인터페이스 유무에 따라 JDK Proxy 혹은 CGLIB을 선택해서 프록시를 생성해준다.</p><p>프록시 팩토리는 <code>InvocationHandler</code> 와 <code>MethodInterceptor</code> 를 대신하는 <code>Advice</code> 를 도입한다. 어떤 방식으로 프록시를 만들던 <code>Advice</code> 를 호출하게 되도록 구현됐다.</p><p>즉 <code>AdviceInvocationHandler</code> 와 <code>AdviceMethodInterceptor</code> 를 스프링에서 구현해서 이 객체들이 개발자가 구현한 Advice에게 프록시 로직 실행을 위임하고, Advice는 프록시 로직 수행 후 진짜 객체에게 메시지를 전달한다.</p><h2 id="Advice-구현"><a href="#Advice-구현" class="headerlink" title="Advice 구현"></a>Advice 구현</h2><p><code>org.aopalliance.intercept</code> 패키지의 <code>MethodInterceptor</code> 를 구현하는 방법이 있다. (Advice를 상속한 인터페이스)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAdvice</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;TimeProxy 실행&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">resultTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">        log.info(<span class="string">&quot;TimeProxy 종료 resultTime=&#123;&#125;ms&quot;</span>, resultTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="실행-예시"><a href="#실행-예시" class="headerlink" title="실행 예시"></a>실행 예시</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FooService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FooService</span>();</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 인터페이스가 있어도 CGLIB 방식 프록시를 쓰고 싶다면</span></span><br><span class="line">proxyFactory.setProxyFactoryClass(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> <span class="title class_">FooAdvice</span>());</span><br><span class="line"><span class="type">FooService</span> <span class="variable">proxy</span> <span class="operator">=</span> (FooService) proxyFactory.getProxy();</span><br></pre></td></tr></table></figure><h1 id="포인트컷-어드바이스-어드바이저"><a href="#포인트컷-어드바이스-어드바이저" class="headerlink" title="포인트컷, 어드바이스, 어드바이저"></a>포인트컷, 어드바이스, 어드바이저</h1><p>포인트컷 : 어디에 적용할까? (대상 여부 필터)</p><p>어드바이스 : 어떤 내용을 적용할까? (프록시 로직)</p><p>어드바이저 : 포인트컷 + 어드바이스의 조합</p><p>즉 조언자(어드바이저)는 어디에(포인트컷) 조언을(어드바이스) 적용해야 할 지 알고 있다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(Pointcut.TRUE, <span class="keyword">new</span> <span class="title class_">TimeAdvice</span>());</span><br><span class="line">proxyFactory.addAdvisor(advisor);</span><br></pre></td></tr></table></figure><p>ProxyFactory는 어드바이저를 받아서 프록시를 만든다. 어드바이스만 설정하면 항상 참으로 판단하도록 하는 포인트컷을 적용하여 어드바이저를 만든다.</p><p>ProxyFactory는 여러 어드바이스를 적용한 하나의 프록시 객체를 만들 수 있다. 여러 AOP 로직을 적용한다고 여러 프록시 객체가 만들어지는 게 아니다.</p><h2 id="여러-종류의-포인트컷"><a href="#여러-종류의-포인트컷" class="headerlink" title="여러 종류의 포인트컷"></a>여러 종류의 포인트컷</h2><p><code>PointCut</code> 인터페이스는 크게 <code>ClassFilter</code>와 <code>MethodFilter</code> 인터페이스로 필터링한다. 클래스 이름 기준으로 하거나 메서드 이름 기준으로 필터링할 때 사용된다.</p><p>스프링에서는 이런 인터페이스 기반으로 여러 포인트컷을 제공한다.</p><ul><li><code>NameMatchMethodPointcut</code> : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를<br>사용한다.</li><li><code>JdkRegexpMethodPointcut</code> : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.</li><li><code>TruePointcut</code> : 항상 참을 반환한다.</li><li><code>AnnotationMatchingPointcut</code> : 애노테이션으로 매칭한다.</li><li><code>AspectJExpressionPointcut</code> : aspectJ 표현식으로 매칭한다.</li></ul><p>여기서 제일 중요한 건 마지막 AspectJ 기반 포인트컷이다. 실무에서 제일 많이 사용한다.</p><h1 id="빈-후처리기"><a href="#빈-후처리기" class="headerlink" title="빈 후처리기"></a>빈 후처리기</h1><p>스프링의 도움으로 인터페이스 기반과 구현체 기반 신경쓰지 않고 어드바이저로 프록시를 적용할 수 있게 됐다. 하지만 여전히 <code>ProxyFactory</code>로 프록시 객체를 만들어서 빈 등록해줘야 한다. 그리고 컴포넌트 스캔으로 등록되는 빈은 이 방법을 쓸 수 없다.</p><p>이런 문제를 빈 후처리기가 해결한다.<br>빈 후처리기는 빈 객체가 생성되고 스프링 빈 저장소에 등록되기 전에 특정 작업을 실행할 수 있다. 이때 특정 작업은 등록될 객체를 조작하거나 심지어는 아예 다른 객체를 등록시켜버릴 수 있다. 즉 타겟 객체를 빈으로 생성해놓고 빈 후처리기를 통해 타겟 객체를 품고 있는 프록시 객체를 등록시켜버릴 수 있다는 의미이다.</p><p>빈 후처리기를 사용하려면 <code>BeanPostProcessor</code> 인터페이스를 구현하고 스프링 빈으로 등록하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@PostConstruct</code> 같이 초기화 전에 하거나 <code>@PostConstruct</code> 같이 초기화가 일어나고 나서 진행될 수 잇다.</p><p>반환되는 객체가 빈으로 등록된다.</p><p><code>@PostConstruct</code> 를 구현할 때도 빈 후처리기가 활용된다. <code>CommonAnnotationBeanPostProcessor</code> 를 통해 해당 어노테이션이 붙은 메서드를 호출한다.</p><p>컴포넌트 스캔으로 빈 등록되는 객체를 조작하거나 바꾸기 어려웠는데, 빈 후처리기를 통해 조작할 수 있게됐다. 빈 후처리기를 통해 빈 객체를 프록시로 바꿔서 등록할수도 있다는 의미이다!!!! 즉 설정 파일을 통해서 프록시를 하지 않고 빈 후처리기로 바꿔치기하면 된다! 이제 개발자는 프록시 관련 걱정을 안해도 되겟구나~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageLogTracePostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Advisor advisor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PackageLogTracePostProcessor</span><span class="params">(<span class="keyword">final</span> String basePackage, <span class="keyword">final</span> Advisor advisor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">        <span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, <span class="keyword">final</span> String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> bean.getClass().getPackageName();</span><br><span class="line">        <span class="keyword">if</span> (!packageName.startsWith(basePackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(bean);</span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시는 패키지 이름을 주입받아서 프록시 적용을 판단햇지만 advisor의 포인트컷으로 판단할 수 있다.</p><h1 id="스프링이-제공하는-빈-후처리기"><a href="#스프링이-제공하는-빈-후처리기" class="headerlink" title="스프링이 제공하는 빈 후처리기"></a>스프링이 제공하는 빈 후처리기</h1><p><code>spring-boot-start-aop</code> 라이브러리를 추가하고 <code>@EnableAspectJAutoProxy</code> 설정을 해주면(스프링 부트는 생략) AOP 관련 빈을 등록해준다.<br>이 과정에서 <code>AnnotationAwareAspectJAutoProxyCreator</code>라는 빈 후처리기가 스프링 빈으로 등록된다!</p><p>이 빈 후처리기는 스프링 빈으로 등록된 advisor들을 자동으로 찾아와서 프록시가 필요한 곳에 자동으로 프록시를 적용한다.(@Aspect 도 인식해서 프록시를 적용해서 AOP한다)</p><p>즉 모든 어드바이저를 가져와서 그 어드바이저 안에 있는 포인트컷을 통해 각 객체들이 프록시를 만들어야 되는지 확인하고 프록시를 만들어준다.<br>그러면 만들어진 프록시는 포인트컷에 해당하는 어드바이저들과 타겟 객체가 있겟구나! (여러 프록시를 만드는게 아니라 하나의 프록시에 여러 어드바이저를 가진다!!)</p><p>즉 스프링에서 제공하는 빈 후처리기가 프록시를 자동으로 등록해주는 과정은 다음과 같다.<br><code>빈 객체 생성 - 빈 후처리기에 전달 - 빈으로 등록된 모든 어드바이저 조회 - 포인트컷 필터링으로 프록시 객체 필요 여부 확인 - 프록시 생성 - 프록시를 빈 등록</code></p><p>이제 어드바이저만 잘 정의하면 프록시와 관련된 걱정을 하지 않고 추가 기능을 마음껏 구현할 수 있게 됐다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링의 예외 처리</title>
      <link>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/</guid>
      <pubDate>Tue, 14 Feb 2023 13:03:42 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;기본-예외-처리&quot;&gt;&lt;a href=&quot;#기본-예외-처리&quot; class=&quot;headerlink&quot; title=&quot;기본 예외 처리&quot;&gt;&lt;/a&gt;기본 예외 처리&lt;/h1&gt;&lt;p&gt;스프링은 기본적으로 예외가 발생하면 &lt;code&gt;/error&lt;/code&gt;에 매핑된 핸</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="기본-예외-처리"><a href="#기본-예외-처리" class="headerlink" title="기본 예외 처리"></a>기본 예외 처리</h1><p>스프링은 기본적으로 예외가 발생하면 <code>/error</code>에 매핑된 핸들러를 찾는다.<br>만약 <code>/error</code>에 매핑되지 않았다면 우리가 흔히 보게 되는 <code>Whitelabel Error Page</code>를 보여주게 된다.</p><h2 id="스프링-MVC의-요청-흐름"><a href="#스프링-MVC의-요청-흐름" class="headerlink" title="스프링 MVC의 요청 흐름"></a>스프링 MVC의 요청 흐름</h2><p>요청이 오면 <code>필터 -&gt; 서블릿(디스패처 서블릿) -&gt; 인터셉터 -&gt; 핸들러</code> 순으로 진행된다.<br>이때 컨트롤러에서 예외가 처리되지 않고 발생하면 <code>컨트롤러 -&gt; 인터셉터 -&gt; 서블릿(디스패처 서블릿) -&gt; 필터 -&gt; WAS(톰캣)</code> 순으로 예외가 전파된다.</p><h2 id="DispatcherServlet의-예외-처리"><a href="#DispatcherServlet의-예외-처리" class="headerlink" title="DispatcherServlet의 예외 처리"></a>DispatcherServlet의 예외 처리</h2><p>디스패처 서블릿의 application context는 <code>HandlerExceptionResolver</code>를 구현해서 처리되지 않은 예외를 인터셉트해서 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC에서는 기본적으로 세가지 예외 리졸버를 만든다.</p><ul><li><code>ExceptionHandlerExceptionResolver</code> : 핸들러나 컨트롤러 어드바이스에서 <code>@ExceptionHandler</code> 가 처리할 수 있는 예외를 처리한다.</li><li><code>ResponseStatusExceptionResolver</code> : <code>@ResponseStatus</code> 가 붙은 예외를 처리한다.</li><li><code>DefaultHandlerExceptionResolver</code> : 스프링의 기본 전략으로 예외를 처리한다.</li></ul><p>이 세가지 리졸버는 순서대로 체인되어 실행된다.</p><h1 id="서블릿에서-예외"><a href="#서블릿에서-예외" class="headerlink" title="서블릿에서 예외"></a>서블릿에서 예외</h1><p>서블릿에서는 크게 두가지 로 예외 처리를 지원한다.</p><ul><li><code>Exception</code></li><li><code>response.sendError(HTTP 상태 코드, 오류 메시지)</code></li></ul><h2 id="예외"><a href="#예외" class="headerlink" title="예외"></a>예외</h2><p>자바에서 직접 실행하는 경우, main 함수를 실행하는 main 스레드가 예외를 만나서 처리하지 못하고 main 메서드를 넘어가게 되면 예외 정보를 남기고 스레드가 종료된다.</p><p>한편 웹 어플리케이션은 요청 별로 스레드가 할당되고 서블릿 컨테이너 안에서 실행된다. 애플리케이션에서 처리하지 못한 예외는 어디로 가는걸까?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WAS(여가까지 전파) &lt;- 필터 &lt;- 서블릿 &lt;- 인터셉터 &lt;- 컨트롤러(예외 발생)</span><br></pre></td></tr></table></figure><p>WAS는 예외를 받으면 상태코드 500으로 처리한다.</p><h2 id="response-sendError-HTTP-상태-코드-오류-메시지"><a href="#response-sendError-HTTP-상태-코드-오류-메시지" class="headerlink" title="response.sendError(HTTP 상태 코드, 오류 메시지)"></a>response.sendError(HTTP 상태 코드, 오류 메시지)</h2><p>이 방식은 당장 예외가 발생한 것은 아니지만 서블릿 컨테이너에게 오류가 발생했음을 알린다.</p><p>이 메서드를 호출하면 response 객체 안에 호출 기록을 남겨두고 WAS가 이를 확인하고 예외로 인식한다.</p><h2 id="서블릿-예외-처리-오류-화면-제공"><a href="#서블릿-예외-처리-오류-화면-제공" class="headerlink" title="서블릿 예외 처리 - 오류 화면 제공"></a>서블릿 예외 처리 - 오류 화면 제공</h2><p>웹서버 팩토리커스터마이저를 통해 상태코드에 따라 주소를 매핑하고, WAS는 상태 코드가 응답하면 매핑된 주소로 진짜 요청을 다시 날린다! WAS가 날린 요청을 처리하기 위해 컨트롤러를 통해 예외 처리된 화면을 보여 줄 수 있다.</p><p>여기서 중요한 점은 WAS가 다시 요청을 날릴 때 필터 → 서블릿 → 인터셉터 를 다 거친다는 사실이다.<br>WAS가 다시 요청을 보낼 때는 요청 객체에 예외 관련 정보를 담아서 요청을 보낸다.</p><h3 id="필터"><a href="#필터" class="headerlink" title="필터"></a>필터</h3><p>서블릿은 <code>DispatcherType</code> 을 통해 지금 보낸 요청이 고객이 요청한 것인지 WAS가 에러로 인한 내부 호출한 내용인지 파악하는데 도움을 준다. 그래서 필터가 인증 인가 같은 로직을 예외 처리를 위한 요청에서 적용하지 않고 넘길 수 있게 된다. (필터의 기본 디스패처타입이 REQUEST라서 적용되지 않는다. 만약 예외 처리 요청을 위한 필터를 만들려면 디스패처 타입을 ERROR로 설정해주면 된다.)</p><h3 id="인터셉터"><a href="#인터셉터" class="headerlink" title="인터셉터"></a>인터셉터</h3><p>예외가 발생하는 요청인 경우, postHandle 메서드가 작동하지 않고 afterCompletion 만 작동한다. 하지만 WAS가 예외 처리를 위해 내부 요청을 보내는  경우는 해당 요청 자체는 예외가 발생하지 않으므로 postHandle도 잘 작동한다.</p><h1 id="스프링-부트의-예외-처리"><a href="#스프링-부트의-예외-처리" class="headerlink" title="스프링 부트의 예외 처리"></a>스프링 부트의 예외 처리</h1><p>서블릿은 귀찮게 경로를 정해주고 그 경로에 맞는 컨트롤러를 만들어줘야 했다.</p><p>스프링 부트는 <code>/error</code> 를 기본으로 에러 페이지를 설정한다. 그리고 <code>BasicErrorController</code> 라는 스프링 컨트롤러를 자동으로 등록한다. 이 일을 <code>ErrorMvcAutoConfiguration</code> 이라는 클래스가 자동으로 등록해준다.</p><p>컨트롤러는 <code>resources/tempalte/error</code> 디렉토리에서 <code>5xx.html, 400.html</code> 와 같은 이름의 파일을 상태코드에 매핑해서 뷰를 보여준다. 그리고 모델로 에러 상황과 관련된 데이터를 전달한다.</p><p>만약 컨트롤러 로직을 확장하고 싶으면 기존의 <code>BasicErrorController</code> 를 상속해서 오버라이딩하면 된다.</p><h1 id="API-예외-처리"><a href="#API-예외-처리" class="headerlink" title="API 예외 처리"></a>API 예외 처리</h1><h2 id="서블릿의-API-예외-처리"><a href="#서블릿의-API-예외-처리" class="headerlink" title="서블릿의 API 예외 처리"></a>서블릿의 API 예외 처리</h2><p>WAS가 예외를 감지하고 내부에서 다시 보낸 요청을 처리하는 컨트롤러에서 HTTP header의 accept를 json으로 해주고 <code>ResponseEntity</code> 를 반환하도록 하면 JSON으로 변환 되서 반환된다.</p><h2 id="스프링-부트의-API-예외-처리"><a href="#스프링-부트의-API-예외-처리" class="headerlink" title="스프링 부트의 API 예외 처리"></a>스프링 부트의 API 예외 처리</h2><p>스프링 부트는 기본적으로 accept를 어떻게 하냐에 따라 JSON을 알아서 반환해줄 수도, 뷰를 반환해줄 수도 있다.</p><h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><p>WAS까지 예외가 전달되면 500으로 처리한다. 이를 바꾸고 싶으면 <code>HandlerExceptionResolver</code>를 사용하자.</p><p><code>HandlerExceptionResolver</code> 가 디스패처 서블릿에 등록되면 디스패처 서블릿에 전달된 예외를 잡아서 <code>response.sendError(status code)</code> 를 호출하고 빈 <code>ModelAndView</code> 을 반환한다. 즉 WAS까지 안가고 요청도 다시 보내지 않는다.</p><p>여기서 빈 <code>ModelAndView</code> 를 반환하면 예외가 처리되고 정상 흐름으로 진행되고 <code>ModelAndView</code>  가 지정되어서 반환되면 해당 내용으로 뷰를 렌더링한다. null을 반환하면 다음 리졸버를 찾는다. 만약 맞는 리졸버가 없으면 WAS까지 예외가 전파된다.</p><h3 id="스프링이-제공하는-ExceptionResolver"><a href="#스프링이-제공하는-ExceptionResolver" class="headerlink" title="스프링이 제공하는 ExceptionResolver"></a>스프링이 제공하는 ExceptionResolver</h3><ol><li>ExceptionHandlerExceptionHandler<ol><li>특정 컨트롤러에서 발생한 예외를 <code>@ExceptionHandler</code> 로 처리.</li><li>참고로 파라미터로 받는 예외를 통해 어떤 예외를 처리할지 선언하는 역할도 한다.</li></ol></li><li>ResponseStatusExceptionHandler<ol><li><code>@ResponseStatus</code> 가 붙은 경우</li><li><code>ResponseStatusException</code> 이 발생시켜서 이미 존재하는 예외를 처리</li></ol></li><li>DefaultHandlerExceptionResolver<ol><li>스프링 내부에서 발생하는 예외를 적절한 상태코드로 처리</li></ol></li></ol><p>1~3까지 해결이 안되면 다음으로 넘기는 방식.</p><h3 id="ControllerAdvice-RestControllerAdvice"><a href="#ControllerAdvice-RestControllerAdvice" class="headerlink" title="@ControllerAdvice, @RestControllerAdvice"></a>@ControllerAdvice, @RestControllerAdvice</h3><p>대상이 되는 여러 컨트롤러에 <code>@InitBinder</code>, <code>@ExceptionHandler</code>  기능을 부여하는 역할을 한다.</p><p>대상을 지정안하는 경우 모든 컨트롤러에 적용된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우테코 수료 이후 새로운 프로젝트 준비까지 회고</title>
      <link>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/</guid>
      <pubDate>Sat, 11 Feb 2023 12:43:04 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;실패-그리고-반성&quot;&gt;&lt;a href=&quot;#실패-그리고-반성&quot; class=&quot;headerlink&quot; title=&quot;실패 그리고 반성&quot;&gt;&lt;/a&gt;실패 그리고 반성&lt;/h1&gt;&lt;p&gt;우아한테크코스가 끝난 뒤 본 면접들에서 모두 떨어졌다. 이유를 정확히 알 수</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="실패-그리고-반성"><a href="#실패-그리고-반성" class="headerlink" title="실패 그리고 반성"></a>실패 그리고 반성</h1><p>우아한테크코스가 끝난 뒤 본 면접들에서 모두 떨어졌다. 이유를 정확히 알 수 없지만 내가 느끼기에는 여러가지 아쉬움이 있었다. 먼저 빠르고 정확하게 학습하는 습관을 만들지 못했다. 우아한테크코스를 하면서 주위 사람들이 공부하는 내용을 따라가기 급급했다. 원하는 지식이 무엇인지 차분히 고민하고, 집중해서 빠르고 정확하게 학습해야 하지 않았나 싶다. 시간 관리도 부족했다. 우아한테크코스에서 팀 프로젝트를 할 때 내 일정을 팀에서 주어지는 업무에 맞춰서 수동적으로 그리고 아무 시간 관리 전략 없이 막무가내로 시간을 보냈다.</p><h1 id="시간-관리하기"><a href="#시간-관리하기" class="headerlink" title="시간 관리하기"></a>시간 관리하기</h1><p>떨어지고 나서 먼저 나만의 시간 관리 시스템을 만들었다. 우아한테크코스 특강 중 칸반으로 자신의 일정을 관리하는 현업자 분의 이야기가 떠올랐다. 그 특강을 들을 당시 잠깐 해볼까 했지만 공부하느라 정신이 없어서 포기했었다. 새로 처음부터 다시 시작하려는 지금이 이런 시간 관리 방법을 고민하기 적절하다고 생각했다.</p><p>시간 관리는 노션의 칸반 보드로 구현했다. 대략 <code>백로그</code>-<code>이번주 할 일</code>-<code>오늘 할 일</code>-<code>하고 있는 일</code>-<code>대기 중인 일</code>-<code>다한 일</code> 이렇게 나눴다. 처음에는 매우 간단하게 시작했는데 시간 관리를 해보면서 내 목표와 맞게 추가하다 보니 단계가 늘었다.</p><p>칸반을 하면서 좋았던 점은 칸반에 할 일을 추가하는 과정에서 계획이 들어가고 그 계획이 시각화되어서 체감이 잘된다. 그리고 하나하나 일을 완료로 옮길 때마다 성취감을 느낄 수 있었다.</p><h2 id="단계-별로-계획하기"><a href="#단계-별로-계획하기" class="headerlink" title="단계 별로 계획하기"></a>단계 별로 계획하기</h2><p>나는 6개월 이후 취업을 목표로 칸반으로 시간 관리를 한다. 그렇기에 정해진 기간 안에 목표를 이루기 위해 남은 시간을 쪼개서 각 목표를 두고 학습해야 했다. 일단 6개월은 각 6개의 달로 나눌 수 있고, 하나의 달은 여러 주로 나눌 수 있다. 나는 먼저 내가 가고 싶은 기업의 2~3년차 경력직의 필요요건을 찾아서 대략 각 달마다 나눠서 할당했다. 물론 나에게 벅찰 수 있지만, 높은 목표를 설정하고 실행하는 과정에서 조정하면 된다고 판단했다. 그리고 각 달의 목표를 이루기 위해서 그 목표를 구체적인 여러 행동으로 나눠서 매 주마다 할당했다. 그래서 이번 주에 할당된 일은 칸반에서 <code>이번주 할 일</code>에서 시각화 된다. 마지막으로 한 주의 할일은 하루씩 나눠져서 실행된다. 이 내용은 칸반에서 <code>오늘 할 일</code>에서 시각화된다.</p><h1 id="새로운-프로젝트"><a href="#새로운-프로젝트" class="headerlink" title="새로운 프로젝트"></a>새로운 프로젝트</h1><p>나는 면접 탈락 이후 갈 곳이 있다. 썩 달갑지는 않지만 아직 학교를 한 학기를 다녀야 한다. 그래서 학교에서 어떤 수업을 들어야 하나 고민했다. CS 과목을 들을까? 사실 우아한테크코스 이전엔 네트워크와 데이터베이스 수업을 들었다. 학점도 각각 A+를 받았다. 그러나 이 경험이 취업에 큰 도움이 되지는 않았다. 차라리 혼자 공부하거나 스터디를 하는 게 더 유익하다고 판단했다. 그러면 비대면 꿀강의를 찾아서 신청할까? 일단 꿀강의 수강 신청에 실패하면 리스크가 크다. 그리고 꿀강의라고 해서 레포트나 퀴즈같은 성가신 일을 피할 순 없다.<br>마지막으로 남은 선택지는 프로젝트. 우리 학교는 참빛 설계학기라는 제도를 운영한다. 이 제도는 학생들이 주제를 자유롭게 정해서 지도 교수를 섭외해서 한 학기동안 진행하는 제도이다. 학점도 유연하게 받을 수 있고 지원금이 100만원(!)이나 된다! 프로젝트를 하기로 했다!</p><h2 id="프로젝트를-하면서-어려웠던-점"><a href="#프로젝트를-하면서-어려웠던-점" class="headerlink" title="프로젝트를 하면서 어려웠던 점"></a>프로젝트를 하면서 어려웠던 점</h2><p>프로젝트 주제는 학교 기자재 대여 웹 서비스 만들기이다. 대여 내역을 수기로 써서 관리하고 이 내용을 네이버 카페에 관리자들이 다시 전산화하는 불편한 방식을 개선하고자 한다.<br>애자일 방식으로 개발을 진행하려 할 때 어려운 점이 드러났다. 먼저 2주를 스프린트 기간이라고 하면, 그 주간안에 의미있는 소프트웨어 결과물이 나와야 한다. 우리팀은 기획 1명 프론트 2, 백엔드 1로 구성됐다. 한 스프린트 안에서 기능 계획, UX 레이아웃, API 설계 등 각자 작업을 하기전에 먼저 선행되어야 하는 작업이 있다. 그래서 그 작업이 되기 전까지는 개발이 되지 못한다. 이 경우 실질적인 개발 기간이 줄어드는데 이런 상황이 괜찮은 건지 고민된다.<br>그리고 기능을 계획하는 과정에서도 어려움이 있었다. 에픽을 선정하는 과정이 어려웠다. 스토리는 직관적이라 가능했는데, 이를 에픽으로 어떤 기준으로 묶어야 하는지가 어려웠다. 그래서 일단 첫 스프린트는 스토리의 동사에서 에픽을 추출해서 묶기로 했다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링과 JPA 환경에서 동시성 문제 해결하기</title>
      <link>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/</guid>
      <pubDate>Fri, 10 Feb 2023 12:50:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;동시성-문제&quot;&gt;&lt;a href=&quot;#동시성-문제&quot; class=&quot;headerlink&quot; title=&quot;동시성 문제&quot;&gt;&lt;/a&gt;동시성 문제&lt;/h1&gt;&lt;p&gt;동시성 문제는 공유 자원을 여러 스레드가 수정할 때 공유 자원의 일관성이 깨지는 상황을 말한다. </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="동시성-문제"><a href="#동시성-문제" class="headerlink" title="동시성 문제"></a>동시성 문제</h1><p>동시성 문제는 공유 자원을 여러 스레드가 수정할 때 공유 자원의 일관성이 깨지는 상황을 말한다. 예를 들어 내 계좌에 1000원을 두 스레드가 동시에 입금하려고 한다고 가정해보자.</p><p>병렬로 스레드가 작업을 수행하고 위에서 부터 시간순으로 진행됨을 나타낸다.<br>스레드 A가 남은 금액 조회 : 0원<br>스레드 B가 남은 금액 조회 : 0원<br>스레드 A가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)<br>스레드 B가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)<br>스레드 A가 커밋하면서 금액을 1000원으로 업데이트 : 1000원<br>스레드 B가 커밋하면서 금액을 1000원으로 업데이트 : 1000원(어라? 1000원을 두 스레드가 입금하면 2000원이 되어야 한다!!!!)</p><p>위 예시를 보면 알 수 있듯이 공유 자원드 아무 제약 없이 조회(획득)해서 각자 작업을 하고 업데이트 하는 경우 예상하지 못한 결과가 나올 수 있다.</p><h1 id="예시-코드"><a href="#예시-코드" class="headerlink" title="예시 코드"></a>예시 코드</h1><p>먼저 도메인 엔티티는 간략하게 포인트 하나만 둔다. 이 포인트 객체는 사용자의 포인트 누적액과 포인트 적립과 사용에 쓰이는 바코드를 포함한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">val</span> barcode: String,</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그리고 바코드에 해당하는 포인트 객체를 조회하는 메서드를 포함한 레포지토리 코드이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcode</span><span class="params">(barcode: <span class="type">String</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 서비스 코드이다. (주입받는 부분은 생략하고 메서드만 표기했다.)<br>이해를 위해 매우 간략하게 구현된 점을 이해하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUp</span><span class="params">(shopId: <span class="type">Long</span>, barcode: <span class="type">String</span>, amount: <span class="type">Long</span>)</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">val</span> point = pointRepository.findByBarcode(barcode)</span><br><span class="line">        .orElseGet &#123; pointRepository.save(Point(<span class="number">0</span>, barcode)) &#125; <span class="comment">// 기존의 바코드가 존재하지 않으면 새 객체를 만들어서 영속화한다.</span></span><br><span class="line">    point.amount += amount</span><br><span class="line">    <span class="keyword">return</span> point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이를 테스트 하기 위해 테스트 메서드를 만들어보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="string">&quot;포인트 적립 동시성 문제 검증&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUp_concurrency</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> threadCount = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> executorService = Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> countDownLatch = CountDownLatch(threadCount)</span><br><span class="line">    <span class="keyword">val</span> barcodeValue = <span class="string">&quot;1234567890&quot;</span></span><br><span class="line">    callSaveUp(<span class="number">1</span>, barcodeValue) <span class="comment">//적립할 양과 바코드를 받아 적립하는 메서드이다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.threadCount) &#123;</span><br><span class="line">        executorService.submit &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callSaveUpAPI( <span class="number">1</span>, barcodeValue)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await()</span><br><span class="line">    <span class="keyword">val</span> point = pointRepository.findByBarcode(barcodeValue)</span><br><span class="line">        .orElseThrow()</span><br><span class="line">    assertThat(point.amount).isEqualTo((threadCount + <span class="number">1</span>).toLong())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CountDownRatch?<br>CountDownRatch는 어떤 스레드가 다른 스레드에서 작업이 완료될 때까지 기다릴 수 있도록 해주는 클래스다. 위 예시에서는 작업을 하는 스레드들이 완료될 때마다 countDown을 해서 모든 스레드들이 작업을 마칠 때까지 await하도록 구현했다.</p></blockquote><h1 id="synchronized-키워드"><a href="#synchronized-키워드" class="headerlink" title="synchronized 키워드"></a>synchronized 키워드</h1><p>먼저 자바 및 코틀린에서 쉽게 생각할 수 있는 synchronized 키워드를 사용할 수 있다. 미리 말하자면, 이 방법은 확장성에 좋지않고 스프링에서는 고려해야할 부분이 있다.</p><ol><li>확정성에 좋지 않은 이유.<br>synchronized는 해당 어플리케이션 안에서만 유효하다. 즉 여러 서버를 운영하게 되면 여러 어플리케이션이 요청을 처리하게 되는데, 자신이 아닌 다른 어플리케이션의 요청은 제어할 수 없게된다.</li><li>스프링에서 고려해야 하는 부분. <code>@Transactional</code><br>일반적으로 서비스 계층에서 <code>@Transactional</code>을 사용해서 각 요청에 트랜잭션을 적용한다. 하지만 스프링은 트랜잭션을 프록시로 처리하게 된다. 즉 원래 메서드를 감싼 외부 메서드가 존재하게 된다. 업데이트는 트랜잭션 종료 시 실행되는데 스프링에서는 원래 메서드가 종료되면 외부 메서드에서 트랜잭션 종료 처리릃 하게 된다. 즉 값의 반영이 되지 않은 시점에서 다른 스레드가 원래 메서드를 통해 반영되지 않은 값을 조회할 수 있다.</li></ol><h1 id="Database에서-해결하기"><a href="#Database에서-해결하기" class="headerlink" title="Database에서 해결하기"></a>Database에서 해결하기</h1><p>데이터베이스의 Lock을 활용해서 해결할 수 있다.</p><h2 id="낙관적-락"><a href="#낙관적-락" class="headerlink" title="낙관적 락"></a>낙관적 락</h2><p>낙관적 락은 서비스 특성 상 동시성 문제가 발생할 경우가 적은 상황에서 사용한다. 실제로는 락을 사용한다기 보다는 수정 시점을 기록하는 칼럼(버전)을 통해 동시성 문제를 일으키는 쿼리를 감지하는 방식이다.</p><p>엔티티에 버전을 기록하는 칼럼을 추가하고, 조회했을 때 버전과 값을 변경해서 반영할 때의 버전이 같아야 반영하고 버전을 +1하는 방식이다. </p><p>가령 여러 스레드가 동시에 하나의 데이터를 조회해서 값을 변경하고 반영하려고 한다면, 모두 다 버전이 1인 상황에서 값을 반영하려고 할 것이고, 먼저 하나의 스레드가 반영이 되어서 버전이 2가 되어버리면 그 외 버전 1인 업데이트 쿼리가 모두 반영되지 않도록 막는다.</p><h3 id="코드로-살펴보기"><a href="#코드로-살펴보기" class="headerlink" title="코드로 살펴보기"></a>코드로 살펴보기</h3><p>먼저 도메인 엔티티에 버전을 추가해주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">val</span> barcode: String,</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그리고 레포지토리 메서드에서 <code>@Lock</code> 어노테이션만 추가해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Lock(LockModeType.OPTIMISTIC)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcodeAndShopSector</span><span class="params">(barcode: <span class="type">String</span>, shopSector: <span class="type">ShopSector</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 추가로 낙관적 락은 동시성이 우려된 경우 예외를 발생한다는 사실을 알아두자. 즉 서비스 단에서 예외가 발생한 경우 재시도하는 코드를 추가해야 테스트 코드가 통과 될 것이다!</p><h2 id="비관적-락"><a href="#비관적-락" class="headerlink" title="비관적 락"></a>비관적 락</h2><p>비관적 락은 모든 시도가 동시성 문제를 일으킬 수 있을 경우 사용한다. DB에서 락을 획득해서 다른 스레드가 자원을 접근하지 못하거나 수정을 막는 방식이다. 구현하는 방법은 매우 간단하다. 레포지토리에서 <code>@Lock</code>의 인자를 다르게 해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointRepository</span>: <span class="type">JpaRepository</span>&lt;<span class="type">Point, String</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Lock(LockModeType.PESSIMISTIC_WRITE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByBarcode</span><span class="params">(barcode: <span class="type">String</span>)</span></span>: Optional&lt;Point&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>락과 트랜잭션<br>락은 반드시 트랜잭션이 존재할 때만 가능하다. 만약 레포지토리 메서드를 트랜잭션이 아닌 환경에서 실행하면 예외가 발생한다.</p></blockquote><blockquote><p>추가로 더 알아보기</p></blockquote><p>네임드락, 레디스를 활용해서 비슷한 문제를 해결할 수 있다. 코드는 강의 자바 코드이다.</p><h2 id="네임드락"><a href="#네임드락" class="headerlink" title="네임드락"></a>네임드락</h2><p>네임드락은 이름을 가진 메타데이터 락이다. 네임드락은 글로벌 락이라서 이미 한 세션이 A라는 이름의 네임드락을 가지고 있다면 다른 세션들은 같은 이름의 네임드락을 얻지 못한다. 여러 서버들의 동기화를 구현할 때 사용된다.<br>하지만 네임드락은 정해진 시간이 다 지나거나 락을 해제하는 명령어를 실행해야 락이 풀리고 다른 세션에서 접근할 수 있게되므로 사용에 각별한 주의를 해야 한다.<br>그리고 실무에서는 네임드락은 데이터소스를 따로 분리해서 적용하는 걸 추천한다. 커넥션이 부족해질 수 있기 때문이다.</p><h3 id="레포지토리"><a href="#레포지토리" class="headerlink" title="레포지토리"></a>레포지토리</h3><p>일단 이번 예제에서는 하나의 데이터소스로 해보자. MySQL 네이티브 쿼리로 <code>get_lock</code>과 <code>release_lock</code> 함수로 네임드락을 획득하고 해제할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LockRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Stock, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;select get_lock(:key, 3000)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getLock</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;select release_lock(:key)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>레포지토리를 주입받아서 서비스 로직이 실행되기 전에 락을 얻고 서비스 로직이 끝나면 락을 반납하는 방식으로 구현하면 된다.<br>네임드락은 데이터소스와 락 직접 해지, 그리고 트랜잭션 주기가 달라지는 부분이 있으므로 주의해서 사용하자.</p><h1 id="레디스를-활용하기"><a href="#레디스를-활용하기" class="headerlink" title="레디스를 활용하기"></a>레디스를 활용하기</h1><p>레디스는 lettuce를 활용하는 방법과 redisson을 활용하는 방법 두가지가 있다.</p><h2 id="lettuce-사용"><a href="#lettuce-사용" class="headerlink" title="lettuce 사용"></a>lettuce 사용</h2><p>lettuce는 네임드락과 매우 비슷하다. 키와 밸류를 가지고 특정 세션이 키와 밸류를 레디스에 저장하고 나면 다른 세션은 그 키가 존재하는 한 접근하지 못하는 방식이다.</p><h3 id="레포지토리-구현"><a href="#레포지토리-구현" class="headerlink" title="레포지토리 구현"></a>레포지토리 구현</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisRepository</span><span class="params">(<span class="keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">lock</span><span class="params">(Long key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate</span><br><span class="line">                .opsForValue()</span><br><span class="line">                .setIfAbsent(generateKey(key), <span class="string">&quot;lock&quot;</span>, Duration.ofMillis(<span class="number">3_000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">unlock</span><span class="params">(Long key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(generateKey(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">generateKey</span><span class="params">(<span class="keyword">final</span> Long key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 lettuce 방식은 락 획득이 실패하면 스핀락으로 재시도를 하기 때문에 만약 락 획득이 실패하는 경우 잠깐 기다리는 로직을 추가로 구현해주자.</p><h2 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h2><p>레디슨은 다른 세션들이 계속 락을 얻기 위해 시도하는게 아니라 락이 해제가 되면 채널을 통해 기다리던 세션들에게 알리는 방식이다.(pub-sub) 그래서 비용이 적게 든다. 하지만 별도의 라이브러리를 추가해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonStockFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonStockFacade</span><span class="params">(<span class="keyword">final</span> RedissonClient redissonClient, <span class="keyword">final</span> StockService stockService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redissonClient = redissonClient;</span><br><span class="line">        <span class="built_in">this</span>.stockService = stockService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Long quantity)</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(id.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> rLock.tryLock(<span class="number">5</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!available) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Lock 획득 실패&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stockService.decrease(id, quantity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서로 연관관계가 없는 엔티티를 DTO로 조회하기</title>
      <link>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/</guid>
      <pubDate>Thu, 09 Feb 2023 07:32:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제-상황&quot;&gt;&lt;a href=&quot;#문제-상황&quot; class=&quot;headerlink&quot; title=&quot;문제 상황&quot;&gt;&lt;/a&gt;문제 상황&lt;/h1&gt;&lt;p&gt;전세계의 프로 축구 선수를 관리하는 시스템을 만든다고 가정하자. 이 시스템에는 나라, 리그, 선수 이렇게</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h1><p>전세계의 프로 축구 선수를 관리하는 시스템을 만든다고 가정하자. 이 시스템에는 나라, 리그, 선수 이렇게 세가지 엔티티가 있다. 이 세 엔티티 모두 직접 참조는 되어 있지 않은 상태로 모두 물리적인 연관관계는 없다. 다만 리그가 나라를 id로 간접 참조하고, 선수가 리그를 id로 간접 참조하고 있다고 하자. 그렇다면 코드는 다음과 같을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Nation</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Nation</span><span class="params">(<span class="keyword">final</span> String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">League</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> Long nationId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">League</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">League</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Long nationId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nationId = nationId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long leagueId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Player</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티가 이런 상황에서 특정 국가에서 뛰고 있는 모든 선수의 이름, 그 선수의 소속 리그 이름, 그 선수 소속 리그의 국가 이름을 조회하려고 한다. 물리적인 관계가 있다면 JPQL fetch join으로 모든 엔티티의 정보를 가져와서 DTO에 매핑하는 방법을 사용할 수 있다. 하지만 간접 참조로 fetch join으로 최적화가 안된다. 이 문제를 해결하기 위해서는 일단 두 단계로 문제를 쪼개보자.</p><ol><li>일단 원하는 정보가 여러 테이블에 흩어져 있기 때문에 이를 모아서 조회해야 한다. 즉 조인을 활용해야 한다.</li><li>조인 한 결과물을 담을 수 있는 객체가 필요하다. 우리의 문제 상황에서는 조회된 결과물이 한 엔티티에 담을 수 없기 때문에 DTO를 만들어서 담을 것이다.</li></ol><h1 id="JPQL에서-연관-관계가-없는-엔티티-조인하기"><a href="#JPQL에서-연관-관계가-없는-엔티티-조인하기" class="headerlink" title="JPQL에서 연관 관계가 없는 엔티티 조인하기"></a>JPQL에서 연관 관계가 없는 엔티티 조인하기</h1><p>사실 SQL과 매우 비슷하다. <code>join &#123;엔티티&#125; on &#123;조건&#125;</code> 이런 형태로 조인을 해주면 된다. 우리의 사레를 JQPL로 표현하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select &#123;나중에 만들 DTO&#125;</span></span><br><span class="line"><span class="meta">                 from Player p</span></span><br><span class="line"><span class="meta">                 join League l on p.leagueId = l.id</span></span><br><span class="line"><span class="meta">                 join Nation n on n.id = l.nationId</span></span><br><span class="line"><span class="meta">                 where n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p>위의 예시는 각 조인을 명시적으로 표현해줬다. 하지만 조인을 명시적으로 표현하지 않아도 from 절에 명시하고 where 절에서 조인 조건을 명시해도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select &#123;나중에 만들 DTO&#125;</span></span><br><span class="line"><span class="meta">                 from Player p, League l, Nation n</span></span><br><span class="line"><span class="meta">                 where p.leagueId = l.id and n.id = l.nationId and n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><h2 id="조인-종류"><a href="#조인-종류" class="headerlink" title="조인 종류"></a>조인 종류</h2><p>여기서 잠깐 JPQL의 조인 종류에 대해서 알아보자. 왜냐면 LEFT JOIN에 대해 잘 모르고 사용했다가 잘못된 테스트임에도 테스트가 통과되고 있었다.<br>일단 조인은 여러 테이블을 하나의 테이블로 합치는 행동이다. 이때 합칠 때 특정 조건을 걸어서 우리가 원하는 결과물만 받을 수 있게 된다.<br>조인의 종류는 이때 중요해지는데, 조인의 종류에 따라 결과물이 달라지기 때문이다.</p><p>먼저 INNER JOIN. 이 경우 두 테이블을 합칠 때 조인 조건이 맞는 데이터만 가져와서 합친다.<br>INNER JOIN이 아닌 LEFT JOIN, RIGHT JOIN, OUTER JOIN은 조인 조건을 만족하지 않는 데이터도 결과에 포함된다.<br>LEFT JOIN은 조인 조건에 맞는 데이터 + 왼쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 왼쪽 테이블의 모든 데이터가 결과값으로 반환된다.)<br>RIGHT JOIN은 조인 조건에 맞는 데이터 + 오른쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 오른쪽 테이블의 모든 데이터가 결과값에 포함된다.)<br>OUTER JOIN은 조인 조건에 맞는 데이터를 제외한 왼쪽 테이블과 오른쪽 테이블의 모든 데이터를 결과값을 보여준다. (즉 INNER JOIN의 여집합이겠다.)</p><h3 id="JPQL에서-조인"><a href="#JPQL에서-조인" class="headerlink" title="JPQL에서 조인"></a>JPQL에서 조인</h3><p>JPQL에서는 위에서 언급한 INNER, LEFT JOIN을 지원한다. (RIGHT JOIN은 지원하지 않으므로 두 테이블의 적용 위치를 바꿔서 LEFT JOIN으로 하면 동일한 결과를 얻을 수 있다.)<br>그리고 FETCH JOIN이라는 것을 지원한다. FETCH JOIN은 연관관계가 있는 엔티티가 Lazy Loading일 때 쿼리 한번에 연관된 객체를 같이 조회해서 가져오는 방법이다. 연관관계가 있는 엔티티를 조회하는 경우 매우 중요한 개념이지만 현재는 연관관계가 없는 엔티티 조회하는 상황이므로 넘어가겠다.</p><h1 id="결과값을-DTO로-받기"><a href="#결과값을-DTO로-받기" class="headerlink" title="결과값을 DTO로 받기"></a>결과값을 DTO로 받기</h1><p>JQPL에서 결과값을 DTO로 받으려면 다음과 같다. <code>SELECT new &#123;패키지&#125;.&#123;DTO 클래스&#125;(...생성자...)</code> 이를 적용한 코드는 다음과 같다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">                select new com.example.jointest.blogging.PlayerDto(p.id, p.name, l.name, n.name)</span></span><br><span class="line"><span class="meta">                 from Player p, League l, Nation n</span></span><br><span class="line"><span class="meta">                 where p.leagueId = l.id and n.id = l.nationId </span></span><br><span class="line"><span class="meta">                 and n.name = :name</span></span><br><span class="line"><span class="meta">                &quot;&quot;&quot;)</span></span><br><span class="line">List&lt;PlayerDto&gt; <span class="title function_">findDtoByNation</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p>JPQL에서 엔티티나 값 객체가 아닌 (<code>@Entity</code>나 <code>@Embeddable</code>이 안붙은 클래스) 경우는 이렇게 패키지 명을 써줘야 해서 매우 코드가 불편한 게 단점이다.<br>그래서 QueryDSL을 활용하면 더 깔끔한 코드를 작성할 수 있게 된다!!! 나중에 QueryDSL로 더 개선해보자!!</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/jpa/">JPA</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>애노테이션과 리플렉션</title>
      <link>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/</guid>
      <pubDate>Sun, 05 Feb 2023 06:51:34 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;애노테이션-선언과-사용&quot;&gt;&lt;a href=&quot;#애노테이션-선언과-사용&quot; class=&quot;headerlink&quot; title=&quot;애노테이션 선언과 사용&quot;&gt;&lt;/a&gt;애노테이션 선언과 사용&lt;/h1&gt;&lt;h2 id=&quot;애노테이션-적용&quot;&gt;&lt;a href=&quot;#애노테이션</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="애노테이션-선언과-사용"><a href="#애노테이션-선언과-사용" class="headerlink" title="애노테이션 선언과 사용"></a>애노테이션 선언과 사용</h1><h2 id="애노테이션-적용"><a href="#애노테이션-적용" class="headerlink" title="애노테이션 적용"></a>애노테이션 적용</h2><p>코틀린 애노테이션 적용은 자바와 매우 비슷하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated(<span class="meta-string">&quot;Use removeAt(index) instead&quot;</span>, ReplaceWith(<span class="meta-string">&quot;removeAt(index)&quot;</span>)</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>애노테이션에 인자로는 원시 타입 값, 문자열, enum, 클래스 참조, 다른 어노테이션 클래스, 마지막으로 앞서 말한 요소의 배열을 전달해줄 수 있다.<br>다만 인자를 전달할 때는 자바와 다른 점이 있다.</p><ul><li>클래스를 인자로 전달할 때 <code>::class</code>로 전달한다</li><li>어노테이션 인자로 다른 어노테이션을 전달할 때는 <code>@</code>를 빼고 전달한다.</li><li>배열을 인자로 전달하려면 <code>arrayOf</code> 함수를 사용한다. 다만 가변인자로 전달할 때는 그러지 않아도 된다.</li></ul><p>어노테이션 인자를 컴파일 시점에서 알아야 한다. 따라서 어노테이션 인자로 프로퍼티를 전달할 때 임시 프로퍼티나 일반 프로퍼티는 사용하지 못한다. const가 붙은 프로퍼티를 인자로 전달할 수 있다.</p><h2 id="어노테이션-대상"><a href="#어노테이션-대상" class="headerlink" title="어노테이션 대상"></a>어노테이션 대상</h2><p>사용 지점 대상 선언으로 어노테이션을 붙일 요소를 정할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Rule</span></span><br></pre></td></tr></table></figure><p>위 예시를 보면 앞에 사용 지점 대상을 적고 콜론으로 어노테이션 이름적는다. 이런 방식으로 getter 메서드에 어노테이션을 적용해야 되는 경우를 프로퍼티를 통해 적용할 수 있다.</p><h3 id="사용-지점-대상-목록"><a href="#사용-지점-대상-목록" class="headerlink" title="사용 지점 대상 목록"></a>사용 지점 대상 목록</h3><ul><li>property : 프로퍼티 전체.</li><li>field ; 프로퍼티에 생성되는 필드(뒷받침하는 경우도 포함)</li><li>get : 프로퍼티 게터</li><li>set : 프로퍼티 세터</li><li>receiver : 확장 함수나 프로퍼티의 수신 객체 파라미터</li><li>param : 생성자 파라미터</li><li>setparam : 세터 파라미터</li><li>delegate : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드</li><li>file : 파일 안에 선언된 최상위 함수와 프로퍼티를 담아둔 클래스</li></ul><h2 id="어노테이션-선언"><a href="#어노테이션-선언" class="headerlink" title="어노테이션 선언"></a>어노테이션 선언</h2><p>객체를 직렬화하는 제이키드 라이브러리의 어노테이션을 예제로 어노테이션 선언에 대해 알아본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExclude</span></span></span><br></pre></td></tr></table></figure><p>어노테이션 클래스는 오직 메타데이터의 구조를 정의하기 때문에 내부에 아무 코드도 들어있을 수 없다.</p><p>파라미터가 있는 어노테이션은 주 생성자를 통해 파라미터를 정의한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonName</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>이를 자바 어노테이션 선언과 비교하면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메타어노테이션-어노테이션을-처리하는-방법-제어"><a href="#메타어노테이션-어노테이션을-처리하는-방법-제어" class="headerlink" title="메타어노테이션: 어노테이션을 처리하는 방법 제어"></a>메타어노테이션: 어노테이션을 처리하는 방법 제어</h2><p>어노테이션 클래스에 적용할 수 있는 어노테이션을 메타어노테이션이라고 부른다.<br>표준 라이브러리에 있는 메타어노테이션 중 가장 흔히 쓰이는 메타어노테이션은 <code>@Target</code>이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.PROPERTY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExclude</span></span></span><br></pre></td></tr></table></figure><p><code>@Target</code> 메타어노테이션은 어노테이션을 적용할 수 있는 요소 유형을 지정한다.</p><p>메타어노테이션을 직접 만들어야 한다면 다음과 같이 구현한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.ANNOTATION_CLASS)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingAnnotation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//사용</span></span><br><span class="line"><span class="meta">@BindingAnnotation</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinding</span></span></span><br></pre></td></tr></table></figure><h2 id="어노테이션-파라미터로-클래스-사용"><a href="#어노테이션-파라미터로-클래스-사용" class="headerlink" title="어노테이션 파라미터로 클래스 사용"></a>어노테이션 파라미터로 클래스 사용</h2><p>어떤 클래스를 선언 메타데이터로 참조할 수 있는 기능이 필요한 때가 있다. 클래스 참조를 파라미터로 하는 어노테이션 클래스를 선언하면 그런 기능을 사용할 수 있다.<br>제이키드 라이브러리의 <code>@DeserializeInterface</code>를 통해 이해해보자. 이 어노테이션은 인터페이스 타입인 프로퍼티를 역직렬화할 때 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@DeserailizeInterface(CompanyImpl::class)</span> <span class="keyword">val</span> company: Company</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이제 이 어노테이션의 정의를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeInterface</span></span>(<span class="keyword">val</span> targetClass: KClass&lt;<span class="keyword">out</span> Any&gt;)</span><br></pre></td></tr></table></figure><p>KClass는 java.lang.Class 타입과 같은 역할을 하는 코틀린 타입이다. 여기서 제네릭 타입에 out이 붙었다. out이 붙지 않고 KClass&lt;Any&gt;로 하면 해당 어노테이션에 CompanyImpl::class를 인자로 넘기지 못하고 Any::class만 인자로 넘길 수 있다. out이 없으면 하위타입이 되지 못하기 때문이다!</p><h2 id="어노테이션-파라미터로-제네릭-클래스-받기"><a href="#어노테이션-파라미터로-제네릭-클래스-받기" class="headerlink" title="어노테이션 파라미터로 제네릭 클래스 받기"></a>어노테이션 파라미터로 제네릭 클래스 받기</h2><p>파라미터로 제네릭 클래스를 받는 어노테이션을 정의해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">foo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> barClass: KClass&lt;<span class="keyword">out</span> SomeClass&lt;*&gt;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>제네릭 클래스인 SomeClass를 구현한 클래스만 파라미터로 받을 수 있게 구현된 예시이다.<br>여기서 아직 어떤 타입이 인자로 올 지 확정할 수 없기 때문에 스타 프로젝션이 적용됐다.</p><h1 id="리플렉션-실행-시점에-코틀린-객체-내부-관찰"><a href="#리플렉션-실행-시점에-코틀린-객체-내부-관찰" class="headerlink" title="리플렉션: 실행 시점에 코틀린 객체 내부 관찰"></a>리플렉션: 실행 시점에 코틀린 객체 내부 관찰</h1><p>리플렉션은 실행 시점에 동적으로 객체의 프로퍼티와 메서드에 접근할 수 있게 해주는 방법이다.<br>리플렉션은 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메서드나 프로퍼티 이름을 오직 실행 시점에서 알 수 있는 경우(JSON 직렬화)에 리플렉션이 필요하다.<br>코틀린에서는 java.lang.reflect 패키지를 통해 제공되는 표준 자바 리플렉션과 kotlin.reflect 패키지를 통해 제공되는 코틀린 리플렉션 API를 다룬다. 코틀린 리플렉션은 자바 리플렉션의 복잡한 기능을 아직 지원하지 않는 경우가 있어서 아직 자바 리플렉션을 필요로 한다. 다만 코틀린 리플렉션이 자바 클래스도 다룰 수 있다.</p><h2 id="코틀린-리플렉션-API-KClass-KCallable-KFunction-KProperty"><a href="#코틀린-리플렉션-API-KClass-KCallable-KFunction-KProperty" class="headerlink" title="코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty"></a>코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty</h2><h3 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h3><p>KClass는 java.lang.class에 해당하며 클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등 작업이 가능하다. 특정 인스턴스의 KClass를 얻기 위해서는 <code>&#123;instance&#125;.javaClass.kotlin</code>으로 얻을 수 있다.</p><h3 id="KCallable"><a href="#KCallable" class="headerlink" title="KCallable"></a>KCallable</h3><p>KCallable은 함수와 프로퍼트를 아우르는 공통 상위 인터페이스다. 그 안에는 call 메서드가 있다. call 메서드를 호출하면 함수나 프로퍼티의 게터를 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KCallable</span>&lt;<span class="type">out R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: R</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KFunction"><a href="#KFunction" class="headerlink" title="KFunction"></a>KFunction</h3><p>KFunction는 함수의 상위 인터페이스이다. call로 메서드를 호출할 수 있는데 이때 매개변수 갯수가 안맞으면 예외가 발생한다. 이를 방지 하기위해 KFunctionN&lt;…&gt;을 사용할 수 있다. 이 인터페이스는 invoke함수를 통해 정해진 매개변수를 받도록 제한한다. 다만 이런 경우 적용가능한 메서드가 적다.</p><h3 id="KProperty-KMutableProperty"><a href="#KProperty-KMutableProperty" class="headerlink" title="KProperty, KMutableProperty"></a>KProperty, KMutableProperty</h3><p>KProperty는 call로 프로퍼티의 게터를 호출한다. 하지만 프로퍼티 인터페이스는 더 좋은 방법으로 게터를 호출할 수 있다.<br>KProperty0은 최상위 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 이 인터페이스에 get메서드가 정의되어 있다.<br>KProperty1은 멤버 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 멤버 프로퍼티는 객체가 있어야 가능하므로, 인자가 하나인 get 메서드가 정의되어 있다. 그리고 제네릭 클래스이기 때문에 수신 객체의 타입을 검증할 수 있다.<br>KMutableProperty0, KMutableProperty1은 각 KProperty0, KProperty1를 확장한 인터페이스로 세터를 제공한다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코틀린의 제네릭스</title>
      <link>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/</link>
      <guid>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/</guid>
      <pubDate>Fri, 03 Feb 2023 04:23:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;코틀린의 제네릭스는 자바와 비슷한 점이 많다. 자바와 다른 부분도 많으니 이 점을 살펴보자!&lt;/p&gt;
&lt;h1 id=&quot;제네릭-타입-파라미터&quot;&gt;&lt;a href=&quot;#제네릭-타입-파라미터&quot; class=&quot;headerlink&quot; title=&quot;제네릭 타입 파라미터</description>
        
      
      
      
      <content:encoded><![CDATA[<p>코틀린의 제네릭스는 자바와 비슷한 점이 많다. 자바와 다른 부분도 많으니 이 점을 살펴보자!</p><h1 id="제네릭-타입-파라미터"><a href="#제네릭-타입-파라미터" class="headerlink" title="제네릭 타입 파라미터"></a>제네릭 타입 파라미터</h1><p>코틀린의 제네릭 타입 파라미터는 자바와 매우 비슷하지만 몇 가지 새로운 기능에 대해 배워보자.</p><h2 id="타입-파라미터-제약"><a href="#타입-파라미터-제약" class="headerlink" title="타입 파라미터 제약"></a>타입 파라미터 제약</h2><p>코틀린은 타입 파라미터 제한으로 클래스나 함수에 사용할 수 있는 타입 인자를 제한할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">sum</span><span class="params">()</span></span>: T</span><br></pre></td></tr></table></figure><p>이렇게 함수를 선언하면 숫자를 원소로 갖는 리스트 객체만 <code>sum</code> 함수를 호출할 수 있게 된다!! 와우~</p><p>타입 파라미터 제약을 사용한 예시를 살펴보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Person&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.forEach &#123;println(<span class="string">&quot;<span class="subst">$&#123;it.name&#125;</span> hello~&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Bob&quot;</span>), Person(<span class="string">&quot;Tom&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// numbers.hello() 컴파일 에러</span></span><br><span class="line">people.hello()</span><br></pre></td></tr></table></figure><p>타입 파라미터 제한에 따라 함수도 제한한 예시이다.</p><p>여기서 더 실전적인 예시를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(first: <span class="type">T</span>, second: <span class="type">T</span>)</span></span> : T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (first &gt; second) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(max(<span class="string">&quot;airplane&quot;</span>, <span class="string">&quot;zebra&quot;</span>))</span><br></pre></td></tr></table></figure><p>Comparable을 구현한 타입, 즉 원소 간 비교가 가능한 타입 파라미터만 사용할 수 있는 함수를 구현했다.</p><h3 id="타입-파라미터에-여러-제약-걸기"><a href="#타입-파라미터에-여러-제약-걸기" class="headerlink" title="타입 파라미터에 여러 제약 걸기"></a>타입 파라미터에 여러 제약 걸기</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">ensureTrailingPeriod</span><span class="params">(seq: <span class="type">T</span>)</span></span></span><br><span class="line">        <span class="keyword">where</span> T : CharSequence, T : Appendable &#123;</span><br><span class="line">    <span class="keyword">if</span> (!seq.endsWith(<span class="string">&#x27;.&#x27;</span>)) seq.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 시그니처 뒷 쪽에 where 절로 타입 파라미터가 여러 조건을 만족하도록 제한을 걸 수 있다. 위 예시에서는 T가 CharSequence와 Appendable의 하위 타입이어야 가능함을 의미한다.</p><h2 id="타입-파라미터를-널이-될-수-없는-타입으로-한정"><a href="#타입-파라미터를-널이-될-수-없는-타입으로-한정" class="headerlink" title="타입 파라미터를 널이 될 수 없는 타입으로 한정"></a>타입 파라미터를 널이 될 수 없는 타입으로 한정</h2><p>타입 파라미터에 아무런 제약 없이 사용하면 <code>Any?</code>를 상한으로 하는 것과 마찬가지다. 만약 널을 허용하지 않는 타입으로 제한하고 싶으면 <code>&lt;T: Any&gt;</code>로 상한을 걸어주자.<br>터</p><h1 id="실행-시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터"><a href="#실행-시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터" class="headerlink" title="실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터"></a>실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터</h1><p>JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다. 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다. </p><h2 id="실행-시점의-제네릭-타입-검사와-캐스트"><a href="#실행-시점의-제네릭-타입-검사와-캐스트" class="headerlink" title="실행 시점의 제네릭: 타입 검사와 캐스트"></a>실행 시점의 제네릭: 타입 검사와 캐스트</h2><p>코틀린도 자바와 마찬가지로 제네틱 타입 인자 정보는 런타임에 지워진다. 타입 소거는 저장해야 하는 타입 정보의 크기가 줄어들어서 메모리 사용량이 줄어드는 장점은 있다.<br>하지만 타입 소거 때문에 실행 시점에 타입 인자를 검사할 수 없다. 예를 들면 다음과 같은 코드는 컴파일 에러가 발생한다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;String&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>왜냐면 실행 시점에서 value가 List인지 아닌지는 명확히 판별할 수 있지만, List&lt;String&gt;인지, List&lt;Long&gt;인지는 확인할 수 없기 때문이다.</p><p>하지만 방법은 있다. 스타 프로젝션을 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;*&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>인자를 알 수 없는 제네릭 타입을 표현할 때 스타 프로젝션을 사용한다.(자바의 와일드카드와 비슷)<br>스타 프로젝션을 사용하면 as나 as? 캐스팅도 가능하다. 문제는 타입 파라미터를 정확히 모르니 컴파일은 가능해도 런타임에 캐스팅 에러가 발생할 수 있다.</p><h2 id="실체화한-타입-파라미터를-사용한-함수-선언"><a href="#실체화한-타입-파라미터를-사용한-함수-선언" class="headerlink" title="실체화한 타입 파라미터를 사용한 함수 선언"></a>실체화한 타입 파라미터를 사용한 함수 선언</h2><p>타입 소거에 의해 런타임에는 타입 인자 정보를 알 수 없다. 하지만 코틀린 인라인 함수의 타입 인자는 알 수 있다!!!</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isA</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T</span><br><span class="line"></span><br><span class="line">println(isA&lt;String&gt;(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>인라인 함수의 타입 파라미터 앞에 reified로 지정하면 실행 시점에서 타입 파라미터를 사용할 수 있다. 이때 파라미터에 람다를 받지 않는데도 타입 파라미터를 실체화 하기 위해서 inline 했읆을 주목하자. 즉 성능을 위해 inline 한 게 아니라 타입 파라미터 사용을 위해서 inline 선언한 것이다. 이때 해당 함수의 길이에 따라 성능 문제가 발생할 수 있다. 그럴 경우 반드시 필요한 부분을 분리해서 성능을 최적화 할 수 있다.</p><blockquote><p>왜 inline은 타입 파라미터를 실체화 할 수 있나?</p></blockquote><p>컴파일러가 인라인 함수의 본문을 바이트코드로 호출한 곳에 집어 넣을 때, 호출 할 때 제네릭 타입에 전달된 클래스를 알 수 있어서 타입 파라미터 자리에 정확한 클래스를 넣을 수 있다.<br>위 예시의 경우 다음과 같이 인라이닝된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;hello&quot;</span> <span class="keyword">is</span> String)</span><br></pre></td></tr></table></figure><blockquote><p>자바에서는 실체화한 타입 파라미터를 가진 inline 함수를 호출할 수 없다.</p></blockquote><p>자바에서 인라인 함수를 호출할 수 있다. 이 경우 일반 함수처럼 사용되서 인라이닝 되지 않는다. 실체화 된 타입 파라미터가 있는 inline 함수의 경우 반드시 인라이닝이 되어야 하기 때문에 자바에서는 해당 함수를 호출하지 못하도록 했다.</p><h2 id="실체화한-타입-파라미터의-제약"><a href="#실체화한-타입-파라미터의-제약" class="headerlink" title="실체화한 타입 파라미터의 제약"></a>실체화한 타입 파라미터의 제약</h2><p>실체화한 타입 파라미터는 몇가지 제약이 있다. 실체화한 타입 파라미터 개념 자체에서 오는 제약과 코틀린에서 실체화한 타입 파라미터를 구현하는 과정에서 오는 제약이 있다. 따라서 구현이 달라지면 나중에 완화될 제약이 있다.</p><p>가능한 것</p><ul><li>타임 검사와 캐스틍 (is, as 등)</li><li>코틀린 리플렉션 API (::class 등)</li><li>코틀린 타입에 대응하는 java.lang.Class 얻기 (::class.java)</li><li>다른 함수를 호출할 때 타입 인자로 사용</li></ul><p>불가능한 것</p><ul><li>타입 파라미터 클래스의 인스턴스 생성</li><li>타입 파라미터 클래스의 동반 객체 메서드 호출</li><li>실체화된 타입 파라미터 자리에 실체화 되지 않은 타입 파라미터로 받은 타입을 넘기기</li><li>클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기</li></ul><h1 id="변성-제네릭과-하위-타입"><a href="#변성-제네릭과-하위-타입" class="headerlink" title="변성: 제네릭과 하위 타입"></a>변성: 제네릭과 하위 타입</h1><p>변성 개념은 <code>List&lt;Any&gt;</code>와 <code>List&lt;String&gt;</code>과 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.</p><h2 id="변성이-있는-이유-인자를-함수에-넘기기"><a href="#변성이-있는-이유-인자를-함수에-넘기기" class="headerlink" title="변성이 있는 이유: 인자를 함수에 넘기기"></a>변성이 있는 이유: 인자를 함수에 넘기기</h2><p><code>List&lt;Any&gt;</code>를 인자로 받는 함수에 <code>List&lt;String&gt;</code> 객체를 전달해도 괜찮을까?<br>보통 <code>Any</code>가 더 상위 객체이니 별 문제 없을 것 같다. 하지만 경우에 따라 컴파일 에러가 발생한다. (책에서는 경우에 따라 런타임에서 문제가 될 수 있다고 했지만 실제로는 아예 컴파일이 되지 않는다.)</p><h3 id="문제가-되는-경우-원소-추가-변경하는-경우"><a href="#문제가-되는-경우-원소-추가-변경하는-경우" class="headerlink" title="문제가 되는 경우: 원소 추가, 변경하는 경우"></a>문제가 되는 경우: 원소 추가, 변경하는 경우</h3><p>아래 코드를 보면 리스트의 원소를 추가, 변경 가능한 MutableList를 매개변수로 갖는 함수에게 타입 인자가 하위 계층인 리스트를 전달하면 컴파일 자체가 되지 않는다.</p><p>그렇지 않은 함수는 별 문제 없이 잘된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addContent</span><span class="params">(contents: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">   contents.add(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printContents</span><span class="params">(contents: <span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(contents.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strings = mutableListOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">printContents(strings)</span><br><span class="line">addContent(strings) <span class="comment">// 컴파일 에러!</span></span><br></pre></td></tr></table></figure><h2 id="클래스-타입-하위-타입"><a href="#클래스-타입-하위-타입" class="headerlink" title="클래스, 타입, 하위 타입"></a>클래스, 타입, 하위 타입</h2><h3 id="클래스와-티입의-구분"><a href="#클래스와-티입의-구분" class="headerlink" title="클래스와 티입의 구분"></a>클래스와 티입의 구분</h3><p>타입과 클래스는 다른 개념이다. 예를 들어 String이라는 클래스는 코틀린에서 <code>String</code>과 <code>String?</code>두가지 타입을 만들어낸다. 즉 하나의 클래스에서 두가지의 타입이 나온다.<br>그렇다면 List는 어떨까? List는 하나의 클래스이다. 다만 타입 매개변수에 따라 수많은 타입이 가능하다. (List&lt;String&gt;, List&lt;Int&gt; 등…) 이제 타입과 클래스가 구분된다는 의미가 와닿는다.</p><h3 id="하위-타입-상위-타입"><a href="#하위-타입-상위-타입" class="headerlink" title="하위 타입, 상위 타입"></a>하위 타입, 상위 타입</h3><p>타입 A 자리에 타입 B가 와도 문제가 없을 때 B가 A의 하입 타입이다 라고 말한다. 반면 A는 B의 상위 타입이라고 한다. 컴파일러는 변수에 값을 대입할 때 변수의 타입이 값의 타입보다 상위 타입인지 확인한다.</p><p>간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다. 하지만 널 가능성과 제네릭 클래스의 경우 하위 타입과 하위 클래스의 차이가 두드러진다.<br>Int는 Int?의 하위 타입이라고 볼 수 있다. 하지만 두 타입 모두 같은 클래스를 기반으로 한 타입이다.</p><p>제네릭 클래스의 경우 List&lt;Any&gt;는 List&lt;String&gt;의 상위 타입이라고 볼 수 있다. 하지만 MutableList&lt;Any&gt;는 MutableList&lt;String&gt;의 상위 타입이라고 볼 수 없다. (이유는 문제가 되는 이유라는 소제목을 보자.)<br>즉 타입 인자가 서로 다른 타입이 들어갔을 경우 두 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않는 상황을 무공변이라고 한다! (참고로 자바에서는 모든 클래스가 무공변이라 한다.)<br>지</p><h2 id="공변성-하위-타입-관계를-유지"><a href="#공변성-하위-타입-관계를-유지" class="headerlink" title="공변성: 하위 타입 관계를 유지"></a>공변성: 하위 타입 관계를 유지</h2><p>같은 제네릭 클래스 기반의 서로 다른 타입 인자를 가진 두 인스턴스의 하위 타입 관계가 유지되면 공변이라고 얘기한다.</p><p>코틀린에서 공변한 클래스를 선언하는 방법을 소개한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out 키워드를 타입 파라미터 앞에 붙여주자. 공변인 타입 파라미터는 함수 정의에 사용된 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다. 즉 하위 관계인 타입 인자가 함수에 사용되어도 된다는 의미다.</p><h3 id="아웃-인-생산-소비"><a href="#아웃-인-생산-소비" class="headerlink" title="아웃, 인, 생산, 소비"></a>아웃, 인, 생산, 소비</h3><p>모든 클래스를 공변으로 만들면 안된다. 타입 안정성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에 있어야 한다.이는 클래스가 타입의 값을 생산(반환)할 수는 있지만, 타입 값을 소비(파라미터 타입 선언)할 수 없다는 의미다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transformIn</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123; ... &#125; <span class="comment">// 타입을 소비 (in)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transformOut</span><span class="params">()</span></span> : T &#123; ... &#125; <span class="comment">// 타입을 생산 (out)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정리하자면 공변성은 타입 인자를 아웃(생산, 반환) 위치에만 사용하는 클래스만 가능하다.</p><blockquote><p>공변의 규칙에서 자유로운 생성자 &amp; private 메서드<br>공변은 인스턴스가 생성되고 나서 하위 타입 관계를 유지할 수 있도록 하는 규칙이므로 생성자는 관련없다. 그리고 인, 아웃 규칙은 외부에서 볼 수 있는 클래스 API 관점에서 정의이다. private 메서드는 인, 아웃 둘 다 해당하지 않는다.</p></blockquote><h2 id="반공변성-뒤집힌-하위-타입-관계"><a href="#반공변성-뒤집힌-하위-타입-관계" class="headerlink" title="반공변성: 뒤집힌 하위 타입 관계"></a>반공변성: 뒤집힌 하위 타입 관계</h2><p>반공변성은 공변성의 반대다. 즉 타입 A가 타입 B의 하위 타입인데, Consumer&lt;B&gt;가 Consumer&lt;A&gt;의 하위 타입이 될 때 반공변성이라고 한다. 인 아웃 규칙도 반대다. 인 위치에서만 타입이 사용되어야 반공변성이 성립한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용-지점-변성-타입이-언급되는-지점에서-변성-지정"><a href="#사용-지점-변성-타입이-언급되는-지점에서-변성-지정" class="headerlink" title="사용 지점 변성: 타입이 언급되는 지점에서 변성 지정"></a>사용 지점 변성: 타입이 언급되는 지점에서 변성 지정</h2><p>클래스에서 in과 out으로 타입 매개변수에 변성을 지정해주지 않고 타입이 언급되는 곳마다 변성을 적용하는 방법이 사용 지점 변성이다. 자바에서 와일드카드 기능을 통해 <code>? extends String</code> 이런 식으로 사용 지점 변성을 사용한다. (물론 기존의 선언 지점 변성이 코드 중복을 줄여주는 장점이 있어 더 간결하다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) destination.add(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무공변인 MutableList를 인자로 받아 인과 아웃에서 모두 사용하고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) destination.add(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in, out 키워드를 통해 적절한 변성을 적용했다. 이때 in, out 키워드를 붙인 타입에서는 타입 프로젝션이 일어난다. 일반적인 MutableList가 아닌 변성이 적용된 MutableList 타입으로 만들어서, 해당 변성에 맞는 메서드만 호출할 수 있게 된다.</p><h2 id="스타-프로젝션-타입-인자-대신-사용"><a href="#스타-프로젝션-타입-인자-대신-사용" class="headerlink" title="스타 프로젝션: 타입 인자 대신 * 사용"></a>스타 프로젝션: 타입 인자 대신 * 사용</h2><p>스타 프로젝션은 어떤 구체적인 타입이 타입 인자로 정해졌는데, 정확히 어떤 타입인지 추론할 수 없을 때 사용한다. 일반적으로 타입 인자가 중요하지 않은 경우 주로 사용한다. <code>MutableList&lt;*&gt;</code>를 통해 스타 프로젝션에 대해 이해해보자.</p><h3 id="Any-와-차이"><a href="#Any-와-차이" class="headerlink" title="Any?와 차이"></a>Any?와 차이</h3><p><code>MutableList&lt;*&gt;</code>와 <code>MutableList&lt;Any?&gt;</code>는 의미가 다르다. 후자는 어떤 객체든 담을 수 있는 리스트이다. 전자는 구체적인 타입 인자가 정해졌는데 추론할 수 없는 상황이므로 아무 객체나 담으면 안된다. 반면 전자에서 값을 꺼낼 때는 타입을 정확히 추론할 수는 없지만 Any?의 하위타입일 것은 명확하므로 반환하는 타입은 Any?가 된다. 따라서 <code>MutableList&lt;*&gt;</code>는 아웃 프로젝션 타입이 된다. 즉 생성(반환)만 되고 소비(인자로 사용)은 안되는 타입이다!</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>고차 함수(파라미터와 반환 값으로 람다 사용)</title>
      <link>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/</guid>
      <pubDate>Tue, 31 Jan 2023 07:41:02 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;고차-함수&quot;&gt;&lt;a href=&quot;#고차-함수&quot; class=&quot;headerlink&quot; title=&quot;고차 함수&quot;&gt;&lt;/a&gt;고차 함수&lt;/h1&gt;&lt;p&gt;고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다. 코틀린의 고차 함수가 인자나 반환값으로 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h1><p>고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다. 코틀린의 고차 함수가 인자나 반환값으로 함수를 사용하기 위해서는 함수 타입이 필요하다.</p><h2 id="함수-타입"><a href="#함수-타입" class="headerlink" title="함수 타입"></a>함수 타입</h2><p>자바에서 람다 식을 매개변수나 반환값으로 사용하기 위해서는 함수형 인터페이스를 사용했다. 코틀린에서는 함수 타입이 존재한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x + y&#125;</span><br><span class="line"><span class="keyword">val</span> action: () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="number">42</span>) &#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 함수 타입에 대해 알 수 있다. 마치 람다 식처럼 생겼다.</p><p>널을 반환하거나 함수 타입 자체가 널이 될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> canReturnNull: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>? = &#123; <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">val</span> funOrNull: ((<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>)? = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>함수 타입이 파라미터로 활용될 때 함수 타입의 파라미터에 이름을 정해줄 수 있다.<br>고차 함수에서 함수 타입 호출은 일반 함수 호출처럼 괄호 안에 인자를 넣어서 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(callback: (<span class="type">code</span>:<span class="type">Int</span>, <span class="type">content</span>:<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    callback(<span class="number">1</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething &#123; code, content -&gt; println(<span class="string">&quot;code = <span class="variable">$code</span>, content = <span class="variable">$content</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="자바에서-코틀린-함수-타입-사용"><a href="#자바에서-코틀린-함수-타입-사용" class="headerlink" title="자바에서 코틀린 함수 타입 사용"></a>자바에서 코틀린 함수 타입 사용</h3><p>코틀린의 함수 타입은 자바에서 <code>FunctionN</code>이라는 인터페이스로 바뀐다. 매개 변수 갯수에 따라 <code>FunctionN&lt;R&gt;</code>, <code>Function&lt;R, P1&gt;</code> 등으로 바뀐다. 이렇게 바뀐 인터페이스 안에는 <code>invoke</code> 메서드가 정의되어 있다. <code>invoke</code>를 통해 함수를 실행시킬 수 있다.</p><p>이때 Unit을 반환하는 함수 타입을 자바에서도 사용할 수 있으나 자바에서 void를 반환하는 람다를 Unit을 반환하는 함수 타입에 전달해줄 수 없다. 코틀린의 Unit은 값이 있지만 자바의 void는 값이 없기 때문이다.</p><h2 id="디폴트-값을-지정한-파라미터와-널이-될수-있는-함수-타입-파라미터-활용"><a href="#디폴트-값을-지정한-파라미터와-널이-될수-있는-함수-타입-파라미터-활용" class="headerlink" title="디폴트 값을 지정한 파라미터와 널이 될수 있는 함수 타입 파라미터 활용"></a>디폴트 값을 지정한 파라미터와 널이 될수 있는 함수 타입 파라미터 활용</h2><p>고차 함수에 함수 타입 파라미터에 디폴트 값을 넣어줄 수 있다. 또한 널이 될 수 있도록 타입을 정할 수 있다. 다만 이런 경우 고차 함수에서 함수 타입에 해당하는 객체를 바로 호출할 수 없고 안전하게 호출해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomethingWithDefault</span><span class="params">(callback: ((<span class="type">code</span>: <span class="type">Int</span>, <span class="type">content</span>: <span class="type">String</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    callback?.invoke(<span class="number">1</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">        ?: run &#123; println(<span class="string">&quot;input null&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomethingWithDefault() <span class="comment">// input null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="람다를-활용한-중복-제거"><a href="#람다를-활용한-중복-제거" class="headerlink" title="람다를 활용한 중복 제거"></a>람다를 활용한 중복 제거</h2><p>사이트 방문 데이터에 대항 정보를 통계내는 코드를 작성할 때 람다로 중복을 제거해보자.</p><p>일단 데이터는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    WINDOWS, MAC, IOS, ANDROID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteVisit</span></span>(</span><br><span class="line">    <span class="keyword">val</span> path: String,</span><br><span class="line">    <span class="keyword">val</span> duration: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="keyword">val</span> os: OS</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> log = listOf(</span><br><span class="line">    SiteVisit(<span class="string">&quot;/&quot;</span>, <span class="number">1.0</span>, OS.WINDOWS),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/hello&quot;</span>, <span class="number">2.0</span>, OS.MAC),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/welcome&quot;</span>, <span class="number">3.0</span>, OS.ANDROID),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/goodbye&quot;</span>, <span class="number">4.0</span>, OS.ANDROID),</span><br><span class="line">    SiteVisit(<span class="string">&quot;/welcome&quot;</span>, <span class="number">5.0</span>, OS.IOS),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>이제 안드로이드 사용자들의 평균 방문 시간을 출력해보자.</p><blockquote><p>하드 코딩한 필터를 사용한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageAndroidDuration = log</span><br><span class="line">    .filter &#123; it.os == OS.ANDROID &#125;</span><br><span class="line">    .map(SiteVisit::duration)</span><br><span class="line">    .average()</span><br><span class="line">println(averageAndroidDuration)</span><br></pre></td></tr></table></figure><p>이렇게 구현하면 다른 os의 평균을 구할 때마다 중복된 코드를 적어줘야 한다. 이를 개선해보자.</p><blockquote><p>개선한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;SiteVisit&gt;</span>.<span class="title">averageDurationFor</span><span class="params">(os: <span class="type">OS</span>)</span></span> =</span><br><span class="line">    filter &#123; it.os == os &#125;</span><br><span class="line">        .map(SiteVisit::duration)</span><br><span class="line">        .average()</span><br></pre></td></tr></table></figure><p>이제 디바이스 별로 방문시간 통계를 내는 상황을 코드로 짜보자.</p><blockquote><p>하드코딩한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageMobileDuration = log</span><br><span class="line">    .filter &#123; it.os <span class="keyword">in</span> setOf(OS.IOS, OS.ANDROID) &#125;</span><br><span class="line">    .map(SiteVisit::duration)</span><br><span class="line">    .average()</span><br><span class="line">println(averageMobileDuration)</span><br></pre></td></tr></table></figure><p>이를 고차 함수를 활용해서 개선해보자.</p><blockquote><p>개선한 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;SiteVisit&gt;</span>.<span class="title">averageDurationFor</span><span class="params">(predicate: (<span class="type">SiteVisit</span>) -&gt; <span class="type">Boolean</span>)</span></span> =</span><br><span class="line">    filter(predicate)</span><br><span class="line">        .map(SiteVisit::duration)</span><br><span class="line">        .average()</span><br><span class="line"></span><br><span class="line">println(log.averageDurationFor &#123; it.os <span class="keyword">in</span> setOf(OS.ANDROID, OS.IOS) &#125;)</span><br></pre></td></tr></table></figure><p>와우! 재활용이 엄청 잘되겠다~</p><h1 id="인라인-함수-람다의-부가-비용-없애기"><a href="#인라인-함수-람다의-부가-비용-없애기" class="headerlink" title="인라인 함수: 람다의 부가 비용 없애기"></a>인라인 함수: 람다의 부가 비용 없애기</h1><p>코틀린은 람다를 보통 무명 클래스로 컴파일 하지만 람다 식을 사용할 때마다 클래스를 만들지는 않는다.<br>람다가 변수를 포획하면 람다가 생성되는 시점에 무명 클래스 객체가 생긴다.<br>따라서 람다는 같은 작업을 하는 일반 함수에 비해 덜 효율적인 것 같다.</p><p>하지만 inline 변경자를 통해 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트 코드로 바꾸치기 한다.</p><h2 id="인라이닝이-작동하는-방식"><a href="#인라이닝이-작동하는-방식" class="headerlink" title="인라이닝이 작동하는 방식"></a>인라이닝이 작동하는 방식</h2><p>어떤 함수를 <code>inline</code>으로 선언하면 해당 함수를 호출하는 코드 대신 해당 함수의 본문이 바이트 코드로 컴파일된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">(callback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    callback()</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;it&#x27;s foo function!&quot;</span>)</span><br><span class="line">    doSomething2 &#123; println(<span class="string">&quot;do foo things~!&quot;</span>) &#125;</span><br><span class="line">    println(<span class="string">&quot;end of foo function!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>이런 식으로 inline을 적용하는 경우 foo 함수는 다음 코드와 같은 바이트 코드로 컴파일 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;it&#x27;s foo function!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;do foo things~!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;end of foo function!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시를 유심히 보면 함수 본문과 전달받은 람다가 인라이닝 된 것을 볼 수 있다.<br>이때 람다 대신 함수 타입의 변수에 람다를 담아서 전달하는 경우 해당 변수에 어떤 값이 담긴지 모르기 때문에 람다 부분은 인라이닝이 되지 않고 함수 본문만 인라이닝 된다.</p><p>만약 특정 람다를 인라이닝하고 싶지않으면 noinline 변경자를 파라미터 이름 앞에 붙이면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">(<span class="keyword">noinline</span> callback: () -&gt; <span class="type">Unit</span>, otherCallback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;start to do Something&quot;</span>)</span><br><span class="line">    callback()</span><br><span class="line">    otherCallback()</span><br><span class="line">    println(<span class="string">&quot;end of something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>모듈 밖이나 자바에서 인라인 함수를 호출하는 경우는 컴파일러는 일반 호출로 컴파일한다.</p></blockquote><h2 id="컬렉션-연산-인라이닝"><a href="#컬렉션-연산-인라이닝" class="headerlink" title="컬렉션 연산 인라이닝"></a>컬렉션 연산 인라이닝</h2><p><code>filter</code>, <code>map</code>과 같은 컬렉션 연산은 람다를 매개변수로 받아 사용하는 인라인 함수이다. 이 경우 전달받은 람다와 컬렉션 연산 함수의 본문이 인라인된다!<br>하지만 컬렉션 연산은 매번 연산마다 연산 결과를 컬렉션으로 만들어내서 여러 연산을 하는 경우 비효율적이다.</p><p>이런 비효율을 줄이는 게 시퀀스인데, 시퀀스를 사용하면 중간 시퀀스가 전달 받은 람다를 필드로 저장하는 객체로 표현되며 최종 연산이 진행될 때 중간 시퀀스에 있는 여러 람다를 연쇄 호출하는 방식으로 진행된다.</p><p>즉 시퀀스는 람다를 저장해야 하므로 람다를 인라인하지 않는다. 따라서 지연 계산을 통해 성능 개선하려고 모든 컬렉션 연산을 시퀀스로 하면 안된다. 컬렉션의 크기가 작은 경우 컬렉션 연산을 통한 인라이닝이 더 성능에 도움이 될 수 있다. 컬렉션 크기가 매우 큰 경우에만 시퀀스를 활용하자.</p><h2 id="함수를-인라인으로-선언해야-하는-경우"><a href="#함수를-인라인으로-선언해야-하는-경우" class="headerlink" title="함수를 인라인으로 선언해야 하는 경우"></a>함수를 인라인으로 선언해야 하는 경우</h2><p>inline 키워드를 남용하면 안된다. 왜냐면 일반 함수 호출은 JVM이 이미 강력하게 인라이닝하기 때문이다.</p><p>JVM은 바이트코드가 기계어로 번역되는 과정에서 일어난다. JVM의 최적화는 바이트코드 상에서 호출된 함수 부분에서 따로 함수 코드가 중복되지 않는다. 반면 코틀린의 인라인 함수는 바이트코드에서 함수 호출 지점을 함수 본문으로 변환해서 코드 중복이 생긴다. 게다가 함수 직접 호출은 스택 트레이스가 더 깔끔해진다.</p><p>반면 람다를 인자로 받는 함수를 인라이닝하면 이익이 많다. 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요가 없어진다. JVM이 함수 호출과 람다를 인라이닝할 정도로 똑똑하지는 않다. 인라이닝을 사용하면 일반 람다에서 사용 못하는 기능을 사용할 수 있다.(넌로컬)</p><p>인라이닝을 적용할 때는 해당 함수의 크기를 고려하자. 길이가 매우 긴 함수를 인라이닝하면 바이트코드의 용량이 매우 커질 수 있다. 이런 경우 매개변수의 람다를 선택적으로 인라이닝하지 않거나 하는 방식을 고려해볼 수 있다.</p><h1 id="고차-함수-안에서-흐름-제어"><a href="#고차-함수-안에서-흐름-제어" class="headerlink" title="고차 함수 안에서 흐름 제어"></a>고차 함수 안에서 흐름 제어</h1><p>람다를 호출하는 함수에서 return을 호출하면 어떻게 될까?<br>사람들 중 Alice라는 이름의 사람을 찾는 코드 예시로 흐름 제어 사례를 살펴보자.</p><blockquote><p>명령형 코드 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">27</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (person <span class="keyword">in</span> people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Alice is not found...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="람다-안의-return문-람다를-둘러싼-함수로-반환"><a href="#람다-안의-return문-람다를-둘러싼-함수로-반환" class="headerlink" title="람다 안의 return문: 람다를 둘러싼 함수로 반환"></a>람다 안의 return문: 람다를 둘러싼 함수로 반환</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice2</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Alice is not found...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>람다 안에서 return을 사용하면 람다로부터만 반환되느게 아니라 람다를 호출하는 함수가 실행을 끝내고 반환된다. 이렇게 나를 감싼 블록보다 더 바깥의 블록을 반환하게 만드는 return문을 넌로컬 return이라 부른다. 마치 자바 for 루프 내부에서 return을 하면 해당 루프를 사용하는 함수가 종료되는 것과 같은 논리이다.</p><p>이렇게 return이 바깥쪽 함수를 반환시킬 수 있는 경우는 람다를 인자로 받는 함수가 인라인 함수인 경우에만 그렇다!!!!!!!</p><p>인라인 함수가 아닌 함수는 변수에 저장되어 호출 시점이 바깥 함수 호출 시점과 분리될 수 있다. 그래서 함수 내부의 return이 바깥쪽 함수 반환을 시킬 수 없게 된다.</p><h2 id="람다로부터-반환-레이블을-사용한-return"><a href="#람다로부터-반환-레이블을-사용한-return" class="headerlink" title="람다로부터 반환: 레이블을 사용한 return"></a>람다로부터 반환: 레이블을 사용한 return</h2><p>람다 식에서 for 루프의 break과 비슷한 역할을 하는 로컬 return이 있다. break 시킬 람다나 함수를 레이블로 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice3</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach <span class="symbol">label@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@label</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice4</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;FOUND!!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="무명-함수-기본적으로-로컬-return"><a href="#무명-함수-기본적으로-로컬-return" class="headerlink" title="무명 함수: 기본적으로 로컬 return"></a>무명 함수: 기본적으로 로컬 return</h2><p>넌로컬 반환문을 여럿 사용해야 하는 경우 무명 함수로 코드를 더 쉽게 만들 수 잇다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice4</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    people.forEach(<span class="function"><span class="title">fun</span> <span class="params">(person)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) <span class="keyword">return</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;person.name&#125;</span> is not Alice&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무명 함수 내부 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킨다. (무명 함수 바깥 함수를 반환시키지 않는다!!!) 애초에 return은 fun으로 정의된 가장 안쪽 함수를 반환시키는 데, 람다식은 fun으로 정의되지 않아 람다 밖의 함수를 반환시킨 것이다. 무명 함수는 fun으로 함수 선언되었으니 바깥 함수를 종료시키지 않을 수 있다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>연산자 오버로딩과 기타 관례</title>
      <link>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/</guid>
      <pubDate>Thu, 26 Jan 2023 08:38:17 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;산술-연산자-오버로딩&quot;&gt;&lt;a href=&quot;#산술-연산자-오버로딩&quot; class=&quot;headerlink&quot; title=&quot;산술 연산자 오버로딩&quot;&gt;&lt;/a&gt;산술 연산자 오버로딩&lt;/h1&gt;&lt;p&gt;코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="산술-연산자-오버로딩"><a href="#산술-연산자-오버로딩" class="headerlink" title="산술 연산자 오버로딩"></a>산술 연산자 오버로딩</h1><p>코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서 <strong>관례</strong>라고 부른다.<br>코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자다. 기존 자바에서는 원시 타입과 문자열 정도에 산술 연산자를 쓸 수 있다. 하지만 관례를 적절히 사용하면 다른 클래스에도 산술 연산자를 쓸 수 있다.</p><h2 id="이항-산술-연산-오버로딩"><a href="#이항-산술-연산-오버로딩" class="headerlink" title="이항 산술 연산 오버로딩"></a>이항 산술 연산 오버로딩</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p3 = p1 + p2</span><br><span class="line">println(p3) <span class="comment">// x = 4, y = 6</span></span><br></pre></td></tr></table></figure><p>산술 연산자 <code>+</code>는 <code>plus</code> 라는 이름의 함수로 오버로딩할 수 있다. 이때 산술 연산 오버로딩은 함수 앞에 <code>operator</code>가 붙어야 한다.<br>연산자 오버로딩은 확장함수로도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이항 산술 연산자는 <code>times</code>, <code>div</code>, <code>mod(rem)</code>, <code>plus</code>, <code>minus</code> 등 정해진 함수 이름을 사용해야 하며 기존 연산자의 우선순위와 같다.</p><blockquote><p>연산자 함수와 자바<br>코틀린 연산자는 함수로 정의된다. 긴 이름을 사용하면 일반 함수로 호출할 수 있다.</p></blockquote><h3 id="코틀린-연산자가-자동으로-교환-법칙을-지원하지는-않음"><a href="#코틀린-연산자가-자동으로-교환-법칙을-지원하지는-않음" class="headerlink" title="코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음"></a>코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">times</span><span class="params">(scale: <span class="type">Int</span>)</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x * scale, y * scale)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(p1 * <span class="number">2</span>) <span class="comment">// x = 2, y = 4</span></span><br><span class="line"><span class="comment">// p1 * 2는 컴파일 되지 않는다.</span></span><br></pre></td></tr></table></figure><p>연산자 오버로딩은 다양한 매개변수를 가질 수 있다. 위의 예시도 그런 상황인데, 이때 일반적인 산술연산자 처럼 교환법칙을 지원하지는 않는다.<br>그리고 오버로딩된 연산자의 반환값이 반드시 두 피연산자 중 하나여야만 하는 것도 아니다.</p><h2 id="복합-대입-연산자-오버로딩"><a href="#복합-대입-연산자-오버로딩" class="headerlink" title="복합 대입 연산자 오버로딩"></a>복합 대입 연산자 오버로딩</h2><p><code>+=</code>, <code>-=</code> 같은 복합 대입 연산자는 사실 <code>+</code>, <code>-</code> 같은 연산자를 오버로딩하면 자연스럽게 지원된다.<br>하지만 이런 경우 새로운 객체를 만들어서 반환하게 된다. (위 예시를 보면 새로운 객체를 만들어서 반환한다.)</p><p>이를 대비해 복합 대입 연산자도 오버로딩을 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plusAssign</span><span class="params">(other: <span class="type">Point</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.x += other.x</span><br><span class="line">    <span class="keyword">this</span>.y += other.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p1+=p2</span><br><span class="line">println(p1) <span class="comment">// x = 4, y = 6</span></span><br></pre></td></tr></table></figure><p>이때 주의해야 할 점은 복합 대입 연산자와 이에 필요한 이항 산술 연산자를 같이 재정의하면 컴파일러가 어떤 연산자를 사용해서 코드를 실행해야 할 지 알 수 없어서 컴파일 에러가 생긴다.<br>그래서 이 두가지 산술 연산자를 동시에 재정의하지 않도록 하자. 위 예시에서는 <code>plus</code>와 <code>plusAssign</code>을 동시에 재정의하면 <code>+=</code>를 할 때 컴파일 오류가 생긴다. 객체의 프로퍼티를 변경할 수 없는 경우는 <code>plus</code>와 같은 이항 산술 연산자만 오버로딩하고 변경 가능한 클래스를 설계한다면 <code>plusAssign</code>만 제공하는 방식을 고려할 수 있다.</p><h3 id="코틀린-컬렉션에서-대응-예시"><a href="#코틀린-컬렉션에서-대응-예시" class="headerlink" title="코틀린 컬렉션에서 대응 예시"></a>코틀린 컬렉션에서 대응 예시</h3><p>코틀린 컬렉션에서는 변경 가능한 컬렉션에는 <code>+=</code>와 <code>-=</code>를 통해 메모리에 있는 객체 상태를 변경시킬 수 있게 해놨다. 반면 읽기 전용 컬렉션에서는 <code>+=</code>와 <code>-=</code>는 변경을 적용한 복사본을 반환하도록 했다.</p><h2 id="단항-연산자-오버로딩"><a href="#단항-연산자-오버로딩" class="headerlink" title="단항 연산자 오버로딩"></a>단항 연산자 오버로딩</h2><p>단항 연산자도 크게 다르지 않다. <code>unaryPlus</code>, <code>unaryMinus</code>, <code>not</code> 등 정해진 이름을 통해 오버로딩한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(-x, -y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 <code>++</code>와 <code>--</code> 같은 전위와 후위 증가(감소) 연산자는 연산해서 반환할 값만 정해주면 연산자를 어떻게 사용하느냐에 따라 컴파일러가 알아서 전위 혹은 후위 연산을 처리해준다.<br><code>inc</code>와 <code>dec</code>을 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">inc</span><span class="params">()</span></span> : Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(++x, ++y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(p2++)</span><br><span class="line">println(++p2)</span><br></pre></td></tr></table></figure><h1 id="비교-연산자-오버로딩"><a href="#비교-연산자-오버로딩" class="headerlink" title="비교 연산자 오버로딩"></a>비교 연산자 오버로딩</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>코틀린에서 <code>==</code>가 참조 주소를 비교하는 동일성 비교가 아닌 값을 비교하는 동등성 비교로 작동한다. 이를 가능하게 하는 것도 관례의 힘이다.<br>대략 다음과 같은 코드가 작동하는 셈이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a == b</span></span><br><span class="line">a?.equals(b) ?: (b == <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>참고로 <code>!=</code> 또한 <code>==</code>의 결과를 반전시키면 되니 자연스럽게 지원된다.</p><h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h2><p>코틀린에서 관례를 통해 <code>compareTo</code>를 <code>&lt;,&gt;, &lt;=, &gt;=</code>로 해결할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>) : Comparable&lt;Point&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Point</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> compareValuesBy(<span class="keyword">this</span>, other, Point::x, Point::y) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Point(<span class="number">3</span>, <span class="number">4</span>) &lt;= Point(<span class="number">4</span>, <span class="number">3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Point가 Comparable을 구현하여 <code>compareTo</code>를 재정의 했다. 이때 기존 인터페이스에 <code>operator</code> 선언이 되어 있어서 위 예시에는 생략됐다.</p><h1 id="컬렉션과-범위에-대해-쓸-수-있는-관례"><a href="#컬렉션과-범위에-대해-쓸-수-있는-관례" class="headerlink" title="컬렉션과 범위에 대해 쓸 수 있는 관례"></a>컬렉션과 범위에 대해 쓸 수 있는 관례</h1><p>코틀린에서 관례를 통해 컬렉션의 원소에 접근해 읽거나 쓰는 연산을 함수가 아닌 연산자로 할 수 있다.</p><h2 id="인덱스로-원소에-접근-get과-set"><a href="#인덱스로-원소에-접근-get과-set" class="headerlink" title="인덱스로 원소에 접근: get과 set"></a>인덱스로 원소에 접근: get과 set</h2><p><code>mutableMap[key] = newValue</code> 처럼 코틀린에서는 맵에서 대괄호로 원소에 접근하거나 원소를 쓸 수 있다.<br>코틀린에서는 이를 인덱스 연산자라고 한다. Map과 MutalbeMap 인터페이스에는 두 메서드가 이미 들어있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; x</span><br><span class="line">        <span class="number">1</span> -&gt; y</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">when</span>(index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="keyword">this</span>.x = value</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="keyword">this</span>.y = value</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">println(point[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line">point[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">println(point[<span class="number">0</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="in-관례"><a href="#in-관례" class="headerlink" title="in 관례"></a>in 관례</h2><p>코틀린에서 지원하는 in 연산자는 contains 함수에 대응한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">contains</span><span class="params">(other: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> other.x &lt;= x &amp;&amp; other.y &lt;= y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Point(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">in</span> Point(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="rangeTo-관례"><a href="#rangeTo-관례" class="headerlink" title="rangeTo 관례"></a>rangeTo 관례</h2><p>범위를 만드는 <code>..</code> 연산자는 rangeTo 함수에 대응한다.<br>알아둘 점은 Comparable 인터페이스를 구현하면 rangeTo를 구현할 필요가 없다. 왜냐면 코틀린 표준 라이브러리에 Comparable 객체에 대해 적용 가능한 rangeTo 함수가 정의되어 있기 때문이다.<br>rangeTo는 다른 산술 연산자나 범위 메서드보다 우선순위가 낮아서 되도록 괄호로 감싸서 표현해주자.<br><code>0..(n + 1)</code> 이렇게 가독성을 높게 하거나 <code>(0..n).forEach &#123;...&#125;</code> 이렇게 컴파일이 되도록 할 수 있다.</p><h2 id="for-루프를-위한-iterator-관례"><a href="#for-루프를-위한-iterator-관례" class="headerlink" title="for 루프를 위한 iterator 관례"></a>for 루프를 위한 iterator 관례</h2><p>코틀린의 for 루프는 in 연산자를 사용한다. 하지만 contains에 대응하는 in과는 다른 연산자이다.<br><code>for (x in list) &#123;...&#125;</code> 이렇게 for 루프 안에 있는 in은 iterator 함수에 대응한다.<br>코틀린은 확장 함수를 통한 관례를 통해 문자열을 for 루프를 돌 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">iterator</span><span class="params">()</span></span>: CharIterator</span><br></pre></td></tr></table></figure><p>특정 클래스에 적용도 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> ClosedRange<span class="type">&lt;Point&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;Point&gt; =</span><br><span class="line">    <span class="keyword">object</span> : Iterator&lt;Point&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> current = start</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = current &lt;= endInclusive</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: Point = current.apply &#123; current = Point(current.x + <span class="number">1</span>, current.y + <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="구조-분해-선언과-component-함수"><a href="#구조-분해-선언과-component-함수" class="headerlink" title="구조 분해 선언과 component 함수"></a>구조 분해 선언과 component 함수</h1><p>구조분해 선언을 관례로 구현하면 다음과 같은 코드를 가능하게 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> (x, y) = point</span><br><span class="line">println(x) <span class="comment">// 1</span></span><br><span class="line">println(y) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>구조분해 선언은 내부적으로 다음과 같이 작동한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val (x, y) = point</span></span><br><span class="line"><span class="keyword">val</span> x = point.component1()</span><br><span class="line"><span class="keyword">val</span> y = point.component2()</span><br></pre></td></tr></table></figure><p>즉 componentN 함수에 대응한 관례를 만들면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component2</span><span class="params">()</span></span> = y</span><br></pre></td></tr></table></figure><p>구조 분해 선언은 Map과 for 루프에서 효과적이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Map의 Entry가 확장함수로 구조 분해를 제공해서 위와 같은 코드가 가능하다.</p><h1 id="프로퍼티-접근자-로직-재활용"><a href="#프로퍼티-접근자-로직-재활용" class="headerlink" title="프로퍼티 접근자 로직 재활용"></a>프로퍼티 접근자 로직 재활용</h1><p>위임 프로퍼티에도 코틀린의 관례가 뒷받침 된다. 위임 프로퍼티를 사용하면 값을 뒤받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있다.</p><h2 id="위임-프로퍼티-소개"><a href="#위임-프로퍼티-소개" class="headerlink" title="위임 프로퍼티 소개"></a>위임 프로퍼티 소개</h2><p>위임 프로퍼티의 일반적인 문법은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로퍼티 p는 접근자 로직을 다른 객체(Delegate)에게 위임한다.<br>컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다.<br>프로퍼티 p는 자신의 작업을 위임 객체에게 전달한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate = Delegate()</span><br><span class="line">    <span class="keyword">var</span> p: Type</span><br><span class="line">    <span class="keyword">set</span>(value:Type) = delegate.setValue(..., value)</span><br><span class="line">    <span class="keyword">get</span>() = delgate.getValue(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 위임 프로퍼티를 위해 생성된 위임객체는 setValue와 getValue 메서드 호출을 통해 위임한다.<br>위임 프로퍼티를 위한 위임 객체이 되려면 setValue와 getValue 메서드를 가져야 한다.<br>다양한 매개변수가 있지만 현재 기본 구조 설명을 위해 생략했다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(...)</span></span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(..., value: <span class="type">Type</span>)</span></span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="위임-프로퍼티-사용-by-lazy-사용한-프로퍼티-초기화-지연"><a href="#위임-프로퍼티-사용-by-lazy-사용한-프로퍼티-초기화-지연" class="headerlink" title="위임 프로퍼티 사용: by lazy() 사용한 프로퍼티 초기화 지연"></a>위임 프로퍼티 사용: by lazy() 사용한 프로퍼티 초기화 지연</h2><p>Person 클래스의 email을 가져오는 loadEmail 메서드가 오래걸리는 작업이라 최초 접근에만 초기화하는 경우를 생각해보자.<br>만약 뒷받침하는 프로퍼티 기법을 사용하면 다음과 같이 null로 초기화 해놓고 사용할 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _emails: List&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> emails:List&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_emails == <span class="literal">null</span>) _emails = loadEmail()</span><br><span class="line">            <span class="keyword">return</span> emails</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 이 방법은 코드가 복잡하고 스레드 안전하지도 않다!</p><p>위임 프로퍼티를 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> emails: List&lt;String&gt; <span class="keyword">by</span> lazy &#123; loadEmail() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lazy는 첫 호출 시 지연 초기화하는 함수이고 람다를 매개변수로 받는다.<br>lazy는 기본적으로 스레드 안전하고 필요에 따라 락을 람다에 전달할 수 있고, lazy가 동기화를 하지 못하게 할 수도 있다.</p><h2 id="위임-프로퍼티-컴파일-규칙"><a href="#위임-프로퍼티-컴파일-규칙" class="headerlink" title="위임 프로퍼티 컴파일 규칙"></a>위임 프로퍼티 컴파일 규칙</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 코드가 있다고 할 때 컴파일러는 Delegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티를 &lt;delegate&gt;라는 이름으로 부른다. 컴파일러는 프로퍼티를 포현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 &lt;property&gt;라는 이름으로 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> &lt;delegate&gt; = Delegate()</span><br><span class="line">    <span class="keyword">var</span> p: Type</span><br><span class="line">    <span class="keyword">get</span>() = &lt;delegate&gt;.getValue(<span class="keyword">this</span>, &lt;property&gt;)</span><br><span class="line">    <span class="keyword">set</span>(value: Type) = &lt;delegate&gt;.setValue(<span class="keyword">this</span>, &lt;property&gt;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위임 프로퍼티의 특징을 보면 프로퍼티를 꼭 초기화 하지 않아도 된다. 즉 프로퍼티 값이 저장될 곳을 바꿀 수 있고 간단한 로직을 추가할 수 도 있다.</p><h2 id="프로퍼티-값을-맵에-저장"><a href="#프로퍼티-값을-맵에-저장" class="headerlink" title="프로퍼티 값을 맵에 저장"></a>프로퍼티 값을 맵에 저장</h2><p>프로퍼티를 동적으로 정의할 수 있는 확장 가능한 객체라고 부른다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = _attributes[<span class="string">&quot;name&quot;</span>]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 프로퍼티를 담을 수 있는 맵을 가지고, 필수 프로퍼티를 선언하고 접근 로직을 맵을 통해 가져오도록 구현했다.<br>이를 위임 프로퍼티로 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>by 뒤에는 위임 객체가 와야 한다. Map과 MutableMap은 기본적으로 getValue와 setValue를 제공하기 때문에 가능하다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/kotlin-in-action/">Kotlin in Action</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>퀴즈로 학습하는 운영체제와 정보기술의 원리</title>
      <link>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/</link>
      <guid>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/</guid>
      <pubDate>Sun, 22 Jan 2023 13:39:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;3장&quot;&gt;&lt;a href=&quot;#3장&quot; class=&quot;headerlink&quot; title=&quot;3장&quot;&gt;&lt;/a&gt;3장&lt;/h1&gt;&lt;details&gt;
  &lt;summary&gt;메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?&lt;/summary&gt;
  컨트롤러라는</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="3장"><a href="#3장" class="headerlink" title="3장"></a>3장</h1><details>  <summary>메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?</summary>  컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.</details><details>  <summary>운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가</summary>운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코드만 메모리에 올리는데, 이 코드를 커널이라고 부른다.  </details><details>  <summary>입출력 장치에서 읽어온 데이터를 임시 저장하는 하드웨어 장치는 무엇이라고 하는가?</summary>  컨트롤러는 데이터를 데이터를 입출력 장치로 보내거나 가져오기 전에 임시 저장하는 메모리를 로컬 버퍼라고 한다.</details><details>  <summary>데이터를 읽어오는 명령을 컨트롤러가 완료하여 로컬 버퍼로 읽어오는 작업을 완료한 경우 어떻게 CPU에게 해당 사실을 알리는가? 그 사실을 안 CPU는 어떻게 행동하는가?</summary>  컨트롤러는 데이터를 모두 읽어온 경우, CPU의 인터럽트 라인에 인터럽트를 추가하여 해당 작업을 완료했음을 알린다. CPU는 매번 명령을 실행하기 전에 자신의 인터럽트 라인을 확인해서 처리해야할 인터럽트가 있는지 확인한다. 인터럽트가 존재하는 경우 인터럽트 벡터를 통해 인터럽트 처리 루틴이 존재하는 주소로 가서 인터럽트에 맞는 처리 로직을 실행한다.</details><details>  <summary>인터럽트의 종류와 각 종류의 차이점을 설명해보자.</summary>  인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 입출력 컨트롤러같은 하드웨어가 인터럽트 라인을 설정하고, 소프트웨어 인터럽트는 소프트웨어가 인터럽트 라인을 설정한다.</details><details>  <summary>소프트웨어 인터럽트의 종류에 대해 설명해보자.</summary> 소프트웨어 인터럽트는 예외 상황과 시스템콜과 있다. 예외상황은 프로세스가 잘못된 메모리를 접근하려거나 값을 0으로 나누려는 잘못된 연산을 할 때 발생한다. 반면 시스템콜은 사용자 프로그램이 운영체제 코드를 사용해야 할 때 운영체제에게 해당 코드를 실행해주기를 요청하는 방법이다.</details><details>  <summary>인터럽트를 처리할 때 CPU의 상태를 어떻게 저장되는가?</summary>  인터럽트를 처리해야 할 때 CPU의 레지스터 값, 하드웨어 상태, 실행 중인 코드 메무리 주소, 실행중인 위치 등을 PCB에 저장하고 CPU의 레지스터를 지운 다음 인터럽트 루틴을 실행한다.</details><details>  <summary>입출력 방식 두가지에 대해서 설명해보자.</summary>  입출력은 동기식 입출력, 비동기식 입출력이 있다. 동기식 입출력은 한 프로세스가 CPU를 점유해 진행 중에 입출력을 해야 하는 경우 그 프로세스가 해당 입출력 작업이 완료될 때까지 기다리고 CPU는 해당 프로세스의 점유를 뺏고 다른 프로세스를 진행시키는 방식이다. 이때 입출력 작업 완료를 기다리는 프로세스는 봉쇄 상태가 되어서 CPU 자원을 할당받지 못하게 된다. 반면 비동기식 입출력은 입출력을 해야 하는 경우 해당 입출력이 끝날 때까지 기다리지 않고 해당 프로세스에서 입출력 작업이 완료되지 않아도 수행할 수 있는 작업을 이어서 진행한다.</details><details>  <summary>동기식 입출력에서 입출력 발생 시 다른 프로세스에게 CPU를 할당했을 때 이 프로세스에서도 입출력이 발생하면 어떤 문제가 발생할 수 있고 이를 어떻게 방지하는가?</summary>  만약 먼저 실행하던 프로세스에서 입출력이 발생해서 다른 프로세스에게 CPU를 할당했는데 다음 프로세스도 입출력이 발생하면 여러 입출력 요청이 발생할 수 있다. 이 경우 입출력의 동기화가 지켜지지 않는 문제가 발생할 수 있다. 나중에 실행된 프로세스의 입출력 요청을 먼저 수행하고 처음 프로세스의 입출력이 같은 자원에 대한 입출력 요청을 했을 때 처음 프로세스는 예상하지 못한 결과를 얻을 수 있다. 이를 막기 위해 장치 별로 큐를 두어 요청한 순서대로 처리할 수 있게 한다.</details><details>  <summary>DMA라는 장치의 필요성에 대해 설명해보시오</summary>  입출력이 완료되어 로컬버퍼에 담긴 내용을 메모리에 올려야 할 때, 컨트롤러가 인터럽트 라인을 세팅해서 CPU가 메모리에 데이터를 적재하도록 한다. 문제는 이런 입출력 처리를 매번 인터럽트를 통해 CPU가 메모리에 적재하도록 하면 너무 여러번 CPU는 인터럽트 처리를 해야된다. DMA는 CPU가 메모리에 로컬버퍼의 데이터를 적재하는 일을 대리한다. 그래서 로컬버퍼 데이터를 메모리에 적재하는 일 때문에 CPU가 인터럽트 당하지 않도록 한다. DMA는 바이트 단위가 아니라 블록이라는 단위로 메모리를 읽어온 후 다 읽어온 경우 CPU에게 인터럽트를 통해 완료를 알린다.</details><details>  <summary>저장장치 계층 구조에 대해 설명해보자.</summary>  컴퓨터의 저장장치는 주기억장치와 보조기억장치로 나뉜다. 주기억장치는 메모리를 휘발성이고 일반적으로 RAM을 매체로 사용한다. 보조기억장치는 비휘발성으로 하드디스크나 SSD를 매체로 사용한다. 저장장치 계층 구조는 레지스터 - 캐시 메모리 - 메인 메모리 - 마그네틱 디스크- 광디스크- 마그네틱 테이프 이런 구조로 빠를 수록 비싸고 용량이 적다. 앞 세가지는 주기억장치이고 나머지는 보조기억장치이다.</details><details>  <summary>보조기억 장치의 목적에 대해 설명해보자. 각 목적의 비교를 해보자</summary>  보조기억 장치는 비휘발성의 특징을 통해 파일 시스템을 구현하는데 사용된다. 또한 주기억장치인 메모리의 연장 공간인 스왑 영역 역할을 한다. 운영체제는 프로그램 수행에 당장 필요하지 않은 부분은 디스크 스왑 영역에 적재한다. 이렇게 스왑 아웃된 영역은 필요하게 될 때 메모리에 올려서 사용하게 된다. 파일 시스템은 비휘발성을 활용하지만 스왑 영역은 메모리의 연장이므로 휘발성인 특징을 나타낸다.</details><details>  <summary>캐싱 기법에 대해서 설명하고 왜 효과적인지 설명해라.</summary>  상대적으로 빠른 저장장치를 이용해 느린 저장장치의 선응을 향상 시키는 총체적 기법을 일컫는다. 느린 저장장치에서 자주 사용되거나 당장 사용되는 정보를 빠른 저장장치에 선별적으로 저장해서 두 저장 장치 사이의 속도를 완충시킨다. 컴퓨터 내의 데이터나 프로그램을 구성하는 부분이 균등하게 사용되지 않고 일부분만 주로 사용하는 특성이 있기 때문에 적은 양의 캐시로도 효과를 볼 수 있다.</details><details>  <summary>하드웨어 보안이 필요한 이유와 어떻게 달성하는 지 설명해보라</summary>  여러 프로그램이 실행될 때 다른 프로그램의 메모리 영역에 침범하는 일이 발생할 수 있다. 이런 문제를 막기 위해 운영체제는 커널모드와 사용자모드를 분리해서 사용자 프로그램이 보안에 예민한 부분을 직접 제어하지 못하게 막고 운영체제에게 서비스를 요청하는 방식으로 구현했다. 모드비트를 통해 사용자 프로그램이 어떤 모드인지 검증하는 방식으로 위험한 연산을 하지 못하도록 막는다.</details><details>  <summary>메모리 보안을 어떻게 달성하는 지 설명해보고 한계를 설명해보라</summary>  사용자 프로그램이 정해진 메모리 주소 이내에 위치할 수 있도록 기준 레지스터와 한계 레지스터를 정해서 시작주소와 끝 주소를 정해놓는다. 해당 프로그램으로 직접 접근하려는 주소가 기준 레지스터와 한계 레지스터 사이에 없다면 잘못된 접근이라고 판단한다. 다만 이는 하나의 프로그램이 연속적으로 위치하는 단순한 메모리 관리 기법을 사용하는 경우로 한정했을 때 가능하다.</details><details>  <summary>한 프로그램이 CPU의 자원을 오랫동안 독점하는 상황을 막는 역할을 하는 하드웨어에 대해 설명해보자.</summary>  타이머라는 하드웨어를 통해 여러 프로그램이 돌아가면서 CPU를 점유하도록 한다. 특정 시간이 지나면 인터럽트를 일으켜서 운영체제가 CPU 제어권을 획득할 수 있도록 하는 역할을 수행한다.</details><h1 id="4장"><a href="#4장" class="headerlink" title="4장"></a>4장</h1><details>  <summary>CPU에서 프로그램이 실행되려면 메모리에 적재가 되어야 한다. 이때 프로그램 메모리 구조에 대해 설명해보자.</summary>  프로그램 메모리 구조는 네가지로 나뉜다. 소스 코드가 기계어로 변역된 코드가 저장되는 코드 영역, 프로그램의 전역 변수가 저장되는 데이터 영역, 프로그램에서 동적으로 할당된 메모리에 해당하는 힙 영역, 프로그램의 함수 호출 기록과 함수 내에서 사용한 지역 변수를 저장하는 스택 영역으로 나뉜다.</details장<details>  <summary>프로그램 내에서 함수 호출과 프로그램에서 인터럽트 발생 시 복귀 주소 저장 방식의 차이를 설명해보자.</summary>  사용자 프로그램의 함수 호출은 프로그램 메모리 구조 중 스택에 복귀 주소를 저장하고 호출한 함수로 이동해서 함수를 실행한다. 인터럽트 발생 시 복귀 주소는 커널의 메모리 구조 중 데이터 영역 속 PCB에 복귀 주소를 저장한다.</details><details>  <summary>프로그램 카운터 (PC)의 정의와 왜 필요한 지를 설명해보자.</summary>  CPU는 명령어를 하나씩 수행하는 역할을 한다. 이때 CPU가 읽어야할 명령어의 주소를 가리키는 것이 프로그램 카운터이다.</details><details>  <summary>일반명령과 특권명령에 대해 설명해보자.</summary>  일반 명령은 프로그램 메모리에 적재된 데이터를 읽거나 연산하거나 메모리에 데이터를 쓰는 일반적인 명령을 의미한다. 특권명령은 보안과 관련된 명령과 입출력하거나 타이머와 같은 장치가 관련된 명령을 의미한다.</details><details>  <summary>메모리에 프로그램을 적재할 때 프로그램의 모든 내용을 적재하지 않는다. 어떤 방식으로 적재하는 지 설명해보자.</summary>  운영체제는 프로그램에서 당장 필요한 부분만 메모리에 적재한다. 그렇지 않은 코드는 디스크에 스왑 영역에 적재하여 필요한 경우에 메모리에 올려 사용하도록 한다.</details><details>  <summary>커널 메모리 구조에서 스택 영역이 일반 프로그램 구조의 스택과 다른 특징에 대해 설명해보자.</summary>  일반 프로그램은 하나의 스택을 가지는 반면 커널 메모리 구조는 각 프로세스마다 스택을 두어서 분리해서 관리한다.</details><details>  <summary>커널 메모리 구조에서 데어터 영역에는 어떠한 자료구조가 있는지 설명해보자.</summary>  커널 데이터 영역에는 하드웨어와 프로세스를 관리하는 자료구조를 가지고 있다. 외부 입출력 장치를 통해 입출력하려는 프로세스를 줄세우는 큐가 있고, 각 프로세스의 상태 값을 저장하는 PCB가 있다.</details><details>  <summary>프로그램에서 함수 호출의 경우와 시스템콜이 발생하는 경우에 대해 프로그램과 커널의 메모리 구조를 중점으로 설명해보자.</summary>  프로그램에서 함수 호출은 프로그램 메모리의 스택에 복귀 주소를 저장하고 호출된 함수를 처리하고, 시스템콜이 발생하는 경우는 프로그램의 복귀 주소를 커널 메모리의 데이터 영역 속 PCB에 저장해놓고 스택 영역 속 해당 프로세스의 스택에서 실행되는 함수를 기록하고 실행한다.</details><details>  <summary>인터럽트 처리 중 다른 인터럽트가 발생을 허용하지 않는 이유를 설명해보고 만약 허용한다면 어떤 방식으로 처리하는 지 설명해보자.</summary>  인터럽트 처리 도중 다른 인터럽트가 발생해서 처리해야 하는 경우, 해당 인터럽트 루틴에서 사용하는 공유 데이터가 있다면 중간에 처리하는 인터럽트 때문에 공유 데이터의 일관성이 깨질 수 있다. 만약 허용한다면 인터럽트마다 우선 순위를 정해서 수행한다.</details><details>  <summary>일반적인 함수 호출을 다른 함수로 점프하는 반면 시스템콜은 어떻게 다른 코드로 이동하는 지 설명해보자. 그리고 왜 이런 차이가 있는지 설명해보자.</summary>  시스템콜에서 수행되어야 하는 코드는 프로그램의 메모리가 아닌 커널의 메모리에 있다. 이를 실행하려면 CPU 자원 점유를 운영체제가 해야 한다. 그래서 일반 함수 호출은 CPU 점유를 프로세스가 계속 가지지만 시스템콜은 CPU 점유를 운영체제가 하게 된다. 이 과정에서 인터럽트 라인을 세팅해서 CPU에 인터럽트를 발생시킨다.</details><details>  <summary>프로그램이 CPU를 할당받았다가 뺏기는 경우를 설명해보라.</summary>  CPU 할당된 시간이 다 되어서 타이머가 인터럽트를 발생시키거나 프로세스에서 동기식 입출력을 실행할 때 다른 프로그램에게 CPU 자원을 뺏기게 된다.</details><details>  <summary>프로그램이 실행 중이라는 의미는 해당 프로그램의 코드만 실행되는 것을 의미하진 않는다. 실행 될 수 있는 다른 코드를 설명해고 그런 경우에 어떻게 실행되고 있다고 하는지 설명해보자.</summary>  프로세스에서 시스템콜을 호출하는 경우 실행되어야 하는 코드는 해당 프로그램의 코드가 아닌 커널의 코드이다. 이럴 때는 여전히 해당 프로그램이 실행되고 있지만 커널 모드로 실행되고 있다고 말한다.</details><h1 id="5장"><a href="#5장" class="headerlink" title="5장"></a>5장</h1><details>  <summary>프로세스의 문맥이란 무엇일까요?</summary>  프로세스를 실행하기 위한 정보를 의미한다. 하드웨어, 운영체제, 프로세스 메모리 이렇게 세가지로 나뉜다. 하드웨어는 CPU의 PC나 레지스터 값들, 운영체제는 커널 메모리 데이터 영역의 PCB와 스택 영역의 해당 프로세스 커널 스택, 프로세스 메모리는 코드, 스택, 힙, 데이터 영역을 포함한 프로세스가 실행되기 위해 메모리에 올려져야 하는 내용을 말한다.</details><details>  <summary>프로세스의 상태를 설명해보세요?</summary>  프로세스 상태는 크게 6가지로 나뉜다.   시작 상태는 프로세스에 필요한 자료구조는 할당받았지만 아직 메모리를 할당받지 못한 상태이다.   준비 상태는 프로세스가 CPU 할당만 받으면 작업을 수행할 수 있는 상태를 의미한다.  실행 상태는 프로세스가 준비 상태에서 CPU 할당을 받아 작업을 실행 중인 상태다.  봉쇄 상태는 프로세스가 실행 도중 IO 작업 같이 먼저 선행되어야 하는 작업을 해야 해서 CPU를 다음 프로세스에게 넘기고 자신은 IO 작업이 완료될 때까지 대기하는 상태이다.  중지 상태는 외부 요인 때문에 프로세스가 작업을 진행할 수 없는 상태이다. 대표적으로 중기 스케줄러가 스왑 아웃한 프로세스가 중지 상태이다.  완료는 프로세스가 작업을 완수했으나 아직 프로세스와 관련된 자료구업가 아직 해제가 안된 상황이다.</details><details>  <summary>문맥 교환에 대해 설명해보세요</summary>  타이머 인터럽트나 IO 작업 발생으로 인해 실행 중인 프로세스가 다음 프로세스에게 CPU 자원을 넘겨줄 때 이전 프로세스가 실행되던 문맥을 저장하고, 다음 프로세스가 실행할 수 있는 문맥으로 바꾸는 행동을 문맥 교환이라고 한다.</details><details>  <summary>입출력을 진행하는 중이라 봉쇄된 프로세스 A와 지금 진행 중인 프로세스 B가 있다. 이때 디스크 컨트롤러가 인터럽트 라인을 설정하여 CPU가 이를 확인하고 인터럽트 처리 루틴을 실행하는 상황이라면 어떤 프로세스가 진행 중이라고 할 수 있을까?</summary>  이런 경우 아직 B 프로세스가 실행 중이라고 하며, 이때 B 프로세스가 커널 모드로 실행 중이라고 표현한다.</details><details>  <summary>문맥 교환에는 어떤 일이 벌어지는지 설명해보세요</summary>  이전에 실행되던 프로세스의 문맥을 PCB에 저장하고 다음 실행될 프로세스의 PCB를 통해 문맥을 하드웨어에 세팅한다.</details><details>  <summary>문맥 교환과 실행 모드 변경되는 상황의 차이를 설명해보세요</summary>  문맥 교환은 하드웨어 등 프로세스가 실행되는 문맥을 모두 바꾸는 것이지만, 실행 모드 변경은 여전히 같은 프로세스가 진행되고 있기 때문에 모든 문맥을 바꾸지 않고 PCB에 프로세스 명령어의 복귀 지점만 저장해놓는다.</details><details>  <summary>운영체제가 하드웨어와 소프트웨어를 관리하기 위한 큐를 커널의 메모리 구조 중 어떤 곳에서 관리할까요?</summary>  커널의 데이터 영역에서 하드웨어와 소프트웨어를 관리하는 자료구조를 관리한다.</details><details>  <summary>공유 데이터를 접근한 프로세스가 봉쇄 상태라면 다른 프로세스가 공유 데이터에 접근 할 수 있나요?</summary>  접근할 수 없다. 봉쇄 상태이더라도 공유 데이터 사용을 반납한 게 아니다. 프로세스가 공유 데이터 사용을 아직 반납하지 않은 상태에서 다른 프로세스가 이를 접근해서 수정하게 되면 데이터 일관성이 깨져서 기존에 사용하던 프로세스가 예상하지 못한 문제를 일으킬 수 있다.</details><details>  <summary>커널에서 프로세스 관리하는 큐의 종류에는 어떤 것이 있나요?</summary>  준비 상태인 프로세스를 줄 세운 준비큐,  입출력 장치 접근 권한을 줄세운 장치큐,  현재 모든 프로세스를 줄세운 작업큐</details><details>  <summary>단기, 중기, 장기 스케줄러에 대해 설명해보세요</summary>  단기 스케줄러는 준비큐의 프로세스 중 어떤 프로세스를 실행할 지 고른다.  중기 스케줄러는 메모리에 올라간 프로세스가 너무 많아 프로세스 실행이 효율적이지 않을 때 어떤 프로세스를 스왑 아웃할지 고른다. 일반적으로 봉쇄 상태에 있는 프로세스나 준비 상태에 있는 프로세스가 그 대상이 된다.  장기 스케줄러는 시작 상태인 프로세스 중 어떤 프로세스를 준비 상태로 할 지 고른다. 최근에는 메모리 용량이 넉넉해서 장기 스케줄러가 큰 의미가 없어졌다. </details><details>  <summary>부모와 자식 프로세스가 수행되는 모델 두 가지를 설명해보세요.</summary>  부모와 자식이 서로 동등한 입장으로 CPU 자원을 경쟁하는 경우가 있고, 자식 프로세스가 완료 될 때까지 부모 프로세스는 봉쇄 상태가 되는 경우가 있다.</details><details>  <summary>프로세스 간 협력 메커니즘인 IPC의 대표적인 방법 두가지를 설명해보세요.</summary>  공유 메모리 방식은 두 프로세스가 물리적으로 같은 메모리 공간을 참조하는 주소값을 같이 사용하는 방식이다.  메시지 전달 방식은 두 프로세스가 직간접적으로 연결해서 데이터 전달을 커널에게 의뢰하는 방식이다.</details><h1 id="6장"><a href="#6장" class="headerlink" title="6장"></a>6장</h1><details>  <summary>기계어 명령를 세가지로 분류하고 각 명령의 특징을 설명해보자.</summary>  CPU 명령어 : CPU 내부에서 레지스터 값을 제어하는 매우 빠른 명령  메모리 명령어 : 메모리에 값을 읽거나 쓰는 명령어 CPU 명령어보다는 느리지만 빠른 편이다.  입출력 명령어 : 하드웨어를 통해 입출력을 하는 명령어. 굉장히 느리다.</details><details>  <summary>CPU 스케줄링 기법이 필요한 이유는 무엇인가?</summary>  한정된 CPU 자원을 CPU 버스트가 각기 다른 프로세스들에게 효과적으로 분배하기 위해서 CPU 스케줄링이 필요하다.</details><details>  <summary>CPU 스케줄러는 어떤 일을 하는가?</summary>  준비 큐에 있는 프로세스 중 CPU를 할당받고 실행될 프로세스를 선정한다.</details><details>  <summary>CPU 스케줄러가 작동하는 여러 상황을 설명해보자.</summary>  타이머 인터럽트가 발생해서 실행 -> 준비 되는 경우  IO 요청에 의해 실행 -> 봉쇄 되는 경우  CPU 작업 완료되어 실행 -> 종료 되는 경우</details><details>  <summary>선점형과 비선점형 CPU 스케줄러를 구분지어 설명해보자.</summary>  선점형 스케줄러는 특정 프로세스가 실행 중일 때 실행 중인 프로세스보다 우선순위가 더 높은 프로세스가 준비큐에 진입하면 그 프로세스에게 CPU 자원을 넘기는 방식이다.  비선점형 스케줄러는 그런 경우에도 뺏기지 않는다.</details><details>  <summary>디스패처에 대해 설명해보자.</summary>  문맥교환이 일어날 때 PCB의 값을 하드웨어에 세팅해야 하는 일을 하는 운영체제 코드이다.</details><details>  <summary>스케줄링 성능 평가에 사용되는 다섯 가지 지표를 설명해보자.</summary>  CPU 이용률 : 주어진 시간동안 CPU가 작업을 처리한 시간 비율  처리량 : 주어진 시간동안 작업 완료한 프로세스 비율  소요 시간 : 한 프로세스가 CPU를 기다린 시간과 CPU 할당 받아 실행한 시간의 합  대기 시간 : 한 프로세스가 CPU 버스트동안 준비큐에서 기다린 시간  응답 시간 : 한 프로세스가 준비큐에 들어가서 처음 CPU를 할당받은 시간.</details><details>  <summary>선입선출 스케줄링의 장단점은?</summary>  먼저 온 프로세스를 완료할 때까지 CPU 자원 점유를 보장해주니 평균 소요시간과 평균 대기시간이 짧은 편이다. 하지만 CPU 버스트가 긴 프로세스가 점유하면 다른 프로세스들이 오랫동안 CPU를 점유하지 못하게 되는 콘보이 현상을 겪을 수 있다.</details><details>  <summary>최단 작업 우선 스케줄링의 장단점은?</summary>  CPU 버스트가 짧은 프로세스를 먼저 할당해서 IO 자원을 비교적 효율적으로 활용할 수 있고 선입선출 스케줄러의 콘보이 현상도 방지한다.   다만 준비큐에 CPU 버스트가 긴 프로세스가 있을 때 준비큐로 CPU 버스트가 짧은 프로세스가 계속 진입하면 CPU 버스트가 긴 프로세스는 CPU 자원을 점유하지 못하게 되는 기아 현상이 발생할 수 있다.</details><details>  <summary>우선순위 스케줄링의 장단점은?</summary>  우선순위 스케줄링도 기아 현상이 발생할 수 있다. 하지만 CPU 할당을 받지 못한 준비 상태의 프로세스들의 우선순위를 동적으로 한단계 올려주는 노화 기법으로 기아 현상을 해결할 수 있다.</details><details>  <summary>라운드 로빈 스케줄링에서 할당시간을 너무 길게 혹은 너무 짧게 설정하면 생기는 일에 대해 설명해보자.</summary>  라운드 로빈 스케줄링 할당 시간을 너무 늘리면 사실상 선입선출 스케줄링과 같아진다. 그래서 선입선출 스케줄링의 단점을 그대로 가져오게 된다.  할당 시간을 너무 짧게 하면 문맥 교환이 그만큼 더 자주 일어나게 되서 오버헤드가 커진다.</details><details>  <summary>선입선출 스케줄링에 비해 라운드 로빈 스케줄링의 장단점은?</summary>  라운드 로빈 스케줄링은 선입 선출에 비해 평해 소요시간이 길다는 단점이 있다. 하지만 평균 응답시간이 빠르다는 장점이 있다.</details><details>  <summary>멀티레벨 큐에 대해 설명해보자.</summary>  각 프로세스의 특징에 따라 여러 형태의 스케줄링 큐를 운영하는 방식이다. 응답을 빨리 해야되는 프로세스를 할당하는 라운드 로빈 전위 큐와 CPU 버스트가 긴 프로세스를 할당하는 선입 선출 후위 큐를 운영하는 방식으로 구현될 수 있다.</details><details>  <summary>멀티레벨 피드백 큐에 대해 설명해보자.</summary>  우선 순위가 다른 여러 큐를 운영하되, 프로세스가 각 큐를 이동할 수 있는 방식이다. 우선순위가 높은 큐에서 할당 받지 못하면 낮은 큐로 이동하는 방식인데, 이때 해당 프로세스의 우선순위를 높이는 노화 방식을 도입할 수 있다.</details><details>  <summary>스케줄링 알고리즘 평가 방법에 대해 설명해보자.</summary>  큐잉 모델, 시뮬레이션, 구현 및 실축</details><h1 id="7장"><a href="#7장" class="headerlink" title="7장"></a>7장</h1><details>  <summary>컴퓨터 시스템의 주소 체계의 32비트, 64비트는 어떤 의미인가?</summary>  주소 체계는 컴퓨터가 해당 비트만큼 서로 다른 메모리를 구분할 수 있다는 의미이다. 32비트 주소 체계는 2^32가지의 주소를 부여할 수 있다. 컴퓨터는 각 주소마다 1바이트를 부여하므로 32비트 주소 체계는 2^32 바이트 만큼의 주소 공간을 가진다.</details><details>  <summary>프로세스의 논리적 주소는 무엇인가?</summary>  프로세스마다 주어지는 독립된 논리적인 주소 공간을 의미한다.  </details><details>  <summary>주소 바인딩이란 무엇인가</summary>  각 프로세스의 독립된 논리적인 주소를 실제 물리적인 메모리 주소로 변환하는 과정을 말한다.  </details><details>  <summary>실행시간 바인딩에 대해 설명해보자.</summary>  프로세스의 논리적 주소에 매핑된 물리적 주소를 실행시간에서 바뀔 수 있는 바인딩 방법이다. 이 경우 물리적인 주소에 접근할 때마다 실제로 매핑되어 있는지 확인해야 한다. 이때 사용되는 것이 주소 매핑 테이블, 기준 레지스터, 한계 레지스터, MMU이다.  </details><details>  <summary>MMU 기법에 대해 설명해보자.</summary>  MMU(메모리 관리 유닛) 기법은 논리적 주소에 기준 레지스터를 더해서 물리적 주소를 찾아내는 기법이다. 이 기법은 기본적으로 프로세스의 물리적 주소 매핑이 연속되어 있다는 점을 전제로 한다. 각 프로세스마다 기준 레지스터가 달라지기 때문에 MMU는 문맥교환마다 새롭게 세팅되어야 한다.</details><details>  <summary>동적 로딩과 동적 연결에 대해 설명해보자.</summary>  동적 로딩은 프로세스의 모든 내용을 메모리에 적재하는 것이 아닌 필요한 내용만 적재하는 것을 의미한다. 필요하지 않은 내용은 스왑 영역에 두었다가 호출 시 메모리에 할당하는 방식으로 운영한다. 동적 연결은 여러 프로세스가 사용하는 라이브러리 파일을 하나만 메모리에 적재하고 여러 프로세스가 해당 파일을 공유해서 사용하도록 하는 기법이다.  </details><details>  <summary>중첩과 동적로딩의 차이를 설명해보자.</summary>  중첩은 메모리가 부족한 상태에서 큰 메모리 용량을 차지하는 프로세스를 당장 필요한 부분만 메모리에 적재하는 기술이다. 동적 로딩은 동시에 여러 프로세스를 메모리에 적재하기 위해 각 프로세스마다 필요한 부분을 적재하는 방식인 반면 중첩은 부족한 메모리에서 큰 프로세스를 나눠서 실행하기 위한 방법이다.</details><details>  <summary>연속할당 방식의 두가지 할당 방식에 대해 설명해보고 장단점을 설명해보자.</summary>  연속할당 방식은 고정 분할 방식과 가변 분할 방식이 있다. 고정 분할 방식은 메모리를 정해진 크기 만큼 균등하게 나눠서 각 조각 마다 프로세스를 할당하는 방식이다. 이 경우 프로세스가 할당되고 남은 부분인 내부 조각이 발생할 수 있다. 또한 각 조각대로 분할하고 남은 외부조각이 남을 수도 있다. 가변 분할 방식은 분할의 형태가 가변적으로 변하는 형태다. 이때 프로세스를 여러 공간 중 어디에 할당해야할 지 결정해야 하는 문제가 생길 수 있고, 가변 분할 방식도 외부조각 문제가 발생할 수 있다.  </details><details>  <summary>불연속할당 방식에서 페이징 기법에 대해서 설명해보자.</summary>  페이징 기법은 프로세스 메모리를 일정한 크기의 페이지로 균등하게 나눠서 물리적인 메모리를 균등하게 나눈 프레임에 불연속되게 할당하는 방식이다. 페이징 기법은 프로세스가 자신의 페이지가 어떤 프레임에 할당됐는 지 찾아 갈 수 있도록 페이지 테이블을 가진다.</details><details>  <summary>페이징 기법의 성능에서 문제와 해결 방법을 제시해라.</summary>  페이징 기법은 프로세스의 페이지가 실제 물리적인 주소를 찾아야 한다. 이 과정에서 페이지 테이블을 순회하면서 자신의 물리적인 주소를 찾게 되므로 오버헤드를 갖게 된다. 이를 해결하기 위해 TLB라는 캐시를 활용한다. TLB는 병렬로 엔트리를 순회해서 더 빠르게 매핑된 물리 주소를 얻을 수 있다. 다만 TLB는 문맥교환 때 지워진다.</details><details>  <summary>불연속할당 방식에서 세그먼테이션 기법에 대해서 설명해보자.</summary>  세그멘테이션 기법은 균등하게 프로세스 메모리를 나눠서 할당하는 것이 아닌 의미에 따라서 분할 하여 할당하는 방식이다. 크기가 가변적이라 외부조각 문제가 생길 수 있는데, 이를 방지하기 위한 페이지드 세그먼테이션 기법이 있다. 먼저 의미 기준으로 메모리를 나누고 나뉜 메모리들을 균등한 페이지로 다시 나눠서 불연속되게 프레임에 할당하는 방식이다. 이 경우 1차로 세그먼트 테이블, 2차로 페이지 테이블을 통해 물리적인 주소를 찾는다.  </details>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/os/">OS</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/">운영체제와 정보기술의 원리</category>
      
      
      <comments>https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
