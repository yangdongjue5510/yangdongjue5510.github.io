<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mudura | 그거 뭐더라</title>
    <link>https://yangdongjue5510.github.io/</link>
    
    <atom:link href="https://yangdongjue5510.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>This is yangdongjue5510 dev blog.</description>
    <pubDate>Fri, 28 Jan 2022 15:27:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>hello</title>
      <link>https://yangdongjue5510.github.io/2022/01/29/hello/</link>
      <guid>https://yangdongjue5510.github.io/2022/01/29/hello/</guid>
      <pubDate>Fri, 28 Jan 2022 15:27:27 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/01/29/hello/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>데이터베이스 설계 프로세스</title>
      <link>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/</link>
      <guid>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/</guid>
      <pubDate>Thu, 06 Jan 2022 13:35:42 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;요약&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;데이터베이스 설계 과정을 배운다.&lt;/p&gt;
&lt;p&gt;실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다.&lt;/p&gt;
&lt;h1 id=&quot;임무-목표와-임무-명세</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>요약</p></blockquote><p>데이터베이스 설계 과정을 배운다.</p><p>실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다.</p><h1 id="임무-목표와-임무-명세-정의"><a href="#임무-목표와-임무-명세-정의" class="headerlink" title="임무 목표와 임무 명세 정의"></a>임무 목표와 임무 명세 정의</h1><p>임무 명세 : 이 데이터베이스의 존재 이유나 목적을 단순한 한 문장으로 정리</p><p>임무 목표 : 이 데이터베이스가 수행해야 할 작업을 정리.</p><p>이렇게 작성된 목표와 임무 명세는 사용자와 관리자에게 타당해야 한다.<br>각 임무 목표는 하나의 작업을 너무 디테일하지 않을 정도로 기술한다.</p><blockquote><p>예시</p></blockquote><p>임무 명세 : 함께 모으기 데이터베이스는 Sable의 함께모으기(저축 챌린지)에 필요한 데이터를 관리한다.</p><p>임무 1. 챌린지의 정보를 완전히 관리한다.<br>임무 2. 사용자의 정보를 완전히 관리한다.<br>임무 3. 챌린지마다 사용자가 작성한 리뷰를 관리한다.<br>임무 4. 사용자의 계좌를 관리한다.<br>임무 5. 챌린지의 계좌를 관리한다.</p><h1 id="기존-데이터베이스-분석"><a href="#기존-데이터베이스-분석" class="headerlink" title="기존 데이터베이스 분석"></a>기존 데이터베이스 분석</h1><p>해당 데이터베이스의 사용자와 관리자의 요구사항을 인터뷰. 기존의 데이터베이스 분석.</p><p>인터뷰를 통해 대상과 사건을 특정할 수 있다.<br>(<strong>사용자</strong>는 <strong>챌린지</strong>에 참여해서 <strong>규칙</strong>에 따라 <strong>저축</strong> 을 한다.)<br>여기서 대상은 사용자, 챌린지, 규칙, 저축이다.</p><p>대상을 정리했으면, 각 대상에 대한 특징을 찾아낼 수 있다.</p><p>이 과정에서 예상되는 필드를 구성할 수 있다.</p><ul><li>어떤 대상이, 어떤 특징을 가지는 지 분석</li><li>특정 대상의 특징을 설명하는게 필드다.</li><li>값 목록(특별한 값의 집합을 나타내는 특성)은 따로 표시한다.</li><li>계산된 필드는 따로 정리한다.</li><li>중복된 특성은 하나의 필드로 정리한다.(혹은 여러개로 나눠야 할 특성은 분해한다.)</li></ul><blockquote><p>예시</p></blockquote><h4 id="일단-우리-서비스에-요구사항을-정리해본다"><a href="#일단-우리-서비스에-요구사항을-정리해본다" class="headerlink" title="일단 우리 서비스에 요구사항을 정리해본다."></a>일단 우리 서비스에 요구사항을 정리해본다.</h4><p>사용자는 이름, 이메일, 생년월일, 닉네임, 성별, 비밀번호, 하나의 사용자 계좌와 여러 개의 챌린지 계좌를 가진다.<br>챌린지는 챌린지 호스트, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표 금액,  챌린지 성공한 사람들의 리뷰를 가진다.<br>챌린지는 챌린지 모드와 자유 모드가 있다.<br>챌린지 모드는 패널티 금액을 가진다.<br>자유 모드는 패널티 금액이 없다.<br>챌린지는 정해진 시간 전에 모집을 시작해서 시작일이 되면 모집을 마감한다.<br>사용자는 각 챌린지에서 자신이 원할 때 원하는 금액을 사용자 계좌에서 빼서 챌린지 계좌에 저축할 수 있다.<br>각 챌린지 계좌에 사용자가 저금한 내용은 저장된다.<br>….</p><h4 id="이제-대상을-정리해본다-대상은-사람-장소-물건-사건-등…"><a href="#이제-대상을-정리해본다-대상은-사람-장소-물건-사건-등…" class="headerlink" title="이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)"></a>이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)</h4><p>사용자, 챌린지, 호스트, 리뷰, 사용자 계좌, 챌린지 계좌</p><h4 id="이제-대상마다-특징을-정리해본다-계산된-필드와-값-목록-필드를-구분한다"><a href="#이제-대상마다-특징을-정리해본다-계산된-필드와-값-목록-필드를-구분한다" class="headerlink" title="이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.)"></a>이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.)</h4><p> 특징(필드) : 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표금액, 챌린지 패널티 금액, 챌린지 공식 여부, 챌린지 모드</p><p>값 목록 필드 : 사용자가 가지는 챌린지 계좌들, 챌린지에 참여한 사용자들, 사용자가 한 챌린지에 저금한 내용들, 사용자가 참여한 챌린지들, 사용자가 만든 챌린지들</p><p>계산된 필드 : 사용자의 미션 달성율, 사용자의 챌린지 예금 합, 사용자의 챌린지 저축액 / 챌린지 목표 금액, 챌린지의 참여 사용자 합</p><h1 id="데이터-구조-생성"><a href="#데이터-구조-생성" class="headerlink" title="데이터 구조 생성"></a>데이터 구조 생성</h1><ol><li>예비 필드 목록이 존재하면 이를 기반으로 대상에 할당해본다.(대상을 잘 설명하는 것 같은 필드를 할당)<ul><li>예비 필드 목록을 검토하는 중 새로운 대상이 필요하면 추가한다.</li></ul></li><li>앞 단계들을 통해 표현할 다양한 대상를 선정하여 테이블들에 할당한다.<br>(<em>처음 테이블을 만들면 모든 테이블은 데이터 테이블이 된다.</em>)<ol><li>데이터 테이블 : 조직에 중요한 주제를 나타냄</li><li>연결 테이블 : 다대다 관계의 두테이블의 연결 설정</li><li>부분 집합 테이블 : 특정 데이터 테이블과 관계. 특정 주제를 구체적으로 설명.<br>부분 집합 테이블은 데이터들이 해당 필드를 모두 사용하지 않은 경우가 많은 경우를 말한다.<br>(재고 테이블은 책 테이블과 장비 테이블을 하위 테이블로 만들 수 있다. (이는 서로 1대1 관계를 가진다.))</li><li>검증 테이블 : 데이터 무결성을 제공하는 중요한 테이블</li></ol></li><li>각 테이블의 필드들 할당하고 검토<ul><li><strong>좋은 필드의 조건</strong>을 따르는지 확인</li><li>필드들이 단독 값을 저장.</li><li>다중 구조나 다중값 필드는 개선</li><li>부분 집합 테이블을 구성한다.</li></ul></li><li>각 테이블 키 설정<ul><li>각 키는 데이터베이스에서 유일하게 식별할 수 있는 값이어야 한다.<br>(부분 집합 테이블을 제외하면 동일한 기본키를 가지면 안된다.)</li><li>만약 마땅한 키가 없는 경우, 인위적인 키를 만들어줄 수 있다.</li></ul></li><li>데이터베이스 각 필드의 필드 명세 설정<ul><li>일반적 요소 : 필드 이름, 소속 테이블 등…</li><li>물리적 요소 : 데이터 타입, 길이, 문자 지원 등..</li><li>논리적 요소 : 키 종류, 유일성, 널 지원, 기본값 등..</li></ul></li></ol><h5 id="좋은-필드의-조건"><a href="#좋은-필드의-조건" class="headerlink" title="좋은 필드의 조건"></a>좋은 필드의 조건</h5><ul><li>테이블의 대상의 특성을 잘 설명하는 필드가 되도록 한다.</li><li>필드는 단 하나의 값을 포함한다</li><li>더 작은 구성요소로 해체 될 수 없다.</li><li>계산되거나 연결된 값은 포함하지 않는다.</li><li>전체 데이터베이스에서 해당 필드는 유일하다.(연결되는 필드 외에..)</li><li>다중 부분 필드는 여러 필드로 나눠준다. (이름 -&gt; 성 , 이름)</li><li>다중값 필드는 새로운 테이블로 분리해서 사용한다.</li></ul><blockquote><p>예시</p></blockquote><h4 id="예비-필드-목록을-대상에-할당"><a href="#예비-필드-목록을-대상에-할당" class="headerlink" title="예비 필드 목록을 대상에 할당"></a>예비 필드 목록을 대상에 할당</h4><p>사용자 - 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부</p><p>챌린지 - 챌린지 식별아이디, 챌린지 이름, 시작일, 종료일, 내용, 주기, 목표금액, 패널티 금액, 챌린지 공식여부, 챌린지 모드, 챌린지 유효 여부</p><p>사용자 계좌 - 계좌 소유자, 계좌 잔고</p><p>챌린지 계좌 - 계좌 소유자, 계좌 잔고, 소속 챌린지 아이디</p><p>리뷰 - 리뷰 작성자 이메일, 리뷰 내용, 리뷰 작성 날짜, 리뷰의 챌린지 아이디</p><h4 id="값-목록-필드는-다른-테이블로-분리하고-종속되는-주제는-부분-집합-테이블로-만든다"><a href="#값-목록-필드는-다른-테이블로-분리하고-종속되는-주제는-부분-집합-테이블로-만든다" class="headerlink" title="값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다"></a>값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다</h4><p>챌린지의 태그는 따로 일대다 관계를 가지는 태그 테이블로 따로 빼서 만들고,</p><p>계좌 - 사용자 입출금 계좌 &amp; 챌린지 계좌 구조는 종속되는 주제인 사용자 계좌와 챌린지 계좌를 따로 부분집합 테이블로 만든다.</p><h1 id="테이블-관계-연결-및-결정"><a href="#테이블-관계-연결-및-결정" class="headerlink" title="테이블 관계  연결 및 결정"></a>테이블 관계  연결 및 결정</h1><p>테이블은 1대1, 1대다, 다대다 관계가 있다.<br>다만 다대다 관계는 주의해야 한다.</p><h5 id="다대다-관계의-문제"><a href="#다대다-관계의-문제" class="headerlink" title="다대다 관계의 문제"></a>다대다 관계의 문제</h5><p>다대다 관계로 외래키를 도입하면 그 외래키가 중복 데이터가 많이 발생한다.<br>그리고 만약 하나만 관계를 맺는 튜플을 삭제하면, 그 관계를 맺는 다른 테이블의 해당 튜플이 삭제될 수 있다.</p><p>학생과 수업 테이블이 다대다이고 서로 id을 외래키로 연결한다고 하면,<br>학생 테이블의 수업id가 중복되는 데이터가 많아진다.<br>한 학생만 듣는 수업이 있다고 했을 때, 그 학생을 삭제하면 그 수업이 삭제될 수 있다.</p><ol><li>테이블 관계와 관계의 특징을 확인</li><li>기본 키나 연결 테이블을 통해 각 관계에 있는 테이블 간의 논리적인 연결 설정.</li><li>각 테이블에 대한 참여의 유형과 정도를 결정</li></ol><h1 id="업무-규칙-정의-및-결정"><a href="#업무-규칙-정의-및-결정" class="headerlink" title="업무 규칙 정의 및 결정"></a>업무 규칙 정의 및 결정</h1><ol><li>데이터베이스의 다양한 측면에서 제약사항 확인</li><li>업무 규칙 설정</li><li>검증 테이블을 정의, 구현</li></ol><h1 id="뷰의-정의-및-결정"><a href="#뷰의-정의-및-결정" class="headerlink" title="뷰의 정의 및 결정"></a>뷰의 정의 및 결정</h1><ol><li>데이터로 작업하는 다양한 방법을 확인 (상세 정보 조회, 요약 조회 등..)</li><li>적당한 테이블과 필드를 활용해서 뷰를 정의(뷰의 표준을 정할 수 있음.)</li></ol><h1 id="데이터-무결성-재확인"><a href="#데이터-무결성-재확인" class="headerlink" title="데이터 무결성 재확인"></a>데이터 무결성 재확인</h1><ol><li>설계된 테이블이 잘 설계된 테이블인지 확인</li><li>필드가 적절한 구조인지 확인</li><li>테이블 수준 무결성 확인</li><li>필드 명세 점검, 무결성 점검</li><li>관계 유효성 점검, 각 테이블 참여 특징 명확히 결정.</li><li>데이터베이스의 다양한 측면에 있는 제약사항 결정</li></ol>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/database/">Database</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한 테크코스 4기 최종 코딩테스트 후기</title>
      <link>https://yangdongjue5510.github.io/2021/12/19/java/utecoprecourse4/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/19/java/utecoprecourse4/</guid>
      <pubDate>Sun, 19 Dec 2021 12:39:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;최종-코딩테스트-문제-링크&quot;&gt;&lt;a href=&quot;#최종-코딩테스트-문제-링크&quot; class=&quot;headerlink&quot; title=&quot;최종 코딩테스트 문제 링크&quot;&gt;&lt;/a&gt;최종 코딩테스트 문제 링크&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://githu</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="최종-코딩테스트-문제-링크"><a href="#최종-코딩테스트-문제-링크" class="headerlink" title="최종 코딩테스트 문제 링크"></a>최종 코딩테스트 문제 링크</h1><p><a href="https://github.com/woowacourse/java-pairmatching-precourse">https://github.com/woowacourse/java-pairmatching-precourse</a></p><h1 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h1><h2 id="검증-로직-중복"><a href="#검증-로직-중복" class="headerlink" title="검증 로직 중복"></a>검증 로직 중복</h2><p>과정, 레벨, 미션을 입력받을 때, 해당 과정, 레벨, 미션이 존재하는지 검증해야 된다.<br>나는 이를 검사하는 메서드를 각 열거형 객체가 가지고 있도록 하고 findByName메서드로 이름에 맞는 객체를 가져오도록 했다.</p><p>과정을 예를 들면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">BACKEND(<span class="string">&quot;백엔드&quot;</span>),</span><br><span class="line">FRONTEND(<span class="string">&quot;프론트엔드&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">Course(String name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Course <span class="title">findByName</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">exceptionNotContain(input);</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(Course.values()).filter(course -&gt; course.name.equals(input)).findFirst().get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionNotContain</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Arrays.stream(Course.values()).anyMatch(course -&gt; course.name.equals(input))) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(NO_EXIST_COURSE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 exceptionNotContain(String input)이 입력값이 존재하는 지 검증하고 예외를 출력한다.<br>만약 외부에서 과정 객체를 가져오고 싶다면, findByName(String input)을 호출하면 된다.<br>없는 경우는 예외를 일으키고, 있는 경우 해당 객체를 반환할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchingInformation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Course course;</span><br><span class="line"><span class="keyword">private</span> Level level;</span><br><span class="line"><span class="keyword">private</span> Mission mission;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MatchingInformation</span><span class="params">(Course course, Level level, Mission mission)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.course = course;</span><br><span class="line"><span class="keyword">this</span>.level = level;</span><br><span class="line"><span class="keyword">this</span>.mission = mission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MatchingInformation <span class="title">of</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; information = split(line);</span><br><span class="line">Course course = Course.findByName(information.get(COURSE_INDEX));</span><br><span class="line">Level level = Level.findByName(information.get(LEVEL_INDEX));</span><br><span class="line">Mission mission = Mission.findByName(information.get(MISSION_INDEX));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MatchingInformation(course, level, mission);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>매칭 정보 일급컬렉션을 생성할 때, 입력받은 이름을 토대로 findByName메서드를 호출하는 것을 볼 수 있다.</p><p>문제는 과정, 레벨, 미션 이 세가지 열거형 모두 이 메서드를 가지고 있는데, 모두 중복되는 코드로 작성했다.<br>인터페이스를 도입하자니 검증 메서드가 static이라서 힘들었다.</p><h2 id="과정-레벨-출력"><a href="#과정-레벨-출력" class="headerlink" title="과정, 레벨 출력"></a>과정, 레벨 출력</h2><p>과정, 레벨, 미션을 도입하기 전에 항상 과정, 레벨, 미션을 출력해야 한다.</p><p>나는 마음이 급해서 그냥 바로 문자열로 만들어서 매번 출력하도록 처리했다.<br>근데 다른 PR을 보니, 과정, 레벨, 미션을 저장하고, 저장된 정보를 토대로 출력하는 사람들이 많았다.(대단..)</p><h2 id="묻지-말고-시키기"><a href="#묻지-말고-시키기" class="headerlink" title="묻지 말고 시키기"></a>묻지 말고 시키기</h2><p>객체가 가진 데이터를 가져오지 말고, 객체에게 책임을 전달해야 되는데, 기능 구현에 급급하다보니, getter 메서드로 객체에게 묻는 로직이 상당히 많았다.<br>프리코스에서 가장 인상깊게 생각한 피드백이고, 지키기 위해서 노력했는데 막상 시험에서 지키지 못하니 아쉽다.</p><h2 id="구현하지-못한-기능"><a href="#구현하지-못한-기능" class="headerlink" title="구현하지 못한 기능"></a>구현하지 못한 기능</h2><p>페어를 만들 수 없는 상황을 예외 처리해줘야 했는데, 시험을 풀 당시 페어를 만들 수 없는 상황이 뭔지 몰라서 구현을 못했다…</p><p>알고보니 크루가 2명보다 적으면 페어를 못만드는 상황이 생긴다는 것……<br>생각해보니 쉬운 로직인데 너무 긴장해서 구현하지 못한 거 같다. 시간이 부족하기도 했고.</p><h1 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h1><p>돌이켜보면 믿기지 않는 한달이었다.<br>설마 되겠냐는 생각으로 서류 지원했는데 덜컥 붙어서 정신없이 프리코스를 진행한 것 같다.<br>다른 지원자들의 PR을 보니 내가 우물 속 개구리 인걸 깨달았다.</p><p>3주 동안 정말 많은 걸 배웠다.<br>의식있는 노력을 통해 익숙함을 벗어나서 더 좋은 코드를 추구하는 마음가짐을 배웠다.<br>평소 잘 모르는 걸 알면서 방치했던 git 사용법도 이번 기회로 정리해서 배웠다.<br>하드코딩을 제거해서 다른 사람들이 봐도 이해할 수 있는 코드를 작성할 수 있음을 배웠다.<br>한 메서드가 한 역할을 수행하라는 원칙도 알고는 있었는데, 실천을 통해 더 자세히 체화했다.<br>예외가 발생하는 상황을 처리해서 프로그램이 다시 입력할 수 있도록 하는 방법을 배웠다.<br>객체지향 설계를 직접 실천해보고 객체 지향의 기본 개념들을 배웠다.</p><p>프리코스를 해보니, 우아한 테크코스에 가고 싶은 생각이 더 깊어졌다.<br>혹시 내가 자격이 있을까 고민하는 개발 지망생들이 있다면, 꼭 지원해서 프리코스까지 체험해보길 적극 추천한다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4/">우아한 테크 코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/19/java/utecoprecourse4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>메시지와 인터페이스</title>
      <link>https://yangdongjue5510.github.io/2021/12/16/java/object/object4/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/16/java/object/object4/</guid>
      <pubDate>Thu, 16 Dec 2021 11:13:44 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;메시지-인터페이스&quot;&gt;&lt;a href=&quot;#메시지-인터페이스&quot; class=&quot;headerlink&quot; title=&quot;메시지, 인터페이스&quot;&gt;&lt;/a&gt;메시지, 인터페이스&lt;/h1&gt;&lt;p&gt;메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="메시지-인터페이스"><a href="#메시지-인터페이스" class="headerlink" title="메시지, 인터페이스"></a>메시지, 인터페이스</h1><p>메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.<br>메시지는 오퍼레이션 이름과 인자로 구성된다.</p><p>receiver.message(argument); 이렇게 메시지를 구성할 수 있다.</p><h3 id="메시지와-메서드"><a href="#메시지와-메서드" class="headerlink" title="메시지와 메서드"></a>메시지와 메서드</h3><p>그렇지만 메시지가 한 메서드를 가르키는 건 아니다.<br>메서드는 메시지를 수신하는 객체, 인자에 따라 달라진다.<br>메서드는 메시지를 수신했을 때 실행되는 함수를 의미한다.</p><p>이렇게 메시지와 메서드를 구분하면,<br>메시지 전송자와 수신자가 느슨하게 결합된다.<br>전송자는 그냥 내가 어떤 메시지를 보낼 지만 생각하면된다.<br>수신자는 그냥 메시지에 따라 메서드를 실행하기만 하면된다.</p><p>전송자는 수신자가 어떻게 메시지를 처리하는 지 감춰지게 된다.</p><h3 id="퍼블릭-인터페이스"><a href="#퍼블릭-인터페이스" class="headerlink" title="퍼블릭 인터페이스"></a>퍼블릭 인터페이스</h3><p>퍼블릭 인터페이스는 객체가 의사소통을 위해 공개하는 메시지의 집합이다.<br>퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.<br>(오퍼레이션은 어떤 행동에 대한 추상화된 것이라고 보자.)</p><p>시그니처는 오퍼레이션 이름과 파라미터 목록을 합친 것이다.<br>시그니처에 구현을 더하면 메서드가 된다!</p><h1 id="좋은-인터페이스를-위해서"><a href="#좋은-인터페이스를-위해서" class="headerlink" title="좋은 인터페이스를 위해서"></a>좋은 인터페이스를 위해서</h1><p>인터페이스는 <strong>최소한으로, 추상적이어야 한다.</strong></p><p>이런 원칙을 지키기 위해서는 책임주도 설계가 하는게 좋다.<br>메시지를 먼저 선택해서 협력에 상관없는 오퍼레이션을 제거할 수 있다.<br>메시지가 객체를 선택하도록 해서 객체의 의도를 메시지에 표현 할 수 있다.</p><p>다음 규칙을 통해 좋은 인터페이스 규칙을 알아보자.</p><h3 id="디미터-법칙-협력-경로를-제한하라"><a href="#디미터-법칙-협력-경로를-제한하라" class="headerlink" title="디미터 법칙 : 협력 경로를 제한하라"></a>디미터 법칙 : 협력 경로를 제한하라</h3><p>낯선 객체와 협력하지 말고 이웃과 협력하라.<br>객체가 특정 조건을 만족하는 대상에게 메시지를 전송하도록 제한.</p><p>한 객체는 다음 대상들에게 메시지를 전송하도록 제한하자.</p><ol><li><u>this 객체</u></li><li><u>메서드 매개변수</u></li><li><u>this의 속성</u></li><li><u>this의 속성인 컬렉션의 요소</u></li><li><u>메서드 내에서 생성된 지역 객체</u></li></ol><p>이런 식의 코드는 디미터 법칙을 위반하는 예시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  screening.getMovie.getDiscountConditions(); <span class="comment">//위반!!</span></span><br><span class="line">  screening.calculateFee(audienceCount);<span class="comment">//준수!!</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위반코드는 Movie 객체에게 메시지를 전달하고 있다.<br>Movie 객체는 위 다섯가지에 속하지 않는다!!<br>연쇄적으로 메시지를 전달하는 코드를 <strong>기차 충돌 코드</strong>라고 한다.</p><p>준수코드는 screening에게 메시지를 전달하므로 디미터 법칙을 준수했다.</p><p>하지만 <strong>디미터 법칙은 객체의 응집도가 낮아질 수 있다.</strong></p><h4 id="묻지-말고-시켜라"><a href="#묻지-말고-시켜라" class="headerlink" title="묻지 말고 시켜라"></a>묻지 말고 시켜라</h4><p>메시지 전송자는 메시지 수신자의 상태를 기반으로 결정 내리고 수신자의 상태를 바꾸면 안된다!!!<br>전송자가 수신자의 상태를 기반으로 결정하는 건 캡슐화 위반이다!</p><p>묻지 말고 시켜라는 객체의 상태와 행동이 서로 밀첩하도록 설계하게 한다.</p><h3 id="의도를-드러내는-인터페이스"><a href="#의도를-드러내는-인터페이스" class="headerlink" title="의도를 드러내는 인터페이스"></a>의도를 드러내는 인터페이스</h3><p>인터페이스의 메서드는 어떻게가 아닌 무엇을 하는지 드러내도록 하라.<br>무엇을 하는지 드러낸다는 것은, 그 인터페이스의 메서드가가 어떤 책임을 지는지를 표현하는 것이다.<br>절대 내부 구현을 메서드의 이름으로 표현하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedByPeriod</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 상영 정보를 받아서 해당 할인 조건에 맞는 지 검증한다.<br>그러나 위 코드의 메서드들은 클라이언트 입장에서 동일한 일을 한다. 그런데 이 두 메서드가 연관있음을 알 수 없다.<br>또한 판단 기준이 약간 수정된다면 메서드 명을 변경해줘야 되는 일이 생긴다.(캡슐화가 안된다는 소리.)</p><p>다음 코드로 바꿔주는게 적절하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondtion</span> <span class="keyword">implements</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> <span class="keyword">implements</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>결론</p></blockquote><p>객체에게 묻지 말고 시키되, 구현 방법이 아닌 클라이언트의 의도를 드러내는 메시지를 전달하자.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/16/java/object/object4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>깃 사용법(브랜치 활용 등)</title>
      <link>https://yangdongjue5510.github.io/2021/12/12/github-study/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/12/github-study/</guid>
      <pubDate>Sun, 12 Dec 2021 13:35:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;git을-잘-다루기&quot;&gt;&lt;a href=&quot;#git을-잘-다루기&quot; class=&quot;headerlink&quot; title=&quot;git을 잘 다루기&quot;&gt;&lt;/a&gt;git을 잘 다루기&lt;/h1&gt;&lt;h2 id=&quot;브랜치-생성-브랜치-이동&quot;&gt;&lt;a href=&quot;#브랜치-생성-브</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="git을-잘-다루기"><a href="#git을-잘-다루기" class="headerlink" title="git을 잘 다루기"></a>git을 잘 다루기</h1><h2 id="브랜치-생성-브랜치-이동"><a href="#브랜치-생성-브랜치-이동" class="headerlink" title="브랜치 생성, 브랜치 이동"></a>브랜치 생성, 브랜치 이동</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">깃 초기화</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">최초 커밋하기</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"></span><br><span class="line">브랜치 생성하기</span><br><span class="line">git branch issue1</span><br><span class="line"></span><br><span class="line">브랜치 이동하기</span><br><span class="line">git checkout issue1</span><br><span class="line"></span><br><span class="line">브랜치 생성하고 이동하기</span><br><span class="line">git checkout -b issue2</span><br></pre></td></tr></table></figure><h2 id="브랜치-합치기"><a href="#브랜치-합치기" class="headerlink" title="브랜치 합치기"></a>브랜치 합치기</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">다른 브랜치와 합치기</span><br><span class="line">(현재 위치에 다른 브랜치를 합침.)</span><br><span class="line">(빨리 감기 병합.)</span><br><span class="line">git merge issue1</span><br></pre></td></tr></table></figure><h2 id="브랜치-삭제하기"><a href="#브랜치-삭제하기" class="headerlink" title="브랜치 삭제하기"></a>브랜치 삭제하기</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d issue2</span><br></pre></td></tr></table></figure><h2 id="브랜치-병합-시-충돌-해결"><a href="#브랜치-병합-시-충돌-해결" class="headerlink" title="브랜치 병합 시 충돌 해결"></a>브랜치 병합 시 충돌 해결</h2><p>issue1 브랜치에는 다음과 같이 text.txt가 커밋되어 있고.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">whats up</span><br></pre></td></tr></table></figure><p>issue2 브랜치에는 다음과 같이 text.txt가 커밋 되어 있다고 하자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 안녕</span><br></pre></td></tr></table></figure><p>이 상태에서 두 브랜치를 병합하려하면 문제가 생긴다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">현재 HEAD가 issue1에 있을 때를 가정.</span><br><span class="line">git merge issue2</span><br><span class="line">Auto-merging text.txt</span><br><span class="line">CONFLICT (content): Merge conflict in text.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>그리고 text.txt를 보면 다음과 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello</span><br><span class="line">whats up!~~~</span><br><span class="line">=======</span><br><span class="line">hello 하이</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue2</span><br></pre></td></tr></table></figure><p>이 충돌된 내용 ( &lt;&lt;&lt;… , ===… , &gt;&gt;&gt;…)을 잘 처리해주고 다시 커밋하면 된다.<br>다음과 같이 수정하고 커밋해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">whats up!~~~</span><br><span class="line">hello 하이</span><br></pre></td></tr></table></figure><h2 id="rebase로-통합하기"><a href="#rebase로-통합하기" class="headerlink" title="rebase로 통합하기"></a>rebase로 통합하기</h2><p>rebase는 다른 브랜치의 내용을 모두 받아들이고, 자신의 모든 커밋을 그 다음에 이어서 진행하도록 하는 명령이다.</p><p>이전에 했던 merge와 다르게 다른 브랜치를 합치면 원래의 커밋기록이 변경된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">아까 했던걸 취소한다.</span><br><span class="line">git reset --hard HEAD~</span><br><span class="line"></span><br><span class="line">rebase로 통합해보자.</span><br><span class="line">git rebase issue2</span><br><span class="line"></span><br><span class="line">당연히 문제가 생긴다. (충돌)</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: dkdk</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M       text.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging text.txt</span><br><span class="line">CONFLICT (content): Merge conflict in text.txt</span><br><span class="line">error: Failed to merge in the changes.</span><br><span class="line">Patch failed at 0001 dkdk</span><br><span class="line">hint: Use &#x27;git am --show-current-patch&#x27; to see the failed patch</span><br><span class="line">Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.</span><br><span class="line">You can instead skip this commit: run &quot;git rebase --skip&quot;.</span><br><span class="line">To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.</span><br></pre></td></tr></table></figure><p>이전 챕터에서 했던 것처럼 다시 수정해서 커밋하면 충돌을 해결할 수 있다.</p><h2 id="cherry-pick-다른-브랜치의-특정-커밋만-가져오기"><a href="#cherry-pick-다른-브랜치의-특정-커밋만-가져오기" class="headerlink" title="cherry-pick 다른 브랜치의 특정 커밋만 가져오기"></a>cherry-pick 다른 브랜치의 특정 커밋만 가져오기</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick [commit 아이디]</span><br></pre></td></tr></table></figure><h2 id="git-add-commit-취소하기"><a href="#git-add-commit-취소하기" class="headerlink" title="git add, commit 취소하기"></a>git add, commit 취소하기</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add 취소하기.</span><br><span class="line">git reset HEAD [FILE이름]</span><br><span class="line"></span><br><span class="line">commit 취소하기.</span><br><span class="line">1. commit을 취소하고, 파일들이 staged된 상태로 취소(add된 상태)</span><br><span class="line">$ git reset --soft HEAD^</span><br><span class="line"></span><br><span class="line">2. commit을 취소하고, 파일들은 unstaged 상태로 워킹 디렉터리에 보존(디폴트 값.)</span><br><span class="line">$ git reset --mixed HEAD^</span><br><span class="line">$ git reset HEAD^ // 위와 동일</span><br><span class="line">$ git reset HEAD~2 // 마지막 2개의 commit을 취소</span><br><span class="line"></span><br><span class="line">3. commit을 취소하고, 파일들은 unstaged 상태로 워킹 디렉터리에서 삭제</span><br><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><h2 id="commit-message-수정"><a href="#commit-message-수정" class="headerlink" title="commit message 수정"></a>commit message 수정</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch는 원격 저장소의 최신 내용을 새로운 브랜치로 가져온다.<br>이때 fetch의 브랜치는 이름없지만,  FETCH_HEAD라는 이름으로 checkout할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [리모트이름] [브랜치이름]</span><br></pre></td></tr></table></figure><h2 id="git-와"><a href="#git-와" class="headerlink" title="git ~와 ^"></a>git ~와 ^</h2><p><del>는 동일한 브랜치의 상위 커밋을 표현하고자 할 때 쓴다.<br>HEAD</del>1은 HEAD에서 같은 브랜치의 1개 전 커밋을 표현하다.</p><p>^는 브랜치로 분기 될 때 상위 커밋을 표현하고자 할 때 쓴다.<br>HEAD^2는 HEAD에서 다른 브랜치의 상위 커밋을 표현한다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/git/">git</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/12/github-study/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한 테크코스 4기 프리코스 3주차 회고</title>
      <link>https://yangdongjue5510.github.io/2021/12/10/java/utecoprecourse3/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/10/java/utecoprecourse3/</guid>
      <pubDate>Fri, 10 Dec 2021 11:56:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;우아한-테크코스-4기-프리코스-3주차-회고&quot;&gt;&lt;a href=&quot;#우아한-테크코스-4기-프리코스-3주차-회고&quot; class=&quot;headerlink&quot; title=&quot;우아한 테크코스 4기 프리코스 3주차 회고&quot;&gt;&lt;/a&gt;우아한 테크코스 4기 프리코스 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="우아한-테크코스-4기-프리코스-3주차-회고"><a href="#우아한-테크코스-4기-프리코스-3주차-회고" class="headerlink" title="우아한 테크코스 4기 프리코스 3주차 회고"></a>우아한 테크코스 4기 프리코스 3주차 회고</h1><h2 id="3주차-문제-및-내-답안-링크"><a href="#3주차-문제-및-내-답안-링크" class="headerlink" title="3주차 문제 및 내 답안 링크"></a>3주차 문제 및 내 답안 링크</h2><p><a href="https://github.com/woowacourse/java-vendingmachine-precourse">https://github.com/woowacourse/java-vendingmachine-precourse</a></p><h2 id="마주한-문제들"><a href="#마주한-문제들" class="headerlink" title="마주한 문제들"></a>마주한 문제들</h2><h3 id="MVC-패턴-적용"><a href="#MVC-패턴-적용" class="headerlink" title="MVC 패턴 적용"></a>MVC 패턴 적용</h3><p>MVC 패턴은 Model, View, Controller를 기준으로 객체들을 분류해서 프로그램을 만드는 패턴이다.<br>2주차 피드백에 비즈니스 로직에 출력 관련 로직을 같이 두지 말라는 피드백이 있었다.<br>3주차에는 MVC 패턴을 도입해서 View 관련 로직을 분리하고자 했다.</p><p>Model은 데이터를 저장하고, 일관성 있게 처리하는 역할,<br>Controller는 사용자의 입력을 받고, view를 생성하거나 수정하고, model에 접근하여 데이터를 가져오는 역할,<br>View는 사용자에게 보여지는 부분을 구현하는 역할.</p><h5 id="컨트롤러-예시"><a href="#컨트롤러-예시" class="headerlink" title="컨트롤러 예시"></a>컨트롤러 예시</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputMoneyController</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inputMoneyControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputMoneyView.messageInputMoney();</span><br><span class="line">inputMachineMoney();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inputMachineMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MoneyRepository.initializeMachineMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>내 답안에 쓰인 컨트롤러 중 일부다.<br>이 객체는 자판기에 돈을 입금해야 하는  상황을 책임진다.<br>자판기는 사용자에게 돈을 입금하라는 메시지를 출력해줘야 한다.</p><p>출력은 InputMoneyView의 책임이다.<br>InputMoneyView.messageInputMoney()는 입금할 때 필요한 메시지를 출력하라는 의미다.</p><h5 id="뷰-예시"><a href="#뷰-예시" class="headerlink" title="뷰 예시"></a>뷰 예시</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputMoneyView</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">messageInputMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(MESSAGE_INPUT_MONEY);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>뷰가 메시지를 받으면 적절한 메시지를 출력하게 된다.</p><h5 id="모델-예시"><a href="#모델-예시" class="headerlink" title="모델 예시"></a>모델 예시</h5><p>위 컨트롤러를 보면, MoneyRepository.initializeMachineMoney(); 코드가 보일 것이다.<br>컨트롤러가 모델에게 메시지를 전달하고 있다.<br>기계에 돈을 초기화해서 저장해달라는 메시지를 전달한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyRepository</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Money vendingMachineMoney;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeMachineMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vendingMachineMoney = <span class="keyword">new</span> Money();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MoneyRepository는 내가 만든 코드에서 모델에 해당하는 객체다.<br>자판기에 저장되는 돈을 관리하는 책임을 진다.<br>initializeMachineMoney()를 통해 기계가 가진 돈을 초기화해서 저장할 수 있다.</p><h3 id="일급-컬렉션-도입하기"><a href="#일급-컬렉션-도입하기" class="headerlink" title="일급 컬렉션 도입하기"></a>일급 컬렉션 도입하기</h3><p>일급 컬렉션은, 컬렉션을 감싸는 클래스를 만들어서 사용하는 방법이다.<br>다음과 같이 컬렉션을 그냥 쓰지 말고, 멤버 변수가 컬렉션 하나뿐인 일급 컬렉션을 도입하면 이익이 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MachineCoins</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Coin, Integer&gt; machineCoins = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MachineCoins() &#123;</span><br><span class="line">initializeChangeCoins();</span><br><span class="line">setMachineCoins(MoneyRepository.getMachineMoney());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 자판기 기계에 동전을 담당하는 객체다.<br>이 객체가 생성되려면, initializeChangeCoins()와 setMachineCoins(MoneyRepository.getMachineMoney())를 실행한다.</p><p>map에 각 동전과 그 갯수를 0개로 초기화하고,<br>기계가 가진 돈만큼 동전을 만들어서 객체가 보관한다.<br>즉 MachineCoins는 자판기 기계가 가진 돈만큼 동전으로 만들어서 Map에 저장하는 자료구조이다.</p><p>만약 MachineCoins라는 객체가 아닌 그냥 Map&lt;Coin, Integer&gt; 객체로 자판기의 동전을 관리하면 문제가 있다.<br>위에서 얘기했듯이, 동전 갯수는 기계가 가진 돈만큼만 만들어야 한다.</p><p>일반 Map을 사용하면 해당 객체가 그런 조건을 달성했는지 알 수 없다.<br>혹은 다른 사람이 코드를 봤을 때, 조건이 필요한지 알 수 없다. (그냥 Map일 뿐…)</p><p>이때 MachineCoins같이 일급 컬렉션을 사용하면 조건을 달성했음을 보장할 수 있다.<br>그리고 조건을 검증하고, 상태와 행동을 한 클래스에서 확인 할 수 있어서 다른 사람이 파악하기도 편하다.</p><p>그리고 객체에 값을 수정하는 메소드를 만들지 않으면, 그 객체의 값을 불변으로 보장할 수 있기도 하다.</p><blockquote><p>참고</p></blockquote><p><a href="https://jojoldu.tistory.com/412">https://jojoldu.tistory.com/412</a></p><h3 id="맵-순회하는-방법-Map-Entry-Iterator"><a href="#맵-순회하는-방법-Map-Entry-Iterator" class="headerlink" title="맵 순회하는 방법 (Map Entry, Iterator)"></a>맵 순회하는 방법 (Map Entry, Iterator)</h3><p>동전 정보를 Map에 저장했었는데, 동전을 출력하는 로직에서 Map을 순회해야 했었다.</p><p>그냥 for문을 쓰면 될 줄 알았는데, 잘 되지 않았다.<br>다음은 내가 찾은 방법이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Coin, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Coin, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Coin, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">  <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">  <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line">  <span class="comment">//map.remove(key); 이건 될까?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 순회는 잘된다. map의 원소를 수정하면 concurrentmodificationexception가 발생한다.<br>그럴 땐 iterator를 도입한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Coin&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  iterator.next();</span><br><span class="line">  iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 구현하면 순회와 동시에 삭제가 가능하다!</p><h1 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h1><p>긴장감 속에 치뤄진 프리코스가 끝을 향하고 있다.<br>사실 서류 통과가 될 지도 긴가민가했었는데, 어느새 프리코스를 마치고 최종 코딩테스트만 남기고 있다.<br>프리코스를 하기 전에는 내가 자바를 해본 경험이 꽤 있어서 무난하게 프리코스를 통과하지 않을까 싶었는데 오산이었다.</p><p>매 미션마다 다른 분들이 제출한 PR을 보면 엄청난 고수들이 많았다.<br>그럴 때마다 많은 좌절감을 느끼기도 했지만, 오히려 만약 이런 분들에게 피드백 받고 같이 공부하면<br>정말 소중한 기회일 것이고, 그래서 더 프리코스 과제에 더 집중하고자 했다.</p><p>프리코스는 매 주마다 미션을 하나씩 주고, 미션을 구현할 때 지켜야할 규칙을 제시한다.<br>정말 놀라운 건, 이 규칙들이 몇가지 안되는데, 이 규칙들을 지키기가 굉장히 까다롭다는 사실이다.</p><p>메서드 길이 15줄을 넘어가면 안되고, 메서드의 들여쓰기가 2를 넘으면 안된다.<br>이 두가지만 지키려고 해봐도 굉장히 까다롭고, 코드가 완전히 새로워진다.</p><p>그리고 클래스에게 책임을 나눠주고 여러 클래스들이 협력하도록 설계하는 게 재밌었다.<br>사실 스프링을 쓰다보면, 요구사항이 비슷한 경우가 많아서 설계도 비슷하게 반복되는 경우가 많았다.<br>그래서 설계를 크게 고민하지 않았던 적이 많은데 이번 프리코스는 스스로 설계를 고민해야 되는 부분이 많아서 흥미로웠다.</p><p>코딩 실력을 향상시키기에는 3주는 짧다고 볼 수 있지만,<br>프리코스를 하면서 정말 극적으로 코드 보는 시선이 넓어지고, 코드 짜는 좋은 습관도 생긴 것 같다.</p><p>프리코스의 모든 과정은 인터넷에 공개되어 있다.<br>이번 프리코스를 하면서 왜 진작 이런 자료를 찾아서 공부하지 않았는지 생각이 날 정도로 정말 귀한 경험이었다.</p><p>우아한 테크 코스 지원 여부를 떠나서, 프리코스는 초보 자바 개발자라면 반드시 참고하길 바란다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4/">우아한 테크 코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/10/java/utecoprecourse3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한 테크코스 4기 프리코스 2주차 회고</title>
      <link>https://yangdongjue5510.github.io/2021/12/05/java/utecoprecourse2/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/05/java/utecoprecourse2/</guid>
      <pubDate>Sat, 04 Dec 2021 15:40:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;우아한-테크코스-4기-프리코스-2주차-회고&quot;&gt;&lt;a href=&quot;#우아한-테크코스-4기-프리코스-2주차-회고&quot; class=&quot;headerlink&quot; title=&quot;우아한 테크코스 4기 프리코스 2주차 회고&quot;&gt;&lt;/a&gt;우아한 테크코스 4기 프리코스 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="우아한-테크코스-4기-프리코스-2주차-회고"><a href="#우아한-테크코스-4기-프리코스-2주차-회고" class="headerlink" title="우아한 테크코스 4기 프리코스 2주차 회고"></a>우아한 테크코스 4기 프리코스 2주차 회고</h1><h2 id="2주차-문제-amp-내-제출-답안"><a href="#2주차-문제-amp-내-제출-답안" class="headerlink" title="2주차 문제 &amp; 내 제출 답안"></a>2주차 문제 &amp; 내 제출 답안</h2><p><a href="https://github.com/woowacourse/java-racingcar-precourse">https://github.com/woowacourse/java-racingcar-precourse</a></p><p><a href="https://github.com/yangdongjue5510/java-racingcar-precourse">https://github.com/yangdongjue5510/java-racingcar-precourse</a></p><h2 id="마주한-문제들"><a href="#마주한-문제들" class="headerlink" title="마주한 문제들"></a>마주한 문제들</h2><h3 id="책임을-클래스들에게-분배하기"><a href="#책임을-클래스들에게-분배하기" class="headerlink" title="책임을 클래스들에게 분배하기"></a>책임을 클래스들에게 분배하기</h3><p>이번 문제는 메서드를 분리하는 것에 더해, 클래스를 분리해서 책임을 분배해야 한다는 미션을 받았다.</p><p>문제에는 Car 객체가 제시되어 활용하는 요구사항이 추가됐다.</p><p>일단 나눠주여 할 책임을 보면,</p><ul><li>사용자에게 입력을 받는 책임</li><li>입력된 값을 검증하는 책임</li><li>자동차를 만드는 책임</li><li>자동차의 게임을 진행하는 책임</li><li>레이싱 결과를 분별하는 책임</li><li>결과를 출력하는 책임</li></ul><p>이렇게 나눌 수 있었다.</p><p>나는  다음과 같이 클래스들에게 <strong>책임을 나눠줬다</strong>.</p><ul><li>입력을 담당하는 InputManager</li><li>입력값 검증하는 ValidChecker</li><li>자동차를 만들어 게임을 진행하는 RacingPlayer</li><li>자동차의 운행 여부를 판단하여 운행하는 Car</li><li>자동차 위치에 따라 우승자를 찾는 RacingReferee</li></ul><p>이렇게 역할을 나눠줬는데, 역할을 나눠주고 나니 <strong>각 객체의 인스턴스 변수를 다른 객체가 활용해야 하는 경우가 있었다.</strong></p><h4 id="패키지-분리-후-default-접근-지시자"><a href="#패키지-분리-후-default-접근-지시자" class="headerlink" title="패키지 분리 후 default 접근 지시자"></a>패키지 분리 후 default 접근 지시자</h4><p>나는 이 문제를 해결하기 위해 <strong>도매인과 관련된 Car, RacingPlayer, RacingReferee는 같은 패키지로 분리</strong>해줬다.</p><p>그리고 <strong>getter 메서드를 default로 추가</strong>해 도매인 관련된 객체들만 해당 인스턴스 변수를 이용할 수 있게 했다.</p><p>예시로 RacingReferee는 우승자들을 분류해서 리스트로 가지고, 우승자의 이름을 출력하는 책임을 지고 있다.<br>그런데 우승자(Car 객체)는 이름이 private로 되어 있다. 이럴 경우 default getter로 캡슐화를 최대한 준수하고자 했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">...</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="comment">//default 접근지시자를 활용했다.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RacingReferee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;Car&gt; winners;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printWinners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; winners.size(); i++) &#123;<span class="comment">//getName 메서드를 활용하고 있다.</span></span><br><span class="line">builder.append(winners.get(i).getName()).append(MESSAGE_COMMA_WITH_SPACE);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="우승자-알아내기"><a href="#우승자-알아내기" class="headerlink" title="우승자 알아내기"></a>우승자 알아내기</h3><p>Car의 우승 여부를 알려면 각 Car의 위치를 알아야 한다.</p><p>그런데 나는 앞서 말했듯이 우승여부를 다른 객체(RacingReferee)가 한다고 했다.<br>이미 Car 객체의 위치값은 private인데 어떻게 RacingReferee가 이를 계산해서 처리할 것인가?</p><p>가장 편한 대답은 아까처럼 default getter를 만드는 방법이다.<br>하지만 검색을 좀 해봤더니 다른 방식을 알아냈다.</p><p>바로 <strong>Comparable로 정렬하기</strong> 이다.</p><p>Car를 Comparable로 정렬 기준을 만들자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Car otherCar)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> otherCar.position - <span class="keyword">this</span>.position;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이렇게 해놓으면 외부에서 자동차 위치를 알지 못해도 compareTo로 자동차들의 위치를 비교한다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RacingReferee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;Car&gt; winners;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findWinner</span><span class="params">(List&lt;Car&gt; participantCars)</span> </span>&#123;</span><br><span class="line">Collections.sort(participantCars);<span class="comment">//</span></span><br><span class="line">Car winner = participantCars.get(WINNER_INDEX);</span><br><span class="line"><span class="keyword">this</span>.winners = participantCars.stream()</span><br><span class="line">.filter(car -&gt; car.compareTo(winner) == COMPARE_WINNER_RESULT)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RacingReferee는 Car가 어떤 식으로 정렬하는지 알지 못해도 일단 <code>Collections.sort()</code> 하면 우승자 순으로 정렬된다는거만 안다.</p><p>나름 캡슐화를 지킨 방식이라서 재밌었다.</p><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>이번 주차는 비교적 수월하게 했다. 지난주에 설계를 못한다는 생각에 충격을 먹어서, 급하게 객체지향 관련 책을 찾아 본 게 큰 도움이 된거 같다.</p><p>지난 야구 게임을 구현할 때는 한 클래스가 거의 모든 데이터를 독점하고, 여러 일을 책임지고 있는 좋지 않은 설계로 구현했었다.</p><p>이번 문제는 강제로 Car 객체를 사용해야되서 자연스럽게 여러 객체들을 협력에 동참시켜야 했다.<br>특히 이번엔 한 클래스가 데이터를 독점하지 못하도록 어떤 부분에 다른 클래스로 대체할 것인지 고민을 많이 했다.<br>그 고민을 통해 등장시킨게 RacingReferee였다. 이 객체는 우승자를 가지고, 스스로 관리하게 설계했다는 점에서 만족스러웠다.</p><p>그리고 Comparator와 Comparable에 대해 공부할 수 있는 기회였다.<br>최대한 캡슐화를 지키면서 우승 자동차를 구하는 방법을 찾다보니 평소에 잘 이해하지 못했던 개념을 제대로 이해할 수 있었다.<br>이런 아이디어를 내가 직접 생각해낸게 아니라서, 만약 실제 코딩테스트 상황에서 이런 문제를 만나면 어찌해야 될 지 고민이 되긴한다.</p><p>하지만 아직 부족한 부분이 많다.<br>대표적으로 README 작성. 살아있는 문서를 작성하라는데, 이게 좀 힘들다.<br>의외라고 생각할 수 있는데, 나는 문제를 풀 때, 구현에 집중하다 보면, README는 안중에도 없게 된다.(…)<br>그래서 이번엔 비교적 좀 더 신경을 썼는데, 아직 부족한 거 같기도 하다…</p><p>그리고 테스트 코드 작성도 많이 부족하다.<br>나는 사실 이 문제를 여러번 풀어보고 제출한다.<br>이번 주 문제인 레이싱 문제도 대충 3번정도 풀어보고 제출하는 거다.<br>그래서 제출 코드에는 굳이 테스트 코드가 필요없다. 이미 많이 시도해본 코드들이기 때문이다.</p><p>근데 실전에서는 그럴 시간이 없다. 5시간안에 여러번 푼다는건 말도 안된다 ㅋㅋ.<br>그래서 테스트 코드를 작성하는 법을 배워야 한다는 걸 느꼈다.<br>JUnit와 TDD에 대해 공부하려고 한다.</p><p>아직 많이 부족하다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4/">우아한 테크 코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/05/java/utecoprecourse2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13. Comparable과 Comparator의 차이!</title>
      <link>https://yangdongjue5510.github.io/2021/12/03/java/java-basic/java13/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/03/java/java-basic/java13/</guid>
      <pubDate>Fri, 03 Dec 2021 01:29:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Comparable과-Comparator의-차이&quot;&gt;&lt;a href=&quot;#Comparable과-Comparator의-차이&quot; class=&quot;headerlink&quot; title=&quot;Comparable과 Comparator의 차이&quot;&gt;&lt;/a&gt;Comparab</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Comparable과-Comparator의-차이"><a href="#Comparable과-Comparator의-차이" class="headerlink" title="Comparable과 Comparator의 차이"></a>Comparable과 Comparator의 차이</h1><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>둘 다 객체의 비교 기준을 마련하는 인터페이스.</p><p><strong>Comparable</strong>은 **compareTo(T t)**로 자기 자신과 다른 객체의 비교.<br><strong>Comparator</strong>은 <strong>compare(T t, T u)</strong> 자기 자신이 아닌 다른 두 객체 간의 비교.</p><p>Comparable은 <strong>Arrays.sort()나 Collections.sort()를 했을 경우 비교 기준을 제공</strong>한다.<br>Comparator는 <strong>새로운 비교기준이 필요할 때 익명 클래스로 활용</strong> 가능.</p><h2 id="실험"><a href="#실험" class="headerlink" title="실험"></a>실험</h2><h3 id="실험에-필요한-Student"><a href="#실험에-필요한-Student" class="headerlink" title="실험에 필요한 Student"></a>실험에 필요한 Student</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;age = &quot;</span>+age+<span class="string">&quot; score = &quot;</span>+score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 정렬 실험에 사용될 객체를 만들어봤다. 이제 age나 score에 따라 다르게 구현해보자.</p><h3 id="Comparable와-Comparator를-클래스에-적용하기"><a href="#Comparable와-Comparator를-클래스에-적용하기" class="headerlink" title="Comparable와 Comparator를 클래스에 적용하기"></a>Comparable와 Comparator를 클래스에 적용하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparable</strong>을 활용하려면 <strong>compareTo</strong>메서드를 구현해야 한다.</p><p>이 메서드는 자기 자신과 다른 객체를 비교한다. (return 값이 양수면 자기 자신 우선, 음수면 다른 객체 우선)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparator</strong>는 <strong>compare</strong>메서드를 구현해야 한다.</p><p>이 메서드는 서로 다른 객체 두개를 비교한다.</p><h3 id="정렬-실험해보기"><a href="#정렬-실험해보기" class="headerlink" title="정렬 실험해보기"></a>정렬 실험해보기</h3><p>문제는 Comparable을 구현한 경우와 Comparator를 구현한 경우가 정렬을 할 때 다르다는 점이다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implements Comparable&lt;Student&gt; 한 경우</span></span><br><span class="line">Arrays.sort(arr);<span class="comment">//성공!</span></span><br><span class="line">Collections.sort(list);<span class="comment">//성공!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//implements Comparator&lt;Student&gt; 한 경우</span></span><br><span class="line">Arrays.sort(arr);<span class="comment">//컴파일 에러!!</span></span><br><span class="line">Collections.sort(list);<span class="comment">//컴파일 에러!!</span></span><br></pre></td></tr></table></figure><p>실험해보니, <strong>Comparable을 구현했을 때만 정렬이 가능</strong>했다!!<br>Comparator를 구현한 경우 Comparable이 구현되지 않았다며 컴파일 에러를 일으켰다!</p><h4 id="그러면-Comparator는-왜-있는거에요"><a href="#그러면-Comparator는-왜-있는거에요" class="headerlink" title="그러면 Comparator는 왜 있는거에요?"></a>그러면 Comparator는 왜 있는거에요?</h4><p>Student 클래스가 Comparable을 구현하고, 정렬을 age 기준으로 오름차순으로 정렬됐다고 하자.</p><p>근데 프로그래밍하다가 Student를 score 기준으로 오름차 정렬해야 되는 요구사항이 생겼다면?<br>이미 age로 정렬하여 사용하고 있는 곳이 있으면, Comparable을 바꿀수도 없다.</p><p>그럴 때 <strong>익명클래스를 활용한 Comparator</strong>를 통해 해결한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.getScore() - o2.getScore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/03/java/java-basic/java13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>REST Api 프로젝트에서 만난 소소한 문제들</title>
      <link>https://yangdongjue5510.github.io/2021/12/02/spring/restproject1/</link>
      <guid>https://yangdongjue5510.github.io/2021/12/02/spring/restproject1/</guid>
      <pubDate>Thu, 02 Dec 2021 02:44:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Rest api 프로젝트를 하면서 배운 것들을 정리하고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;JPA-entity에서-배운-것들&quot;&gt;&lt;a href=&quot;#JPA-entity에서-배운-것들&quot; class=&quot;headerlink&quot; title=&quot;JPA entity에서 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>Rest api 프로젝트를 하면서 배운 것들을 정리하고자 한다.</p><h2 id="JPA-entity에서-배운-것들"><a href="#JPA-entity에서-배운-것들" class="headerlink" title="JPA entity에서 배운 것들"></a>JPA entity에서 배운 것들</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Investments</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="meta">@Column(nullable = false)</span></span><br><span class="line"><span class="keyword">private</span> Long investId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column(nullable = false)</span></span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span><span class="comment">//다대일 관계</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Products product;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column(nullable = false)</span></span><br><span class="line"><span class="keyword">private</span> Long investmentAmount;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Temporal(TemporalType.DATE)</span></span><br><span class="line"><span class="keyword">private</span> Date investmentDate = <span class="keyword">new</span> Date(); <span class="comment">//기본값을 현재로??</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line"><span class="keyword">private</span> InvestmentStatus investmentStatus = InvestmentStatus.VALID;<span class="comment">//기본값을 유효로 ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA와 디비에는 사용하고 싶지 않지만, VO 클래스 멤버 변수로 사용하고 싶은 변수는 <strong>@Transient</strong>를 붙인다.</p><p>이번 프로젝트에서는 h2 디비를 썼다. h2에서는 기본키 자동증가기능을 사용하려면 <strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong> 를 써야 잘 작동했다. </p><p>칼럼의 NOT NULL은 <strong>@Column(nullable = false)</strong> 로 처리했다. (@NotNull은 안됐다.)</p><p><strong>@Temporal(TemporalType.DATE)</strong> 는 날짜시간 데이터 중 날짜 데이터를 저장한다는 의미다.<br>시분초는 0으로 처리되어 저장된다.</p><p>**@Enumerated(EnumType.STRING)**은 열거형 데이터를 저장할 때 쓰인다.<br>이번 프로젝트는 열거형 이름 그 자체를 도입했다.</p><h2 id="헤더-값-읽기"><a href="#헤더-값-읽기" class="headerlink" title="헤더 값 읽기"></a>헤더 값 읽기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseDto&lt;List&lt;Products&gt;&gt; productGet(<span class="meta">@RequestHeader(&quot;X-USER-ID&quot;)</span> <span class="keyword">long</span> userId) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestHeader안에 헤더의 키값을 넣어주면 가져올 수 있다!</p><h2 id="SpringBoot-Could-not-find-acceptable-representation-Error-Request-failed-with-status-code-406"><a href="#SpringBoot-Could-not-find-acceptable-representation-Error-Request-failed-with-status-code-406" class="headerlink" title="SpringBoot Could not find acceptable representation(Error: Request failed with status code 406)"></a>SpringBoot Could not find acceptable representation(Error: Request failed with status code 406)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDto</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResponseDto</span><span class="params">(T data, HttpStatus status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.status = status;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpStatus status;</span><br><span class="line">T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>406에러는 return된 객체에 setter getter가 없어서 일어났었다.</p><h2 id="stream으로-합구하기"><a href="#stream으로-합구하기" class="headerlink" title="stream으로 합구하기!"></a>stream으로 합구하기!</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; numbers = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stream의 reduce 이용</span></span><br><span class="line">Long sum1 = numbers.stream().reduce(<span class="number">0L</span>, Long::sum);</span><br></pre></td></tr></table></figure><p>reduce를 이용하면 구할 수 있었다!!</p><h2 id="JSON으로-통신할-때-Object-Mapper로-케이스-변환하기"><a href="#JSON으로-통신할-때-Object-Mapper로-케이스-변환하기" class="headerlink" title="JSON으로 통신할 때 Object Mapper로 케이스 변환하기"></a>JSON으로 통신할 때 Object Mapper로 케이스 변환하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> phoneNumber; <span class="comment">//json에는 phone_number로 보임</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@JsonProperty(&quot;user_name&quot;)</span> <span class="comment">//특정 변수에만 적용할 경우.</span></span><br><span class="line">  <span class="keyword">private</span> userName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON을-반환할-때-ResponseEntity"><a href="#JSON을-반환할-때-ResponseEntity" class="headerlink" title="JSON을 반환할 때 ResponseEntity"></a>JSON을 반환할 때 ResponseEntity</h2><p>나는 커스텀해서 ResponseDto를 만들었는데 자바에서는 이미 ResponseEntity가 있더라 크흠…</p><h2 id="SQL-INIT"><a href="#SQL-INIT" class="headerlink" title="SQL INIT"></a>SQL INIT</h2><p>어플리케이션을 시작할 때 SQL을 실행해서 스키마를 만들고 데이터를 입력할 수 있다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">sql:</span></span><br><span class="line">    <span class="attr">init:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">h2</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p><strong>application.yml</strong>에 다음같이 적으면, 항상 어플리케이션을 시작할 때 SQL을 초기화해준다.</p><p>Resources 폴더에 schema-플랫폼이름.sql , data-플랫폼이름.sql 을 실행한다.</p><p>위 예시는 플랫폼을 h2로 했으니, <strong>schema-h2.sql</strong>, <strong>data-h2.sql</strong>이라고 하면된다!!</p><p>이때 <strong>ddl-auto</strong>는 꺼줘여야 잘 작동하게 된다!!</p><h2 id="JPA-Method이름으로-쿼리-만들기"><a href="#JPA-Method이름으로-쿼리-만들기" class="headerlink" title="JPA Method이름으로 쿼리 만들기"></a>JPA Method이름으로 쿼리 만들기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvestmentsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Investments</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Investments <span class="title">updateInvestStatus</span><span class="params">(Investments invest, InvestmentStatus status)</span> </span>&#123;</span><br><span class="line">invest.setStatus(status);</span><br><span class="line">save(invest);</span><br><span class="line"><span class="keyword">return</span> invest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Investments&gt; <span class="title">findInvestmentsByIdAndStatusEquals</span><span class="params">(<span class="keyword">long</span> productId, InvestmentStatus investmentStatus)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Investments&gt; <span class="title">findInvestmentsByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Investments <span class="title">findInvestmentsByUserIdAndIdAndStatusEquals</span><span class="params">(<span class="keyword">long</span> UserId, <span class="keyword">long</span> productId, InvestmentStatus status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>레퍼지토리에 우리가 원하는 쿼리의 역할을 메서드 이름으로 만들면 그에 해당하는 쿼리를 실행하는 메서드가 만들어진다.</p><h2 id="전역-예외-핸들러"><a href="#전역-예외-핸들러" class="headerlink" title="전역 예외 핸들러"></a>전역 예외 핸들러</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseDto&lt;String&gt; <span class="title">handleException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseDto&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예외 핸들러를 따로 만들면, 모든 예외 발생을 다음 메서드로 처리한다.</p><h2 id="생성자-주입"><a href="#생성자-주입" class="headerlink" title="생성자 주입"></a>생성자 주입</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProductsService productsService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> InvestmentsService investmentsService;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>@Autowired 키워드를 쓰는 것보다 @RequiredArgsConstructor와 private final 키워드를 활용한 생성자 주입이 스프링에서 더 권장하는 방법이다.</p><p>나도 이 방법을 사용하기 전까지 순환 참조를 하고 있는 줄 모르고 있었는데, 생성자 주입으로 변경하는 과정에서 실수를 확인 할 수 있었다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/project/">Project</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/reshapi-project/">reshapi project</category>
      
      <category domain="https://yangdongjue5510.github.io/tags/troubleshooting/">troubleShooting</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/12/02/spring/restproject1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>책임 할당을 위한 GRASP 패턴</title>
      <link>https://yangdongjue5510.github.io/2021/11/29/java/object/object3/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/29/java/object/object3/</guid>
      <pubDate>Mon, 29 Nov 2021 11:12:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;GRASP-패턴&quot;&gt;&lt;a href=&quot;#GRASP-패턴&quot; class=&quot;headerlink&quot; title=&quot;GRASP 패턴&quot;&gt;&lt;/a&gt;GRASP 패턴&lt;/h1&gt;&lt;p&gt;일반적인 책임 할당을 위한 소프트웨어 패턴.&lt;/p&gt;
&lt;p&gt;객체에게 책임을 할당할 때</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="GRASP-패턴"><a href="#GRASP-패턴" class="headerlink" title="GRASP 패턴"></a>GRASP 패턴</h1><p>일반적인 책임 할당을 위한 소프트웨어 패턴.</p><p>객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들.</p><blockquote><p>영화 예매 시스템을 통해 GRASP 패턴을 익혀보자.</p></blockquote><h2 id="도메인-개념에서-출발하기"><a href="#도메인-개념에서-출발하기" class="headerlink" title="도메인 개념에서 출발하기"></a>도메인 개념에서 출발하기</h2><p>어떤 책임을 할당해야 할 지 고민해야 될 때 가장 먼저 고려해야 할 게 도메인이다.</p><p>영화에는 금액 할인 영화, 비용 할인 영화가 있다.</p><p>할인 조건에는 순번 조건, 기간 조건이 있다.</p><p>하나의 영화는 여러번 상영될 수 있고,<br>하나의 상영에는 여러 예매가 있을 수 있다.</p><p>그리고 한 영화에는 여러 할인 조건이 사용될 수 있다.</p><p>![](/Users/MUHN2-031/Documents/dev/ghblog/source/img/스크린샷 2021-11-29 오후 8.40.39.png)</p><p>도메인 설계는 완벽할 수 없다.<br>다만 앞으로의 설계와 구현에 출발점일 뿐이다.</p><h2 id="정보-전문가에게-책임을-할당하라-information-expert-pattern"><a href="#정보-전문가에게-책임을-할당하라-information-expert-pattern" class="headerlink" title="정보 전문가에게 책임을 할당하라(information expert pattern)"></a>정보 전문가에게 책임을 할당하라(information expert pattern)</h2><p>애플리케이션이 제공해야 되는 기능을 애플리케이션의 책임으로 생각하라.</p><p>이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고, 메시지를 책임질 첫번째 객체를 선택하는 것으로 시작하자.</p><p>영화 예매시스템은 영화 예매를 책임져야한다.</p><h4 id="이제-이-책임을-수행하는-메시지를-결정해야-한다"><a href="#이제-이-책임을-수행하는-메시지를-결정해야-한다" class="headerlink" title="이제 이 책임을 수행하는 메시지를 결정해야 한다."></a>이제 이 책임을 수행하는 메시지를 결정해야 한다.</h4><p>이때 <strong>메시지는 수신할 객체 중심이 아닌 발신한 객체의 의도를 반영해서 결정</strong>해야 한다.</p><blockquote><p>메시지를 전송할 객체는 무엇을 원할까?</p></blockquote><p>우리가 던져야 할 첫 질문이다.<br>누구와 협력할지는 몰라도 그 객체가 <strong>협력에서 원하는 건</strong> 분명해보인다.<br>영화 예매의 예시에선 영화를 예매하는 것을 원한다. 그렇다면 메시지는 예매하라가 된다.</p><h4 id="메시지를-결정하고-나면-메시지에-적합한-객체를-선택해야-한다"><a href="#메시지를-결정하고-나면-메시지에-적합한-객체를-선택해야-한다" class="headerlink" title="메시지를 결정하고 나면 메시지에 적합한 객체를 선택해야 한다."></a>메시지를 결정하고 나면 메시지에 적합한 객체를 선택해야 한다.</h4><blockquote><p>메시지를 수신할 적합한 객체는 누구인가?</p></blockquote><p>이때 객체는 상태와 행동을 가진 캡슐화의 단위다.<br>객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.<br><em>(무지성 getter, setter는 안된다!)</em></p><p>객체는 자신의 책임과 책임에 필요한 상태를 가져야 한다.<br>객체의 <strong>책임과 책임을 수행하는데 필요한 정보를 잘 아는 객체에게 책임을 할당한다.</strong><br>GRASP는 이 패턴을 <strong>정보 전문가 패턴</strong>이라고 한다.</p><p>이때 정보를 알고 있다는 건 데이터를 저장하고 있다는 의미와는 살짝 다르다.<br>정보를 저장하지 않아도, 어떤 객체를 알고 있거나, 필요한 정보를 계산을 제공하는 방식 등 다양하다.</p><p><strong>정보 전문가가 정보를 알고 있다는 것은 반드시 정보를 저장한다는 의미는 아니다!</strong></p><blockquote><p>영화 예매 시스템의 예시에서는 어떨까?</p></blockquote><p><em>예매하라</em>는 메시지를 잘 수행할 객체를 찾아보면 된다.</p><p>도메인 개념에서 아마 <em>상영 객체</em>가 잘 수행할 것 같다.<br>왜냐면 예매하는 책임에는 상영 시간, 상영 순번, 상영 영화 등 정보가 필요한데, 이런 정보는 상영 객체가 가지는게 자연스럽다.<br>따라서 영화 예매 정보 전문가는 상영이다.</p><h4 id="정보-전문가가-메시지를-처리하는-흐름을-생각하라"><a href="#정보-전문가가-메시지를-처리하는-흐름을-생각하라" class="headerlink" title="정보 전문가가 메시지를 처리하는 흐름을 생각하라."></a>정보 전문가가 메시지를 처리하는 흐름을 생각하라.</h4><p>메시지와 메시지를 처리할 객체를 정했다면 이제 그 정보 전문가가 <strong>내부에서 어떻게 책임을 다할지 생각</strong>해보자.</p><p>이 흐름은 <strong>외부로 공개되지 않으며</strong>, 개략적인 수준에서 책임에 필요한 작업을 생각해보고, <strong>혼자서 못하는 작업인지 분별</strong>할 정도로 생각한다.<br>혼자서 처리할 수 없는 작업은 또다시 <strong>외부로 보내는 메시지가 되고, 이 메시지에 맞는 정보 전문가를 찾는 과정</strong>을 반복한다.</p><p>영화 시스템의 예시에서는 상영 객체가 예매하라는 메시지를 처리할 때, 예매 가격을 처리하는 과정이 필요하다.<br>그러나 상영 객체는 각 영화의 가격이나, 할인 정책을 알지 못한다. 그래서 외부의 도움이 필요하다.</p><p>이제 가격을 계산하라는 새로운 메시지가 생기고, 이 메시지를 책임질 새로운 객체를 선정하면 된다.</p><h2 id="낮은-결합도를-추구해라-low-coupling-pattern"><a href="#낮은-결합도를-추구해라-low-coupling-pattern" class="headerlink" title="낮은 결합도를 추구해라(low coupling pattern)"></a>낮은 결합도를 추구해라(low coupling pattern)</h2><p>설계의 전체적인 결합도가 낮도록 책임을 할당하라.</p><p>위에서 만든 도메인 모델을 보면 연결되있는 개념들이 있다.<br>영화 예매 시스템에서, 영화 객체와 영화 할인 기준 개념은 서로 연관있다.</p><p>반면 상영과 영화 할인 기준 개념은 연결되어 있지않다.<br>만약 이 둘을 연결하려면, 새로운 결합도가 생기는 거고 추천하지 않는다.</p><p>차라리 <strong>이미 연관된 개념</strong>인 영화 객체와 영화 할인 기준 개념을 <strong>서로 연결</strong>하는게 맞다.</p><h2 id="높은-응집도를-추구해라-high-cohesion-pattern"><a href="#높은-응집도를-추구해라-high-cohesion-pattern" class="headerlink" title="높은 응집도를 추구해라(high cohesion pattern)"></a>높은 응집도를 추구해라(high cohesion pattern)</h2><p>영화 예매 시스템에서 상영이 영화 할인과 결합되면 응집도가 낮아지는 문제가 생긴다.</p><p>상영은 이제 영화 할인 계산을 직접할 수 있지만,<br>근데 만약에 영화 할인 관련 객체를 교환하는 경우를 생각해보자.<br>그러면 상영 객체도 같이 변경되어야 하는 거다.(<strong>서로 다른 이유로 변경되는 책임을 지게된다</strong>.)</p><p>상영 정보가 바뀌면 할인 객체도 변경되어야 하고,<br>할인 객체가 바뀌면 상영 객체도 변경되어야 한다.</p><p>이 둘은 <strong>그런 수고를 감수할 정도로 같이 결합해야할 객체인지 의심</strong>해보아야 한다.<br>한 클래스는 한 가지의 변경사항만 책임지도록 하자.<br>변경되는 이유가 여러가지면 이 클래스가 변경되는 시점도 제각각이고, 연관성도 떨어진다.</p><p>차라리 영화 객체와 할인 객체가 연결되는게 맞고, 상영은 영화 객체와만 결합하는게 낫다.<br>그러면 상영은 할인 관련 책임은 신경을 전혀 쓰지 않아도 된다.</p><h4 id="변경의-이유가-지나치게-많은-클래스의-징후"><a href="#변경의-이유가-지나치게-많은-클래스의-징후" class="headerlink" title="변경의 이유가 지나치게 많은 클래스의 징후"></a>변경의 이유가 지나치게 많은 클래스의 징후</h4><ol><li><strong>인스턴스 변수가 초기화되는 시점</strong>을 살펴보자<ol><li>인스턴스 변수가 초기화 될 때 일부만 초기화되면 응집도가 낮다고 봐야한다.</li><li>그렇지 않다면 함께 초기화 되는 기준으로 코드를 분리하라.</li></ol></li><li><strong>메서드들이 인스턴스 변수를 사용하는 방식</strong>을 살펴보자<ol><li>모든 메서드가 모든 변수를 사용하면 응집도가 높은 것.</li><li>일부 메서드들은 특정 변수만 사용하는 경우, 코드를 분리하라.</li></ol></li></ol><h2 id="창조자에게-객체-생성-책임을-할당하라-creator-pattern"><a href="#창조자에게-객체-생성-책임을-할당하라-creator-pattern" class="headerlink" title="창조자에게 객체 생성 책임을 할당하라(creator pattern)"></a>창조자에게 객체 생성 책임을 할당하라(creator pattern)</h2><p>객체를 생성할 책임을 어떤 객체에게 할당할 것인가?</p><p>Creator pattern은 다음 조건을 가장 만족시키는 객체가 생성해야 한다고 주장한다.<br>객체 A를 생성해야 한다면…</p><ol><li>A 객체를 <strong>포함하거나 참조</strong>하는 객체</li><li>A 객체를 <strong>기록</strong>하는 객체</li><li>A 객체를 <strong>긴밀하게 사용</strong>하는 객체</li><li>A 객체를 <strong>초기화 하는데 필요한 데이터</strong>를 가진 객체</li></ol><p>즉 조건들을 보면, A객체와 결합되있는 객체를 찾고 있는 걸 알 수 있다.<br>즉 이미 결합된 관계에서 객체를 만드는게 결합도를 낮추는데 도움이 된다.</p><h2 id="인터페이스로-변화에-대응하라-polymorphism-protected-variations"><a href="#인터페이스로-변화에-대응하라-polymorphism-protected-variations" class="headerlink" title="인터페이스로 변화에 대응하라(polymorphism, protected variations)"></a>인터페이스로 변화에 대응하라(polymorphism, protected variations)</h2><p>코드를 작성하다보면, 특정 객체 타입에 따라 다르게 반응해야 하는 경우가 있다.</p><p>예를 들면 할인 기준에 따라 할인 적용을 다르게 해야 하면 if, else if로 객체의 타입을 검사해서 할인을 적용해줘야 한다.<br>하지만, 이때 기준이 추가되면, 매번 else if를 추가해줘야 된다.</p><p>그래서 인터페이스를 도입해서 원하는 기준으로 초기화해주면, 검사하지 않고 할인 적용 메시지를 보내주면 된다.</p><p>인터페이스를 도입해서 캡슐화하면, 구현 클래스들의 세세한 변경을 외부에서는 신경 안써도 된다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/29/java/object/object3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>REDIRECT와 FORWARD의 차이!!</title>
      <link>https://yangdongjue5510.github.io/2021/11/29/spring/boot/boot13/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/29/spring/boot/boot13/</guid>
      <pubDate>Mon, 29 Nov 2021 06:09:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;REDIRECT와-FORWARD의-차이&quot;&gt;&lt;a href=&quot;#REDIRECT와-FORWARD의-차이&quot; class=&quot;headerlink&quot; title=&quot;REDIRECT와 FORWARD의 차이&quot;&gt;&lt;/a&gt;REDIRECT와 FORWARD의 차이&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="REDIRECT와-FORWARD의-차이"><a href="#REDIRECT와-FORWARD의-차이" class="headerlink" title="REDIRECT와 FORWARD의 차이"></a>REDIRECT와 FORWARD의 차이</h1><h2 id="REDIRECT"><a href="#REDIRECT" class="headerlink" title="REDIRECT"></a>REDIRECT</h2><p>리다이렉트는 “서버가 클라이언트에게 해당 URL로 다시 요청하라고 명령하는 것”이다.</p><ol><li>클라이언트가 서버의 URL에 <strong>요청</strong> (get이던 post던 상관없이)</li><li>서버의 컨트롤러가 해당 URL에 매핑된 메서드 실행</li><li>해당 메서드가 다른 URL로 리다이렉트 시킬 경우, <strong>클라이언트는 그 URL로 GET 요청을 새로 실행!</strong></li></ol><h3 id="REDIRECT의-특징"><a href="#REDIRECT의-특징" class="headerlink" title="REDIRECT의 특징"></a>REDIRECT의 특징</h3><p>리다이렉트는 클라이언트에게 <strong>새로운 GET 요청을 하도록 명령하는 것</strong>이다.</p><p>따라서 <strong>새로운 요청</strong>이 만들어져서, 스프링의 <strong>모델 같은 값이 모두 초기화 된다!!</strong></p><p>대신 GET 요청을 새롭게 실행한 것이라서 브라우저의 <strong>GET 요청한 URL로 달라지고</strong>,<br><strong>새로고침할 경우 GET 요청이 반복되서 실행되는 것</strong>이므로,<br>반복된 POST를 방지 할 수 있다.(이건 포워드에서 더 잘 알아보자.)</p><h3 id="REDIRECT하는-컨트롤러-예시"><a href="#REDIRECT하는-컨트롤러-예시" class="headerlink" title="REDIRECT하는 컨트롤러 예시"></a>REDIRECT하는 컨트롤러 예시</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(++i);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//리다이렉트하면 다음 메서드로 get요청이 간다</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/result&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;get method&quot;</span> +getListString();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="FORWARD"><a href="#FORWARD" class="headerlink" title="FORWARD"></a>FORWARD</h2><p>포워드는 “서버가 포워딩한 URL이 매핑된 메서드를 실행하고 그 결과값을 클라이언트에게 보여준다.”</p><p>즉 서버가 클라이언트에게 해당 URL을 GET 요청으로 다시 하라고 하는 것이 아닌,<br>자기가 해당 URL 매핑된 메서드를 찾아서 실행한다!!</p><p>이때 중요한 건 처음 클라이언트가 보낸 요청 그대로 유지한다는 점이다.<br>리다이렉트는 처음 클라이언트가 보낸 요청은 종료하고, 보내고 싶은 URL로 새로운 GET 요청을 통해 접근했지만,<br>포워드는 처음 클라이언트가 보낸 <strong>요청을 끝내지 않고 서버가 보내고 싶은 URL로 처음 요청을 유지한 상태로 접근한다.</strong></p><h3 id="FORWARD의-특징"><a href="#FORWARD의-특징" class="headerlink" title="FORWARD의 특징"></a>FORWARD의 특징</h3><p>포워드는 새로운 요청을 생성하지 않는다.<br>다만 <strong>다른 URL에 매핑된 메서드에 접근</strong>할 뿐이다.</p><p>그래서 POST요청이 온 상황에서 포워드하면,<br>포워드한 URL로 POST method로 매핑된 메서드에 접근하려고 한다.<br><strong>즉 기존 요청의 HTTP method를 유지한 상황에서 접근한다</strong>.</p><p>기존의 요청이 보존된 상황이므로, 스프링의 <strong>모델 같은 값이 다른 URL로 포워딩되도 유지된다</strong>.</p><p>이때 중요한 건 클라이언트 요청 처리 과정에 포워드가 포함된다는 사실이다.<br>(리다이렉트는 클라이언트의 처음 요청을 종료시키고 새로운 GET 요청을 만들었다. 즉 분리된다.)<br>그래서 <strong>포워딩하고 나서도 클라이언트의 URL은 처음 요청했던 URL과 동일</strong>하다.</p><p>그 상태로 <strong>새로고침을 하면, 맨 처음 클라이언트의 요청을 다시 시작하는 것</strong>이다.<br>즉 POST를 클라이언트가 요청하고, 서버가 view 관련 URL로 포워딩 시킨다고 했을 때,</p><p>클라이언트는 view를 볼 수 있지만, URL은 클라이언트가 POST 요청하던 그대로이다.<br>이 상태에서 새로고침을 하면 다시 클라이언트의 POST 요청 -&gt; 서버가 veiw 관련 URL 포워딩 과정을 다시하게 된다.</p><p>즉 <strong>POST를 반복해서 하게 된다!!!!</strong></p><h3 id="FORWARD하는-컨트롤러-예시"><a href="#FORWARD하는-컨트롤러-예시" class="headerlink" title="FORWARD하는 컨트롤러 예시"></a>FORWARD하는 컨트롤러 예시</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(++i);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//이전 요청에 따라 매핑된다.</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/result&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;get method&quot;</span> +getListString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/result&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;post method&quot;</span> +getListString();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="직접-테스트-해보기"><a href="#직접-테스트-해보기" class="headerlink" title="직접 테스트 해보기"></a>직접 테스트 해보기</h2><h3 id="컨트롤러-클래스"><a href="#컨트롤러-클래스" class="headerlink" title="컨트롤러 클래스"></a>컨트롤러 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getListString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">list.stream().forEach(integer -&gt; sb.append(integer));</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/result&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;get method&quot;</span> +getListString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/result&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;post method&quot;</span> +getListString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(++i);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(++i);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSP-화면"><a href="#JSP-화면" class="headerlink" title="JSP 화면"></a>JSP 화면</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/redirect&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;리다이렉트&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/forward&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;포워드&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/boot/">Boot</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/29/spring/boot/boot13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>응집도와 결합도</title>
      <link>https://yangdongjue5510.github.io/2021/11/29/java/object/object2/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/29/java/object/object2/</guid>
      <pubDate>Sun, 28 Nov 2021 15:45:28 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;응집도와-결합도&quot;&gt;&lt;a href=&quot;#응집도와-결합도&quot; class=&quot;headerlink&quot; title=&quot;응집도와 결합도&quot;&gt;&lt;/a&gt;응집도와 결합도&lt;/h1&gt;&lt;h2 id=&quot;응집도&quot;&gt;&lt;a href=&quot;#응집도&quot; class=&quot;headerlink&quot; ti</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="응집도와-결합도"><a href="#응집도와-결합도" class="headerlink" title="응집도와 결합도"></a>응집도와 결합도</h1><h2 id="응집도"><a href="#응집도" class="headerlink" title="응집도"></a>응집도</h2><p>모듈 내부 요소가 연관된 정도.<br>모듈의 내부 요소가 한 목적을 위해 긴밀하게 협력하는 정도.</p><p>높을 수록 좋다.</p><p><strong>좀더 구체적으로 설명하면,</strong></p><p>하나의 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도<br>하나 바꾸려고 할 때, 모듈 전체를 바꿔야 되면 응집도가 높은 것.</p><p>하나의 변경이 일어날 때, 모듈 하나만 바꿔서 해결 가능하면, 응집도가 높은 것.</p><p>즉 특정 요구 사항을 변경하려고 한다면,<br>그 <strong>요구 사항과 관련된 코드는 하나의 모듈에 모여있어야 한다.</strong></p><p>그 요구 사항과 관련된 코드를 찾기 위해 소스 코드 전체를 구석구석 찾으면 안된다!!</p><h2 id="결합도"><a href="#결합도" class="headerlink" title="결합도"></a>결합도</h2><p>한 모듈이 다른 모듈에 대해 얼마나 많은 정보를 갖고 있는지.<br>의존성 정도를 나타냄.</p><p>다른 모듈에 대해서는 최소한의 정보만 가지고 있는게 좋다.<br>낮을 수록 좋다.</p><p><strong>좀더 구체적으로 설명하면,</strong></p><p><strong>한 모듈이 변경하려 할 때 다른 모듈도 바뀌어야 하는 정도.</strong><br><strong>하나 바꾸려고 하는데 다른 애들도 다 바꿔줘야되면 결합도가 높은거다.</strong><br>(구현된 클래스에 의존하지 말고 인터페이스에 의존하라는 말도 결합도를 낮추기 위해서 등장한다.)</p><p>물론 바꿀 일이 거의 없는 객체는 결합도가 높아도 괜찮다.</p><h2 id="캡슐화와-관계"><a href="#캡슐화와-관계" class="headerlink" title="캡슐화와 관계"></a>캡슐화와 관계</h2><p><strong>캡슐화는 변할 수 있는 내용은 외부에서 알 수 없게 감추는 것이다.</strong></p><p>일반적으로 응집도와 결합도의 문제는 캡슐화를 잘 설계하면 동시에 해결된다.</p><h3 id="캡슐화가-잘된-걸까-public-Getter-setter"><a href="#캡슐화가-잘된-걸까-public-Getter-setter" class="headerlink" title="캡슐화가 잘된 걸까? (public Getter, setter)"></a>캡슐화가 잘된 걸까? (public Getter, setter)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Money free;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">getFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFree</span><span class="params">(Money fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fee = fee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 private 매개변수를 해놓고, getter, setter를 해놓으면 캡슐화가 잘 된걸까?</p><p>답은 <strong>아니다!!!</strong></p><p>게터 세터는 객체 내부 상태에 어떤 정보도 캡슐화하지 못한다. 사실상 그냥 public으로 열어둔거나 다름없다.<br><strong>외부에서 Movie 객체를 접근할 때 이미 Money 객체가 있다는 걸 알게된다.</strong></p><p>이런 경우는 객체가 가지는 데이터에 중점적으로 설계해서 이런 일이 생긴다.<br><strong>객체는 문맥을 고려한 책임을 기반으로 설계되어야 한다.</strong></p><h3 id="높은-결합도"><a href="#높은-결합도" class="headerlink" title="높은 결합도"></a>높은 결합도</h3><p>결합도는 하나의 모듈을 변경하려 할 때 다른 모듈도 다 바뀌어야 하는 정도이다.</p><p>캡슐화를 지키지 못해서 결합도가 높아지는 경우를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Money fee; <span class="comment">//Money에 의존</span></span><br><span class="line">    <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">      fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 예시에선 Money타입의 fee에 요금 정보를 저장하고 있다.<br>근데 만약 Money가 아닌 다른 타입에 fee를 저장하고 싶으면 어떻게 되는가?</p><p>Money 대신 다른 타입을 수행할 수 있도록,<br><strong>getFee()를 수정하고 -&gt; minus()를 수정하고 -&gt; times()를 수정</strong>해야 한다</p><p>Money를 바꿀 뿐인데 <strong>다른 객체의 메서드들이 다 변해줘야 한다</strong>.</p><p>이는 movie의 getFee()가 사실상 객체에 fee와 관련된 내용이 있음을 알리는, 즉 <strong>캡슐화 하지 못해서 생긴 사례</strong>다.</p><h3 id="낮은-응집도"><a href="#낮은-응집도" class="headerlink" title="낮은 응집도"></a>낮은 응집도</h3><p>변경되는 이유가 각자 다른 코드들을 하나의 모듈 안에 뭉쳐 놓으면, 변경과 관련없는 코드도 영향을 받을 수 있다.</p><p>할인 정책을 선택하는 코드와 할인 조건을 검증하는 코드가 한 모듈에 있다고 하자.<br>할인 정책을 추가하려고 하면, 할인 조건을 검증하는 코드는 변경과 큰 상관은 없지만 영향을 받는다.</p><p>응집도가 낮으면 변경 하나를 하려고 할 때 코드 구석구석을 고쳐야 할 수 있다.</p><p>응집도가 낮다는 건 자신과 관련있는 코드가 다른 엉뚱한 곳에 있을 수 있다는 의미이기도 하기 때문이다.</p><blockquote><p>단일 책임 원칙</p></blockquote><p>한 클래스가 변경되려면, 하나의 이유여야 한다는 것이다.<br>즉 응집도 있게 설계해서 그 클래스가 엉뚱한 일에도 영향 받지 않도록 설계되어야 함을 의미한다.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/29/java/object/object2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>12. 자바의 상속 내부 원리 (부모의 private 변수는 자식이 직접 접근 가능할까)</title>
      <link>https://yangdongjue5510.github.io/2021/11/28/java/java-basic/java12/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/28/java/java-basic/java12/</guid>
      <pubDate>Sun, 28 Nov 2021 14:27:33 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;부모의 private 멤버 변수는 자식이 직접 접근할 수 있을까?&lt;br&gt;답은 &lt;strong&gt;No&lt;/strong&gt;다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;자식 객체가 생성되면, 부모 객체는 생성 될까?&lt;/p&gt;
&lt;p&gt;답은 &lt;strong&gt;Y</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><p>부모의 private 멤버 변수는 자식이 직접 접근할 수 있을까?<br>답은 <strong>No</strong>다.</p></li><li><p>자식 객체가 생성되면, 부모 객체는 생성 될까?</p><p>답은 <strong>Yes</strong>다</p></li></ol><p>이를 검증하기 위해 코드를 짜보자.</p><h2 id="예시코드"><a href="#예시코드" class="headerlink" title="예시코드"></a>예시코드</h2><h3 id="부모-클래스"><a href="#부모-클래스" class="headerlink" title="부모 클래스"></a>부모 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Parent!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String privateString = <span class="string">&quot;private&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> String protectedString = <span class="string">&quot;protected&quot;</span>;</span><br><span class="line">String defaultString = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> String publicString = <span class="string">&quot;public&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>부모 객체가 생성되면, 부모 생성 문구를 출력하도록 했다.<br>그리고 접근 지시자 별 문자열을 멤버로 가지고 있다.</p><h3 id="자식-클래스"><a href="#자식-클래스" class="headerlink" title="자식 클래스"></a>자식 클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super(); 부모의 기본 생성자가 생략되어 있다.</span></span><br><span class="line">System.out.println(<span class="string">&quot;SUb class!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자식 객체는 생성자만 가지고 있다.</p><h4 id="이때-자식클래스는-부모의-private-멤버-변수와-생성자를-상속받지-않는다"><a href="#이때-자식클래스는-부모의-private-멤버-변수와-생성자를-상속받지-않는다" class="headerlink" title="이때 자식클래스는 부모의 private 멤버 변수와 생성자를 상속받지 않는다."></a>이때 자식클래스는 부모의 private 멤버 변수와 생성자를 상속받지 않는다.</h4><p>즉 privateString을 제외한 멤버변수를 자식 클래스도 직접 접근 가능하다.<br>자식 객체를 생성하면, 자식의 생성자가 실행된다. (<strong>이때, super()에 의해 부모 생성자 먼저 실행된다!</strong>)</p><p>그렇다고 자식 객체를 만들 때, 부모 객체와 자식 객체가 각각 생기는 게 아니다.<br>자식 객체를 만들어도 하나의 객체를 가진다.</p><p>다만 자식 객체가 생성 되기 전에 부모 객체가 생성되고, 부모 객체의 멤버가 초기화된다.<br>그 다음 자식 생성자가 실행되면서 부모 객체가 생성된 것에 자식 객체가 추가로 씌여진다.</p><p>쉽게말하면 (Object 객체 생성자 실행 -&gt; 부모 객체 생성자 실행 -&gt; 자식 객체 생성자 실행) 이런 식으로 실행되고,<br>이 세가지 클래스에 있는 멤버들은 한 객체(자식)에 초기화된다.</p><h4 id="그렇다면-다음-코드를-실행하면"><a href="#그렇다면-다음-코드를-실행하면" class="headerlink" title="그렇다면 다음 코드를 실행하면?"></a>그렇다면 다음 코드를 실행하면?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Parent first = <span class="keyword">new</span> Parent();</span><br><span class="line">Parent second = <span class="keyword">new</span> Sub();</span><br><span class="line">Sub third = <span class="keyword">new</span> Sub();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같다!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent!</span><br><span class="line">Parent!</span><br><span class="line">SUb <span class="class"><span class="keyword">class</span>!</span></span><br><span class="line"><span class="class"><span class="title">Parent</span>!</span></span><br><span class="line"><span class="class"><span class="title">SUb</span> <span class="title">class</span>!</span></span><br></pre></td></tr></table></figure><blockquote><p>참고 사이트</p></blockquote><p><a href="https://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation">https://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation</a></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/28/java/java-basic/java12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>9. 템플릿 메서드 패턴</title>
      <link>https://yangdongjue5510.github.io/2021/11/27/java/design-pattern/dp9/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/27/java/design-pattern/dp9/</guid>
      <pubDate>Sat, 27 Nov 2021 12:14:40 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;템플릿-메서드-패턴&quot;&gt;&lt;a href=&quot;#템플릿-메서드-패턴&quot; class=&quot;headerlink&quot; title=&quot;템플릿 메서드 패턴&quot;&gt;&lt;/a&gt;템플릿 메서드 패턴&lt;/h1&gt;&lt;p&gt;템플릿 메서드 패턴은 특정 역할의 책임을 &lt;strong&gt;한 메서드에 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="템플릿-메서드-패턴"><a href="#템플릿-메서드-패턴" class="headerlink" title="템플릿 메서드 패턴"></a>템플릿 메서드 패턴</h1><p>템플릿 메서드 패턴은 특정 역할의 책임을 <strong>한 메서드에 여러 메서드를 조합*(이게 템플릿!)*으로 정해놓는 패턴</strong>이다.</p><p><strong>템플릿 메서드를 구성하는 메서드들은 역할에 속하는 객체마다 다르게 구현</strong>될 수 있다.</p><h2 id="활용-예시"><a href="#활용-예시" class="headerlink" title="활용 예시"></a>활용 예시</h2><p>우리는 여러 DB에 연결해야 한다.</p><p>우리가 연결한 DB는 모두 다음과 같은 절차를 따른다고 하자.<br>해당 DB드라이버 찾기 - DB에 로그인 - DB에 연결</p><p>이때 DB마다 사용하는 드라이버가 다르다.</p><p>이 상황에서 템플릿 메서드 패턴을 활용해서 문제를 해결해보자.</p><h4 id="템플릿-메서드를-포함한-추상-클래스"><a href="#템플릿-메서드를-포함한-추상-클래스" class="headerlink" title="템플릿 메서드를 포함한 추상 클래스"></a>템플릿 메서드를 포함한 추상 클래스</h4><p>일단 추상 클래스 안에 주어진 템플릿을 구현한 메서드를 만들어보자!<br>이때 각 DB마다 달라지는 부분은 추상 메서드로 다형성을 확보한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataConnection</span> </span>&#123;</span><br><span class="line"><span class="comment">//템플릿 메서드</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">findDriver();</span><br><span class="line">login();</span><br><span class="line">connectDB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">findDriver</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">connectDB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;로그인을 실행합니다...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="추상-클래스를-상속하는-자식-클래스"><a href="#추상-클래스를-상속하는-자식-클래스" class="headerlink" title="추상 클래스를 상속하는 자식 클래스"></a>추상 클래스를 상속하는 자식 클래스</h4><p>이제 DB마다 클래스를 상속해서 구현하자.<br>추상 메서드를 DB 요구 조건에 맞게 구현하면 된다.</p><p><em>우리는 MySQL과 H2를 예시로 구현해보자</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLConnection</span> <span class="keyword">extends</span> <span class="title">DataConnection</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MySQL 드라이버를 찾습니다.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MySQL과 연결합니다.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2Connection</span> <span class="keyword">extends</span> <span class="title">DataConnection</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;H2 드라이버를 찾습니다.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;H2 드라이버를 연결합니다.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="결과-확인"><a href="#결과-확인" class="headerlink" title="결과 확인"></a>결과 확인</h4><p>이제 적용해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DataConnection dataConnection = <span class="keyword">new</span> MySQLConnection();</span><br><span class="line">dataConnection.process();</span><br><span class="line"></span><br><span class="line">dataConnection = <span class="keyword">new</span> H2Connection();</span><br><span class="line">dataConnection.process();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL 드라이버를 찾습니다.</span><br><span class="line">로그인을 실행합니다...</span><br><span class="line">MySQL과 연결합니다.</span><br><span class="line">H2 드라이버를 찾습니다.</span><br><span class="line">로그인을 실행합니다...</span><br><span class="line">H2 드라이버를 연결합니다.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/design-pattern/">Design Pattern</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/27/java/design-pattern/dp9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>객체지향의 역할, 책임, 협력</title>
      <link>https://yangdongjue5510.github.io/2021/11/26/java/object/object1/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/26/java/object/object1/</guid>
      <pubDate>Fri, 26 Nov 2021 11:36:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;역할-책임-협력&quot;&gt;&lt;a href=&quot;#역할-책임-협력&quot; class=&quot;headerlink&quot; title=&quot;역할, 책임, 협력&quot;&gt;&lt;/a&gt;역할, 책임, 협력&lt;/h1&gt;&lt;p&gt;하나의 프로그램을 만들기 위해서는 다양한 객체가 &lt;strong&gt;자신의 로직&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="역할-책임-협력"><a href="#역할-책임-협력" class="headerlink" title="역할, 책임, 협력"></a>역할, 책임, 협력</h1><p>하나의 프로그램을 만들기 위해서는 다양한 객체가 <strong>자신의 로직</strong>을 실행해서 전체 기능을 완성한다.</p><p>중요한 건, 다양한 객체가 한 기능을 만들기 위해 <strong>메시지</strong> 를 주고 받으며 <strong>상호작용</strong>한다는 사실이다.</p><p>이처럼 어플리케이션의 기능을 완성하기 위해 여러 객체가 상호작용하는 것을 <strong>협력</strong>이라고 한다.</p><p>각 객체들이 수행하는 자신의 로직을 <strong>책임</strong>이라고 하고, 객체들이 협력 안에서 수행하는 책임이 모여 객체가 수행하는 <strong>역할</strong>을 구성한다.</p><h2 id="협력"><a href="#협력" class="headerlink" title="협력"></a>협력</h2><p>두 객체 사이의 협력은 한 객체가 다른 객체에 도움을 요청하면서 시작된다.<br><strong>메시지 전송</strong>은 객체 사이의 협력을 만드는 유일한 커뮤니케이션 수단이다.</p><p>즉 협력이란 어떤 객체가 <strong>다른 객체에게 무엇인가를 요청</strong>하는 행위다.<br>협력은 역할을 수행하기 위한 <strong>특정 책임을 잘 수행할 수 있는 다른 객체에게 위임</strong>하는 행위다.</p><h3 id="협력과-자율성"><a href="#협력과-자율성" class="headerlink" title="협력과 자율성"></a>협력과 자율성</h3><p>메시지를 수신한 객체는 메서드를 실행해 요청을 실행한다.<br>이때 협력을 요청한 객체는 응답하는 객체가 어떤 방식으로 메시지를 처리할지 알지 못한다.<br>요청하는 객체가 해당 책임에 대해 지나치게 개입하면 안된다! (다른 객체의 내부구현에 손대지말라.)<br><em>(ex. 협력에 참여하는 객체의 인스턴스 변수에 직접 접근하는 경우는 해당 객체의 자율성을 훼손 -&gt; private 키워드로 캡슐화)</em></p><h3 id="객체의-행동과-상태"><a href="#객체의-행동과-상태" class="headerlink" title="객체의 행동과 상태"></a>객체의 행동과 상태</h3><p>객체는 <strong>어떤 협력에 참여할 지에 따라 상태와 행동이 정의되어야 한다</strong>.<br>즉 <strong>협력이 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공</strong>한다.<br>협력이 달라지면 객체의 행동도 달라질 수 있다. 협력없는 행동은 아무 의미 없다!</p><p>그렇다면 상태는 왜 존재하는가?<br><strong>상태는 행동에 사용되기 때문에 존재한다.</strong></p><p>즉 협력은 객체의 행동을 정의하고<br>객체의 행동이 필요한 정보에 따라 객체의 상태가 결정된다.</p><p><strong>결국 협력은 객체의 모든 것을 설계하는 문맥을 제공한다.</strong></p><h2 id="책임"><a href="#책임" class="headerlink" title="책임"></a>책임</h2><p>책임은 협력에 참여하기 위해 객체가 수행하는 행동이다.</p><p>책임을 지는 객체는 <strong>책임을 완수하기 위해 필요한 정보를 알고 있어야 한다</strong>.<br>혹은 그 책임을 할 수 없는 객체가 그 책임이 필요한 경우, <strong>그 책임을 할 수 있는 객체를 알고 있어야 한다.</strong></p><p>즉 <strong>책임은 단순한 행동을 해야 하는 것 뿐만 아니라, 그 행동에 필요한 정보도 알고 있어야 하는 것</strong>을 의미한다.</p><p>객체지향에서 제일 중요한 것이 <strong>객체에게 적절한 책임을 지게 하는 것</strong>이다.</p><h3 id="책임-할당"><a href="#책임-할당" class="headerlink" title="책임 할당"></a>책임 할당</h3><p>책임 할당을 위한 기본적인 방법은 <strong>그 책임을 수행하기 위해 필요한 정보를 가장 잘 아는 전문가에게 책임을 주는 것</strong>이다.</p><p>이제 이 책임을 할당하는 과정을 살펴보자.</p><ol><li>하나의 <strong>큰 메시지를 정의</strong>한다.<br>(시스템이 사용자에게 제공하는 큰 기능을 하나의 책임으로 본다)</li><li>메시지를 정의했으면 그 <strong>메시지를 처리할 객체</strong>를 고른다.<br>(이때 메시지가 크기 때문에 그 객체 혼자서 처리 못한다.)</li><li>그 객체가 처리하지 못하는 책임은 다<strong>른 전문가(!)를 찾아서 메시지를 전달</strong>한다.</li><li>이 과정을 2번과 3번을 반복한다.</li></ol><h3 id="책임-주도-개발"><a href="#책임-주도-개발" class="headerlink" title="책임 주도 개발"></a>책임 주도 개발</h3><p>위 과정을 <strong>책임 주도 개발</strong>로 표현하면 다음과 같다</p><ol><li>일단 시스템이 사용자에게 제공하는 기능을 <strong>시스템이 담당할 하나의 책임</strong>으로 본다.<br><em>(시스템의 책임을 파악)</em></li><li>이제 하나의 큰 책임을 더 작은 책임으로 잘게 <strong>분해</strong>한다.</li><li>분해된 책임들을 <strong>객체들에게 할당</strong>한다.</li><li>책임을 수행하던 객체가 다른 객체의 <strong>도움이 필요하면 적절한 객체 혹은 역할을 찾는다</strong>.</li><li>해당 객체가 참여하게 되면서 두 객체는 <strong>협력</strong>하게 된다.</li></ol><h2 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h2><p>역할은 <strong>특정한 협력 안에서 수행하는 책임의 집합</strong>.<br>실제로 협력에서 객체에게 책임을 할당한다기 보다는 <strong>역할에 책임을 할당한다고 보는 게 좋다.</strong></p><p>역할은 유연하고 재사용 가능한 협력을 얻을 수 있게 한다.<br>역할은 <strong>다른 것으로 교체할 수 있는 책임의 집합</strong>이다.</p><p>즉 동일한 책임을 가진 여러 객체가 있다면, 그것을 <strong>추상화</strong> 한 것이 역할이다.</p><p>영화 예매를 예시로 들면,<br>영화 요금을 할인 하는 두 가지 방식이 있다고 하자.<br>하나는 요금의 퍼센트로 할인하는 방식이고,(10퍼센트 할인..)<br>다른 하나는 예매 표 중 일부 값을 할인하는 방식이 있다.(두 표사면 한 표는 할인..)</p><p>이 두 방식 모두 객체로 표현된다면, 이 두 객체는 요금을 할인한다는 동일한 책임을 가진다.<br>그렇다면 우리는 이 같은 책임을 하나의 역할로 추상화하여 표현할 수 있다.<br>이렇게 하면 할인 방식에 따라 협력을 일일히 만들지 않고, 역할이 할인 정책을 추상화하여 담당하게 된다.</p><p>(자바에서 역할을 구현하는 방식은 추상 클래스와 인터페이스를 사용한다.)</p><h3 id="객체냐-역할이냐"><a href="#객체냐-역할이냐" class="headerlink" title="객체냐 역할이냐"></a>객체냐 역할이냐</h3><p>그렇다면 동일 책임을 지는 다른 객체가 없는,<br>즉 하나의 객체만이 해당 책임을 지는 경우에도 그 객체를 역할로 추상화 해줘야 할 까?</p><p>답은 아니다.</p><p>책임 수행하는 대상이 <strong>한 종류면, 간단하게 객체로 간주</strong>해도 좋다.<br>다만 책임 수행하는 객체가 <strong>여러 종류면, 역할로 간주</strong>하라.</p><p>사실 설계 초반에는 객체와 역할을 명확히 하긴 힘들다.<br><strong>다양한 객체들이 협력에 참여한다</strong>는 것이 확실하면 <strong>역할로</strong> 시작해라.<br>애매하고 <strong>확실하지 않은 경우는 객체</strong>로 시작하자. (진행하면서 역할로 대체하면 된다.)</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/">오브젝트</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/26/java/object/object1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>우아한 테크코스 4기 프리코스 1주차 회고</title>
      <link>https://yangdongjue5510.github.io/2021/11/26/java/utecoprecourse1/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/26/java/utecoprecourse1/</guid>
      <pubDate>Fri, 26 Nov 2021 05:48:15 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;우아한-테크코스-4기-프리코스-1주차&quot;&gt;&lt;a href=&quot;#우아한-테크코스-4기-프리코스-1주차&quot; class=&quot;headerlink&quot; title=&quot;우아한 테크코스 4기 프리코스 1주차&quot;&gt;&lt;/a&gt;우아한 테크코스 4기 프리코스 1주차&lt;/h1&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="우아한-테크코스-4기-프리코스-1주차"><a href="#우아한-테크코스-4기-프리코스-1주차" class="headerlink" title="우아한 테크코스 4기 프리코스 1주차"></a>우아한 테크코스 4기 프리코스 1주차</h1><h2 id="1주차-문제-깃허브-링크"><a href="#1주차-문제-깃허브-링크" class="headerlink" title="1주차 문제 깃허브 링크"></a>1주차 문제 깃허브 링크</h2><p><a href="https://github.com/woowacourse/java-baseball-precourse">https://github.com/woowacourse/java-baseball-precourse</a></p><h2 id="문제-간단-요약"><a href="#문제-간단-요약" class="headerlink" title="문제 간단 요약"></a>문제 간단 요약</h2><p>우리가 흔히 아는 야구게임을 자바로 구현하는 게 1주차 문제다.<br>세개의 수를 입력받고 해당 자릿수에 맞는 숫자를 입력한 경우 스트라이크 추가,<br>자릿수는 맞지 않지만 맞는 숫자를 포함한 경우 볼 추가해서 결과를 반환한다.</p><p>3 스트라이크. 즉 정확히 맞출 경우 게임을 종료하고,<br>다시 게임을 시작을 할 수 있도록 해야한다.</p><h2 id="마주한-문제들"><a href="#마주한-문제들" class="headerlink" title="마주한 문제들"></a>마주한 문제들</h2><h3 id="요구사항-작성하기"><a href="#요구사항-작성하기" class="headerlink" title="요구사항 작성하기"></a>요구사항 작성하기</h3><p>일단 우테코 프리코스는 가장 먼저 요구사항을 작성해야 한다.<br><strong>요구 사항을 기능 중점으로 정리해서 README.md를 작성해야 하는게 첫 단계다.</strong></p><p>처음에 필자는 그냥 우테코에서 작성된 요구사항을 마구잡이로 요구사항을 만들었는데,<br>나중에 코드를 작성하려고 했더니, 어떤 요구사항 먼저 해결해야 할 지 막막했다.</p><p>그래서 내가 고민하고 고안해낸 요구사항 분석하는 방법은 다음과 같다.</p><ol><li>가장 먼저 전체적인 <strong>프로그램의 흐름을 이해</strong>한다.</li><li>요구사항은 <strong>기능 관점에서 작성</strong>한다.</li><li>요구사항은 <strong>의존 관계가 가장 느슨한 것 먼저 우선순위로 작성</strong>한다.<ul><li>1주차 프리코스의 문제에서는 목표 숫자를 난수로 만드는게 가장 의존 관계가 느슨하다.</li><li>이게 무슨 말이냐면, 목표 숫자를 난수로 만드는 기능은 다른 기능의 힘을 필요로 하지 않는다는 의미다.</li></ul></li><li>최대한 각 기능들이 <strong>서로의 역할을 간섭하지 않도록</strong> 하라.<ul><li>일단 한 기능에서 예외처리를 담당하면, 다른 기능에서는 예외처리 책임을 질 필요 없다.</li><li>예외처리를 해야 될 경우 예외처리를 담당하는 기능과 협력하도록 하자.</li></ul></li></ol><p>이렇게 요구사항 목록을 작성하고 나면, 프로그래밍을 하는 과정에서 빼먹는 요구사항을 최소한으로 줄일 수 있다.<br>또한 요구사항 구현 순서를 어느정도 정리하고 작성하기 때문에 구현을 더 원활하게 할 수 있다.</p><h3 id="깃-사용"><a href="#깃-사용" class="headerlink" title="깃 사용"></a>깃 사용</h3><p>우테코 프리코스는 깃 커밋을 신중하게 작성해야 한다.<br>그래서 깃을 어떻게 사용하는지가 굉장히 중요하다.</p><ol><li>기능은 따로 브랜치를 만들어서 격리된 상황에서 구현하라.<ul><li>기능을 만들다가 되돌리기 쉽다.</li></ul></li><li>커밋 메시지를 잘 지켜서 작성한다.<ul><li>다른 사람이 쉽게 이해할 수 있도록 하기 위함이다.</li></ul></li><li>커밋은 기능 관점에서 작성해야 한다.<ul><li>지나치게 세세하게 하지도 않고, 지나치게 적게 하지 않기 위함이다.</li></ul></li></ol><h2 id="코드-작성"><a href="#코드-작성" class="headerlink" title="코드 작성"></a>코드 작성</h2><p>우아한 테크코스에서는 최대한 간략하게 코드를 작성하도록 한다.<br>일단 <strong>메서드가 한 역할을 잘하도록하고, 그 메서드가 15줄이 넘지 않도록 하는게 중요</strong>하다.</p><p>필자의 경우, 전체적인 기능을 정리하고 나서,<br>이 기능들을 어떤 클래스가 책임질 지,<br>혹은 메서드를 어떻게 나눌 것인지가 정말 어려웠다.</p><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>프리코스에 참여해보니, 내가 그동안 얼마나 코드를 대충 짰는지 체감하는 경험이 됐다.<br>혼자 코드를 짜다보면 의식의 흐름대로 코드를 짜게 되는 경우가 많다.<br>그러다보면 한 메서드에 수많은 기능이 의존하게 되고, 유지보수도 극악에 향하게 된다.</p><p>프리코스의 요구사항을 만족하는 방식으로 프로그래밍 하다보니 자연스럽게 책임을 나누게 되고,<br>그 책임을 수행하는 여러 객체들의 협동으로 기능을 완성했다.<br>평소 코딩할 때는 생각해보지 못했던 부분을 경험할 수 있어 재밌었다.</p><p>프리코스는 코딩하는 법을 알려주지 않는다. 다만 무엇을 만들라 한다.<br>그런데 하다보면 알게 된다. 아무도 알려주지 않지만 스스로 알게 된다.</p><p>내가 모르는 건 스스로 찾아서 해결하게 된다. 그리고 그 정보를 체득하기 위해 노력하게 된다.</p><p>프리코스를 시작하기 전, 교육을 기획한 자바지기님은 프리코스를 우아한 테크코스를 통과하기 위한 것으로 생각하지 말고,<br>더 좋은 개발자가 되기 위한 과정으로 여겨줬으면 좋겠다고 하셨는데,</p><p>이번 프리코스를 통해 더 좋은 개발자가 될 수 있을 거 같다.<br>다음 프리코스도 더 기대가 된다.</p>]]></content:encoded>
      
      
      
      <category domain="https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4/">우아한 테크 코스</category>
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/26/java/utecoprecourse1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 코딩 규칙(Java Code Conventions)</title>
      <link>https://yangdongjue5510.github.io/2021/11/20/java/java-basic/java11/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/20/java/java-basic/java11/</guid>
      <pubDate>Sat, 20 Nov 2021 14:23:18 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;자바-소스-파일-구조&quot;&gt;&lt;a href=&quot;#자바-소스-파일-구조&quot; class=&quot;headerlink&quot; title=&quot;자바 소스 파일 구조&quot;&gt;&lt;/a&gt;자바 소스 파일 구조&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;시작 주석&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;str</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="자바-소스-파일-구조"><a href="#자바-소스-파일-구조" class="headerlink" title="자바 소스 파일 구조"></a>자바 소스 파일 구조</h2><p><strong>시작 주석</strong></p><p><strong>package 문</strong></p><p><strong>import 문</strong></p><p><strong>Class 혹은 Interface 선언</strong></p><h2 id="시작-주석"><a href="#시작-주석" class="headerlink" title="시작 주석"></a>시작 주석</h2><p>모든 소스 파일은 다음과 같은 시작 주석을 써줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *클래스 이름</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *버전 정보</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *날짜</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *저작권 주의</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="package문-import문"><a href="#package문-import문" class="headerlink" title="package문 import문"></a>package문 import문</h2><p>일반적으로 패키지문을 먼저 쓰고, 임포트문을 다음에 써준다.</p><p>두 문 사이에는 공백을 써준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangdongjue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h2 id="class와-interface-선언"><a href="#class와-interface-선언" class="headerlink" title="class와 interface 선언"></a>class와 interface 선언</h2><p>클래스와 인터페이스 선언 순서를 알아보자</p><ol><li><strong>문서화 주석</strong>(/** … */)</li><li><strong>클래스/인터페이스 문</strong>(public class …)</li><li><strong>구현 주석</strong>(/* … */)</li><li><strong>클래스(static) 변수</strong><br>public - protected - default - private 순으로 나열</li><li><strong>일반 변수</strong><br>클래스 변수와 동일하게 나열</li><li><strong>생성자</strong></li><li><strong>메서드</strong><br>접근자가 아닌 기능에 의해 구성되어야 함.</li></ol><blockquote><p>한줄의 길이</p></blockquote><p>한줄의 길이는 최대 80자다.</p><p>만약 하나의 식이 한 줄에 안들어가면? 줄 나누기를 해주자.</p><h2 id="줄나누기"><a href="#줄나누기" class="headerlink" title="줄나누기"></a>줄나누기</h2><ol><li><p><strong>콤마 후에 두 줄로 나눈다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2,</span><br><span class="line">    VeryLong veryLongExpress3);</span><br></pre></td></tr></table></figure></li><li><p><strong>연산자 앞에 두 줄로 나눈다.</strong><br>이때 연산자 레벨이 맞도록 나눠 줘야 한다. (괄호의 경우…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VeryLong veryLong = veryLong1+(veryLong2+veryLong3)</span><br><span class="line">    +veryLong4;</span><br></pre></td></tr></table></figure></li><li><p><strong>메서드 선언에서 줄 나누기를 할 때는 한번 더 들여써준다.</strong><br>메서드 구현부와 헷갈리면 안되기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2,</span><br><span class="line">        VeryLong veryLongExpress3) &#123;</span><br><span class="line">    ...(메소드 구현부)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h2><p>주석은 코드 개요와 코드 자체로는 알 수 없는 추가 정보를 제공하기 위해서 쓰인다.<br>주석은 프로그램을 이해하기 위한 내용을 다뤄야 한다.<br>코드 상에 이미 표현된 중복 정보는 다루지 말아야 한다.</p><p>자바 주석은 구현 주석과 문서화 주석으로 나뉜다.</p><h3 id="구현-주석"><a href="#구현-주석" class="headerlink" title="구현 주석"></a>구현 주석</h3><ol><li><p><strong>블록 주석</strong><br>파일, 메서드, 클래스 등에 설명 할 때 사용.<br>클래스나 인터페이스 속에서 파일이나 메서드가 시작되기 전에 써줘야 하고,<br>해당 메서드나 파일의 들여쓰기를 반영해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *블록 주석을 작성하자~</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>한 줄 주석</strong><br>짧은 주석은 뒤에 따라오는 코드를 설명.<br>뒤 코드와 동일한 들여쓰기 적용.<br>윗 코드와 한칸 띄어서 사용</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 한 줄 주석 */</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>꼬리 주석</strong><br>아주 짧은 주석이 필요한 경우 설명하는 코드와 같은 줄에 작성.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">/* condition에 해당 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span><span class="comment">/* condition에 해당히지 않음 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>줄 끝 주석</strong><br>한 줄을 통째로 주석 처리하거나, 일부를 주석 처리 할때 사용.<br>코드를 주석처리 할 때 여러줄을 주석하는 건 가능하지만, 그외는 여러줄 주석을 금한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//줄 끝 주석은 이렇게 쓸 수 있다.</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//줄 끝 주석을 여기에도 쓸 수 있다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (condition) &#123;</span></span><br><span class="line"><span class="comment">//  int a = 2;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="문서화-주석"><a href="#문서화-주석" class="headerlink" title="문서화 주석"></a>문서화 주석</h3><p>문서화 주석은 다음 다섯가지를 분석한다.</p><ol><li><strong>자바 클래스</strong></li><li><strong>인터페이스</strong></li><li><strong>생성자</strong></li><li><strong>메서드</strong></li><li><strong>필드</strong></li></ol><p>다만 문서화 주석이 어울리지 않으면, 클래스 선언 후에 블록 주석 혹은 한줄 주석으로 표현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 이 클래스는 어떤 역할을 합니다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><h3 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 옳은 예시 */</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 괜찮지만 불편한 방식 */</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br></pre></td></tr></table></figure><p>이때 중요한 건 한 클래스에 필요한 변수를 선언은 가장 처음에 하는게 좋다!!!!!<br>그리고 지역 변수를 전역 변수와 같은 이름으로 선언하지 말자!!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (condition)&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;<span class="comment">// 이렇게 쓰지 말라는 거다!!!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="클래스-amp-인터페이스-선언"><a href="#클래스-amp-인터페이스-선언" class="headerlink" title="클래스 &amp; 인터페이스 선언"></a>클래스 &amp; 인터페이스 선언</h2><ol><li><p>메서드 이름과 파라미터를 감싸는 괄호 시작 사이에는 빈 공간이 없어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>여는 중괄호는 클래스&amp;인터페이스&amp;메서드의 선언부 문장 끝에 위치한다.</p></li><li><p>닫는 중괄호는 구현부가 없는 경우가 아니면 여는 문장과 동일한 들여쓰기로 새로운 줄로 사용하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Okay</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrong</span> </span>&#123; <span class="keyword">int</span> c; &#125;</span><br></pre></td></tr></table></figure></li><li><p>클래스나 인터페이스 내부의 메서드는 분리되기 위해서 한 줄씩 띄어놔야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/java/">Java</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/java/java-basic/">Java Basic</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/20/java/java-basic/java11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>스프링 부트의 특징</title>
      <link>https://yangdongjue5510.github.io/2021/11/19/spring/boot/boot12/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/19/spring/boot/boot12/</guid>
      <pubDate>Fri, 19 Nov 2021 02:56:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;스프링-부트의-특징&quot;&gt;&lt;a href=&quot;#스프링-부트의-특징&quot; class=&quot;headerlink&quot; title=&quot;스프링 부트의 특징&quot;&gt;&lt;/a&gt;스프링 부트의 특징&lt;/h1&gt;&lt;p&gt;스프링 부트는 스프링의 복잡한 xml 간편화와 빠른 개발을 위해 등장</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="스프링-부트의-특징"><a href="#스프링-부트의-특징" class="headerlink" title="스프링 부트의 특징"></a>스프링 부트의 특징</h1><p>스프링 부트는 스프링의 복잡한 xml 간편화와 빠른 개발을 위해 등장했다.<br>부트는 웹을 위해 필요한 필수 라이브러리를 내장하고 있다.(톰캣 등)</p><p>스타터(starter) : 특정 모듈을 사용할 수 있도록 필요한 라이브러리를 모아놓은 라이브러리 모음</p><p>자동설정(AutoConfiguration) : 추가된 라이브러리나 모듈을 사용할 수 있도록 자동으로 빈 등록이나 프로퍼티 설정을 하는 것.</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/">Spring</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/spring/boot/">Boot</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/19/spring/boot/boot12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>12. 링크 계층</title>
      <link>https://yangdongjue5510.github.io/2021/11/17/cs/network/network12/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/17/cs/network/network12/</guid>
      <pubDate>Wed, 17 Nov 2021 11:27:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;a-링크&quot;&gt;&lt;a href=&quot;#a-링크&quot; class=&quot;headerlink&quot; title=&quot;a. 링크&quot;&gt;&lt;/a&gt;&lt;strong&gt;a. 링크&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;a-1-링크-계층-소개&quot;&gt;&lt;a href=&quot;#a-1-링크-계층-소개&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="a-링크"><a href="#a-링크" class="headerlink" title="a. 링크"></a><strong>a. 링크</strong></h3><h4 id="a-1-링크-계층-소개"><a href="#a-1-링크-계층-소개" class="headerlink" title="a-1. 링크 계층 소개"></a><strong>a-1. 링크 계층 소개</strong></h4><p><img src="https://blog.kakaocdn.net/dn/bad51y/btq69V5AYUh/Hk9B1CJ0XoWn7s6q9DvJG0/img.png" alt="img"></p><p>링크 계층(2계층) 프로토콜을 실행하는 장치를 노드라 함.</p><p>통신 경로상의 인접한 노드들을 연결하는 통신 채널은 링크</p><p>한 링크에서 전송 노드는 데이터그램을 링크 계층 프레임으로 캡슐화해서 링크로 전송한다.</p><h4 id="a-2-링크-계층의-서비스"><a href="#a-2-링크-계층의-서비스" class="headerlink" title="a-2. 링크 계층의 서비스"></a><strong>a-2. 링크 계층의 서비스</strong></h4><ul><li>프레임화 : 네트워크 계층 데이터그램을 링크상으로 전송하기 전에 링크 계층 프래임에 캡슐화.<br><em>header payload trailer 형식으로 캡슐화</em></li><li>링크 접속 : 매체 접속 제어(MAC) 프로토콜은 링크상으로 프레임을 전송하는 규칙에 대해서 명시함</li><li>신뢰적 전달(RDT) : 링크 계층의 신뢰적 전달 서비스도 확인 응답과 재전송 방식으로 가능<br>*트랜스포트 계층이나 애플리케이션 계층과 달리 데이터를 재전송하는 방식과 달리<br>*<em>링크 계층 프로토콜은 오류가 발생한 링크에서 오류를 정정.</em><br><em>왜 수송 계층과 링크 계층 모두 RDT가 필요하지? 링크 계층에서 잘 되도, IP에서 best-effort로 인한 손실이 발생가능. 그래서 수송 계층에서 RDT를 하는 것.</em></li><li>오류 검출과 정정 : 오류 검출은 송신 노드에서 프레임의 오류 검출 비트를 설정하고 수신 노드에서 오류 검사를 수행하게 하는 방식. 오류 정정은 프레임 안의 오류 검출, 프레임의 어느 곳에서 오류가 발생했는지를 찾아내는 것.(오류 검출과 비슷하게 구현)</li></ul><h4 id="a-3-링크-계층이-구현되는-위치"><a href="#a-3-링크-계층이-구현되는-위치" class="headerlink" title="a-3. 링크 계층이 구현되는 위치"></a><strong>a-3. 링크 계층이 구현되는 위치</strong></h4><p>링크 계층은 네트워크 인터페이스 카드로 알려진 네트워크 어댑터로 구현된다.</p><p><img src="https://blog.kakaocdn.net/dn/bjr5nt/btq65sqblYl/YA0rOXs79KUaM2YiPX8LW1/img.png" alt="img"></p><p>링크 계층 제어기로 링크 계층 서비스들의 대다수가 구현한다. 일부 링크 계층 기능은 호스트 cpu에 실행되는 소프트웨어에 구현되어 있다.</p><p>링크 계층은 하드웨어와 소프트웨어의 조합.</p><p>프로토콜 스택상에서 소프트웨어와 하드웨어가 만나는 부분에 위치.</p><p>송신 측의 제어기는 상위 계층에 의해 생성되어 호스트 메모리에 저장된 데이터그램을 링크 계층 프레임을 캡슐화한 후, 링크 접속 프로토콜에 따라 이 프레임을 통신 링크로 전송한다.</p><p>수신 측의 제어기는 프레임을 수신한 후 네트워크 계층 데이터그램을 추출한다.</p><h3 id="b-오류-검출-및-정정-기술"><a href="#b-오류-검출-및-정정-기술" class="headerlink" title="b. 오류 검출 및 정정 기술"></a><strong>b. 오류 검출 및 정정 기술</strong></h3><p><img src="https://blog.kakaocdn.net/dn/cYZQZT/btq69S8YeVH/T6GBpIPcLc70GXmzNC6EC0/img.png" alt="img"></p><p>비트 오류를 방지하기 위해 송신 노드에서 데이터 D에 오류 검출 및 정정 비트들(EDC)을 첨가한다.</p><p>수신자는 자신이 수신한 D’와 EDC’만으로 원래의 D가 D’와 동일한지 결정한다.</p><p><em>오류 검출 비트를 사용하더라도 여진히 미검출된 비트 오류가 있을 수 있다.</em></p><h4 id="b-1-패리티-검사"><a href="#b-1-패리티-검사" class="headerlink" title="b-1. 패리티 검사"></a><strong>b-1. 패리티 검사</strong></h4><h4 id="b-1-1-단일-패리티-비트"><a href="#b-1-1-단일-패리티-비트" class="headerlink" title="b-1-1. 단일 패리티 비트"></a><strong>b-1-1. 단일 패리티 비트</strong></h4><p><img src="https://blog.kakaocdn.net/dn/oHejR/btq66vfDf6f/K9JL2oTbLJuS99dPhEQ0ik/img.png" alt="img"></p><p>데이터 D가 d개의 비트를 가지고 있다고 할 때, 패리티 비트를 하나 추가.</p><p>이 비트들에서 1의 개수가 짝수(혹은 홀수)가 되도록 설정한다.</p><p>수신자는 받은 데이터의 1 갯수가 홀수(혹은 짝수)이면 오류가 있음을 알게 된다.</p><p><em>그러나 짝수 개의 비트 오류가 발생하면 오류를 검출하지 못할 수도 있다.</em></p><h4 id="b-1-2-2차원-단일-비트-패리티"><a href="#b-1-2-2차원-단일-비트-패리티" class="headerlink" title="b-1-2. 2차원 단일 비트 패리티"></a><strong>b-1-2. 2차원 단일 비트 패리티</strong></h4><p>데이터 D를 i개의 행과 j개의 열로 나눠서</p><p>각 가로줄과 세로줄의 1 갯수가 짝수(혹은 홀수)가 되도록 패리티를 설정한다.</p><p><img src="https://blog.kakaocdn.net/dn/w1I2D/btq65d7vlc9/UYDd9kxh8QbTFTsRZjPLKK/img.png" alt="img"></p><p>이 방식은 수신자가 단일 비트 오류의 발생을 검출할 수 있을 뿐 아니라,</p><p>열과 행의 인덱스 값을 사용해 잘못된 비트를 실제로 식별해 오류를 정정할 수 있다.</p><h4 id="b-2-체크섬"><a href="#b-2-체크섬" class="headerlink" title="b-2. 체크섬"></a><strong>b-2. 체크섬</strong></h4><p>데이터 바이트를 16비트 정수 단위로 취해서, 더한 값의 1의 보수가 인터넷 체크섭이 되며,</p><p>이를 세그먼트 헤더에 넣어준다.</p><p>오버헤드가 적지만 오류 면에서 상대적으로 취약하다.</p><h4 id="b-3-순환중복검사-CRC"><a href="#b-3-순환중복검사-CRC" class="headerlink" title="b-3. 순환중복검사(CRC)"></a><strong>b-3. 순환중복검사(CRC)</strong></h4><p><img src="https://blog.kakaocdn.net/dn/dy8LZT/btq64MCi7Jt/cUw7DDVk0m9XZbkKxvUshk/img.png" alt="img"></p><p>데이터 D가 비트 d로 이뤄져 있을 때,</p><p>G로 표현하는 생성자로 알려진 r+1 비트 패턴에 대해서 합의한다.</p><p>송신자는 r개의 추가비트 R을 선택해서 D 뒤에 덧붙이며,</p><p>d+r 비트 패턴은 모듈 <em>-2연산(XOR 연산)을</em> 이용하면 G로 정확히 나누어진다.</p><p>수신자는 d+r개의 수신 비트를 G로 나눈다. 나머지가 0이 아니면 오류가 존재하는 것.</p><p>예시로 해보자</p><p><img src="https://blog.kakaocdn.net/dn/b4M6Vn/btq66VkL6pH/tkwN2IhS9flsyvcPel12Ek/img.png" alt="img"></p><p>일단 생성자 G를 1001로 약속하고,<br>101110인 데이터 D에 2^r을 곱한 것을</p><p>G로 나눈 나머지를 R로 정한다.</p><p>그 이후 D*2^R XOR R을 수신자에게 보낸다</p><p>XOR 연산은 같은 자리 같은 숫자이면 0인 연산이다.</p><p>간단히 생각하면 D뒤에 R을 그냥 덧붙인 결과라 생각하자.</p><p>예시에 따르면 101110011이 된다.</p><h3 id="c-다중-접속-링크와-프로토콜"><a href="#c-다중-접속-링크와-프로토콜" class="headerlink" title="c. 다중 접속 링크와 프로토콜"></a><strong>c. 다중 접속 링크와 프로토콜</strong></h3><p>다수의 송수신 노드들의 공유되는 브로드캐스트 채널로의 접속을 조정하는 문제.</p><p>즉 다중 접속 문제에 의한 충돌을 해결해야 한다.</p><p>이런 전송을 조정하기 위한 것이 다중 접속 프로토콜.</p><p><img src="https://blog.kakaocdn.net/dn/cljHGZ/btq66kypwi1/B5lnFS1gfvJHn28ZYzmZ01/img.png" alt="img"></p><p><em>#out of band channel &amp; in band channel</em></p><p><em>out of band = control과 data가 다른 채널로 전달</em></p><p><em>in band = control 과 data가 같은 채널로 전달</em></p><p><em>무선랜은 in-band channel</em></p><h4 id="c-1-이상적인-다중-접속-프로토콜의-조건"><a href="#c-1-이상적인-다중-접속-프로토콜의-조건" class="headerlink" title="c-1. 이상적인 다중 접속 프로토콜의 조건"></a><strong>c-1. 이상적인 다중 접속 프로토콜의 조건</strong></h4><ol><li>단 하나의 노드가 전송하려 할 때, 그 노드가 R bps의 처리율을 갖는다.</li><li>M개의 노드가 전송하려 할 때, 각 노드가 R/M bps의 처리율(평균적 의미)을 갖는다.</li><li>프로토콜이 분산되어 있어, 고장으로 시스템이 정지될 수 없다.</li><li>비용이 적게 든다.</li></ol><h4 id="c-2-채널-분할-프로토콜"><a href="#c-2-채널-분할-프로토콜" class="headerlink" title="c-2. 채널 분할 프로토콜"></a><strong>c-2. 채널 분할 프로토콜</strong></h4><h4 id="c-2-1-시분할-다중화-TDM"><a href="#c-2-1-시분할-다중화-TDM" class="headerlink" title="c-2-1. 시분할 다중화(TDM)"></a><strong>c-2-1. 시분할 다중화(TDM)</strong></h4><p><img src="https://blog.kakaocdn.net/dn/E7uPq/btq69TfOuO2/Y2k3JMpTd1GFtJKPm9JBl1/img.png" alt="img"></p><p>TDM은 시간을 시간 프레임으로 나누고 또한 각 시간 프레임을 N개의 시간 슬롯으로 나눈다.</p><p>각 시간 슬롯은 N개의 노드에게 할당된다.</p><p>노드는 전송할 패킷이 있을 때마다 TDM 프레임에서 자신에게 할당된 시간 슬롯 동안 패킷 비트를 전송.</p><p><em>참가자들에게 고정된 시간을 주고, 말할 게 없어도 시간을 준다.</em></p><p><em>전송하고픈 노드가 하나라도 노드 전송률은 평균 R/N으로 제한.</em></p><p><em>노드가 전송 순서상 자신의 차례를 기다려야함.</em></p><h4 id="c-2-2-주파수분할-다중화-FDM"><a href="#c-2-2-주파수분할-다중화-FDM" class="headerlink" title="c-2-2. 주파수분할 다중화(FDM)"></a><strong>c-2-2. 주파수분할 다중화(FDM)</strong></h4><p><img src="https://blog.kakaocdn.net/dn/tsV1B/btq665Vmomd/V5zWeGYYdePqd5oe64Ogbk/img.png" alt="img"></p><p>FDM은 R bps의 채널을 다른 주파수로 나눠서 각 주파수를 N개 노드 중 하나에게 할당한다.</p><p><em>TDM과 비슷한 장단점을 가짐.</em></p><h4 id="c-3-랜덤-접속-프로토콜"><a href="#c-3-랜덤-접속-프로토콜" class="headerlink" title="c-3. 랜덤 접속 프로토콜"></a><strong>c-3. 랜덤 접속 프로토콜</strong></h4><p>항상 채널의 최대 전송률인 R bps로 전송한다.</p><p>충돌이 생기면 충돌과 관련된 각 노드는 프레임이 충돌없이 전송될 때까지 자신의 프레임을 계속해서 재전송.</p><p>대신 그 프레임을 재전송하기 전에 랜덤 지연 시간 동안 기다린다.</p><h4 id="c-3-1-슬롯-알로하"><a href="#c-3-1-슬롯-알로하" class="headerlink" title="c-3-1. 슬롯 알로하"></a><strong>c-3-1. 슬롯 알로하</strong></h4><p><img src="https://blog.kakaocdn.net/dn/BnpYW/btq64yLg2ii/8kk6MkuQtp8tMShTYBGujk/img.png" alt="img"></p><p><em>가정</em></p><ul><li>모든 프레임은 정확히 L비트로 구성</li><li>시간은 L/R초의 슬롯들로 구성(즉 한 슬롯은 한 프레임 전송에 걸리는 시간과 같음)</li><li>노드는 슬롯의 시작점에서만 프레임을 전송하기 시작</li><li>각 노드는 언제 슬롯이 시작하는지 알 수 있게끔 동기화되어 있음</li><li>한 슬롯에서 2개 이상의 프레임이 충돌 시, 모든 노드는 그 슬롯이 끝나기 전에 충돌 발생을 알게 됨</li></ul><p><em>작동 방식</em></p><ul><li>노드는 전송할 새 프레임이 있으면 다음 슬롯까지 기다렸다가 전체 프레임을 전송</li><li>충돌이 없으면, 노드는 성공적으로 자신의 프레임을 전송한 것<br><em>따라서 보낸 프레임을 다시 보낼 필요 없음</em></li><li>충돌하면, 노드는 그 슬롯이 끝나기 전 충돌을 검출, 노드는 그 프레임이 충돌 없이 전송 될 때까지 확률 p로 해당 프레임을 다음 스롯들에서 재전송한다.<br><em>각 노드들은 자신의 동전을 던지며, 재전송할지 다음 슬롯에서 동전을 다시 던질지를 결정한다.</em></li></ul><p><em>장점</em></p><ul><li>활성노드가 채녈의 전속력 R로 계속해서 프레임을 전송할 수 있돌록 허용</li><li>상당히 분산(노드는 슬롯을 동기화시켜야)</li><li>매우 단순</li><li>활성 노드가 하나일 때 잘 동작</li></ul><p><em>단점</em></p><ul><li>여러 노드가 참여하면 충돌이 생겨 낭비가 생긴다.</li><li>모두가 전송을 자제해 슬롯이 비는 상황이 생길 수 있다.</li></ul><p><em>효율성(여러개의 활성 노드가 있을 때 충돌없이 전송되는 시간 비율)</em></p><p>N개의 노드가 확률 p로 슬롯 알로하로 패킷을 보낼 때 임의의 노드가 성공 확률은? Np(1-p)^(N-1)</p><p>최대 효율은 효율성의 극대화인데, 이 프로토콜의 최대 효율은 0.37.(겨우 37%의 슬롯만 낭비되지 않는다…)</p><h4 id="c-3-2-알로하"><a href="#c-3-2-알로하" class="headerlink" title="c-3-2. 알로하"></a><strong>c-3-2. 알로하</strong></h4><p>슬롯 알로하는 모든 노드가 슬롯의 시작점에서 전송을 시작할 수 있도록 동기화되어 있기를 요구</p><p>하지만 알로하 프로토콜은 슬롯이 없고 완전히 분산된 프로토콜</p><p>전송된 프레임이 하나 이상의 다른 전송과 충돌하면, 노드는 확률 p로 즉시 프레임을 전송한다.</p><p><img src="https://blog.kakaocdn.net/dn/cAQMTm/btq66vNy0RI/HmcUkOIKWKD6t0klZ9hou0/img.png" alt="img"></p><p>주어진 노드가 성공적인 전송을 할 확률은 p(1-p)^2(N-1)</p><p>순수 알로하 프로토콜의 최대 효율은 1/2e 즉 슬롯 알로하의 절반…</p><h4 id="c-3-3-CSMA"><a href="#c-3-3-CSMA" class="headerlink" title="c-3-3. CSMA"></a><strong>c-3-3. CSMA</strong></h4><ul><li>말하기 전에 들어라 : 다른 사람이 말하고 있으면 말이 끝날 때까지 기다려라.<br>네트워크에서는 이를 캐리어 감지 라고 한다.</li><li>다름 사람이 동시에 말하기 시작하면 말을 중단하라 : 네트워크에서 이것을 충돌 검출이라 함<br>(송신 노드는 전송하면서 동시에 채널을 듣는다.)<br>멈춘 후 랜덤 시간 동안 기다린 후 유휴 시 감지 및 전송 과정을 반복</li></ul><p>하지만 브로드캐스트 채널의 종단간의 채널 전파 지연이 CSMA의 성능을 결정하는 데 중요함.</p><p>전파 지연이 길 수록 네트워크의 다른 노드에서 이미 시작된 전송을 캐리어 감지 노드가 감지 할 수 없는 경우 증가.</p><h4 id="c-3-4-CSMA-CD"><a href="#c-3-4-CSMA-CD" class="headerlink" title="c-3-4. CSMA/CD"></a><strong>c-3-4. CSMA/CD</strong></h4><p>다중접속 프로토콜에 충돌 검출을 추가한 것.</p><p>쓸모 없는 프레임(충돌이 발생한 프레임)을 모두 전송하지 않게 됨.</p><p><img src="https://blog.kakaocdn.net/dn/ebHAEj/btq66V6duw5/vX8spaEY3IZpLA7vQF3jD0/img.png" alt="img"></p><ol><li>링크 계층 프레임을 만든 후에 그 프레임을 어댑터의 버퍼에 저장</li><li>채널이 유휴한 것을 감지하면(채널로부터 어댑터로 들어오는 신호 에너지가 없으면) 프레임 전송을 시작한다.<br>채널이 바쁜 것을 감지하면, 신호 에너지가 감지되지 않을 때까지 기다렸다가 프레임을 전송한다.</li><li>전송하는 동안 어댑터는 다른 어댑터로부터 신호가 있는지 감시한다.</li><li>전송 도중 다른 어댑터로부터 신호 에너지를 감지하면, 자신의 프레임 전송을 취소한다.</li><li>임의의 랜덤 시간(이진지수적 백오프)만큼 기다린 후 2단계로 돌아간다</li></ol><p><em>#이진지수적 백오프</em></p><p>충돌을 n번 경험한 프레임을 전송할 때, {0,1,2…,2^n-1} 중 랜덤하게 선택한다.</p><p>새 프레임을 준비할 때 최근 발생했던 충돌을 고려하지 않는다.</p><p><em>효율성</em></p><p>prop : 신호 에너지가 임의의 두 어댑터 사이에서 전파되는 데 걸리는 최대 시간</p><p>trans : 최대 크기의 이더넷 프레임을 전송하는 데 걸리는 시간<br>(10Mbps 이더넷에서 대략 1.2msec)</p><p><img src="https://blog.kakaocdn.net/dn/Z3iXC/btq650762Dw/XXfQpvDmbJEJzcBir0bJs1/img.png" alt="img"></p><h4 id="c-4-순번-프로토콜"><a href="#c-4-순번-프로토콜" class="headerlink" title="c-4. 순번 프로토콜"></a><strong>c-4. 순번 프로토콜</strong></h4><p>다중 접속 프로토콜의 두가지 특성</p><p>단 하나의 노드만이 활성화 되면 그 노드가 R bps의 처리율을 가져야 한다</p><p>M개의 노드가 활성이면 각 노드가 거의 R/M bps의 처리율을 가진다.</p><p>알로하와 CSMA는 첫번째 특성을 가지나 두 번째 특성은 없다.</p><p>순번 프로토콜을 개발하게 된 계기이다.</p><p><em>채널 나누기 MAC protocol : high load 일 때 효율적 공정, low load일 때 비효율(무조건 1/N을 분배)</em></p><p><em>랜덤 access MAC protocol : low load 일 때 효율, high load일 때 비효율(충돌 overhead)</em></p><h4 id="c-4-1-폴링-프로토콜"><a href="#c-4-1-폴링-프로토콜" class="headerlink" title="c-4-1. 폴링 프로토콜"></a><strong>c-4-1. 폴링 프로토콜</strong></h4><p><img src="https://blog.kakaocdn.net/dn/rUMFN/btq7bDKvH9n/cdQY1jUocKfnAnYmuQeza1/img.png" alt="img"></p><p>노드 중 하나를 마스터 노드로 지정.</p><p>각 노드를 라운드 로빈 형식으로 폴링.</p><p>마스터가 노드1에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다.</p><p>노드 1이 모두 보내고 나면 노드 2에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다.</p><p><em>단점</em></p><p>폴링 지연(노드가 전송할 수 있음을 알리는데 걸리는 시간)으로 인해 활성 노드는 R bps보다 작은 전송률을 가진다.</p><p>마스터 노드가 고장 나면 전체가 작동 안하게 됨</p><h4 id="c-4-2-토큰-전달-프로토콜"><a href="#c-4-2-토큰-전달-프로토콜" class="headerlink" title="c-4-2. 토큰 전달 프로토콜"></a><strong>c-4-2. 토큰 전달 프로토콜</strong></h4><p><img src="https://blog.kakaocdn.net/dn/bYCEap/btq7bDRhp59/ZehWKElAbQTPOYwBikfixk/img.png" alt="img"></p><p>토큰이라고 알려진 작은 특수 목적 프레임이 정해진 순서대로 노드 간에 전달된다.</p><p>토큰이 노드1-&gt;노드2-&gt;노드3 순으로 토큰을 전달한다.</p><p>노드는 토큰을 수신하면, 보낼 데이터가 있을 때만 토큰을 잡는다.</p><p>보낼 게 있으면 최대 개수 만큼 프레임을 보낸다.</p><p>노드하나가 실패하면 전체가 동작하지 않는다.</p><h3 id="d-스위치-근거리-네트워크"><a href="#d-스위치-근거리-네트워크" class="headerlink" title="d. 스위치 근거리 네트워크"></a><strong>d. 스위치 근거리 네트워크</strong></h3><p>스위치 네트워크에서는 링크 계층 프레임을 전달하기 위해 IP 주소가 아닌 링크 계층 주소를 사용</p><h4 id="d-1-링크-계층-주소체계와-ARP"><a href="#d-1-링크-계층-주소체계와-ARP" class="headerlink" title="d-1. 링크 계층 주소체계와 ARP"></a><strong>d-1. 링크 계층 주소체계와 ARP</strong></h4><h4 id="d-1-1-MAC-주소"><a href="#d-1-1-MAC-주소" class="headerlink" title="d-1-1. MAC 주소"></a><strong>d-1-1. MAC 주소</strong></h4><p>호스트의 어댑터 혹은 라우터의 어댑터가 링크 계층 주소를 가진다.</p><p>다수의 어댑터를 가지고 있는 호스트나 라우터는 여러개의 링크 계층 주소를 가진다.</p><p>MAC 주소는 6바이트(48비트) 길이이고, 16진수 표기법으로, 각 바이트는 2개의 16진수로 표현.</p><p>어떤 어댑터도 동일한 주소를 가지지 않는다!(IEEE에서 주소 할당)</p><p>MAC 주소는 평면 구조를 가지며, 어댑터의 위치에 따라 변경되지 않음</p><p><em>마치 사람의 주민등록번호와 같다(ip는 위치에 따라 변하는 것처럼, 주소와 비슷하다)</em></p><h4 id="d-1-2-ARP"><a href="#d-1-2-ARP" class="headerlink" title="d-1-2. ARP"></a><strong>d-1-2. ARP</strong></h4><p><img src="https://blog.kakaocdn.net/dn/cht8QM/btq64wNqd08/dWUTn5fxNsEIhXHqXAlqnK/img.png" alt="img"></p><p>네트워크 계층 주소(ip)와 링크 계층 주소(MAC 주소) 사이의 변환<br>(ARP는 링크 계층과 네트워크 계층의 경계에 있다고 봐야한다.)</p><p>ARP는 동일한 서브넷상에 있는 호스트나 라우터 인터페이스의 IP 주소만을 해결한다.</p><p>호스터와 라우터는 자신의 메모리에 ARP 테이블을 가지고 있다.</p><p>테이블엔 &lt;IP 주소, MAC 주소, TTL&gt;이 있다.</p><p>ARP 테이블을 보고 노드를 찾아 간다.</p><p>만약 송신 노드의 ARP 테이블에 목적지 노드에 대한 엔트리가 없다면?</p><ul><li>먼저 송신 노드 ARP 패킷이라는 특수 패킷을 구성한다.<br>ip주소와 mac 주소를 포함하는 필드를 갖고 있다.</li><li>ARP 질의 패킷의 목적은 해결하려는 ip주소에 대응하는 mac 주소를 결정하기 위해<br>모든 호스트와 라우터에게 질의하는 것.</li><li>송신 노드는 어댑터에게 ARP 패킷을 전달하여,<br>브로드캐스트 주소(FF-FF-FF-FF-FF-FF)로 패킷을 전송하도록 지시<br><em>서울시 xx구 xx동 xx아파트 101호에 사는 사람 주민번호가 뭔지 아는사람?</em></li><li>각 노드의 어댑터는 ARP 패킷을 자신의 ARP 모듈로 전달,<br>모듈이 자신의 ip와 패킷 속 ip와 비교하여 일치할 경우 요구 정보를 반환.</li><li>질의를 한 호스트는 답변을 듣고, 자신의 ARP 테이블을 갱신</li></ul><p><em>질의 메시지는 브로드캐스트로 전달되지만 응답 메시지는 표준 프레임으로 전송된다.</em></p><p><em>ARP의 플러그 앤 플레이, 즉 노드의 ARP 테이블이 자동으로 구축된다.</em></p><h4 id="d-1-2-1-서브넷에-없는-노드로-데이터그램-전송"><a href="#d-1-2-1-서브넷에-없는-노드로-데이터그램-전송" class="headerlink" title="d-1-2-1. 서브넷에 없는 노드로 데이터그램 전송"></a><strong>d-1-2-1. 서브넷에 없는 노드로 데이터그램 전송</strong></h4><p><img src="https://blog.kakaocdn.net/dn/SsaEp/btq66uOPp1j/sv2m3m1d8r9aGF6W0wtEuK/img.png" alt="img"></p><p>라우터는 각 인터페이스 당 하나의 IP 주소를 가진다. 각 라우터 인터페이스는 ARP 모듈(라우터 안)과 어댑터를 가진다.</p><p><em>물론 각 인터페이스 별로 MAC 주소를 가진다.</em></p><ul><li>ARP로 라우터의 MAC 주소를 알아내 원래 목적지를 담은 데이터그램을 포함한 프레임을 전달한다</li><li>라우터의 어댑터의 링크 계층 프레임이 자신을 목적지로 했는지 확인 후 라우터의 네트워크 계층으로 보낸다.</li><li>라우터는 포워딩 테이블을 참조해 정확한 인터페이스를 결정한다</li><li>데이터그램을 새 프레임에 캡슐화해 서브넷 2로 전송한다.</li><li>ARP로부터 목적지의 MAC 주소를 알아내 보낸다.</li></ul><h4 id="d-2-이더넷"><a href="#d-2-이더넷" class="headerlink" title="d-2. 이더넷"></a><strong>d-2. 이더넷</strong></h4><p>최초의 이더냇 랜은 노드를 연결하기 위해 동축 버스를 사용.</p><p>버스 토폴로지의 이더넷은 브로드캐스트 랜으로, 전송되는 모든 프레임은 버스에 연결된 모든 어댑터를 거치며 처리됨</p><p>이후 랜을 허브 기반의 스타 토폴로지를 사용하는 이더넷으로 대체했다.</p><p>허브는 프레임이 아닌 각각의 비트에 대한 처리를 하는 물리 계층 장치이다. 허브도 브로드캐스트 랜이므로, 여러 프레임이 수신되면 충돌이 발생해 재전송 해야한다.</p><p>허브 이후 중앙의 허브가 충돌이 없는 스위치로 대체되었다.</p><p><img src="https://blog.kakaocdn.net/dn/s0eVw/btq7bDqlyfA/GGDWTq4ttdO7mZ424pqLFk/img.png" alt="img"></p><h4 id="d-2-1-이더넷-구조"><a href="#d-2-1-이더넷-구조" class="headerlink" title="d-2-1. 이더넷 구조"></a><strong>d-2-1. 이더넷 구조</strong></h4><p><img src="https://blog.kakaocdn.net/dn/ci2JaQ/btq7bgWmtuV/10uukUsJKvk5edep64mT91/img.png" alt="img"></p><ul><li>데이터 필드(46~1500바이트) : IP 데이터그램을 운반(다른 네트워크 계층도 가능), 46보다 작으면 채워서라도 보내야 하고, 1500바이트보다 많으면 데이터그램을 단편화해야함.</li><li>목적지 주소(6바이트) : 목적지 어댑터의 MAC주소</li><li>출발지 주소(6바이트) : 전송하는 어댑터의 MAC주소</li><li>타입 필드(2바이트) : 이더넷으로 하여금 네트워크 게층 프로토콜을 다중화(연계). IP 외의 다른 네트워크 계층 프로토콜을 사용할 수 있음을 의미</li><li>순환중복검사(CRC, 4바이트)</li><li>프리앰블(8바이트) : 첫 7바이트는 10101010값을 가짐. 마지막 바이트는 10101011이다. 첫 7개의 바이트는 수신 어댑터를 깨우고, 수신자의 클록을 송신자의 클록에 동기화시키는 역할을 한다. 8번째 바이트의 마지막 두 비트(연속으로 오는 1)는 어댑터로 하여금 중요한 것이 오고 있음을 알려준다.</li></ul><h4 id="d-2-2-이더넷-특징"><a href="#d-2-2-이더넷-특징" class="headerlink" title="d-2-2. 이더넷 특징"></a><strong>d-2-2. 이더넷 특징</strong></h4><ul><li>비연결형 서비스<br>핸드셰이킹하지 않고 이더넷 프레임에 데이터그램을 캡슐화해서 그 프레임을 랜으로 전송</li><li>비신뢰적인 서비스<br>CRC를 통과해도 응답이 없고, 실패해도 응답이 없다. CRC를 실패하면 그냥 수신자가 폐기한다.<br>CRC를 통과했는지 알 방법이 없다.(TCP가 이 역할을 대신한다.)</li></ul><h4 id="d-3-링크-계층-스위치"><a href="#d-3-링크-계층-스위치" class="headerlink" title="d-3. 링크 계층 스위치"></a><strong>d-3. 링크 계층 스위치</strong></h4><p>스위치는 그 자체가 서브넷의 호스트와 라우터들에게 <em>투명</em>함.</p><p>호스트/라우터는 프레임을 스위치가 아닌 다른 호스트/라우터를 목적지로 해서 랜상으로 보내며,<br>중간에 스위치가 프레임을 받아서 다른 노드에게 전달하는 것을 <em>알지 못한다.</em></p><h4 id="d-3-1-스위치의-전달-및-여과"><a href="#d-3-1-스위치의-전달-및-여과" class="headerlink" title="d-3-1. 스위치의 전달 및 여과"></a><strong>d-3-1. 스위치의 전달 및 여과</strong></h4><p>여과 : 프레임을 전달할지 혹은 폐기할 지 결정.</p><p>전달 : 전송될 인터페이스를 결정하고 해당 인터페이스로 내보내는 것.</p><p>여과와 전달은 스위치 테이블을 이용.</p><p>&lt;MAC 주소, 그 MAC 주소로 가게 하는 스위치 인터페이스, 해당 엔트리가 만들어진 시점&gt;</p><h4 id="d-3-2-스위치의-작동-방식"><a href="#d-3-2-스위치의-작동-방식" class="headerlink" title="d-3-2. 스위치의 작동 방식"></a><strong>d-3-2. 스위치의 작동 방식</strong></h4><p><em>목적지 주소 DD-DD-DD-DD-DD-DD를 가진 프레임이 스위치의 인터페이스 X에 도착했다고 가정</em></p><ol><li>목적지 주소에 대한 엔트리가 스위치 테이블에 없을 경우 : 인터페이스 X를 제외한 모든 인터페이스에 프레임 복사본을 보낸다.(브로드캐스트)</li><li>목적지 주소가 인터페이스 X에 대한 엔트리가 있는 경우 : 이 경우, 다른 인터페이스를 전달할 필요가 없으며, 프레임을 여과를 실행하여 제거(DD-DD-DD-DD-DD-DD로 보내려면 인터페이스 X를 사용해야 될 경우 잘못된 상황이다.)</li><li>목적지 주소가 인터페이스 Y에 대한 엔트리가 있는 경우 : Y에 접속된 랜 세그먼트로 전달</li></ol><h4 id="d-3-3-스위치의-자가학습"><a href="#d-3-3-스위치의-자가학습" class="headerlink" title="d-3-3. 스위치의 자가학습"></a><strong>d-3-3. 스위치의 자가학습</strong></h4><p>*<strong>플러그앤플레이*</strong></p><p>스위치 테이블을 자동으로 동적으로 자치적으로 구축하는 기능</p><ol><li>스위치 테이블은 초기에 비어있다.</li><li>인터페이스로 수신한 각 프레임에 대해서 다음 정보를 저장한다.<br>a. 프레임의 출발지 주소필드에 있는 MAC 주소<br>b. 프레임이 도착한 인터페이스<br>c. 현재시간</li><li>일정시간이 지난 후에도 스위치가 해당 주소를 출발지 주소로 하는 프레임을 수신하지 못하면 테이블에서 삭제한다.</li></ol><h4 id="d-3-4-스위치-vs-라우터"><a href="#d-3-4-스위치-vs-라우터" class="headerlink" title="d-3-4. 스위치 vs 라우터"></a><strong>d-3-4. 스위치 vs 라우터</strong></h4><p><img src="https://blog.kakaocdn.net/dn/bizHZE/btq66j0KMeS/TtmlxLV88KSkbc7tvzLbo1/img.png" alt="img"></p><p>라우터 : 네트워크 계층 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 3계층까지 프레임 처리해야함</p><p>스위치 : MAC 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 플러그앤 플레이, 2계층까지만 패킷 처리</p><h4 id="d-4-가상-근거리-네트워크-VLAN"><a href="#d-4-가상-근거리-네트워크-VLAN" class="headerlink" title="d-4. 가상 근거리 네트워크(VLAN)"></a><strong>d-4. 가상 근거리 네트워크(VLAN)</strong></h4><p>트래픽 격리 부족, 사용자 관리, 스위치의 비효율적인 사용을 해결하기 위한 기술.</p><p>VLAN을 지원하는 스위치는 하나의 물리적 근거리 네트워크 기반 구조상에서 여러 개의 가상 근거리 네트워크들을 정의할 수 있게 한다.</p><p><img src="https://blog.kakaocdn.net/dn/0yL6E/btq65rkRqhU/IKozLeokuVD56u6fAuKgSK/img.png" alt="img"><img src="https://blog.kakaocdn.net/dn/tJvxI/btq64LDGpGk/j8AKKVrh4x8c3teXHFxHCk/img.png" alt="img"></p><h4 id="d-4-1-VLAN-트렁킹"><a href="#d-4-1-VLAN-트렁킹" class="headerlink" title="d-4-1. VLAN 트렁킹"></a><strong>d-4-1. VLAN 트렁킹</strong></h4><p><img src="https://blog.kakaocdn.net/dn/uVaA8/btq66uVI1r6/G7rJ91UTNhc9Nb8GTEZ5gK/img.png" alt="img"></p><p>트렁크 포트를 지정해 트렁크 링크를 통해 다른 스위치로 전달해준다.</p><p>프레임이 속한 VLAN을 식별해주는 4바이트 VLAN 태그를 헤더에 덧붙여 어떤 VLAN의 요청인지를 파악한다.(802.1Q)</p><h4 id="d-4-2-802-1Q"><a href="#d-4-2-802-1Q" class="headerlink" title="d-4-2. 802.1Q"></a><strong>d-4-2. 802.1Q</strong></h4><p><img src="https://blog.kakaocdn.net/dn/lrCyu/btq7d42lcoj/fqK7eWpILG2gNwZwzQ5H9K/img.png" alt="img"></p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/network/">Network</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/17/cs/network/network12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>11. 네트워크 계층 제어 평면(ICMP, SNMP)</title>
      <link>https://yangdongjue5510.github.io/2021/11/17/cs/network/network11/</link>
      <guid>https://yangdongjue5510.github.io/2021/11/17/cs/network/network11/</guid>
      <pubDate>Wed, 17 Nov 2021 11:27:48 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;a-인터넷-제어-메시지-프로토콜-ICMP&quot;&gt;&lt;a href=&quot;#a-인터넷-제어-메시지-프로토콜-ICMP&quot; class=&quot;headerlink&quot; title=&quot;a. 인터넷 제어 메시지 프로토콜(ICMP)&quot;&gt;&lt;/a&gt;&lt;strong&gt;a. 인터넷 제어 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="a-인터넷-제어-메시지-프로토콜-ICMP"><a href="#a-인터넷-제어-메시지-프로토콜-ICMP" class="headerlink" title="a. 인터넷 제어 메시지 프로토콜(ICMP)"></a><strong>a. 인터넷 제어 메시지 프로토콜(ICMP)</strong></h3><p>호스트와 라웉터가 서로 간에 네트워크 계층 정보를 주고받기 위해 사용된다.</p><p>대표적으로 인터넷 문제 식별을 할 수 있다.</p><p>ICMP는 구조적으로 IP 바로 위에 있고 IP 페이로드에 담겨 전송된다.</p><p><img src="https://blog.kakaocdn.net/dn/tJVQS/btq650mniSM/7H7sJpW8UMdwLPL8Bk2rB1/img.png" alt="img"></p><p>TYPE과 CODE값으로 상태를 구분해 인식한다.</p><h4 id="a-1-ICMP-메시지-타입"><a href="#a-1-ICMP-메시지-타입" class="headerlink" title="a-1. ICMP 메시지 타입"></a><strong>a-1. ICMP 메시지 타입</strong></h4><p><img src="https://blog.kakaocdn.net/dn/GqD5n/btq69WDfFMN/QTsmbPz5wjviy7WZ57KEOk/img.png" alt="img"><img src="https://blog.kakaocdn.net/dn/dY6knq/btq66WcGvVA/wUEYRvYDOPHlXIKdiOIRlK/img.png" alt="img"></p><p><img src="https://blog.kakaocdn.net/dn/GbYNs/btq66lcISpa/FYxEI6brTuv1WtsbNUct40/img.png" alt="img"></p><p><img src="https://blog.kakaocdn.net/dn/YlR1I/btq69WiWwim/wKzyNBA5RfKNenSM0aT1IK/img.png" alt="img"></p><h3 id="b-네트워크-관리와-SNMP"><a href="#b-네트워크-관리와-SNMP" class="headerlink" title="b. 네트워크 관리와 SNMP"></a><strong>b. 네트워크 관리와 SNMP</strong></h3><p>적절한 비용으로 요규사항을 만족시키기 위해, 네트워크와 구성요소 자원들을 감시, 테스트, 폴링, 설정, 분석, 평가, 제어하는 하드웨어, 소프트웨어, 인간요소 등을 배치하고 통합, 조정하는 것.</p><p><img src="https://blog.kakaocdn.net/dn/p9hpi/btq67SOTdPS/kSTGytZ6NNf2zLRcc9odCk/img.png" alt="img"></p><p>관리 서버는 네트워크 관리 활동이 일어나는 장소. 네트워크 관리 정보의 수집, 처리, 분석, 게시를 제어.</p><p>피관리 장치는 관리 대상 네트워크에 존재하는 네트워크 장치들. 피관리 장치 내부에는 피관리 객체들이 있다.</p><p>피관리 객체는 하드웨어 일부, 소프트웨어 요소에 대한 설정 매개변수들이다.</p><p>피관리 장치 내의 피관리 객체들에 관련된 정보들은 MIB에 저장된다.</p><p>피관리 장치에는 네트워크 관리 에이전트가 있어 관리 서버와 통신하며, 피관리 장치에 대한 행동을 취하는 프로세스이다.</p><p>네트워크 관리 프로토콜은 관리 서버와 피관리 장치들 사이에서 연결.</p><h3 id="c-SNMP"><a href="#c-SNMP" class="headerlink" title="c. SNMP"></a><strong>c. SNMP</strong></h3><p>관리 서버와 그 관리 서버를 대표하여 실행되고 있는 에이전트 사이에서 네트워크 관리 제어 및 정보 메시지를 전달하기 위해 사용</p><p><img src="https://blog.kakaocdn.net/dn/rdnlE/btq7biGi4j2/NKZwko1p5fDOXcu4kGSGqK/img.png" alt="img"></p><p>SNMP 관리 서버는 에이전트에게 요청을 수신하고 SNMP 에이전트는 이를 수행한 후 요청에 대한 응답을 보냄</p><p>에이전트가 요구받지 않았더라도 트랩 메시지를 관리 서버에게 전송.</p><p>트랩 메시지는 MIB 객체 값들을 변화시킨 예외 상황의 발생을 통지하기 위해 이용.</p><p><img src="https://blog.kakaocdn.net/dn/bqDTMm/btq67RJdUss/KvZuvg5faGthGiNdKSMCKK/img.png" alt="img"></p><p>출처: <a href="https://nongue.tistory.com/165?category=866237">https://nongue.tistory.com/165?category=866237</a> [가자미의 개발이야기]</p>]]></content:encoded>
      
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/">Computer Science</category>
      
      <category domain="https://yangdongjue5510.github.io/categories/computer-science/network/">Network</category>
      
      
      
      <comments>https://yangdongjue5510.github.io/2021/11/17/cs/network/network11/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
