---
title: 24. 백준 1406번 에디터
date: 2021-08-24 13:48:01
tags:
category:
    - Computer Science
    - Algorithm
    - Problem Solving
---
이 문제는 참 고생 많이 했다 ㅋㅋ...


> 틀렸던 접근 1

주어진 문자열을 char 배열로 받은 다음, 이 녀석을 ArrayList에 저장하자.
그 다음 arrayList를 하나더 추가해서 마치 스택처럼 사용하자.
그렇게 모든 명령을 수행하고 나면
두 arraylist에 저장된 요소들을 반복문으로 하나씩 출력하자.

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException{
        var bf = new BufferedReader(new InputStreamReader(System.in));
        char[] charArr = (bf.readLine()).toCharArray();
        //List list = Arrays.asList(charArr);
        //var wordStk = new ArrayList<Character>(Arrays.asList(charArr));
        var wordStk = new ArrayList<Character>();
        var testCase = Integer.parseInt(bf.readLine());
        var tmpStk = new ArrayList<Character>();
        for (char c : charArr)
            wordStk.add(c);
        for (int i = 0 ; i < testCase ; i++){
            var cmdLine = new StringTokenizer(bf.readLine());
            var cmd = cmdLine.nextToken();
            if (cmd.equals("P")){
                wordStk.add(cmdLine.nextToken().charAt(0));
            } else if (cmd.equals("L")){
                if (wordStk.size() != 0){
                    tmpStk.add(wordStk.get(wordStk.size()-1));
                    wordStk.remove(wordStk.size()-1);
                }
            } else if (cmd.equals("D")){
                if (tmpStk.size() != 0){
                    wordStk.add(tmpStk.get(tmpStk.size()-1));
                    tmpStk.remove(tmpStk.size()-1);
                }
            } else if (cmd.equals("B")){
                if (wordStk.size() != 0){
                    wordStk.remove(wordStk.size()-1);
                }
            }
        }
        for (char c : wordStk)
            System.out.print(c);
        for (char c : tmpStk)
            System.out.print(c);
    }
}
```

## 문제점들...
근데 문제가 있다. Arrays.asList(char[])가 작동을 안한다...
asList가 배열이나, 가변인자를 받기 때문이다.


가변인자란 여러 인자를 받으면, 이를 배열로 만들어서 인자로 활용하는 개념이다.
즉 asList에 기본값을 가진 배열이 오면, List<\char[]>이 온다..!
(다르게 말하자면, 오토박싱이 이뤄지지 않는다. 개별의 값만 오토박싱한다.)
그래서 기본값을 가진 배열은 asList로 다룰수 없다.(래퍼클래스 배열만 가능)


그리고 출력할 때도 문제가 있다.
무지성으로 여러번 출력하는 거보다 한방에 모아서 출력하는게(StringBuffer) 훨씬 속도가 빠르다!


그리고 나는 자바에 스택이 있는 걸 깜빡하고 arrayList로 작성했는데,
다시 찾아보니 스택을 지원했다. 그래서 스택으로 고쳐 써봤다.


> 고친 코드

```java
import java.util.*;
import java.io.*;
import java.util.stream.*;

public class Main{
    public static void main(String[] args) throws IOException{
        var bf = new BufferedReader(new InputStreamReader(System.in));
        var sb = new StringBuilder();
        
        var charArr = bf.readLine().toCharArray();
        var wordStk = new Stack<Character>();
        var testCase = Integer.parseInt(bf.readLine());
        var tmpStk = new Stack<Character>();
        
        for (char c : charArr)
            wordStk.add(c);
        for (int i = 0 ; i < testCase ; i++){
            var cmdLine = new StringTokenizer(bf.readLine());
            var cmd = cmdLine.nextToken();
            if (cmd.equals("P")){
                wordStk.push(cmdLine.nextToken().charAt(0));
            }
            else if (cmd.equals("D")){
                if (tmpStk.size() != 0){
                    wordStk.push(tmpStk.pop());
                }
            }
            else if (wordStk.size()==0)
                continue;
            else if (cmd.equals("L")){
                tmpStk.push(wordStk.pop());
            }
            else if (cmd.equals("B")){
                wordStk.pop();
            }
        }
        for (char c : wordStk)
            sb.append(c);
        while(!tmpStk.isEmpty())
            sb.append(tmpStk.pop());
        System.out.println(sb);
    }
}
```

