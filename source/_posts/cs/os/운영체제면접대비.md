---
title: 운영체제 면접대비 스터디
date: 2021-10-14 14:53:10
tags:
category:
    - Computer Science
    - OS
---

# 목차

**[1주차](#1주차)**
[프로세스와 스레드의 차이](#프로세스와-스레드의-차이)
[쓰레드의 동기화 이슈](#쓰레드의-동기화-이슈)
[교착 상태와 기아 상태](#교착-상태와-기아-상태)
[메모리 계층](#메모리-계층)

**[2주차](#2주차)**
[메모리 할당 방식](#메모리-할당-방식)
[메모리 단편화](#메모리-단편화)
[메모리 할당 알고리즘](#메모리-할당-알고리즘)
[가상 메모리](#가상-메모리)
[요구 페이징](#요구-페이징)
[페이지 교체 알고리즘](#페이지-교체-알고리즘)

**[3주차](#3주차)**
[페이징](#페이징)
[세그멘테이션](#세그멘테이션)
[상호배제 방식](#상호배제-방식)
[뮤텍스](#뮤텍스)
[세마포어](#세마포어)

[**4주차**](#4주차)
[PCB와 프로세스 컨텍스트](#PCB와-프로세스-컨텍스트)
[컨텍스트 스위칭](#컨텍스트-스위칭)
[사용자 수준 스레드 vs 커널 수준 스레드](#사용자-수준-스레드-vs-커널-수준-스레드)
[fork와 vfork의 차이점](#fork와-vfork의-차이점)

[**5주차**](#5주차)
[RaceCondition](#Race-Condition)
[시스템콜vs서브루틴](#시스템콜-vs-서브루틴)

## 1주차

### 프로세스와 스레드의 차이

**정의**

프로세스 : 메모리에 올려져 실행 중인 프로그램
쓰레드 : 프로세스 안에서 실행되는 흐름 단위

**공유자원 차이**

프로세스 : 프로세스들 끼리는 IPC를 제외하면 공유를 허용하지 않음
쓰레드 : code, data, heap은 서로 공유. stack은 서로 독립적.(각자의 흐름을 가져야 함)

<details>
<summary>*프로세스 구조*</summary>

- code : 컴파일된 코드가 저장(프로그램 끝날 때 해제)
- Data : 선언된 변수가 저장되는 영역 (전역변수, static, 프로그램 끝날 때 해제)
  - BSS(초기화 안된 전역변수) / DATA(초기화 된 전역변수)
- heap : 동적으로 할당된 메모리가 저장
- stack : 함수와 관련된 인자나 변수 저장 (다양한 레지스터 사용!)

</details>


<details>
<summary>*IPC*</summary>

프로세스 간 상태 확인 및 데이터 송수신할 때 사용.

프로세서마다 공유하는 커널 공간을 통해 데이터를 쓰고 읽음.

IPC 비용이 커서 멀티 프로세스보다 멀티 스레드를 활용하기도 함.

</details>

<details>
  <summary>*Context Switching*</summary>
프로세스의 상태 정보를 저장하고 복원하는 과정

**PCB** : 프로세스의 상태를 저장한 구조체
(program counter와 stack pointer 등 다양한 레지스터 저장)
스위칭 될 때마다 PCB를 저장하고 로드.
서로 자원이 공유되지 않으니, 스위칭 연산이 비싸다.

> 쓰레드보다 프로세스 바꿀 때가 더 든다. 왜 ? 쓰레드는 공유 자원이라 바꿀게 스레드보다 더 적다.

</details>

**약점**

프로세스 : 

- 서로 자원 공유가 제한됨
-  IPC 연산 비용
-  일일히 자원 할당하는 시스템콜 비용

쓰레드 : 

- 하나만 잘못되도 프로세스 전체에 악영향
- 동기화 이슈

<details>
  <summaray>*멀티 프로세스 vs 멀티 쓰레드*</summaray>

멀티 프로세스

- 여러 cpu가 동시에 여러개의 프로세스 처리
- 메모리 침범 막아서 안전성 높음
- 작업량이 많으면 컨텍스트 스위칭으로 인해 성능이 저하

멀티 스레드

- 하나의 프로세스에서 여러 스레드가 각자 하나의 작업을 처리
- 자원 공유로 빠른 작업 가능
- 스레드 하나가 망하면 한 프로세스가 다같이 망함

</details>

### 쓰레드의 동기화 이슈

상호배재(mutex)

- 한 스레드가 공유 자원에 접근하면 다른 스레드가 접근 못하게 하기
- 임계 자원(crtical resource) : 접근 제한 자원
- 임계 영역(critical section) : 접근 제한 코드. 영역

세마포어(semaphore)

- 공유 자원에 정해진 수의 사용자만 접근 허락

### 교착 상태와 기아 상태

교착 상태(dead lock)

- 여러 쓰레드가 서로 상대방의 작업이 끝나길 기다리느라 다음 작업을 못하는 상황

기아 상태

- 우선순위가 낮은 프로세스가 계속 경쟁에 뒤쳐져 원하는 자원을 계속 못받는 상태.

**이슈 해결 방법**

교착 상태

- 예방 : 원인을 제거
- 회피 : 발생하지 않도록 알고리즘 도입
  - 은행원 알고리즘 / 자원할당 알고리즘
- 회복 : 문제가 발생한 프로세스를 중단, 메모리 해제
- 무시 : 해결할 때 생기는 비용이 너무 비싸면 무시

> 예방이 가장 낭비가 심하다.

기아 상태

- 우선순위 수시로 바꿈
- FIFO 기반 스케줄러로 바꿈

<details>
  <summary>*교착 상태의 원인*</summary>

- 상호배제 : 다른 프로세스도 갖고 싶은 걸 자기만 가지려함
- 점유대기 : 자원을 가지고 있으면서 다른 자원을 대기
- 비선점 : 자원을 가진 프로세스의 자원을 못 뺏음
- 순환대기 : 다음 프로세스가 원하는 걸 가지고 있음.

</details>

### 메모리 계층

레지스터 - 캐시 - 메모리 - 하드디스크

메모리를 필요에 따라 나눈 계층
(오른쪽으로 갈 수록 CPU가 느리게 접근)

**레지스터**
CPU 요청 처리에 필요한 정보를 임시 저장하는 기억장치

**캐시**
데이터나 값을 미리 복사해놓는 임시 저장소.

**메인 메모리**
RAM, ROM으로 구성된 명령, 자료를 기억하는 장치.
cpu에서 직접 접근가능 하다는게 하드디스크와 다름

**하드디스크**
비휘발성 순차적 데이터 저장소. 느리지만 저렴.
직접 사용하지 못하고 시스템콜로 메모리에 옮겨서 사용.

**계층이 필요한 이유**

- 디코딩 속도
  - 큰 메모리 용량은 디코딩하는데 많은 시간 소요.
  - 메모리가 작으면 빠르게 디코딩해서 접근 가능
- 참조의 지역성
  - 자주 쓰이는 데이터는 계속 더 자주 쓰임
- 경제성
  - 빠를 수록 비싸서 저렴한 메모리를 효율적으로 활용해야함.



## 2주차

### 메모리 할당 방식

**연속 할당 방식 **
프로그램 전체를 한 공간에 연속적으로 할당.

> 정적 분할과 동적 분할

정적 분할 : 메모리 영역을 고정된 크기로 미리 나눠놓고 맞는 프로세스를 집어넣는 방식. 내외부단편화 모두 일어남.
동적 분할 : 프로세스에 맞게 메모리 영역을 할당함. 외부단편화가 생길 수 있음.

**비연속 할당 방식**
프로그램을 페이지로 나눈 후, 여러 곳에 흩어져서 할당.

### 메모리 단편화

프로세스를 메모리에 올릴 때 생기는 메모리 낭비 현상.
대표적으로 외부 단편화와 내부 단편화가 있다.

**외부 단편화**

어떤 프로세스보다 전체 물리 메모리의 남은 공간이 더 많아도, 
물리 메모리의 남은 공간들이 연속적이지 못해서 프로세스를 메모리에 올리지 못하는 상황

**내부 단편화**

물리 메모리의 남은 공간에 어떤 프로세스를 할당하고 남은 공간이 
다른 프로세스를 받아들이지 못해 낭비되는 상황

메모리 단편화 해결하기

**COMPACTION** 압축

비어있는 공간을 연속적인 공간으로 재배치.
현재 프로세스들을 다른 곳(하드디스크 등)에 복사했다가 다시 메모리에 올려야 함
병목현상이나, IO 문제가 발생 가능하다. -> 외부 

**Coalescing holes( 공간 통합)**

프로세스가 끝나고 메모리에서 사라지면, 새로 생긴 빈 공간을 주위 빈공간과 합침.
좀 더 큰 프로세스가 올 수 있게 만들고 오버헤드가 낮음

### 메모리 할당 알고리즘

멀티 프로세스 환경에서 여러 프로세스가 동시에 실행된다.
단편화 문제를 줄이기 위해 메모리를 할당하는 알고리즘.

- BEST FIT : 현재 물리 메모리의 빈 공간을 모두 탐색해서 가장 낭비가 적은 공간에 프로세스 올림
- FIRST FIT : 현재 물리 메모리에서 프로세스를 올릴 수 있는 빈 공간 중 가장 먼저 찾은 공간에 프로세스 올림
- WORST FIT : 현재 물리 메모리 남은 공간들 중 프로세스를 할당하고도 남은 공간이 가장 큰 공간에 프로세스 올림
  (남은 공간에 다음에 올 프로세스가 들어올 가능성을 생각한 것.)

**평가**

효율성 : BEST FIT, FIRST FIT > WORST FIT
복잡도 : FIRST FIT > BEST FIT , WORST FIT

**FIRST FIT의 50퍼센트 규칙**

전체 메모리에 N개의 블록이 할당되었다고 했을 때 0.5N개의 블록이 외부 단편화되어 사용할 수 없음.
총 (1.5N 중 0.5N, 즉 1/3만큼 사용할 수 없게 된다.)

### 가상 메모리

메모리에 로드되어 실행 중인 프로세스가 가상의 메모리 공간을 참조해 거대한 물리 메모리를 사용하는 것처럼 보이게 하는 방식.

프로세스를 모두 메모리에 할당하기엔 한계가 있다.(리눅스의 프로세스 크기가 4기가.)
CPU가 프로세스의 모든 공간을 사용하지는 않는다.

자주 사용하지 않는 부분은 하드디스크에 저장
가상 주소로 통해 메모리에 접근.

**프레임** : 물리 메모리를 구성하는 가장 작은 단위
**페이지** : 가상 메모리를 구성하는 가장 작은 단위

**MMU** : CPU가 가상 메모리에 접근하고 싶을 때 가상 주소를 실제 물리 주소로 바꾸어 접근

**페이지 폴트** : 프로세스의 페이지 중 일부가 RAM에 올려지지 않은 상황.

### 요구 페이징

페이지 폴트가 발생하면, 가상 메모리에서 해당 페이지를 찾아야 함.(요구페이징)
CPU는 프로세스 페이지의 주소를 **페이지 테이블**에 기록했음.

페이지 테이블의 가상 주소를 보고 요청하면, MMU가 실제 물리 주소로 변환해서
하드디스크에 있는 페이지를 물리 메모리에 올려야 한다.

### 페이지 교체 알고리즘

가상 메모리에서 페이지를 가져왔는데, 메모리에 남는 프레임이 없어서 올리지 못하는 경우,
메모리의 다른 페이지를 빼서 가상 메모리에 넣고, 가져온 페이지를 물리 메모리에 넣어야 한다.

- OPT : 앞으로 안쓸거 같은 페이지를 교체
- FIFO : 가장 먼저 할당된 페이지를 교체
- LRU least recently used : 오랫동안 덜 쓴 페이지 교체 - 지역성(로컬리티)
- LFU least fre: 사용 빈도가 적은 페이지 교체
- NUR : 최근에 사용안한 페이지 교체



## 3주차

### 페이징

비연속할당 방식, 고정 분할 기법의 일종으로 프로세스를 여러 개의 페이지로 나눠 메모리에 흩어져서 할당됨
외부 단편화를 막을 수 있지만, 페이지 크기가 커질 수록 내부 단편화도 커짐.(필요한 메모리보다 할당된 메모리가 더 큰 경우)

페이징을 하기 위해서는 mmu와 페이지테이블이 필요하다.


### 세그멘테이션

페이징은 물리적으로 동일한 크기로 분할하는 기법이지만
세그멘테이션은 논리적인 기준으로 분할하는 기법이다.
세그멘테이션은 각 세그멘트가 크기가 달라서 메모리에 할당하고 해제하는 과정에서 외부 단편화가 날 수 있다.

외부 단편화를 방지하기 위해 세그멘트를 페이징하는 paged segmentation 기법을 사용한다.

### 상호배제 방식

공유 자원 접근을 제한하는 방식.

### 뮤텍스

여러 프로세스/스레드가 공유 자원에 접근하는 상황을 막는 상호 배제 락 매커니즘.
임계 구역(공유 자원)에 하나의 프로세스/스레드만 접근 가능함

### 세마포어

여러 프로세스/스레드 중 정해진 프로세스/스레드 갯수만큼만 접근을 허락하는 매커니즘.
대기 중인 프로세스/스레드가 공유 자원을 사용할 수 있는 지 계속 검사하는 과정이 발생 가능(바쁜 대기)

세마포어는 뮤텍스가 될 수 있는데, 뮤텍스는 세마포어가 될 수 없다!!!
세마포어는 소유가 불가능한데, 뮤텍스가 소유가 가능하다.



## 4주차

### PCB와 프로세스 컨텍스트

**프로세스 메타데이터**
CPU는 프로세스 메타데이터로 프로세스를 식별.
Process ID, Process State, Program Counter, Process Context 등...
Program Counter = 다음에 실행될 명령어의 주소를 저장.

**PCB(Process Control Block)** 
프로세스 관리를 위한 메타데이터를 저장하는 자료구조. 커널이 관리

**프로세스 컨텍스트**
CPU가 해당 프로세스를 실행하기 위한 프로세스 데이터 모음.
CPU는 레지스터를 기반으로 코드를 실행하므로, 
프로세서의 상태와 관련된 레지스터 집합을 프로세스 컨텍스트라고 이해.



### 컨텍스트 스위칭

하나의 프로세스가 CPU를 사용하고 있을 때, 
하던 프로세스 작업을 중단하고 다른 프로세스 작업을 하기 위해,
진행 중이던 프로세스의 컨텍스트를 PCB에 저장하고,
다음 프로세스를 진행하기 위해 PCB에서 해당 컨텍스트를 가져와 작업을 진행한다.

#### 프로세스와 쓰레드 컨텍스트 스위칭

프로세스 : PCB에 프로세스 컨텍스트를 저장.
쓰레드 : 프로세스 내부의 TCB에 컨텍스트를 저장.

#### 컨텍스트 스위칭이 일어나는 경우

1. 인터럽트 발생
2. CPU 사용 허가 시간 모두 소모
3. 입출력 대기해야 하는 경우



### 사용자 수준 스레드 vs 커널 수준 스레드

#### 커널 수준 스레드

커널이 생성해서 관리하는 스레드.
커널이 직접 관리하므로 권한이 많지만, 그만큼 오버헤드가 일어남

한 프로세스에 여러 쓰레드를 할당하면, 한 스레드가 블락되도 다른 스레드로 대신하면 됨.

커널에서 관리하다 보니, 컨텍스트 스위칭도 발생. 오버헤드가 일어남

#### 사용자 수준 스레드

사용자 모드에서 동작하는 스레드.
사용자 레벨에서 스레드 전용 라이브러리를 이용해서 여러 스레드를 생성.
(자바에서 스레드 함수 이용하던지..)

스케줄링을 커널이 하지 않고 스레드 라이브러리에 따라 스케줄링.

이 스레드들은 커널의 기능을 사용하지 못하고,
커널도 이들의 존재를 모른다.



### fork와 vfork의 차이점.

#### fork

UNIX 계열에서 새로운 프로세스 만드는 함수
자식 프로세스가 부모 프로세스를 복제하는 방식

#### vfork

부모 프로세스와 자식 프로세스가 페이지 테이블 공유.
복사하지 않고 공유하므로 생성 속도가 빠르지만,
공유된 자원을 두고 경쟁할 수 있다. -> 부모 프로세스는 자식이 exit하거나 execute할 때까지 block



## 5주차

### Race Condition

공유 자원에 여러 프로세스가 동시에 접근하려고 경쟁하는 상황
결과의 순서를 기대할 수 없다

#### Race Condition attack

Setuid(소유자 권한으로 실행)으로 설정된 파일이 실행 중일 때,
생성된 임시파일과 같은 이름의 파일에 심볼릭링크를 만들어서 원본 파일을 지우고
새로운 임시 파일이 생성될 때, 심볼릭 링크를 통해 파일 내용을 변경.

시스템은 변경된 파일을 새롭게 생성된 파일로 착각하고 프로세스 진행.

##### 레이스컨디션 대응

1.  가능하면 임시파일 생성 금지
2. 파일 생성 시, 동일 파일 존재 시, 파일 생성 혹은 쓰기를 금지
3. 만들려는 파일에 링크가 걸려있으면 실행중단
4. 임시파일이 공격자에 의해 삭제되지 않도록 함(umask를 최하 022정도로 유지. 쓰기 권한 제거)



### 시스템콜 vs 서브루틴

커널은 하드웨어를 제어하는 일종의 API.
시스템콜은 커널의 서비스를 호출하는 명령어.
서브루틴은 프로그래밍 할때 사용하는 대부분의 API.

서브루틴이 시스템콜을 호출하고 -> 시스템콜이 커널을 호출.
->커널의 수행 결과를 시스템콜로 전달->시스템콜이 다시 서브루틴에게 보냄
