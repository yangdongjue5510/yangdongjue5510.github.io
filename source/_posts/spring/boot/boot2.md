---
title: 2. Spring과 JPA의 특징 with 데어 프로그래밍
date: 2021-08-20 17:36:50
tags:
category:
    - Spring
    - Boot
---
## 1. 스프링이란? by 데어 프로그래밍
*스프링은 프레임워크이다.*
*스프링은 오픈소스이다.*
*스프링은 IoC 컨테이너를 가진다.*
*스프링은 DI 를 지원한다.*
*스프링은 엄청나게 많은 필터를 가지고 있다.*
*스프링은 엄청나게 많은 어노테이션을 가지고 있다. (리플렉션, 컴파일체킹)*
*스프링은 MessageConverter를 가지고 있다. 기본값은 현재 Json이다.*
*스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.*
*스프링은 계속 발전중이다.*

### IoC(Inversion of Control) 제어의 역전
일반적인 java 객체를 new로 생성해서 개발자가 관리하는 게 아닌,
Spring Container에 모두 맡긴다.


개발자가 관리하는게 아닌 프레임워크가 제어하므로, 제어의 역전이라 한다.
**개발자가 클래스들을 만들면, 스프링 컨테이너가 이를 읽고 나서 인스턴스화(힙 메모리 공간에 띄운다) 해서 관리한다.**
**개발자가 코드로 new 할 필요가 없다는 의미다!**
### DI(Dependecy Injection) 의존성 주입
외부로부터 내가 사용할 객체를 주입받는다!(스프링 컨테이너가 주입해준다.)
**스프링 컨테이너는 하나의 인스턴스를 만들어 그 인스턴스를 공유해 사용하도록 한다.(익숙한데..? 그렇다 싱글톤 패턴!)**

- DI 장점
    - 의존성에서 격리, 코드 테스트에 용이하다
    - 불가능한 상황을 Mock 같은 기술을 통해 안정적으로 테스트 가능
    - 코드를 확장하거나 변경 할 때 영향 최소화(추상화)
    - 순환참조 예방.

### 스프링의 필터
톰캣을 거쳐서 스프링 컨테이너에 접근하려는 시도들 중 권한이 있는 것만을 통과하도록 필터를 사용할 수 있다.
이때 톰캣에서 사용되는 필터는 web.xml에 filter로 생성되어 있고,
스프링 컨테이너의 필터는 인터셉터라고 부른다.(AOP개념이 이때 사용되기도 한다. 천천히 공부하자!)


### 컴파일 체킹
**어노테이션**도 일종의 주석인데, 컴파일러가 무시하지 않고, 컴파일러가 체크하도록 해놓은 표시같은거다!
그래서 어노테이션에 맞지 않을 경우 컴파일러가 멈추도록 한다.

> 스프링에서는?

스프링의 어노테이션은 보통 객체를 생성하는 역할을 한다.
@component(클래스를 읽어서 메모리에 로딩해라!), 
@Autowired(로딩된 객체를 해당 변수에 집어넣어!) 이런식이다.


스프링 컨테이너는 런타임동안 클래스 내부를 분석(**리플렉션**)해서 해당 클래스의
메소드, 필드, 어노테이션을 찾아서 어떻게 작동해야할지를 정한다.


### MessageConverter
서로 다른 언어가 서로 데이터를 주고 받으려면, 서로 합의한 형식을 주고 받기로 하자.
우리는 이 합의로 한 형식을 **JSON**으로 사용하고 있다.
즉 자바 시스템에서 파이썬 시스템으로 어떤 데이터를 보내고 싶어할 때는
자바 - json - 파이썬 이런 식으로 전달된다.


> MessageConverter?

메세지컨버터(jackson이 기본)는 요청할 때 자바 오브젝트를 json으로 바꿔주거나
응답받을 때 json을 자바 오브젝트로 바꿔주는 라이브러리다.


### BufferedWriter, BufferedReader를 용이하게 사용?
보통 inputStream으로 1byte(8bit) 씩 읽어드리는데,
효율적인 사용을 위해 BufferedReader로 가변적인 문장길이를 갖는 데이터를 쉽게 받을 수 있다.


스프링에서는 @ResponseBody라는 어노테이션을 쓰면 자연스럽게 BufferedWriter를 사용하고
@RequestBody라는 어노테이션을 쓰면 자연스럽게 BufferedReader를 사용한다!


## 2. JPA란?
*JPA는 Java Persistence API 이다.*
*JPA는 ORM 기술이다.*
*JPA는 반복적인 CRUD 작업을 생략하게 해준다.*
*JPA는 영속성 컨텍스트를 가지고 있다.*
*JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)*
*JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)*
*방언 처리가 용이하여 Migration하기 좋음. 유지보수에도 좋음.(다양한 dbms 제공)*
*JPA는 쉽지만 어렵다.*


### Java Persistence API?
RAM은 휘발성 메모리다. 꺼지면 날라간다.
그래서 우리는 하드디스크나 DBMS에 저장하는데, 이를 Persistence라고 부른다.


**JPA는 말 그대로, 자바로 만든 걸 persistence하게 저장할 수 있게하는 api이다.**

> 근데 API가 뭐에요?

어플리케이션 프로그래밍 인터페이스다.
즉 프로그램을 만드는 기준을 알려주는 것.
이때 인터페이스라는 말은 기준을 제공하는 자와 기준에 따르는 자의 관계가 상하관계가 존재한다.
(이것이 프로토콜과의 차이다.)

### JPA는 ORM?
object를 데이터베이스에 넣는 방법론 중 하나.


(일반적으로 데이터베이스 설계 - 이에 맞게 자바 클래스 모델링)
데이터베이스의 형태와 자바 데이터타입이 다르기 때문에
자바는 클래스로 데이터베이스의 형태를 자바에 모델링한다.


**(JPA는 먼저 클래스 설계 - 이에 맞게 데이터베이스 생성)**
자바가 클래스로 데이터베이스로 만들고 싶은 형태를 만든다.
그러면 자연스럽게 데이터베이스에 클래스 형태에 맞도록 모델링된다.


예를 들면 db는 객체를 저장하지 못하지만, 자바는 가능하다.
자바에서 객체와 자료형으로 데이터를 저장하면 JPA가 이를 db에 맞도록 변환해서 db에 저장한다!
### CRUD 작업 코드 생략
(일반적 상황 - 매 쿼리마다 일어나는 반복적인 행동)
자바가 db에 접근해서 세션을 오픈하고
자바가 db에 쿼리를 보내고, db는 그에 맞는 데이터를 보낸다.
이때 자바는 db가 보낸 데이터를 이해 못하므로, 이를 이해하기 위한 중간 작업을 한다.
이 작업이 끝나면 세션을 닫는다.

**(JPA 도입 - 위 모든 행동들을 하나의 함수로 해결!)**

### 영속성 컨텍스트
영속성은 어떤 데이터를 영구적으로 저장할 수 있게 한다는 의미.
컨텍스트는 어떤 대상의 모든 정보를 의미한다.


영속성 컨텍스트는 db에 저장하기 위해 필요한 모든 정보를 의미한다.
자바와 db사이에서 이를 조율하는 역할로 이해하면 편하다.
자바가 데이터를 가져와서 수정하면, 
영속성 컨텍스트가 이를 반영하고, db의 내용도 업데이트 해주는 등 db를 위한 모든 일은 영속성 컨텍스트를 통해 이뤄진다.


