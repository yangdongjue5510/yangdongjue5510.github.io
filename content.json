{"meta":{"title":"mudura | 그거 뭐더라","subtitle":"mudura powered by yangdongjue5510","description":"This is yangdongjue5510 dev blog.","author":"yangdongjue5510","url":"https://yangdongjue5510.github.io","root":"/"},"pages":[{"title":"소프트웨어 엔지니어링","date":"2021-09-09T12:06:57.000Z","updated":"2022-01-22T16:20:00.072Z","comments":true,"path":"img/engineer1.html","permalink":"https://yangdongjue5510.github.io/img/engineer1.html","excerpt":"","text":"Software Engineering?개발 운용 유지보수 등 생명 주기 전반을 체계적, 서술적, 정량적으로 다루는 학문 SLDC요구사항 분석 -&gt; 설계 -&gt; 구현 -&gt; 테스트 -&gt; 유지보수 하는 과정 요구사항 분석요구사항 유도 : 대화를 통해 요구사항을 결정 -&gt; 애매하면 구체적이 되도록 유도! 비즈니스 요구사항 : 왜 이걸 하는지, 고객은 어떤 이득을 보는지 사용자 요구사항 : 사용자가 이걸 통해 어떤걸 할 수 있는지(유스케이스 다이어그램과 유저스토리를 작성) 기능적 요구사항 : 개발자가 이 제품의 무엇을 개발할 것인지 “해야한다” / “하면 안된다”로 모든 요구사항을 서술해야 한다. 비즈니스 룰 : 비즈니스적 제약사항 유저 로그인을 위해서는 페이스북 계정이 있어야한다. 등.. 품질 명세 : 100명의 사용자가 1.5초 안에는 처리해야..등.. Software Development Lifecycle Process ModelBuild-fix Model설계없이 일단 개발! 만족할 때까지 수정!개발 문서도 없고 파악도 힘들고… Waterfall Model순차적으로 개발, 가장 많이 사용.체계적인 문서화, 정형화된 접근 가능!하지만 한 단계에서 오래 걸리면 다음 단계로 넘어가는데 오래걸림한 단계가 완료되야 다음 단계로 넘어감 Prototype Model요구 사항을 프로토타입으로 구현하고, 피드백받고 다시 수정하고다시 수정하는 방식.대규모 프로젝트에 적용하긴 힘듬. Agile프로젝트 생명 주기 동안 반복적인 개발 촉진.지나친 계획과 부족한 계획의 절충안.문서 작성보다는 코드를 활용한 방법 eXtream Programming요구조건을 확인 할 수 있는 테스트 코드를 먼저 작성하고,그 코드를 만족할 수 있도록 프로그래밍(TDD)2주 주기로 계획 설립, 프로토타입으로 개발 방향 점검(Planning)Pair Programming(한명이 개발, 한명이 검사) Scrum 만들어야 될 기능/개선점에 우선순위를 부여 일정 기간안에 실제 작동하는 제품을 제작. 스프린트 : 반복적인 개발 주기(계획 회의 ~ 제품 리뷰 단위) 스프린트 계획 회의 : 스프린트 목표와 백로그 계획 스프린트 백로그 : 필요한 작업 목록 일일 회의 : 어제 한일, 오늘 할 일, 장애 현상 공유 정리 개발 이전 요구사항 분석 고객 측면 기능 측면 외부 인터페이스 디자인 프로토타입 유스케이스 스토리 보드 데이터 플로우, ERD 작성 API 기획회의 API 디자인"}],"posts":[{"title":"Java의 Call by Value","slug":"java/java-basic/java-call-by-value","date":"2022-04-02T09:11:48.000Z","updated":"2022-04-02T13:59:23.532Z","comments":true,"path":"2022/04/02/java/java-basic/java-call-by-value/","link":"","permalink":"https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/","excerpt":"","text":"요약 자바에는 Call by Value만 존재한다.Call by Value는 함수의 인자에 값을 전달하는 방식이고,Call by Reference는 함수의 인자에 주소를 전달하는 방식이다. Call by Value vs Call by Reference프로그래밍 언어에서 함수에 인자로 전달하는 방식에 따라 나뉜다. Call by ValueCall by Value는 함수 호출시 전달되는 변수의 값을 복사해서 전달한다.이렇게 전달된 인자는 외부에서 있었던 변수와는 달리 함수 내부의 지역 변수로 활용된다.즉 함수 안에서 인자를 변경해도 외부 변수 값은 변경되지 않는다. 12345678910111213141516public class CallByValueTest &#123; private void swap(int a, int b) &#123; int tmp = a; a = b; b = tmp; &#125; @Test public void swapTest() &#123; int a = 1; int b = 2; swap(1, 2); assertThat(a == 2 &amp;&amp; b == 1).isTrue(); &#125;&#125; 위 테스트 코드를 살펴보자.swap 함수는 두 int형 변수의 값을 바꾸는 함수다. 그런데 테스트 결과는 맞지 않게 나온다.원인은 swap 함수에서 변수를 가져오는 과정이 Call by Value이기 때문이다. 테스트 코드에서 전달한 a와 swap 내부에서의 a는 서로 영향을 주지 않는다.테스트 코드의 a에 저장된 1이라는 값을 복사해서 메서드의 a에 저장한 것일 뿐이다. Call by ReferenceCall by Reference는 함수 호출 시 전달되는 변수의 참조값을 전달하는 방식이다.함수가 인자로 주소값을 전달받고나서 이를 함수 내부에서 접근하여 수정하면,함수 외부의 변수도 변화가 생길 수 있다. Java의 Call by Value Java는 전달되는 인자의 타입에 따라 약간 다르게 보인다. 원시 타입자바는 8가지 원시 타입이 있다.(byte, short, int, long, float, double, char, boolean) 원시 타입 변수들은 스택 메모리에 그대로 저장된다.그래서 원시 타입이 인자로 전달될 때는 스택에 저장된 값 그대로 복사되어서 전달된다. 전달된 값은 원래 변수와는 다른 별개의 변수. 즉 Call by Value 방식으로 전달된다.전달된 갑쇼은 해당 메서드가 종료되면 스택에서 제거된다. 예시로 이해하기12345678910111213141516public class CallByValueTest &#123; @Test public void swapTest() &#123; int a = 1; int b = 2; //1단계 swap(1, 2); //2단계 assertThat(a == 2 &amp;&amp; b == 1).isTrue(); &#125; private void swap(int c, int d) &#123; int tmp = c; c = d; d = tmp; //3단계 &#125;&#125; 아까 본 예시로 다시 이해해보자. 1단계까지 실행하고 나면 스택에는 a = 1, b = 2 라는 정보를 저장하게 된다.2단계를 실행하고 나면 a = 1, b = 2 라는 정보에 새로운 스택 프레임이 생기고 그곳에 c = 1, d = 2가 생긴다.즉 (a =1 , b = 2), (c = 1, d = 2) 이런 식으로 스택에 저장된다. 이제 3단계까지 실행하면 스택은 (a = 1, b =2), (c = 2, d = 1, tmp = 1) 이렇게 저장된다.swap 메서드가 종료되면 swap 메서드의 프레임이 종료되므로 결국 (a = 1, b = 2)만 스택에 남는다. 참조 타입참조 타입은 쉽게 말해서 객체의 주소를 저장하는 타입이다.보통 기본 타입을 제외한 모든 것을 의미한다. 참조 타입은 기본 타입과 다르게 값 그 자체를 저장하지 않는다.대신 그 값의 주소 값을 저장한다. 그렇다면 그 값의 주소는 어디의 주소를 의미하는 걸까?그 주소는 바로 힙 영역에 있는 인스턴스의 주소를 의미한다. 즉 참조 타입은 객체의 주소를 가지고 스택에 저장되고,그 주소는 힙 영역에 있는 인스턴스의 주소다. 앞서서 자바는 Call by Value라고 했다.참조 타입도 예외는 아니다. Call by Value다.다만 전달되는 Value가 주소값이라서 기본 타입과는 다르게 작동한다. 예시로 이해하기12345678910111213141516171819202122class UserAge &#123; int value;&#125;public class CallByValueTest &#123; @Test void callByValueObject() &#123; UserAge a = new UserAge(); a.value = 1; UserAge b = new UserAge(); b.value = 2; //1단계 swap(a, b); //2단계 assertThat(a.value == 2 &amp;&amp; b.value == 1).isTrue(); &#125; private void swap(UserAge c, UserAge d) &#123; int tmp = c.value; c.value = d.value; d.value = tmp; &#125;&#125; UserAge는 int 형 데이터를 저장하는 클래스다.이제 두개의 UserAge를 만들어서 값을 변경하는 swap 메서드에 전달해보자. 1단계까지 오면 스택에 a = UserAge 주소값1, b = UserAge 주소값2 이 오게된다.우리가 만든 실제 객체는 힙 영역에 있고 스택의 주소값은 힙 영역을 가르키는 값이다. 2단계까지 오면 이제 새로운 스택 프레임이 생긴다.c와 d에 a, b가 가진 값(즉 주소값)을 복사해서 넣어준다. 즉 Call by Value 방식으로 전달한다. 스택에는 (a = UserAge주소1, b = UserAge주소2), (c = UserAge주소1, d = UserAge주소2) 이렇게 저장된다. 이때 주목할 점은 a와 c가 같은 주소값을 저장하고 있고, b와 d가 같은 값을 저장하고 있다는 점이다.이제 c를 통해 힙에 있는 인스턴스를 변경하면 나중에 a를 통해 인스턴스에 접근했을 때 값이 변경되어 있게 된다.(b와 d도 같은 관계다.) 정리 자바는 모두 Call by Value이다.다만 원시 타입은 값 자체를 복사해서 전달하고,참조 타입은 참조하는 객체의 주소를 복사해서 전달한다. 참고 https://deveric.tistory.com/92https://www.baeldung.com/java-pass-by-value-or-pass-by-referencehttps://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-valuehttps://kingpodo.tistory.com/54https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-framehttps://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"post","slug":"java/object/post","date":"2022-03-27T07:09:39.000Z","updated":"2022-03-27T13:36:29.560Z","comments":true,"path":"2022/03/27/java/object/post/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/27/java/object/post/","excerpt":"","text":"사용하는 입장에서 예상 가능한 코드 의존성이 적절한 코드(결합도가 낮은 코드) 너무 세세한 부분까지 알지 못하도록 정보를 차단 객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하자. 불필요한 세부사항을 객체 내부로 캡슐화하는 것 -&gt; 객체의 자율성 + 응집도가 높은 객체 단순 타입보다는 객체를 선언해서 의미를 전달하는게 좋다. (관련 로직이 한곳에 모이는 효과도 있다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}]},{"title":"상속과 조합","slug":"java/object/post-3","date":"2022-03-12T04:28:30.000Z","updated":"2022-03-19T05:29:39.679Z","comments":true,"path":"2022/03/12/java/object/post-3/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/12/java/object/post-3/","excerpt":"","text":"상속의 위험성상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.내가 필요로 하는 클래스와 매우 유사한 클래스가 있다면 해당 클래스를 상속하면 같은 코드를 여러번 쓸 필요가 줄어든다. 상속은 코드 재사용을 위해 캡슐화를 희생시킨다. 부모 클래스의 코드를 재활용하기 위해 자식 클래스도 재활용할 코드를 모두 공개되기 때문이다. 경고 1. 자식 클래스 메서드 안에서 super 참조로 부모 클래스의 메서드를 직접 호출하면 두 클래스의 결합도가 높아진다. (super 참조를 제거하라.) 상속을 염두해두고 설계하지 않은 클래스를 상속하기 어렵다.기존의 코드를 다른 상황에 재사용하기 위해서는 개발자가 나름의 해석을 하고 가정한다.그러나 개발자의 가정을 이해해야 하는 코드는 읽기가 어려워진다. 실제 요구사항과 구현이 다르면 우리는 기존의 구현을 요구사항과 같은 결과를 나타내도록 많은 가정을 하게된다. 상속을 하려면 부모 클래스의 가정과 추론 과정을 정확하게 이해해야 한다.상속은 부모 클래스의 구체적인 구현을 이해해야 할 가능성이 높다. 그래서 결합도(다른 모듈에 대해 알고 있어야할 지식의 수준)가 높다. 자식 클래스가 부모 클래스의 변경이 취약해진다. 취약한 기반 클래스 문제.만약 부모 클래스의 변경된 부분이 자식 클래스에 파생되는 행동이라면, 자식 클래스의 행동이 예상과 다르게 작동 될 수 있다. 상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만든다.상속은 부모 클래스의 퍼블릭 인터페이스가 아닌 다른 곳을 고쳐도 영향을 받는다. 이게 캡슐화를 약화시킨다는 증거다. 경고 2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다. 코드 재활용을 하기 위해 부모 클래스를 상속 할 경우, 부모에서 공개 됐던 메서드들이 자식 클래스의 내부 규칙을 깨트릴 수 있다. 오브젝트에서 제시한 예시는 Vector를 상속받는 Stack이다.Stack은 push와 pop으로만 데이터를 수정할 수 있다. 그러나 Vector는 퍼블릭 인터페이스로 다양한 인덱스에 add할 수 있게한다. 이는 Stack의 규칙을 깨트리는 방식이다. 123456Stack&lt;String&gt; stack = new Stack&lt;&gt;();stack.push(&quot;1st&quot;);stack.push(&quot;2nd&quot;);stack.push(&quot;3rd&quot;);stack.add(0, &quot;4th&quot;); //이건 Vector의 퍼블릭 인터페이스. 스택의 규칙에 어긋난 행동 경고 3. 자식이 부모의 메서드를 오버라이딩하면 부모의 다른 메서드가 자식의 메서드를 결합하게 될 수 있다. 부모 클래스의 특정 메서드를 자식 클래스가 오버라이딩 하게 되면, 부모 클래스에서 해당 클래스를 원래의 메서드(즉 오버라이딩 되기 전 메서드)를 예상하고 사용했던 부분에서 예기치 못한 작동(오버라이딩 된 메서드)를 수행할 수 있다. 경고 4. 부모 클래스에 변화가 생기면 자식도 같이 변해야 되는 일이 생길 수 있다. 상속은 결합도가 높아서, 부모와 자식이 같이 변하거나, 자식과 부모를 변경하지 않거나 두가지 선택지 밖에 없다. 부모 클래스를 오버라이딩 하지 않고 불필요한 퍼블릭 인터페이스를 상속받지 않아도 부모의 중요한 부분이 변경되면 자식 클래스도 같이 변경될 수 밖에 없다. 상속을 보다 안전하게 사용하기추상화에 의존자식 클래스가 부모 클래스의 구현이 아닌 부모 클래스의 추상화에 의존해야 한다.더 정확하게 말하면 부모와 자식 모두 추상화에 의존해야 한다. 달라지는 부분을 찾아 메서드로 분리비슷해보이는 클래스 간에 서로 다른 부분을 메서드를 추출한다.그러면 다른 부분을 제외하면 나머지 메서드들은 동일하게 된다.그러면 이제 중복 코드를 부모 클래스로 올린다.그리고 달라지는 부분은 부모의 추상 메서드로, 각 클래스들이 구현하도록 하면 된다. 이제 자식 클래스들은 부모의 추상 메서드에만 의존하게 되므로 느슨하게 결합된다. 하지만 이런 추상 클래스를 활용한 추상화에 의존하는 방법도 문제가 있다.객체 행동만 변하면 각 클래스를 독립적으로 변경시키면 되겠지만, 인스턴스 변수가 추가되는 경우는 다르다.부모 클래스에 인스턴스 변수가 추가되어 객체 생성때 초기화해줘야 하는 경우, 상속되는 모든 클래스는 수정을 해줘야 한다. 합성을 활용하기상속은 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 방법.합성은 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다. 합성은 구현에 의존하지 않는다.합성은 내부 부분 객체의 퍼블릭 인터페이스에 의존한다. 즉 구현에 의존하는 것이 아닌 인터페이스에 의존하도록 할 수 있다.합성은 내부 부분 객체의 구현 방식이 변경되어도 전체 객체는 영향이 적다. 상속은 정적인 관계인데 합성은 동적인 관계이다.코드 작성 때 정해진 상속 관계를 실행 시점에서 변경이 불가능하다.반면 합성 관계는 코드 작성 때 정해진 관계를 실행 시점에서 변경이 가능하다. 상속을 합성으로 바꾸는 방법은 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다. 합성의 안전성불필요한 인터페이스 상속 문제부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,자식 클래스의 규칙에 맞게 인스턴스의 퍼블릭 인터페이스를 활용하면 된다. 메서드 오버라이딩 오작동 문제부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,자식 클래스의 메서드가 부모 인스턴스의 메서드를 오버라이딩해서 부모 인스턴스의 퍼블릭 인터페이스와 협력하면 된다.(이때 오버라이딩한 인스턴스 메서드가 인스턴스에게 동일한 메서드 호출을 전달하는 메서드를 포워딩 메서드라고 한다.) 부모 클래스와 자식 클래스의 동시 수정 문제합성이 이 문제를 완전히 해결하지는 못한다. 하지만 조합된 내부 인스턴스의 변경사항을 최대한 캡슐화 시킬 수 있다. 합성의 유연성하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함. 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많이 늘어날 수 있다. 추상 메서드와 훅 메서드추상 메서드 : 개방 - 폐쇄 원칙을 만족하기 위한 설계. 하위 계층이 오버라이딩해서 구현훅 메서드 : 추상 메서드는 반드시 모두가 구현해야 해서 불편하다. 대부분의 하위 계층이 똑같이 구현하면 중복 코드가 많이 생기기 때문에 기본 구현을 해놓고 달라지는 경우에만 오버라이딩하는 메서드 기능 추가를 할 때 상속을 남용하면 필요 이상으로 클래스가 만들어진다.(클래스 폭발, 조합의 폭발)이런 문제는 자식 클래스와 부모 클래스의 다양한 조합이 필요한데 상속은 컴파일 타임에 관계가 결정되어 버려서 모든 조합을 미리 만들어놓으면서 생기는 문제다. 합성을 사용하면 컴파일 타임에서 정한 관계를 런타임에서 수정할 수 있다.상속은 조합의 결과를 개별의 클래스에 밀어넣는 방법이고, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 다음 런타임에서 인스턴스를 조립하는 방식이다. 그러면 상속은 언제 사용하는가코드 재활용을 목적으로 상속하면 변경하기 어렵고 유연하지 못하게 된다.만약 상속을 사용하려고 할 때 스스로에게 물어보자.내가 상속을 이용하는게 코드 재사용을 위한 것인가? 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위한 것인가? (코드 재사용을 위한 것이면 상속을 피해야 한다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"클린코드를 위한 함수","slug":"java/clean-code/clean-code-2","date":"2022-03-04T08:37:59.000Z","updated":"2022-03-04T09:30:44.033Z","comments":true,"path":"2022/03/04/java/clean-code/clean-code-2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-2/","excerpt":"","text":"함수는 한 가지만 해라!함수에 적힌 코드들의 추상화 수준이 같은 단계로 통일시켜라는 의미다.혹은 함수 내에서 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 셈이다. 12345678910111213public Lotto createLotto(List&lt;String&gt; tokens) &#123; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (String token : tokens) &#123; numbers.add(Integer.parseInt(token)); &#125; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); for (int number : numbers) &#123; lottoNumbers.add(new LottoNumber(number)); &#125; return new Lotto(lottoNumbers);&#125; 위 코드는 크게 추상화 단계가 두가지이다. 문자열을 숫자로 바꾸는 단계 (추상화 단계 낮음) 숫자를 LottoNumber로 바꾸는 단계 (추상화 단계 중간) LottoNumber를 Lotto로 바꾸는 단계 (추상화 단계 높음) 이제 이 작업들을 나눠서 리팩토링 해보자.자연스럽게 내려가기 규칙이 적용되서 다음에 오는 함수는 추상화 단계가 하나씩 줄어드는 걸 볼 수 있다. 12345678910111213141516171819public Lotto createLotto(List&lt;String&gt; tokens) &#123; return new Lotto(createLottoNumbers(tokens));&#125;public List&lt;LottoNumber&gt; createLottoNumbers(List&lt;String&gt; tokens) &#123; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList(); for (int number : parseAll(tokens)) &#123; lottoNumbers.add(number); &#125; return lottoNumbers;&#125;public List&lt;Integer&gt; parseAll(List&lt;String&gt; tokens) &#123; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (String token : tokens) &#123; numbers.add(Integer.parse(token)); &#125; return numbers;&#125; 함수 인수함수에 전달되는 인수는 0개가 제일 좋다.3개 이상은 되도록 피해야 한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Clean Code","slug":"clean-code","permalink":"https://yangdongjue5510.github.io/tags/clean-code/"}]},{"title":"클린코드를 위한 의미 있는 이름","slug":"java/clean-code/clean-code-1","date":"2022-03-04T05:44:23.000Z","updated":"2022-03-04T08:37:55.679Z","comments":true,"path":"2022/03/04/java/clean-code/clean-code-1/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/clean-code/clean-code-1/","excerpt":"","text":"의도를 분명히 밝혀라 변수(혹은 함수나 클래스)의 존재 이유가 무엇인가? 어떤 일을 수행하는가? 어떻게 사용하는가? 이름으로 위 세가지가 표현이 안된다면 문제가 있다. 변수의 이름은 범위 크기에 비례해야 한다.123456int pricePerLotto = 1000;int Prizesum = 0;for (Lotto lotto : lottos) &#123; prizeSum += pricePerLotto * lotto.getPrize();&#125; 이름이 길수록 사용되는 범위가 넓다고 생각하자.예를 들면 for 문의 i는 해당 루프에서만 사용되서 짧아도 된다.이름이 길수록 검색도 용이하다. 맥락을 추가하라이름 그 자체로 의미를 분명히 보여주는 변수는 없다.함수나 클래스에서 맥락을 부여하면 이름을 더 자연스럽게 읽힐 수 있다.이마저도 힘들면 접두사를 붙일 수 있다. (stateName, 이런 식으로..) 123public void printNameAndPosition(String name, String position) &#123; System.out.println(name + position);&#125; name는 어떤 이름을 의미하고, positon는 어떤 위치를 표시하는 건지 도저히 알 수 없다. 이름과 포지션은 사실 자동차의 이름과 자동차의 위치를 말해주는 변수들이다.그럼 이를 더 잘 알려주기 위해 맥락을 추가해보자. 12345678public class Car &#123; private String name; private int position; public void printNameAndPosition() &#123; System.out.println(name + position); &#125;&#125; 이제 Car라는 맥락 안에서 이름과 위치를 파악하면 좀 더 의미있게 파악할 수 있다. 불필요한 맥락 제거그렇다고 불필요하게 맥락을 이름에 붙여주는건 불필요하다. 1234public class Car &#123; private String carName; private int carPosition; &#125; 이미 Car라는 맥락 안에서 쓰이는 이름에 굳이 car를 붙이지 않아도 되지않을까?","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Clean Code","slug":"clean-code","permalink":"https://yangdongjue5510.github.io/tags/clean-code/"}]},{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","slug":"java/effective-java/effective5","date":"2022-03-03T15:47:28.000Z","updated":"2022-03-03T16:37:16.427Z","comments":true,"path":"2022/03/04/java/effective-java/effective5/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective5/","excerpt":"","text":"요약 클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.이런 영향력이 있는 자원을 클래스 내부에서 만들면 안된다.대신 이 자원(혹은 자원을 만드는 팩토리)을 해당 클래스를 인스턴스화 할 때 넘겨주자. 자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴맞춤법 검사기가 사전을 자원으로 가진다고 가정하자.만약 사전을 직접 명시한다는 건 어떤 얘기일까? 12345678//정적 유틸리티를 활용한 예제public class SpellChecker &#123; private static final Dictionary dictionary = new Dictionary(Language.ENGLISH); private SpellChecker() &#123;&#125; //객체 생성 방지 public static String changeSuggestions(String typo) &#123;...&#125;&#125; 12345678//싱글톤을 활용한 예제public class SpellChecker &#123; private final Dictionary dictionary = new Dictionary(Language.ENGLISH); private static SpellChecker INSTANCE = new SpellChecker(); private SpellChecker() &#123;&#125; public static String changeSuggestions(String typo) &#123;...&#125;&#125; 위 두 예시 모두 자원인 사전을 final로 직접 명시하고 있다. 나중에 다른 사전을 사용하고 싶을 때 변경이 힘들어진다. final을 제거하고 사전을 교체하는 메서드를 추가하는 방식은 멀티스레드 환경에 쓸 수 없음. 즉 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식을 사용하면 안된다! 의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기1234567public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Dictionary dictionary) &#123; this.dictionary = dictionary; &#125; //메서드..&#125; 자원이 많거나 의존 관계가 어떻든 잘 작동 불변성을 지원 생성자, 정적 팩터리, 빌더 모두에 적용 가능 자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;1234567public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Supplier&lt;? extends Dictionary&gt; dictionaryFactory) &#123; this.dictionary = dictionaryFactory.get(); &#125; //메서드...&#125; 자원 팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.자바에서는 Supplier&lt;T&gt;가 해당한다. 위처럼 생성자(정적 팩토리 메서드나 빌더)에 팩토리를 넘겨받으면 다음같이 활용 가능하다. 12345public class Application &#123; public static void main(String[] args) &#123; SpellChecker englishChecker = new SpellChecker(() -&gt; new Dictionary(Language.ENGLISH)); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}]},{"title":"인스턴스화를 막으려거든 private 생성자를 사용해라","slug":"java/effective-java/effective4","date":"2022-03-03T15:04:59.000Z","updated":"2022-03-03T15:47:23.827Z","comments":true,"path":"2022/03/04/java/effective-java/effective4/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/effective-java/effective4/","excerpt":"","text":"인스턴스화하지 않으려는 클래스?객체지향적이지 않지만 필요할 때가 있다.java.lang.Math, java.util.Array 같이 기본 타입 값이나 배열 관련 메서드를 모아둔 곳java.util.Collections와 같이 특정 인터페이스를 구현한 객체를 생성하는 정적 메서드를 모아둔 곳.final 클래스와 관련된 메서드를 모아놓을 때. (final 클래스를 상속해서 하위 클래스에 메서드를 못넣음) 인스턴스화 하지 않으려면 private 생성자를 사용12345public class NotInstance &#123; private NotInstance() &#123; throw new AssertionError(); &#125;&#125; private로 기본 생성자를 해놓으면 외부에서 인스턴스화를 막을 수 있다.Private 기본 생성자를 해놓으면 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문이다. Private 기본 생성자는 상속도 못하게 만든다. 123456public class SomeClass extends Instance &#123; public SomeClass() &#123; //super(); 가 생략되어 있음. //부모 객체의 생성자가 private면 이 과정이 안되니 상속이 안된다. &#125;&#125; 추상 클래스의 위험성 추상 클래스 그 자체는 인스턴스화할 수 없다. 하지만, 추상 클래스는 상속한 클래스를 통해 인스턴스화 할 수 있다.게다가 사용자가 추상 클래스를 보면 인스턴스화 하지 말라고 이해하지 않고, 상속받아서 사용하라고 이해하기 때문에 더 위험하다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}]},{"title":"자바 제네릭과 와일드카드 튜토리얼","slug":"java/java-basic/generic-tutorial","date":"2022-02-25T07:26:32.000Z","updated":"2022-04-02T13:57:26.954Z","comments":true,"path":"2022/02/25/java/java-basic/generic-tutorial/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/","excerpt":"","text":"요약 본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.JDK 8 기반으로 작성됐다. https://docs.oracle.com/javase/tutorial/java/generics/why.html 제네릭은 왜 쓰는가제네릭은 클래스, 인터페이스, 메서드를 선언할 때 타입(클래스, 인터페이스)도 매개변수로 만들 수 있다.전통적인 매개변수와 마찬가지로 타입 매개변수도 다양한 인풋을 받을 수 있게한다. 타입 체크를 컴파일 타임에 한다. 12345678910//정수를 리스트에 담아서 사용하려고 했는데 실수로 문자열을 넣는 상황//제네릭이 아닌 경우List list = new ArrayList();list.add(&quot;hello&quot;); //컴파일 에러가 발생하지 않는다.int hello = (int) list.get(0); //나중에 실행하면 여기서 ClassCastException이 발생한다.//제네릭인 경우List&lt;Integer&gt; genericList = new ArrayList&lt;&gt;();genericList.add(&quot;hello&quot;); //컴파일 에러 캐스팅 할 필요 없어진다. 12345678//제네릭 없는 경우List list = new ArrayList();list.add(&quot;하이&quot;);String hi = (String) list.get(0); //제네릭을 전달하지 않으면 Object를 반환List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();stringList.add(&quot;하이&quot;);String hello = list.get(0); 제네릭 간단하게 사용해보자아무 타입이나 저장할 수 있는 Box 클래스를 구현하고자 한다.제네릭 없이 구현하자면 다음과 같을 것 이다. 1234567891011class ObjectBox &#123; Object content; public Object getContent() &#123; return content; &#125; public void setContent(Object content) &#123; this.content = content; &#125;&#125; 이런 경우, get할 때마다 casting을 해줘야 된다.그리고 담겨진 내용물을 잘못 파악해 casting해도 컴파일 타임에 알 수 없고 런타임 때 ClassCastException이 발생한다. 제네릭을 사용1234567891011class GenericBox&lt;T&gt; &#123; T content; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125;&#125; 제네릭을 사용하면 캐스팅이 필요없고 casting도 필요 없다. 타입 파라미터 네이밍 컨벤션위에서 T는 타입 파라미터라고 한다. E - Element K - Key N - Number T - Type V - Value S, U, V - 2, 3, 4번째 타입 이렇게 지칭한다. 제네릭 타입 인보킹과 인스턴스화제네릭 타입 인보킹은 위에서 적은 T와 같은 매개변수를 우리가 의도한 실제 타입으로 변환하는 행위를 말한다. 1Box&lt;Integer&gt; integerBox; 참조변수를 통해 타입 인보킹을 해줄 수 있다.이때 조심해야 할 것은 T는 타입 매개변수이고, Integer는 타입인자이다. 이 두가지는 다르다. 제네릭을 사용하는 클래스를 인스턴스화하려면 다음과 같다. 123Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();//타입 추론도 된다.Box&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"Enum에서 메서드 참조와 BiFunction 사용하기","slug":"java/woowa-tech-course/post-2","date":"2022-02-24T14:12:58.000Z","updated":"2022-02-24T15:21:11.218Z","comments":true,"path":"2022/02/24/java/woowa-tech-course/post-2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/","excerpt":"","text":"요약 int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다. 문제 배경 (안좋은 사례 모음) 로또 순위를 Enum LottoRank로 등수와 상금을 관리하고자 한다.LottoRank가 맞춘 번호 갯수와 보너스 번호 맞춤여부를 전달받아 등수를 판별해야 한다. LottoRank에 맞춘 번호 갯수와 보너스 번호 맞춤여부를 추가로 저장하면 된다? 123456789public enum LottoRank &#123; FIRST(new Money(2_000_000_000), 6, false), SECOND(new Money(30_000_000),5, true), THIRD(new Money(1_500_000), 5, false), FOURTH(new Money(50_000), 4, false), FIFTH(new Money(5_000), 3, false), NOTHING(Money.ZERO, 2, false); //이하 생략...&#125; 그런데 문제가 있다. 4등, 5등은 보너스 맞춤여부가 false이든 true이든 상관없이 맞춘 갯수만 중요하다.그리고 꽝인 경우, 맞춘 갯수가 2개 뿐만 아니라 1개, 0개여도 꽝이다. 그리고 꽝도 4등 5등의 경우와 마찬가지로 보너스 맞춤여부가 상관없다.이런 경우도 전부 알맞은 상금을 가진 열거형 객체를 반환해줘야 한다. 좀 더 순위가 나오는 경우를 구체화한다? 12345678910111213141516public enum LottoRank &#123; FIRST(new Money(2_000_000_000), 6, false), SECOND(new Money(30_000_000),5, true), THIRD(new Money(1_500_000), 5, false), FOURTH(new Money(50_000), 4, false), FOURTH_WITH_BONUS(new Money(50_000), 4, true), FIFTH(new Money(5_000), 3, false), FIFTH_WITH_BONUS(new Money(5_000), 3, true), NOTHING_TWO(Money.ZERO, 2, false); NOTHING_TWO_WITH_BONUS(Money.ZERO, 2, true); NOTHING_ONE(Money.ZERO, 1, false); NOTHING_ONE_WITH_BONUS(Money.ZERO, 1, true); NOTHING_(Money.ZERO, 0, false); NOTHING_WITH_BONUS(Money.ZERO, 0, true); //이하 생략...&#125; 음…이렇게 하면 당연히 안된다!!!!!!!물론 보너스 번호 일치여부를 또 다른 열거형으로 도입하면 보너스 맞춤여부가 상관없는 경우 BONUS_MATCH.NOT_NEED 이런 식으로 처리하면 되긴 할 것이다.그렇지만 NOTHING의 맞춘 갯수가 0 ~ 2개를 모두 적용되어야 된다. BiFunction 도입하기이제 생각을 좀 바꿔보자.열거형 객체가 순위를 정하는 기준을 메서드참조로 저장하고 있다면 어떨까? 1. 일단 등수를 구별하는 기준을 메서드로 만들어주자123456789101112131415161718192021222324252627public enum LottoRank &#123; //생략... private static boolean isFirstPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 6; &#125; private static boolean isSecondPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 5 &amp;&amp; bonusMatch; &#125; private static boolean isThirdPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 5 &amp;&amp; !bonusMatch; &#125; private static boolean isFourthPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 4; &#125; private static boolean isFifthPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 3; &#125; private static boolean isNothingPrize(Integer matchCount, boolean bonusMatch) &#123; return 0 &lt;= matchCount &amp;&amp; matchCount &lt; 3; &#125;&#125; 이렇게 각 등수를 구분하는 기준을 정해준다.물론 bonusMatch를 사용하지 않는 경우도 있다. 하지만 나중에 메서드 참조를 위해서 넣어줬다. 2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다.1234567891011121314151617public enum LottoRank &#123; FIRST(new Money(2_000_000_000), LottoRank::isFirstPrize), SECOND(new Money(30_000_000), LottoRank::isSecondPrize), THIRD(new Money(1_500_000), LottoRank::isThirdPrize), FOURTH(new Money(50_000), LottoRank::isFourthPrize), FIFTH(new Money(5_000), LottoRank::isFifthPrize), NOTHING(Money.ZERO, LottoRank::isNothingPrize); private final Money prize; private final BiFunction&lt;Integer, Boolean, Boolean&gt; predicate; LottoRank(Money prize, BiFunction&lt;Integer, Boolean, Boolean&gt; predicate) &#123; this.prize = prize; this.predicate = predicate; &#125; // 이하 생략&#125; 두가지 객체를 받아서 한가지로 결과를 반환하는 BiFunction 인터페이스를 필드로 가지고, 생성자로 초기화해주자.그리고 우리가 만들었던 메서드들이 메서드 참조로 BiFunction을 구현하게 된다!! 3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다.12345678910111213141516public enum LottoRank &#123; //열거형의 필드와 생성자는 위에 나와있으니 생략. public static LottoRank of(Integer matchCount, boolean bonusMatch) &#123; return Stream.of(values()) .filter(rank -&gt; rank.isMatched(matchCount, bonusMatch)) .findFirst() .orElseThrow(InvalidMatchCountException::new); &#125; //등수 기준 구현 메서드는 위에 나와있으니 생략. private boolean isMatched(int matchCount, boolean bonusMatch) &#123; return predicate.apply(matchCount, bonusMatch); &#125;&#125; LottoRank의 모든 객체들을 순회하면서 그 객체의 BiFunction에 판별에 필요한 정보를 전달해줘서 적절한 순위를 찾아낸다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"Junit으로 parameterized test","slug":"java/woowa-tech-course/post-1","date":"2022-02-21T12:16:22.000Z","updated":"2022-03-12T04:17:21.320Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/post-1/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/","excerpt":"","text":"요약 @ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다. @MethodSource 도입 배경 자동차 이름의 글자 갯수가 5개 이하여야 하고, 자동차 이름이 빈 문자열이면 안되고 등등 다양한 제약 사항을 테스트해보고 싶다고 하자.근데 테스트 코드를 작성하다보니 다음과 같이 메서드가 비슷비슷하게 나올 때 이를 리팩토링해보자. 12345678910111213141516171819@SuppressWarnings(&quot;NonAsciiCharacters&quot;)public class CarNameTest &#123; @Test public void 자동차_이름_글자수_테스트() &#123; assertThatThrownBy(() -&gt; new CarName(&quot;다섯글자이상&quot;)) .isInstanceOf(RuntimeException.class) .hasMessageContaining(&quot;자동차 이름은 5자 이하여야 합니다.&quot;); &#125; @Test public void 자동차_이름이_존재하지_않는_경우_테스트() &#123; assertThatThrownBy(() -&gt; new CarName(&quot;&quot;)) .isInstanceOf(RuntimeException.class) .hasMessageContaining(&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;); &#125; // 등등...&#125; 해결하기 주목할 점은 한 테스트 메서드에 여러개의 인자를 여러 케이스로 보낼 수 있다는 점이다!! 1234567891011121314151617181920public class CarNameTest &#123; private static Stream&lt;Arguments&gt; provideCarNameAndExceptionMessage() &#123; return Stream.of( Arguments.of(null, &quot;자동차 이름을 찾을 수 없습니다!&quot;), Arguments.of(&quot;다섯글자이상&quot;, &quot;자동차 이름은 5자 이하여야 합니다.&quot;), Arguments.of(&quot;&quot;, &quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;) ); &#125; @ParameterizedTest @MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;) public void 자동차_이름_예외_테스트(String carName, String message) &#123; assertThatThrownBy(() -&gt; new CarName(carName)) .isInstanceOf(CarNameException.class) .hasMessageContaining(message); &#125;&#125; 다음같이 @ParameterizedTest해서 @MethodSource로 해결할 수 있다! @ValueSource 도입 배경 한가지 메서드에 여러가지 경우의 수를 넣어 실험하고 싶은데 어떻게 할까?예를 들어 자동차 이름에 여러가지 이름을 넣어보고 실제로 들어갔는지 테스트해보고 싶으면 어떻게 할지 고민해보자. 1234567891011@Testpublic void 자동차_이름_테스트() &#123; Car klayCar = new Car(&quot;klay&quot;, 0); assertThat(klayCar.getName()).isEqualTo(&quot;klay&quot;); Car eveCar = new Car(&quot;eve&quot;, 0); assertThat(eveCar.getName()).isEqualTo(&quot;eve&quot;); Car pobiCar = new Car(&quot;pobi&quot;, 0); assertThat(pobiCar.getName()).isEqualTo(&quot;pobi&quot;);&#125; 이렇게 무식하게 하면 당연히 뚜들겨 맞는다. 해결하기 주목할점은 전달될 인자의 자료형에 따라 strings, ints 등 필드값을 바꿔주면 된다. 123456@ParameterizedTest@ValueSource(strings = &#123;&quot;클레이&quot;, &quot;이브&quot;, &quot;포비&quot;&#125;)public void 자동차_이름_테스트(String carName) &#123; Car car = new Car(carName, 0); assertThat(car.getName()).isEqualTo(carName);&#125; @EnumSource열거형도 파라미터로 전달해줄 수 있다. 123456@ParametherizedTest@EnumSource(value = CardFace.class)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore &gt; 0 &amp;&amp; cardScore &lt; 11).isTrue();&#125; names 필드를 통해 열거형에서 일부만 골라서 넘겨줄 수 있다. 123456@ParametherizedTest@EnumSource(value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore == 10).isTrue();&#125; mode 필드를 사용하면 일부를 제외하고 넘겨줄 수 있다. 123456789@ParametherizedTest@EnumSource( value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;, mode = EnumSource.Mode.EXCLUDE)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore != 10).isTrue();&#125; @CsvSourceCsvSource는 여러 값을 문자열로 작성해주면 알아서 맞는 매개변수로 바꿔서 가져온다. 123456789101112@ParameterizedTest@CsvSource(value = &#123;&quot;ACE,FIVE,true&quot;, &quot;ACE,SIX,false&quot;&#125;)void canReceiveCard(CardFace face1, CardFace face2, boolean expected) &#123; final Participator dealer = new Dealer(); final Card firstCard = new Card(SPADE, face1); final Card secondCard = new Card(SPADE, face2); dealer.receiveCard(firstCard); dealer.receiveCard(secondCard); assertThat(dealer.canReceiveCard()).isEqualTo(expected);&#125; 파라미터 테스트 이름 설정하기 @ParameterizedTest의 name 필드에 {매개변수인덱스}를 넘겨주면 해당 인자가 테스트 이름에 포함된다. {매개변수 인덱스} 말고도 다양한 템플릿을 사용할 수 있다.{displayName} : 테스트 메서드 이름{arguments} : 모든 인자를 쉼표로 구분해서 모두 표현{argumentsWithNames} : 모든 인자를 이름과 함께 보여줌. 123456789101112131415@ParameterizedTest(name = &quot;&#123;0&#125; vs &#123;1&#125; is &#123;2&#125;&quot;)@CsvSource(value = &#123;&quot;BLACKJACK,BUST,WIN&quot;, &quot;BLACKJACK,STAND,WIN&quot;, &quot;STAND,BUST,WIN&quot;, &quot;BLACKJACK,BLACKJACK,DRAW&quot;, &quot;STAND,STAND,DRAW&quot;, &quot;BUST,BUST,DRAW&quot;, &quot;BUST,STAND,LOSE&quot;, &quot;STAND,BLACKJACK,LOSE&quot;,&#125;)void getResultFromStatus(Status status1, Status status2, Result expected) &#123; Result actual = Result.of(status1, status2); assertThat(actual).isEqualTo(expected);&#125; 더 알아보기 https://www.baeldung.com/parameterized-tests-junit-5 https://www.arhohuttunen.com/junit-5-parameterized-tests/","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"우아한테크코스 자동차 경주 미션 회고","slug":"java/woowa-tech-course/post","date":"2022-02-21T09:37:50.000Z","updated":"2022-02-24T14:17:24.023Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/post/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/","excerpt":"","text":"아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다. 페어 프로그래밍으로 같이 하면서, 처음엔 나 혼자하는게 더 빠르지 않을까 싶기도 했었는데,같이하는 페어의 독특한 생각을 많이 느낄 수 있어서 나 혼자하는 것보다 더 괜찮은 결과물을 얻을 수 있었던 것 같다. 미션을 마무리한 날, 같은 데일리 미팅 크루들과 자신의 코드를 설명하는 시간을 가졌다.역시 각 크루들의 코드가 나와 다른 부분도 많았는데, 그 부분을 잘 설득하는 크루를 보며 감탄했다.반면 나는 아직 설명도 제대로 못하고, 내가 왜 그렇게 짰는지 설득도 잘 못하는 것 같아 아쉽다…! 부족한 게 많으면 나아질 부분도 많다는 뜻. 이제 더 열심히 공부해서 다른 크루에게 도움이 되는 크루가 되자.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"자바의 예외 Throwable, Error, Exception","slug":"java/java-basic/java-exception","date":"2022-02-21T01:34:05.000Z","updated":"2022-02-21T05:08:15.161Z","comments":true,"path":"2022/02/21/java/java-basic/java-exception/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/java-basic/java-exception/","excerpt":"","text":"요약 Throwable -&gt; Exception -&gt; RuntimeException 등 다양한 예외Throwable은 stackTrace 생성 등 예외에 필요한 다양한 일을 함Exception은 예외 메시지를 받아 초기화할 수 있다RuntimeException은 치명적이진 않은 예외를 뜻함.RuntimeException은 치명적일 수 있는 에외로 반드시 처리를 해줘야 함. Throwable모든 에러와 예외의 부모 클래스다.Throwable의 인스턴스만 JVM이나 throw 키워드를 통해 예외나 에러를 thrown 될 수 있다.마찬가지로 catch문에 Throwable의 인스턴스만 올 수 있다. Throwable 객체는 생성될 때 해당 예외가 발생하던 수행 스택의 스냅샷을 가지게 된다.또한 다른 Throwable에 의해 생성된 경우 cause를 통해 알 수 있다.cause는 상위 Exception가 throw 될 때 굳이 하위 레이어의 내용까지 전파하지 않기 위함이다. 사실 개발하는 입장에서는 자주 사용하진 않는다. ErrorThrowable을 상속받는 클래스로,Try catch로 처리되어선 안될 정도로 심각한 문제를 일으킬 수 있는 문제들을 Error 클래스로 표현한다.일반적으로 비정상적인 상태를 나타낼 때 주로 사용된다. ExceptionThrowable을 상속받는 클래스로,Try catch 되어야할 이유가 있는 문제들을 Exception으로 표현한다.이때 Checked Exception과 RuntimeException 두가지로 구분된다. Checked Exception은 반드시 try catch 되거나 throws 되어야 컴파일 되는 예외이다.RuntimeException은 try catch 되거나 throws 되지 않아도 되는 예외이다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"자바 사용자 정의 예외 만들기","slug":"java/woowa-tech-course/java-custom-exception","date":"2022-02-20T23:37:58.000Z","updated":"2022-02-24T14:16:59.712Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/java-custom-exception/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/java-custom-exception/","excerpt":"","text":"요약 예외를 상속하는 클래스를 통해 예외를 만들 수 있다.생성자를 통해 에러 메시지를 초기화 할 수 있다. 배경 12345public void checkCarNameEmpty(String carName) &#123; if (carName == null || carName.equals(&quot;&quot;)) &#123; throw new RuntimeException(&quot;자동차 이름이 입력되지 않았습니다!&quot;); &#125;&#125; 다음같이 작성하면 자동차 이름이 빈 문자열이거나 null인 경우 런타임예외를 발생시킨다. RuntimeException은 너무 포괄적인 의미이니 도메인에 적합한 예외를 만들어보자. 예외 클래스 만들기1. 생성자를 그대로 사용하기1234567891011121314public class EmptyCarNameException extends RuntimeExecption &#123; public EmptyCarNameException(String message) &#123; super(message); &#125; public EmptyCarNameException(Throwable cause) &#123; super(message); &#125; public EmptyCarNameException(String message, Throwable cause) &#123; super(message); &#125;&#125; 이런 식으로 예외를 상속한 클래스를 만들고, 생성자들을 만들면 커스텀 예외로 활용할 수 있다. 2. 좀 더 활용하기12345public class CarNameException extends RuntimeException &#123; public CarNameException(String message) &#123; super(message); &#125;&#125; 먼저 자동차 이름에 관련된 예외들이 모두 상속하는 수퍼클래스를 만들었다. 12345public class EmptyCarNameException extends CarNameException &#123; public EmptyCarNameException() &#123; super(&quot;빈 문자열을 자동차 이름으로 입력할 수 없습니다.&quot;); &#125;&#125; 자동차 이름 예외를 상속받도록 하였고,이미 특정 도메인 상황을 예외로 만들고 싶어서 사용자 정의 예외를 만들었기 때문에, 굳이 매번 에러메시지를 입력받아 생성할 필요가 없다고 생각했다.그래서 예외 클래스에 정해진 에러 메시지로 초기화하도록 만들었다. 실제 코드에 적용시켜보기123456789101112131415161718192021222324252627282930313233343536373839404142public class CarName &#123; private static int MAX_CAR_NAME_LENGTH = 5; private static String EMPTY_STRING = &quot;&quot;; private final String carName; public CarName(String carName) &#123; checkCarName(carName); this.carName = carName; &#125; private static void checkCarName(String input) &#123; checkCarNameNotNull(input); checkCarNameLength(input); checkCarNameExists(input); checkCarNameIsNotSpace(input); &#125; private static void checkCarNameNotNull(String carName) &#123; if (carName == null) &#123; throw new CarNameNullPointerException(); &#125; &#125; private static void checkCarNameLength(String carName) &#123; if (carName.length() &gt; MAX_CAR_NAME_LENGTH) &#123; throw new CarNameLengthOverException(carName.length()); &#125; &#125; private static void checkCarNameExists(String carName) &#123; if (carName.equals(EMPTY_STRING)) &#123; throw new CarNameNotExistsException(); &#125; &#125; private static void checkCarNameIsNotSpace(String carName) &#123; if (carName.trim().equals(EMPTY_STRING)) &#123; throw new CarNameSpaceException(); &#125; &#125;&#125; 이제 도메인에서 우리가 만든 사용자 예외를 검증해보자.도메인 객체가 만들어지기 전에 예외를 모두 검증한다. 테스트해보기1234567891011121314151617181920public class CarNameTest &#123; private static Stream&lt;Arguments&gt; provideCarNameAndExceptionMessage() &#123; return Stream.of( Arguments.of(null, &quot;자동차 이름을 찾을 수 없습니다!&quot;), Arguments.of(&quot;다섯글자이상&quot;, &quot;자동차 이름은 5자 이하여야 합니다.&quot;), Arguments.of(&quot;&quot;, &quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;) ); &#125; @ParameterizedTest @MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;) public void 자동차_이릅_예외_테스트(String carName, String message) &#123; assertThatThrownBy(() -&gt; new CarName(carName)) .isInstanceOf(CarNameException.class) .hasMessageContaining(message); &#125;&#125; 다양한 예외 상황마다 예외 객체와 예외 메시지를 통해 테스트를 할 수 있다! 사용자 예외의 장단점장점 클래스의 이름으로 어떤 예외인지 가늠가능하다. CarNameEmtpyException이면 어떤 상황인지 바로 이해가능하다! 상세한 예외 정보를 제공할 수 있다. 자동차의 이름 길이가 5를 넘기면 예외를 발생시키고자 한다. 이때 사용자가 입력한 이름의 길이도 함께 알려주고 싶다면? 12345public class CarNameLengthOverException extends CarNameException &#123; public CarNameLengthOverException(int length) &#123; super(&quot;자동차 이름은 5자 이하여야 합니다. 입력된 글자 수 : &quot; + length); &#125;&#125; 예외 핸들링이 용이하다. 해당 예외 상황에 관련된 정보를 한 곳에 관리 가능하다. 단점 새로운 클래스를 작성해줘야 된다. 굳이 이미 있는 예외 클래스로도 처리 가능한데, 굳이 새로운 클래스를 작성해야 될 지 고민해야한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"자바 일급 컬렉션 활용해보기","slug":"java/woowa-tech-course/java-first-collection","date":"2022-02-16T12:10:39.000Z","updated":"2022-02-24T14:17:03.142Z","comments":true,"path":"2022/02/16/java/woowa-tech-course/java-first-collection/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/16/java/woowa-tech-course/java-first-collection/","excerpt":"","text":"요약 일급 컬렉션은 컬렉션 객체를 감싸는 객체를 말한다.일급 컬렉션은 객체를 만들 때 검증해야 할 로직을 모아 둘 수 있다.일급 컬렉션은 해당 컬렉션이 행해야 할 책임을 모아 둘 수 있다. 불변성을 지키기 위해서는 setter 금지. 일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당 getter 할 때 불변 객체 반환. 일급 컬렉션이란일급 컬렉션은 컬렉션 객체를 감싸는 객체다.일급 컬렉션은 멤버 변수로 감싸고자 하는 컬렉션만 갖는다. 12345678public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; //이하 생략... &#125; 일급 컬렉션의 강점1. 일급 컬렉션은 해당 컬렉션의 검증 로직을 한 곳에 모을 수 있다.예를 들어 자동차 경주에 참가할 자동차 리스트를 관리한다고 가정하자.이때 참가할 자동차들의 이름은 중복되면 안된다. 일급 컬렉션을 활용하면 참가할 자동차를 생성할 때 다음 같이 검증할 수 있다. 12345678910111213141516171819202122public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; private static void checkCarNameDuplicated(List&lt;String&gt; carNames) &#123; long count = carNames.stream().distinct().count(); if (count != carNames.size()) &#123; throw new CarNameDuplicationException(); &#125; &#125; //이하 생략...&#125; 이렇게 일급 컬렉션 객체의 생성자에 검증 로직을 넣어두면 참여중인 자동차 객체는 반드시 중복되지 않은 이름들을 가진다고 확신할 수 있다. 일급 컬렉션을 사용하지 않는다면 이런 검증 로직은 서비스 메서드로 처리하게 된다.그러면 매번 참여중 인 자동차를 만들 때 마다 서비스 메서드를 호출해줘야 되는 번거로움이 생긴다. 2. 상태와 행동을 한 곳에서 관리 할 수 있다.참여한 자동차들은 모두 레이싱을 시도하는 역할을 할 수 있다. 다음 같이 일급 컬렉션에 행동을 추가해서 관리할 수 있다. 12345678910111213141516171819202122public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; //생략... public void executeCarRacing(RandomNumberGenerator randomNumberGenerator) &#123; for (Car car : cars) &#123; car.tryToMoveBy(randomNumberGenerator); &#125; &#125;&#125; 일급 컬렉션을 통해 이 객체가 어떤 행동을 하는지도 한눈에 볼 수 있게됐다. 일급 컬렉션과 불변성일급 컬렉션이 불변하다는 특징을 가졌다고 알려졌는데, 사실 그렇지 않을 수 있다는 포스트도 있다. 관련 포스트 불변성을 지키고 싶다면 다음 세가지를 지켜주자 setter를 사용하지 않는다. 일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당하자. getter를 할 때 불변한 콜렉션으로 반환하자. 1234567891011121314151617public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); // &lt;- 새로운 주소가 할당된다. for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; public List&lt;Car&gt; getCars() &#123; return Collections.unmodifiableList(this.cars); //&lt;- getter할 때 불변된 리스트가 반환된다. &#125;&#125; 여전히 궁금한 것들 왜 일급 컬렉션은","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"구글 자바 컨벤션 및 우테코 컨벤션에서 자주 틀리는 내용 모음!","slug":"java/woowa-tech-course/java-convention","date":"2022-02-15T14:42:53.000Z","updated":"2022-02-24T14:16:52.630Z","comments":true,"path":"2022/02/15/java/woowa-tech-course/java-convention/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/15/java/woowa-tech-course/java-convention/","excerpt":"","text":"요약 static import를 하지 않는다.구현 순서는 상수 -&gt; 클래스 변수 -&gt; 인스턴스 변수 -&gt; 생성자 -&gt; 메서드 순이다.변수 이름에 자료형을 사용하지 말라인스턴스 변수의 수를 최소화 한다.오버로드한 메서드(생성자)들 사이에 다른 코드를 넣지말라.비할당 연산자에서 줄바꿈하는 경우, 기호 앞에서 끊어짐(. :: &lt;&amp;&gt; 등…)할당 연산자에서 줄바꿈하는 경우 기호 뒤에서 끊어짐(사실 어느쪽도 허용) static import 하지 않는다12345678910//안좋은 예시import static somepackage.SomeClass.doMethod;import otherpackage.OtherClass;public class Application &#123; public static void main(String[] args) &#123; doMethod(); OtherClass otherClass = new OtherClass(); otherClass.doMethod(); &#125;&#125; doMethod가 메서드가 두개다. 그래서 혼동이 온다. 구현 순서는 상수 -&gt; 클래스 변수 -&gt; 인스턴스 변수 -&gt; 생성자 -&gt; 메서드 순12345678910111213141516public class SomeClass &#123; private static final int CONSTANT_INT = 1; public static int classVariable = 2; private int instanceVariable = 3; public SomeClass() &#123; &#125; public static void doMethod() &#123; &#125;&#125; 변수 이름에 자료형을 사용하지 말라123//이런 변수이름들은 곤란하다.String carString = &quot;blah&quot;;List&lt;Integer&gt; intList; 인스턴스 변수의 수를 최소화 한다.오버로드한 메서드(생성자)들 사이에 다른 코드를 넣지말라.비할당 연산자에서 줄바꿈하는 경우, 기호 앞에서 끊어짐(. :: &lt;&amp;&gt; 등…)할당 연산자에서 줄바꿈하는 경우 기호 뒤에서 끊어짐(사실 어느쪽도 허용)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"자바에서 정규 표현식 잘 활용하기","slug":"java/woowa-tech-course/java-regex","date":"2022-02-09T14:45:29.000Z","updated":"2022-02-24T14:17:07.974Z","comments":true,"path":"2022/02/09/java/woowa-tech-course/java-regex/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/09/java/woowa-tech-course/java-regex/","excerpt":"","text":"요약 Pattern 클래스와 Matcher 클래스를 활용해서 자바 정규 표현식을 잘 표현한다. 특히 Matcher클래스에 정규 표현식을 compile(String)하고, matcher(String)으로 대상 문자열을 전달해준다.이때 find()메서드를 반드시 실행해줘야 정상적으로 Matcher 객체에 관련 내용이 할당된다!! Pattern 클래스로 정규 표현식 통과 여부 확인하기주어진 문자열이 input이고, 정규식이 REGEX라는 변수에 할당됐을 때,Pattern 클래스로 여부를 확인할 수 있다. 123private static boolean isMatches(String input) &#123; return Pattern.matches(REGEX, input);&#125; Matcher 클래스로 정규 표현식에 해당하는 문자열 부분 가져오기Pattern 클래스로 정규 표현식을 compile 메서드로 넘겨주고, 검사할 문자열을 matcher 메서드로 전달해주면 해당 문자열에 대한 Matcher 객체를 생성할 수 있다.이때 중요한 건! 해당 객체의 find 함수를 실행해야 group 메서드로 입력된 문자열 중 정규 표현식에 해당하는 부분을 가져올 수 있다. 12345private static String findRegexPart(String input) &#123; Matcher matcher = Pattern.compile(REGEX).matcher(input); matcher.find(); return matcher.group();&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"JPA에서 @Embedded로 복합키 매핑하기","slug":"spring/JPA/compositekey","date":"2022-02-03T08:11:16.000Z","updated":"2022-02-03T14:19:35.624Z","comments":true,"path":"2022/02/03/spring/JPA/compositekey/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/03/spring/JPA/compositekey/","excerpt":"","text":"요약 @Embeddable를 붙인 복합키 클래스를 만든다 엔티티 클래스에 @EmbeddedId를 통해 복합키 필드를 만든다. 이때 엔티티 클래스의 모든 매개변수를 받는 생성자를 만든다.이때 복합키 필드는 new로 객체를 초기화해준다. 문제 상황챌린지 테이블과 태그 테이블이 다대다 관계인 상황이다.이때 태그 테이블은 이름이 기본키이고, 챌린지 테이블은 챌린지 ID가 기본키로 가진다. 우리는 챌린지 테이블과 태그 테이블 사이에 매핑 테이블을 도입해서 다대일 관계 두 개로 분리해서 사용하기로 했다.챌린지 -(일대다)- 매핑 테이블 -(다대일)- 태그 이때 매핑 테이블은 기본키로 태그의 이름과 챌린지의 챌린지아이디를 가진다.(즉 복합키이다.)이를 어떻게 JPA로 표현할까? 관련 코드 해결방법 @EmbeddedId를 도입해서 복합키를 모은 클래스를 따로 만들어서 해결한다. ChallengeTag(매핑 테이블)12345678910111213141516171819202122232425@Builder@NoArgsConstructor@Setter@Getter@Entitypublic class ChallengeTag &#123; @EmbeddedId private ChallengeTagPK challengeTagPK; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;challenge_id&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT)) @MapsId(&quot;challengeId&quot;) private Challenge challenge; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;name&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT)) @MapsId(&quot;name&quot;) private Tag tag; public ChallengeTag(ChallengeTagPK challengeTagPK, Challenge challenge, Tag tag) &#123; this.challengeTagPK = new ChallengeTagPK(); this.challenge = challenge; this.tag = tag; &#125;&#125; ChallengeTagPK라는 필드를 만들어서 @EmbeddedId를 붙여줬다. 이러면 기본키를 복합키를 필드로 가지는 객체로 설정 할 수 있다. 이때 주의할 점 몇가지 알아보자. 1. 복합키에 따른 객체를 선언해줘야 한다. challengeId와 name을 복합키로 가지므로, Challenge 객체와 Tag 객체를 멤버로 가져야 한다. 각 객체는 @MapsId(“필드명”)으로 연결해줘야 한다. (괄호 안 이름은 ChallengeTagPK의 필드명이다.) 2. 모든 필드를 매개변수로 받는 생성자를 선언해야 한다. 이때 기본키를 담당하는 객체는 new로 초기화 한다! @AllArgsConstructor로 하지 않는다. ChallengeTagPK(기본키 클래스)12345678910111213@EqualsAndHashCode@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Embeddablepublic class ChallengeTagPK implements Serializable &#123; private Long challengeId; private String name;&#125; @Embeddable을 붙이면 복합키를 표현하는 클래스이다. 몇 가지 중요한 점을 살펴보자. 1. Setter 메서드를 선언해줘야 한다. 나중에 이 클래스의 필드를 challenge와 tag의 기본키를 가져와 초기화한다. 2. Serializable을 구현해야 한다. Serializable은 직렬화가 가능하다는 의미이다. 자바 객체를 외부 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는게 직렬화이다.(자바 객체를 바이트로 만들면 다른 자바 시스템에서 Reader로 읽어들일 수 있다.) 3. equals와 hashcode를 오버라이딩 해줘야 한다. 기본키는 식별할 수 있도록 해주는 역할이다. @Embeddable이 붙은 객체는 각 객체들과 구분되는 기준이 명확해야 한다.이 기준을 equals와 hashcode를 오버라이딩해서 해결한다. 롬복으로 @EqualsAndHashCode 를 붙여주면 쉽게 해결 가능하다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"JPA","slug":"spring/jpa","permalink":"https://yangdongjue5510.github.io/categories/spring/jpa/"}],"tags":[{"name":"sable project","slug":"sable-project","permalink":"https://yangdongjue5510.github.io/tags/sable-project/"}]},{"title":"데이터베이스 설계 프로세스","slug":"cs/database/powerofdatabase01","date":"2022-01-06T13:35:42.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2022/01/06/cs/database/powerofdatabase01/","link":"","permalink":"https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/","excerpt":"","text":"요약 데이터베이스 설계 과정을 배운다. 실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다. 임무 목표와 임무 명세 정의임무 명세 : 이 데이터베이스의 존재 이유나 목적을 단순한 한 문장으로 정리 임무 목표 : 이 데이터베이스가 수행해야 할 작업을 정리. 이렇게 작성된 목표와 임무 명세는 사용자와 관리자에게 타당해야 한다.각 임무 목표는 하나의 작업을 너무 디테일하지 않을 정도로 기술한다. 예시 임무 명세 : 함께 모으기 데이터베이스는 Sable의 함께모으기(저축 챌린지)에 필요한 데이터를 관리한다. 임무 1. 챌린지의 정보를 완전히 관리한다.임무 2. 사용자의 정보를 완전히 관리한다.임무 3. 챌린지마다 사용자가 작성한 리뷰를 관리한다.임무 4. 사용자의 계좌를 관리한다.임무 5. 챌린지의 계좌를 관리한다. 기존 데이터베이스 분석해당 데이터베이스의 사용자와 관리자의 요구사항을 인터뷰. 기존의 데이터베이스 분석. 인터뷰를 통해 대상과 사건을 특정할 수 있다.(사용자는 챌린지에 참여해서 규칙에 따라 저축 을 한다.)여기서 대상은 사용자, 챌린지, 규칙, 저축이다. 대상을 정리했으면, 각 대상에 대한 특징을 찾아낼 수 있다. 이 과정에서 예상되는 필드를 구성할 수 있다. 어떤 대상이, 어떤 특징을 가지는 지 분석 특정 대상의 특징을 설명하는게 필드다. 값 목록(특별한 값의 집합을 나타내는 특성)은 따로 표시한다. 계산된 필드는 따로 정리한다. 중복된 특성은 하나의 필드로 정리한다.(혹은 여러개로 나눠야 할 특성은 분해한다.) 예시 일단 우리 서비스에 요구사항을 정리해본다.사용자는 이름, 이메일, 생년월일, 닉네임, 성별, 비밀번호, 하나의 사용자 계좌와 여러 개의 챌린지 계좌를 가진다.챌린지는 챌린지 호스트, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표 금액, 챌린지 성공한 사람들의 리뷰를 가진다.챌린지는 챌린지 모드와 자유 모드가 있다.챌린지 모드는 패널티 금액을 가진다.자유 모드는 패널티 금액이 없다.챌린지는 정해진 시간 전에 모집을 시작해서 시작일이 되면 모집을 마감한다.사용자는 각 챌린지에서 자신이 원할 때 원하는 금액을 사용자 계좌에서 빼서 챌린지 계좌에 저축할 수 있다.각 챌린지 계좌에 사용자가 저금한 내용은 저장된다.…. 이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)사용자, 챌린지, 호스트, 리뷰, 사용자 계좌, 챌린지 계좌 이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.) 특징(필드) : 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표금액, 챌린지 패널티 금액, 챌린지 공식 여부, 챌린지 모드 값 목록 필드 : 사용자가 가지는 챌린지 계좌들, 챌린지에 참여한 사용자들, 사용자가 한 챌린지에 저금한 내용들, 사용자가 참여한 챌린지들, 사용자가 만든 챌린지들 계산된 필드 : 사용자의 미션 달성율, 사용자의 챌린지 예금 합, 사용자의 챌린지 저축액 / 챌린지 목표 금액, 챌린지의 참여 사용자 합 데이터 구조 생성 예비 필드 목록이 존재하면 이를 기반으로 대상에 할당해본다.(대상을 잘 설명하는 것 같은 필드를 할당) 예비 필드 목록을 검토하는 중 새로운 대상이 필요하면 추가한다. 앞 단계들을 통해 표현할 다양한 대상를 선정하여 테이블들에 할당한다.(처음 테이블을 만들면 모든 테이블은 데이터 테이블이 된다.) 데이터 테이블 : 조직에 중요한 주제를 나타냄 연결 테이블 : 다대다 관계의 두테이블의 연결 설정 부분 집합 테이블 : 특정 데이터 테이블과 관계. 특정 주제를 구체적으로 설명.부분 집합 테이블은 데이터들이 해당 필드를 모두 사용하지 않은 경우가 많은 경우를 말한다.(재고 테이블은 책 테이블과 장비 테이블을 하위 테이블로 만들 수 있다. (이는 서로 1대1 관계를 가진다.)) 검증 테이블 : 데이터 무결성을 제공하는 중요한 테이블 각 테이블의 필드들 할당하고 검토 좋은 필드의 조건을 따르는지 확인 필드들이 단독 값을 저장. 다중 구조나 다중값 필드는 개선 부분 집합 테이블을 구성한다. 각 테이블 키 설정 각 키는 데이터베이스에서 유일하게 식별할 수 있는 값이어야 한다.(부분 집합 테이블을 제외하면 동일한 기본키를 가지면 안된다.) 만약 마땅한 키가 없는 경우, 인위적인 키를 만들어줄 수 있다. 데이터베이스 각 필드의 필드 명세 설정 일반적 요소 : 필드 이름, 소속 테이블 등… 물리적 요소 : 데이터 타입, 길이, 문자 지원 등.. 논리적 요소 : 키 종류, 유일성, 널 지원, 기본값 등.. 좋은 필드의 조건 테이블의 대상의 특성을 잘 설명하는 필드가 되도록 한다. 필드는 단 하나의 값을 포함한다 더 작은 구성요소로 해체 될 수 없다. 계산되거나 연결된 값은 포함하지 않는다. 전체 데이터베이스에서 해당 필드는 유일하다.(연결되는 필드 외에..) 다중 부분 필드는 여러 필드로 나눠준다. (이름 -&gt; 성 , 이름) 다중값 필드는 새로운 테이블로 분리해서 사용한다. 예시 예비 필드 목록을 대상에 할당사용자 - 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부 챌린지 - 챌린지 식별아이디, 챌린지 이름, 시작일, 종료일, 내용, 주기, 목표금액, 패널티 금액, 챌린지 공식여부, 챌린지 모드, 챌린지 유효 여부 사용자 계좌 - 계좌 소유자, 계좌 잔고 챌린지 계좌 - 계좌 소유자, 계좌 잔고, 소속 챌린지 아이디 리뷰 - 리뷰 작성자 이메일, 리뷰 내용, 리뷰 작성 날짜, 리뷰의 챌린지 아이디 값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다챌린지의 태그는 따로 일대다 관계를 가지는 태그 테이블로 따로 빼서 만들고, 계좌 - 사용자 입출금 계좌 &amp; 챌린지 계좌 구조는 종속되는 주제인 사용자 계좌와 챌린지 계좌를 따로 부분집합 테이블로 만든다. 테이블 관계 연결 및 결정테이블은 1대1, 1대다, 다대다 관계가 있다.다만 다대다 관계는 주의해야 한다. 다대다 관계의 문제다대다 관계로 외래키를 도입하면 그 외래키가 중복 데이터가 많이 발생한다.그리고 만약 하나만 관계를 맺는 튜플을 삭제하면, 그 관계를 맺는 다른 테이블의 해당 튜플이 삭제될 수 있다. 학생과 수업 테이블이 다대다이고 서로 id을 외래키로 연결한다고 하면,학생 테이블의 수업id가 중복되는 데이터가 많아진다.한 학생만 듣는 수업이 있다고 했을 때, 그 학생을 삭제하면 그 수업이 삭제될 수 있다. 테이블 관계와 관계의 특징을 확인 기본 키나 연결 테이블을 통해 각 관계에 있는 테이블 간의 논리적인 연결 설정. 각 테이블에 대한 참여의 유형과 정도를 결정 업무 규칙 정의 및 결정 데이터베이스의 다양한 측면에서 제약사항 확인 업무 규칙 설정 검증 테이블을 정의, 구현 뷰의 정의 및 결정 데이터로 작업하는 다양한 방법을 확인 (상세 정보 조회, 요약 조회 등..) 적당한 테이블과 필드를 활용해서 뷰를 정의(뷰의 표준을 정할 수 있음.) 데이터 무결성 재확인 설계된 테이블이 잘 설계된 테이블인지 확인 필드가 적절한 구조인지 확인 테이블 수준 무결성 확인 필드 명세 점검, 무결성 점검 관계 유효성 점검, 각 테이블 참여 특징 명확히 결정. 데이터베이스의 다양한 측면에 있는 제약사항 결정","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[]},{"title":"우아한테크코스 4기 최종 코딩테스트 후기","slug":"java/woowa-tech-course/utecoprecourse4","date":"2021-12-19T12:39:13.000Z","updated":"2022-02-24T14:17:55.860Z","comments":true,"path":"2021/12/19/java/woowa-tech-course/utecoprecourse4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/19/java/woowa-tech-course/utecoprecourse4/","excerpt":"","text":"최종 코딩테스트 문제 링크https://github.com/woowacourse/java-pairmatching-precourse 아쉬운 점검증 로직 중복과정, 레벨, 미션을 입력받을 때, 해당 과정, 레벨, 미션이 존재하는지 검증해야 된다.나는 이를 검사하는 메서드를 각 열거형 객체가 가지고 있도록 하고 findByName메서드로 이름에 맞는 객체를 가져오도록 했다. 과정을 예를 들면 다음과 같다. 123456789101112131415161718192021public enum Course &#123; BACKEND(&quot;백엔드&quot;), FRONTEND(&quot;프론트엔드&quot;); private String name; Course(String name) &#123; this.name = name; &#125; public static Course findByName(String input) &#123; exceptionNotContain(input); return Arrays.stream(Course.values()).filter(course -&gt; course.name.equals(input)).findFirst().get(); &#125; private static void exceptionNotContain(String input) &#123; if (!Arrays.stream(Course.values()).anyMatch(course -&gt; course.name.equals(input))) &#123; throw new IllegalArgumentException(NO_EXIST_COURSE); &#125; &#125;&#125; 여기서 exceptionNotContain(String input)이 입력값이 존재하는 지 검증하고 예외를 출력한다.만약 외부에서 과정 객체를 가져오고 싶다면, findByName(String input)을 호출하면 된다.없는 경우는 예외를 일으키고, 있는 경우 해당 객체를 반환할 것이다. 1234567891011121314151617181920public class MatchingInformation &#123; private Course course; private Level level; private Mission mission; private MatchingInformation(Course course, Level level, Mission mission) &#123; this.course = course; this.level = level; this.mission = mission; &#125; public static MatchingInformation of(String line) &#123; List&lt;String&gt; information = split(line); Course course = Course.findByName(information.get(COURSE_INDEX)); Level level = Level.findByName(information.get(LEVEL_INDEX)); Mission mission = Mission.findByName(information.get(MISSION_INDEX)); return new MatchingInformation(course, level, mission); &#125; ...&#125; 매칭 정보 일급컬렉션을 생성할 때, 입력받은 이름을 토대로 findByName메서드를 호출하는 것을 볼 수 있다. 문제는 과정, 레벨, 미션 이 세가지 열거형 모두 이 메서드를 가지고 있는데, 모두 중복되는 코드로 작성했다.인터페이스를 도입하자니 검증 메서드가 static이라서 힘들었다. 과정, 레벨 출력과정, 레벨, 미션을 도입하기 전에 항상 과정, 레벨, 미션을 출력해야 한다. 나는 마음이 급해서 그냥 바로 문자열로 만들어서 매번 출력하도록 처리했다.근데 다른 PR을 보니, 과정, 레벨, 미션을 저장하고, 저장된 정보를 토대로 출력하는 사람들이 많았다.(대단..) 묻지 말고 시키기객체가 가진 데이터를 가져오지 말고, 객체에게 책임을 전달해야 되는데, 기능 구현에 급급하다보니, getter 메서드로 객체에게 묻는 로직이 상당히 많았다.프리코스에서 가장 인상깊게 생각한 피드백이고, 지키기 위해서 노력했는데 막상 시험에서 지키지 못하니 아쉽다. 구현하지 못한 기능페어를 만들 수 없는 상황을 예외 처리해줘야 했는데, 시험을 풀 당시 페어를 만들 수 없는 상황이 뭔지 몰라서 구현을 못했다… 알고보니 크루가 2명보다 적으면 페어를 못만드는 상황이 생긴다는 것……생각해보니 쉬운 로직인데 너무 긴장해서 구현하지 못한 거 같다. 시간이 부족하기도 했고. 후기돌이켜보면 믿기지 않는 한달이었다.설마 되겠냐는 생각으로 서류 지원했는데 덜컥 붙어서 정신없이 프리코스를 진행한 것 같다.다른 지원자들의 PR을 보니 내가 우물 속 개구리 인걸 깨달았다. 3주 동안 정말 많은 걸 배웠다.의식있는 노력을 통해 익숙함을 벗어나서 더 좋은 코드를 추구하는 마음가짐을 배웠다.평소 잘 모르는 걸 알면서 방치했던 git 사용법도 이번 기회로 정리해서 배웠다.하드코딩을 제거해서 다른 사람들이 봐도 이해할 수 있는 코드를 작성할 수 있음을 배웠다.한 메서드가 한 역할을 수행하라는 원칙도 알고는 있었는데, 실천을 통해 더 자세히 체화했다.예외가 발생하는 상황을 처리해서 프로그램이 다시 입력할 수 있도록 하는 방법을 배웠다.객체지향 설계를 직접 실천해보고 객체 지향의 기본 개념들을 배웠다. 프리코스를 해보니, 우아한 테크코스에 가고 싶은 생각이 더 깊어졌다.혹시 내가 자격이 있을까 고민하는 개발 지망생들이 있다면, 꼭 지원해서 프리코스까지 체험해보길 적극 추천한다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"메시지와 인터페이스","slug":"java/object/object4","date":"2021-12-16T11:13:44.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/12/16/java/object/object4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/16/java/object/object4/","excerpt":"","text":"메시지, 인터페이스메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.메시지는 오퍼레이션 이름과 인자로 구성된다. receiver.message(argument); 이렇게 메시지를 구성할 수 있다. 메시지와 메서드그렇지만 메시지가 한 메서드를 가르키는 건 아니다.메서드는 메시지를 수신하는 객체, 인자에 따라 달라진다.메서드는 메시지를 수신했을 때 실행되는 함수를 의미한다. 이렇게 메시지와 메서드를 구분하면,메시지 전송자와 수신자가 느슨하게 결합된다.전송자는 그냥 내가 어떤 메시지를 보낼 지만 생각하면된다.수신자는 그냥 메시지에 따라 메서드를 실행하기만 하면된다. 전송자는 수신자가 어떻게 메시지를 처리하는 지 감춰지게 된다. 퍼블릭 인터페이스퍼블릭 인터페이스는 객체가 의사소통을 위해 공개하는 메시지의 집합이다.퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.(오퍼레이션은 어떤 행동에 대한 추상화된 것이라고 보자.) 시그니처는 오퍼레이션 이름과 파라미터 목록을 합친 것이다.시그니처에 구현을 더하면 메서드가 된다! 좋은 인터페이스를 위해서인터페이스는 최소한으로, 추상적이어야 한다. 이런 원칙을 지키기 위해서는 책임주도 설계가 하는게 좋다.메시지를 먼저 선택해서 협력에 상관없는 오퍼레이션을 제거할 수 있다.메시지가 객체를 선택하도록 해서 객체의 의도를 메시지에 표현 할 수 있다. 다음 규칙을 통해 좋은 인터페이스 규칙을 알아보자. 디미터 법칙 : 협력 경로를 제한하라낯선 객체와 협력하지 말고 이웃과 협력하라.객체가 특정 조건을 만족하는 대상에게 메시지를 전송하도록 제한. 한 객체는 다음 대상들에게 메시지를 전송하도록 제한하자. this 객체 메서드 매개변수 this의 속성 this의 속성인 컬렉션의 요소 메서드 내에서 생성된 지역 객체 이런 식의 코드는 디미터 법칙을 위반하는 예시다. 1234567public Reservation reserve(Screening screening) &#123; ... screening.getMovie.getDiscountConditions(); //위반!! screening.calculateFee(audienceCount); //준수!! ...&#125; 위반코드는 Movie 객체에게 메시지를 전달하고 있다.Movie 객체는 위 다섯가지에 속하지 않는다!!연쇄적으로 메시지를 전달하는 코드를 기차 충돌 코드라고 한다. 준수코드는 screening에게 메시지를 전달하므로 디미터 법칙을 준수했다. 하지만 디미터 법칙은 객체의 응집도가 낮아질 수 있다. 묻지 말고 시켜라메시지 전송자는 메시지 수신자의 상태를 기반으로 결정 내리고 수신자의 상태를 바꾸면 안된다!!!전송자가 수신자의 상태를 기반으로 결정하는 건 캡슐화 위반이다! 묻지 말고 시켜라는 객체의 상태와 행동이 서로 밀첩하도록 설계하게 한다. 의도를 드러내는 인터페이스인터페이스의 메서드는 어떻게가 아닌 무엇을 하는지 드러내도록 하라.무엇을 하는지 드러낸다는 것은, 그 인터페이스의 메서드가가 어떤 책임을 지는지를 표현하는 것이다.절대 내부 구현을 메서드의 이름으로 표현하지 않는다. 1234567public class PeriodCondition &#123; public boolean isSatisfiedByPeriod(Screening screening) &#123; ... &#125;&#125;public class SequenceCondition &#123; public boolean isSatisfiedBySequence(Screening screening) &#123; ... &#125;&#125; 위 코드는 상영 정보를 받아서 해당 할인 조건에 맞는 지 검증한다.그러나 위 코드의 메서드들은 클라이언트 입장에서 동일한 일을 한다. 그런데 이 두 메서드가 연관있음을 알 수 없다.또한 판단 기준이 약간 수정된다면 메서드 명을 변경해줘야 되는 일이 생긴다.(캡슐화가 안된다는 소리.) 다음 코드로 바꿔주는게 적절하다. 1234567891011public interface DiscountCondition &#123; boolean isSatisfiedBy(Screening screening);&#125;public class PeriodCondtion implements DiscountCondition &#123; public boolean isSatisfiedBy(Screening screening) &#123;...&#125;&#125;public class SequenceCondition implements DiscountCondition &#123; public boolean isSatisfiedBy(Screening screening) &#123;...&#125;&#125; 결론 객체에게 묻지 말고 시키되, 구현 방법이 아닌 클라이언트의 의도를 드러내는 메시지를 전달하자.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}]},{"title":"깃 사용법(브랜치 활용 등)","slug":"github-study","date":"2021-12-12T13:35:00.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/12/12/github-study/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/12/github-study/","excerpt":"","text":"git을 잘 다루기브랜치 생성, 브랜치 이동123456789101112131415깃 초기화git init최초 커밋하기git add .git commit -m &quot;first commit&quot;브랜치 생성하기git branch issue1브랜치 이동하기git checkout issue1브랜치 생성하고 이동하기git checkout -b issue2 브랜치 합치기1234다른 브랜치와 합치기(현재 위치에 다른 브랜치를 합침.)(빨리 감기 병합.)git merge issue1 브랜치 삭제하기1git branch -d issue2 브랜치 병합 시 충돌 해결issue1 브랜치에는 다음과 같이 text.txt가 커밋되어 있고. 12hellowhats up issue2 브랜치에는 다음과 같이 text.txt가 커밋 되어 있다고 하자. 1hello 안녕 이 상태에서 두 브랜치를 병합하려하면 문제가 생긴다. 12345현재 HEAD가 issue1에 있을 때를 가정.git merge issue2Auto-merging text.txtCONFLICT (content): Merge conflict in text.txtAutomatic merge failed; fix conflicts and then commit the result. 그리고 text.txt를 보면 다음과 같다. 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADhellowhats up!~~~=======hello 하이&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue2 이 충돌된 내용 ( &lt;&lt;&lt;… , ===… , &gt;&gt;&gt;…)을 잘 처리해주고 다시 커밋하면 된다.다음과 같이 수정하고 커밋해보자. 123hellowhats up!~~~hello 하이 rebase로 통합하기rebase는 다른 브랜치의 내용을 모두 받아들이고, 자신의 모든 커밋을 그 다음에 이어서 진행하도록 하는 명령이다. 이전에 했던 merge와 다르게 다른 브랜치를 합치면 원래의 커밋기록이 변경된다. 123456789101112131415161718192021아까 했던걸 취소한다.git reset --hard HEAD~rebase로 통합해보자.git rebase issue2당연히 문제가 생긴다. (충돌)First, rewinding head to replay your work on top of it...Applying: dkdkUsing index info to reconstruct a base tree...M text.txtFalling back to patching base and 3-way merge...Auto-merging text.txtCONFLICT (content): Merge conflict in text.txterror: Failed to merge in the changes.Patch failed at 0001 dkdkhint: Use &#x27;git am --show-current-patch&#x27; to see the failed patchResolve all conflicts manually, mark them as resolved with&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.You can instead skip this commit: run &quot;git rebase --skip&quot;.To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;. 이전 챕터에서 했던 것처럼 다시 수정해서 커밋하면 충돌을 해결할 수 있다. cherry-pick 다른 브랜치의 특정 커밋만 가져오기1git cherry-pick [commit 아이디] git add, commit 취소하기1234567891011121314add 취소하기.git reset HEAD [FILE이름]commit 취소하기.1. commit을 취소하고, 파일들이 staged된 상태로 취소(add된 상태)$ git reset --soft HEAD^2. commit을 취소하고, 파일들은 unstaged 상태로 워킹 디렉터리에 보존(디폴트 값.)$ git reset --mixed HEAD^$ git reset HEAD^ // 위와 동일$ git reset HEAD~2 // 마지막 2개의 commit을 취소3. commit을 취소하고, 파일들은 unstaged 상태로 워킹 디렉터리에서 삭제$ git reset --hard HEAD^ commit message 수정1git commit --amend fetchfetch는 원격 저장소의 최신 내용을 새로운 브랜치로 가져온다.이때 fetch의 브랜치는 이름없지만, FETCH_HEAD라는 이름으로 checkout할 수 있다. 1git fetch [리모트이름] [브랜치이름] git ~와 ^는 동일한 브랜치의 상위 커밋을 표현하고자 할 때 쓴다.HEAD1은 HEAD에서 같은 브랜치의 1개 전 커밋을 표현하다. ^는 브랜치로 분기 될 때 상위 커밋을 표현하고자 할 때 쓴다.HEAD^2는 HEAD에서 다른 브랜치의 상위 커밋을 표현한다.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://yangdongjue5510.github.io/tags/git/"}]},{"title":"우아한테크코스 4기 프리코스 3주차 회고","slug":"java/woowa-tech-course/utecoprecourse3","date":"2021-12-10T11:56:16.000Z","updated":"2022-02-24T14:17:41.318Z","comments":true,"path":"2021/12/10/java/woowa-tech-course/utecoprecourse3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/10/java/woowa-tech-course/utecoprecourse3/","excerpt":"","text":"우아한 테크코스 4기 프리코스 3주차 회고3주차 문제 및 내 답안 링크https://github.com/woowacourse/java-vendingmachine-precourse 마주한 문제들MVC 패턴 적용MVC 패턴은 Model, View, Controller를 기준으로 객체들을 분류해서 프로그램을 만드는 패턴이다.2주차 피드백에 비즈니스 로직에 출력 관련 로직을 같이 두지 말라는 피드백이 있었다.3주차에는 MVC 패턴을 도입해서 View 관련 로직을 분리하고자 했다. Model은 데이터를 저장하고, 일관성 있게 처리하는 역할,Controller는 사용자의 입력을 받고, view를 생성하거나 수정하고, model에 접근하여 데이터를 가져오는 역할,View는 사용자에게 보여지는 부분을 구현하는 역할. 컨트롤러 예시12345678910public class InputMoneyController &#123; public void inputMoneyControl() &#123; InputMoneyView.messageInputMoney(); inputMachineMoney(); &#125; private void inputMachineMoney() &#123; MoneyRepository.initializeMachineMoney(); &#125;&#125; 내 답안에 쓰인 컨트롤러 중 일부다.이 객체는 자판기에 돈을 입금해야 하는 상황을 책임진다.자판기는 사용자에게 돈을 입금하라는 메시지를 출력해줘야 한다. 출력은 InputMoneyView의 책임이다.InputMoneyView.messageInputMoney()는 입금할 때 필요한 메시지를 출력하라는 의미다. 뷰 예시12345public class InputMoneyView &#123; public static void messageInputMoney() &#123; System.out.println(MESSAGE_INPUT_MONEY); &#125;&#125; 뷰가 메시지를 받으면 적절한 메시지를 출력하게 된다. 모델 예시위 컨트롤러를 보면, MoneyRepository.initializeMachineMoney(); 코드가 보일 것이다.컨트롤러가 모델에게 메시지를 전달하고 있다.기계에 돈을 초기화해서 저장해달라는 메시지를 전달한다. 1234567public class MoneyRepository &#123; private static Money vendingMachineMoney; public static void initializeMachineMoney() &#123; vendingMachineMoney = new Money(); &#125;&#125; MoneyRepository는 내가 만든 코드에서 모델에 해당하는 객체다.자판기에 저장되는 돈을 관리하는 책임을 진다.initializeMachineMoney()를 통해 기계가 가진 돈을 초기화해서 저장할 수 있다. 일급 컬렉션 도입하기일급 컬렉션은, 컬렉션을 감싸는 클래스를 만들어서 사용하는 방법이다.\u0010다음과 같이 컬렉션을 그냥 쓰지 말고, 멤버 변수가 컬렉션 하나뿐인 일급 컬렉션을 도입하면 이익이 있다. 123456789public class MachineCoins &#123; private Map&lt;Coin, Integer&gt; machineCoins = new LinkedHashMap&lt;&gt;(); MachineCoins() &#123; initializeChangeCoins(); setMachineCoins(MoneyRepository.getMachineMoney()); &#125; ...&#125; 위 코드는 자판기 기계에 동전을 담당하는 객체다.이 객체가 생성되려면, initializeChangeCoins()와 setMachineCoins(MoneyRepository.getMachineMoney())를 실행한다. map에 각 동전과 그 갯수를 0개로 초기화하고,기계가 가진 돈만큼 동전을 만들어서 객체가 보관한다.즉 MachineCoins는 자판기 기계가 가진 돈만큼 동전으로 만들어서 Map에 저장하는 자료구조이다. 만약 MachineCoins라는 객체가 아닌 그냥 Map&lt;Coin, Integer&gt; 객체로 자판기의 동전을 관리하면 문제가 있다.위에서 얘기했듯이, 동전 갯수는 기계가 가진 돈만큼만 만들어야 한다. 일반 Map을 사용하면 해당 객체가 그런 조건을 달성했는지 알 수 없다.혹은 다른 사람이 코드를 봤을 때, 조건이 필요한지 알 수 없다. (그냥 Map일 뿐…) 이때 MachineCoins같이 일급 컬렉션을 사용하면 조건을 달성했음을 보장할 수 있다.그리고 조건을 검증하고, 상태와 행동을 한 클래스에서 확인 할 수 있어서 다른 사람이 파악하기도 편하다. 그리고 객체에 값을 수정하는 메소드를 만들지 않으면, 그 객체의 값을 불변으로 보장할 수 있기도 하다. 참고 https://jojoldu.tistory.com/412 맵 순회하는 방법 (Map Entry, Iterator)동전 정보를 Map에 저장했었는데, 동전을 출력하는 로직에서 Map을 순회해야 했었다. 그냥 for문을 쓰면 될 줄 알았는데, 잘 되지 않았다.다음은 내가 찾은 방법이다. 123456Map&lt;Coin, Integer&gt; map = new LinkedHashMap&lt;Coin, Integer&gt;();for (Map.Entry&lt;Coin, Integer&gt; entry : map.entrySet()) &#123; int key = entry.getKey(); int value = entry.getValue(); //map.remove(key); 이건 될까?&#125; 위 코드는 순회는 잘된다. map의 원소를 수정하면 concurrentmodificationexception가 발생한다.그럴 땐 iterator를 도입한다. 12345Iterator&lt;Coin&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) &#123; iterator.next(); iterator.remove();&#125; 이런 식으로 구현하면 순회와 동시에 삭제가 가능하다! 후기긴장감 속에 치뤄진 프리코스가 끝을 향하고 있다.사실 서류 통과가 될 지도 긴가민가했었는데, 어느새 프리코스를 마치고 최종 코딩테스트만 남기고 있다.프리코스를 하기 전에는 내가 자바를 해본 경험이 꽤 있어서 무난하게 프리코스를 통과하지 않을까 싶었는데 오산이었다. 매 미션마다 다른 분들이 제출한 PR을 보면 엄청난 고수들이 많았다.그럴 때마다 많은 좌절감을 느끼기도 했지만, 오히려 만약 이런 분들에게 피드백 받고 같이 공부하면정말 소중한 기회일 것이고, 그래서 더 프리코스 과제에 더 집중하고자 했다. 프리코스는 매 주마다 미션을 하나씩 주고, 미션을 구현할 때 지켜야할 규칙을 제시한다.정말 놀라운 건, 이 규칙들이 몇가지 안되는데, 이 규칙들을 지키기가 굉장히 까다롭다는 사실이다. 메서드 길이 15줄을 넘어가면 안되고, 메서드의 들여쓰기가 2를 넘으면 안된다.이 두가지만 지키려고 해봐도 굉장히 까다롭고, 코드가 완전히 새로워진다. 그리고 클래스에게 책임을 나눠주고 여러 클래스들이 협력하도록 설계하는 게 재밌었다.사실 스프링을 쓰다보면, 요구사항이 비슷한 경우가 많아서 설계도 비슷하게 반복되는 경우가 많았다.그래서 설계를 크게 고민하지 않았던 적이 많은데 이번 프리코스는 스스로 설계를 고민해야 되는 부분이 많아서 흥미로웠다. 코딩 실력을 향상시키기에는 3주는 짧다고 볼 수 있지만,프리코스를 하면서 정말 극적으로 코드 보는 시선이 넓어지고, 코드 짜는 좋은 습관도 생긴 것 같다. 프리코스의 모든 과정은 인터넷에 공개되어 있다.이번 프리코스를 하면서 왜 진작 이런 자료를 찾아서 공부하지 않았는지 생각이 날 정도로 정말 귀한 경험이었다. 우아한 테크 코스 지원 여부를 떠나서, 프리코스는 초보 자바 개발자라면 반드시 참고하길 바란다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"우아한테크코스 4기 프리코스 2주차 회고","slug":"java/woowa-tech-course/utecoprecourse2","date":"2021-12-04T15:40:27.000Z","updated":"2022-02-24T14:17:36.293Z","comments":true,"path":"2021/12/05/java/woowa-tech-course/utecoprecourse2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/05/java/woowa-tech-course/utecoprecourse2/","excerpt":"","text":"우아한 테크코스 4기 프리코스 2주차 회고2주차 문제 &amp; 내 제출 답안https://github.com/woowacourse/java-racingcar-precourse https://github.com/yangdongjue5510/java-racingcar-precourse 마주한 문제들책임을 클래스들에게 분배하기이번 문제는 메서드를 분리하는 것에 더해, 클래스를 분리해서 책임을 분배해야 한다는 미션을 받았다. 문제에는 Car 객체가 제시되어 활용하는 요구사항이 추가됐다. 일단 나눠주여 할 책임을 보면, 사용자에게 입력을 받는 책임 입력된 값을 검증하는 책임 \u0010자동차를 만드는 책임 자동차의 게임을 진행하는 책임 레이싱 결과를 분별하는 책임 결과를 출력하는 책임 이렇게 나눌 수 있었다. 나는 다음과 같이 클래스들에게 책임을 나눠줬다. 입력을 담당하는 InputManager 입력값 검증하는 ValidChecker 자동차를 만들어 게임을 진행하는 RacingPlayer 자동차의 운행 여부를 판단하여 운행하는 Car 자동차 위치에 따라 우승자를 찾는 RacingReferee 이렇게 역할을 나눠줬는데, 역할을 나눠주고 나니 각 객체의 인스턴스 변수를 다른 객체가 활용해야 하는 경우가 있었다. 패키지 분리 후 default 접근 지시자나는 이 문제를 해결하기 위해 도매인과 관련된 Car, RacingPlayer, RacingReferee는 같은 패키지로 분리해줬다. 그리고 getter 메서드를 default로 추가해 도매인 관련된 객체들만 해당 인스턴스 변수를 이용할 수 있게 했다. 예시로 RacingReferee는 우승자들을 분류해서 리스트로 가지고, 우승자의 이름을 출력하는 책임을 지고 있다.그런데 우승자(Car 객체)는 이름이 private로 되어 있다. 이럴 경우 default getter로 캡슐화를 최대한 준수하고자 했다. 1234567public class Car implements Comparable&lt;Car&gt; &#123; private final String name; ... String getName() &#123; //default 접근지시자를 활용했다. return this.name; &#125;&#125; 123456789101112public class RacingReferee &#123; private List&lt;Car&gt; winners; ... private void printWinners() &#123; StringBuilder builder = new StringBuilder(); ... for (int i = 0; i &lt; winners.size(); i++) &#123; //getName 메서드를 활용하고 있다. builder.append(winners.get(i).getName()).append(MESSAGE_COMMA_WITH_SPACE); &#125; ... &#125;&#125; 우승자 알아내기Car의 우승 여부를 알려면 각 Car의 위치를 알아야 한다. 그런데 나는 앞서 말했듯이 우승여부를 다른 객체(RacingReferee)가 한다고 했다.이미 Car 객체의 위치값은 private인데 어떻게 RacingReferee가 이를 계산해서 처리할 것인가? 가장 편한 대답은 아까처럼 default getter를 만드는 방법이다.하지만 검색을 좀 해봤더니 다른 방식을 알아냈다. 바로 Comparable로 정렬하기 이다. Car를 Comparable로 정렬 기준을 만들자. 1234567891011public class Car implements Comparable&lt;Car&gt; &#123; private final String name; private int position = 0; ... @Override public int compareTo(Car otherCar) &#123; return otherCar.position - this.position; &#125; ...&#125; 이렇게 해놓으면 외부에서 자동차 위치를 알지 못해도 compareTo로 자동차들의 위치를 비교한다! 123456789101112public class RacingReferee &#123; private List&lt;Car&gt; winners; ... private void findWinner(List&lt;Car&gt; participantCars) &#123; Collections.sort(participantCars); // Car winner = participantCars.get(WINNER_INDEX); this.winners = participantCars.stream() .filter(car -&gt; car.compareTo(winner) == COMPARE_WINNER_RESULT) .collect(Collectors.toList()); &#125; ...&#125; RacingReferee는 Car가 어떤 식으로 정렬하는지 알지 못해도 일단 Collections.sort() 하면 우승자 순으로 정렬된다는거만 안다. 나름 캡슐화를 지킨 방식이라서 재밌었다. 후기이번 주차는 비교적 수월하게 했다. 지난주에 설계를 못한다는 생각에 충격을 먹어서, 급하게 객체지향 관련 책을 찾아 본 게 큰 도움이 된거 같다. 지난 야구 게임을 구현할 때는 한 클래스가 거의 모든 데이터를 독점하고, 여러 일을 책임지고 있는 좋지 않은 설계로 구현했었다. 이번 문제는 강제로 Car 객체를 사용해야되서 자연스럽게 여러 객체들을 협력에 동참시켜야 했다.특히 이번엔 한 클래스가 데이터를 독점하지 못하도록 어떤 부분에 다른 클래스로 대체할 것인지 고민을 많이 했다.그 고민을 통해 등장시킨게 RacingReferee였다. 이 객체는 우승자를 가지고, 스스로 관리하게 설계했다는 점에서 만족스러웠다. 그리고 Comparator와 Comparable에 대해 공부할 수 있는 기회였다.최대한 캡슐화를 지키면서 우승 자동차를 구하는 방법을 찾다보니 평소에 잘 이해하지 못했던 개념을 제대로 이해할 수 있었다.이런 아이디어를 내가 직접 생각해낸게 아니라서, 만약 실제 코딩테스트 상황에서 이런 문제를 만나면 어찌해야 될 지 고민이 되긴한다. 하지만 아직 부족한 부분이 많다.대표적으로 README 작성. 살아있는 문서를 작성하라는데, 이게 좀 힘들다.의외라고 생각할 수 있는데, 나는 문제를 풀 때, 구현에 집중하다 보면, README는 안중에도 없게 된다.(…)그래서 이번엔 비교적 좀 더 신경을 썼는데, 아직 부족한 거 같기도 하다… 그리고 테스트 코드 작성도 많이 부족하다.나는 사실 이 문제를 여러번 풀어보고 제출한다.이번 주 문제인 레이싱 문제도 대충 3번정도 풀어보고 제출하는 거다.그래서 제출 코드에는 굳이 테스트 코드가 필요없다. 이미 많이 시도해본 코드들이기 때문이다. 근데 실전에서는 그럴 시간이 없다. 5시간안에 여러번 푼다는건 말도 안된다 ㅋㅋ.그래서 테스트 코드를 작성하는 법을 배워야 한다는 걸 느꼈다.JUnit와 TDD에 대해 공부하려고 한다. 아직 많이 부족하다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"13. Comparable과 Comparator의 차이!","slug":"java/java-basic/java13","date":"2021-12-03T01:29:20.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/12/03/java/java-basic/java13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/03/java/java-basic/java13/","excerpt":"","text":"Comparable과 Comparator의 차이결론둘 다 객체의 비교 기준을 마련하는 인터페이스. Comparable은 **compareTo(T t)**로 자기 자신과 다른 객체의 비교.Comparator은 compare(T t, T u) 자기 자신이 아닌 다른 두 객체 간의 비교. Comparable은 Arrays.sort()나 Collections.sort()를 했을 경우 비교 기준을 제공한다.Comparator는 새로운 비교기준이 필요할 때 익명 클래스로 활용 가능. 실험실험에 필요한 Student12345678910111213141516171819202122public class Student &#123; private int age; private int score; public Student(int age, int score) &#123; this.age = age; this.score = score; &#125; @Override public String toString() &#123; return &quot;age = &quot;+age+&quot; score = &quot;+score; &#125; public int getAge() &#123; return age; &#125; public int getScore() &#123; return score; &#125;&#125; 일단 정렬 실험에 사용될 객체를 만들어봤다. 이제 age나 score에 따라 다르게 구현해보자. Comparable와 Comparator를 클래스에 적용하기1234567public class Student implements Comparable&lt;Student&gt; &#123; ... @Override public int compareTo(Student o) &#123; return this.age - o.age; &#125;&#125; Comparable을 활용하려면 compareTo메서드를 구현해야 한다. 이 메서드는 자기 자신과 다른 객체를 비교한다. (return 값이 양수면 자기 자신 우선, 음수면 다른 객체 우선) 1234567public class Student implements Comparator&lt;Student&gt; &#123; ... @Override public int compare(Student o1, Student o2) &#123; return o1.age - o2.age; &#125;&#125; Comparator는 compare메서드를 구현해야 한다. 이 메서드는 서로 다른 객체 두개를 비교한다. 정렬 실험해보기문제는 Comparable을 구현한 경우와 Comparator를 구현한 경우가 정렬을 할 때 다르다는 점이다!! 1234567//implements Comparable&lt;Student&gt; 한 경우Arrays.sort(arr); //성공!Collections.sort(list); //성공!//implements Comparator&lt;Student&gt; 한 경우Arrays.sort(arr); //컴파일 에러!!Collections.sort(list); //컴파일 에러!! 실험해보니, Comparable을 구현했을 때만 정렬이 가능했다!!Comparator를 구현한 경우 Comparable이 구현되지 않았다며 컴파일 에러를 일으켰다! 그러면 Comparator는 왜 있는거에요?Student 클래스가 Comparable을 구현하고, 정렬을 age 기준으로 오름차순으로 정렬됐다고 하자. 근데 프로그래밍하다가 Student를 score 기준으로 오름차 정렬해야 되는 요구사항이 생겼다면?이미 age로 정렬하여 사용하고 있는 곳이 있으면, Comparable을 바꿀수도 없다. 그럴 때 익명클래스를 활용한 Comparator를 통해 해결한다. 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getScore() - o2.getScore(); &#125;&#125;);","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"REST Api 프로젝트에서 만난 소소한 문제들","slug":"spring/restproject1","date":"2021-12-02T02:44:58.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/12/02/spring/restproject1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/02/spring/restproject1/","excerpt":"","text":"Rest api 프로젝트를 하면서 배운 것들을 정리하고자 한다. JPA entity에서 배운 것들12345678910111213141516171819202122232425@Entity@Getter @Setterpublic class Investments &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(nullable = false) private Long investId; @Column(nullable = false) private Long userId; @ManyToOne //다대일 관계 @JoinColumn(name=&quot;id&quot;) private Products product; @Column(nullable = false) private Long investmentAmount; @Temporal(TemporalType.DATE) private Date investmentDate = new Date(); //기본값을 현재로?? @Enumerated(EnumType.STRING) private InvestmentStatus investmentStatus = InvestmentStatus.VALID; //기본값을 유효로 ?&#125; JPA와 디비에는 사용하고 싶지 않지만, VO 클래스 멤버 변수로 사용하고 싶은 변수는 @Transient를 붙인다. 이번 프로젝트에서는 h2 디비를 썼다. h2에서는 기본키 자동증가기능을 사용하려면 @GeneratedValue(strategy = GenerationType.IDENTITY) 를 써야 잘 작동했다. 칼럼의 NOT NULL은 @Column(nullable = false) 로 처리했다. (@NotNull은 안됐다.) @Temporal(TemporalType.DATE) 는 날짜시간 데이터 중 날짜 데이터를 저장한다는 의미다.시분초는 0으로 처리되어 저장된다. **@Enumerated(EnumType.STRING)**은 열거형 데이터를 저장할 때 쓰인다.이번 프로젝트는 열거형 이름 그 자체를 도입했다. 헤더 값 읽기1234@GetMapping(&quot;/product&quot;)public ResponseDto&lt;List&lt;Products&gt;&gt; productGet(@RequestHeader(&quot;X-USER-ID&quot;) long userId) &#123; ...&#125; @RequestHeader안에 헤더의 키값을 넣어주면 가져올 수 있다! SpringBoot Could not find acceptable representation(Error: Request failed with status code 406)12345678910@Getter @Setterpublic class ResponseDto&lt;T&gt; &#123; public ResponseDto(T data, HttpStatus status) &#123; this.status = status; this.data = data; &#125; HttpStatus status; T data;&#125; 406에러는 return된 객체에 setter getter가 없어서 일어났었다. stream으로 합구하기!1234List&lt;Long&gt; numbers = Arrays.asList(1L, 2L, 3L, 4L, 5L);// Stream의 reduce 이용Long sum1 = numbers.stream().reduce(0L, Long::sum); reduce를 이용하면 구할 수 있었다!! JSON으로 통신할 때 Object Mapper로 케이스 변환하기1234567@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)public class User &#123; private phoneNumber; //json에는 phone_number로 보임 @JsonProperty(&quot;user_name&quot;) //특정 변수에만 적용할 경우. private userName&#125; JSON을 반환할 때 ResponseEntity나는 커스텀해서 ResponseDto를 만들었는데 자바에서는 이미 ResponseEntity가 있더라 크흠… SQL INIT어플리케이션을 시작할 때 SQL을 실행해서 스키마를 만들고 데이터를 입력할 수 있다. 12345spring: sql: init: platform: h2 mode: always application.yml에 다음같이 적으면, 항상 어플리케이션을 시작할 때 SQL을 초기화해준다. Resources 폴더에 schema-플랫폼이름.sql , data-플랫폼이름.sql 을 실행한다. 위 예시는 플랫폼을 h2로 했으니, schema-h2.sql, data-h2.sql이라고 하면된다!! 이때 ddl-auto는 꺼줘여야 잘 작동하게 된다!! JPA Method이름으로 쿼리 만들기1234567891011121314public interface InvestmentsRepository extends JpaRepository&lt;Investments, Long&gt; &#123; default Investments updateInvestStatus(Investments invest, InvestmentStatus status) &#123; invest.setStatus(status); save(invest); return invest; &#125; List&lt;Investments&gt; findInvestmentsByIdAndStatusEquals(long productId, InvestmentStatus investmentStatus); List&lt;Investments&gt; findInvestmentsByUserId(long userId); Investments findInvestmentsByUserIdAndIdAndStatusEquals(long UserId, long productId, InvestmentStatus status);&#125; 레퍼지토리에 우리가 원하는 쿼리의 역할을 메서드 이름으로 만들면 그에 해당하는 쿼리를 실행하는 메서드가 만들어진다. 전역 예외 핸들러12345678@ControllerAdvice@RestControllerpublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) public ResponseDto&lt;String&gt; handleException(Exception e) &#123; return new ResponseDto&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); &#125;&#125; 예외 핸들러를 따로 만들면, 모든 예외 발생을 다음 메서드로 처리한다. 생성자 주입1234567891011@RestController@RequestMapping(&quot;/api&quot;)@RequiredArgsConstructorpublic class ApiController &#123; private final ProductsService productsService; private final InvestmentsService investmentsService; ...&#125; @Autowired 키워드를 쓰는 것보다 @RequiredArgsConstructor와 private final 키워드를 활용한 생성자 주입이 스프링에서 더 권장하는 방법이다. 나도 이 방법을 사용하기 전까지 순환 참조를 하고 있는 줄 모르고 있었는데, 생성자 주입으로 변경하는 과정에서 실수를 확인 할 수 있었다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[{"name":"reshapi project","slug":"reshapi-project","permalink":"https://yangdongjue5510.github.io/tags/reshapi-project/"},{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}]},{"title":"책임 할당을 위한 GRASP 패턴","slug":"java/object/object3","date":"2021-11-29T11:12:30.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/29/java/object/object3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/java/object/object3/","excerpt":"","text":"GRASP 패턴일반적인 책임 할당을 위한 소프트웨어 패턴. 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들. 영화 예매 시스템을 통해 GRASP 패턴을 익혀보자. 도메인 개념에서 출발하기어떤 책임을 할당해야 할 지 고민해야 될 때 가장 먼저 고려해야 할 게 도메인이다. 영화에는 금액 할인 영화, 비용 할인 영화가 있다. 할인 조건에는 순번 조건, 기간 조건이 있다. 하나의 영화는 여러번 상영될 수 있고,하나의 상영에는 여러 예매가 있을 수 있다. 그리고 한 영화에는 여러 할인 조건이 사용될 수 있다. ![](/Users/MUHN2-031/Documents/dev/ghblog/source/img/스크린샷 2021-11-29 오후 8.40.39.png) 도메인 설계는 완벽할 수 없다.다만 앞으로의 설계와 구현에 출발점일 뿐이다. 정보 전문가에게 책임을 할당하라(information expert pattern)애플리케이션이 제공해야 되는 기능을 애플리케이션의 책임으로 생각하라. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고, 메시지를 책임질 첫번째 객체를 선택하는 것으로 시작하자. 영화 예매시스템은 영화 예매를 책임져야한다. 이제 이 책임을 수행하는 메시지를 결정해야 한다.이때 메시지는 수신할 객체 중심이 아닌 발신한 객체의 의도를 반영해서 결정해야 한다. 메시지를 전송할 객체는 무엇을 원할까? 우리가 던져야 할 첫 질문이다.누구와 협력할지는 몰라도 그 객체가 협력에서 원하는 건 분명해보인다.영화 예매의 예시에선 영화를 예매하는 것을 원한다. 그렇다면 메시지는 예매하라가 된다. 메시지를 결정하고 나면 메시지에 적합한 객체를 선택해야 한다. 메시지를 수신할 적합한 객체는 누구인가? 이때 객체는 상태와 행동을 가진 캡슐화의 단위다.객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.(무지성 getter, setter는 안된다!) 객체는 자신의 책임과 책임에 필요한 상태를 가져야 한다.객체의 책임과 책임을 수행하는데 필요한 정보를 잘 아는 객체에게 책임을 할당한다.GRASP는 이 패턴을 정보 전문가 패턴이라고 한다. 이때 정보를 알고 있다는 건 데이터를 저장하고 있다는 의미와는 살짝 다르다.정보를 저장하지 않아도, 어떤 객체를 알고 있거나, 필요한 정보를 계산을 제공하는 방식 등 다양하다. 정보 전문가가 정보를 알고 있다는 것은 반드시 정보를 저장한다는 의미는 아니다! 영화 예매 시스템의 예시에서는 어떨까? 예매하라는 메시지를 잘 수행할 객체를 찾아보면 된다. 도메인 개념에서 아마 상영 객체가 잘 수행할 것 같다.왜냐면 예매하는 책임에는 상영 시간, 상영 순번, 상영 영화 등 정보가 필요한데, 이런 정보는 상영 객체가 가지는게 자연스럽다.따라서 영화 예매 정보 전문가는 상영이다. 정보 전문가가 메시지를 처리하는 흐름을 생각하라.메시지와 메시지를 처리할 객체를 정했다면 이제 그 정보 전문가가 내부에서 어떻게 책임을 다할지 생각해보자. 이 흐름은 외부로 공개되지 않으며, 개략적인 수준에서 책임에 필요한 작업을 생각해보고, 혼자서 못하는 작업인지 분별할 정도로 생각한다.혼자서 처리할 수 없는 작업은 또다시 외부로 보내는 메시지가 되고, 이 메시지에 맞는 정보 전문가를 찾는 과정을 반복한다. 영화 시스템의 예시에서는 상영 객체가 예매하라는 메시지를 처리할 때, 예매 가격을 처리하는 과정이 필요하다.그러나 상영 객체는 각 영화의 가격이나, 할인 정책을 알지 못한다. 그래서 외부의 도움이 필요하다. 이제 가격을 계산하라는 새로운 메시지가 생기고, 이 메시지를 책임질 새로운 객체를 선정하면 된다. 낮은 결합도를 추구해라(low coupling pattern)설계의 전체적인 결합도가 낮도록 책임을 할당하라. 위에서 만든 도메인 모델을 보면 연결되있는 개념들이 있다.영화 예매 시스템에서, 영화 객체와 영화 할인 기준 개념은 서로 연관있다. 반면 상영과 영화 할인 기준 개념은 연결되어 있지않다.만약 이 둘을 연결하려면, 새로운 결합도가 생기는 거고 추천하지 않는다. 차라리 이미 연관된 개념인 영화 객체와 영화 할인 기준 개념을 서로 연결하는게 맞다. 높은 응집도를 추구해라(high cohesion pattern)영화 예매 시스템에서 상영이 영화 할인과 결합되면 응집도가 낮아지는 문제가 생긴다. 상영은 이제 영화 할인 계산을 직접할 수 있지만,근데 만약에 영화 할인 관련 객체를 교환하는 경우를 생각해보자.그러면 상영 객체도 같이 변경되어야 하는 거다.(서로 다른 이유로 변경되는 책임을 지게된다.) 상영 정보가 바뀌면 할인 객체도 변경되어야 하고,할인 객체가 바뀌면 상영 객체도 변경되어야 한다. 이 둘은 그런 수고를 감수할 정도로 같이 결합해야할 객체인지 의심해보아야 한다.한 클래스는 한 가지의 변경사항만 책임지도록 하자.변경되는 이유가 여러가지면 이 클래스가 변경되는 시점도 제각각이고, 연관성도 떨어진다. 차라리 영화 객체와 할인 객체가 연결되는게 맞고, 상영은 영화 객체와만 결합하는게 낫다.그러면 상영은 할인 관련 책임은 신경을 전혀 쓰지 않아도 된다. 변경의 이유가 지나치게 많은 클래스의 징후 인스턴스 변수가 초기화되는 시점을 살펴보자 인스턴스 변수가 초기화 될 때 일부만 초기화되면 응집도가 낮다고 봐야한다. 그렇지 않다면 함께 초기화 되는 기준으로 코드를 분리하라. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보자 모든 메서드가 모든 변수를 사용하면 응집도가 높은 것. 일부 메서드들은 특정 변수만 사용하는 경우, 코드를 분리하라. 창조자에게 객체 생성 책임을 할당하라(creator pattern)객체를 생성할 책임을 어떤 객체에게 할당할 것인가? Creator pattern은 다음 조건을 가장 만족시키는 객체가 생성해야 한다고 주장한다.객체 A를 생성해야 한다면… A 객체를 포함하거나 참조하는 객체 A 객체를 기록하는 객체 A 객체를 긴밀하게 사용하는 객체 A 객체를 초기화 하는데 필요한 데이터를 가진 객체 즉 조건들을 보면, A객체와 결합되있는 객체를 찾고 있는 걸 알 수 있다.즉 이미 결합된 관계에서 객체를 만드는게 결합도를 낮추는데 도움이 된다. 인터페이스로 변화에 대응하라(polymorphism, protected variations)코드를 작성하다보면, 특정 객체 타입에 따라 다르게 반응해야 하는 경우가 있다. 예를 들면 할인 기준에 따라 할인 적용을 다르게 해야 하면 if, else if로 객체의 타입을 검사해서 할인을 적용해줘야 한다.하지만, 이때 기준이 추가되면, 매번 else if를 추가해줘야 된다. 그래서 인터페이스를 도입해서 원하는 기준으로 초기화해주면, 검사하지 않고 할인 적용 메시지를 보내주면 된다. 인터페이스를 도입해서 캡슐화하면, 구현 클래스들의 세세한 변경을 외부에서는 신경 안써도 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}]},{"title":"REDIRECT와 FORWARD의 차이!!","slug":"spring/boot/boot13","date":"2021-11-29T06:09:24.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/11/29/spring/boot/boot13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/spring/boot/boot13/","excerpt":"","text":"REDIRECT와 FORWARD의 차이REDIRECT리다이렉트는 “서버가 클라이언트에게 해당 URL로 다시 요청하라고 명령하는 것”이다. 클라이언트가 서버의 URL에 요청 (get이던 post던 상관없이) 서버의 컨트롤러가 해당 URL에 매핑된 메서드 실행 해당 메서드가 다른 URL로 리다이렉트 시킬 경우, 클라이언트는 그 URL로 GET 요청을 새로 실행! REDIRECT의 특징리다이렉트는 클라이언트에게 새로운 GET 요청을 하도록 명령하는 것이다. 따라서 새로운 요청이 만들어져서, 스프링의 모델 같은 값이 모두 초기화 된다!! 대신 GET 요청을 새롭게 실행한 것이라서 브라우저의 GET 요청한 URL로 달라지고,새로고침할 경우 GET 요청이 반복되서 실행되는 것이므로,반복된 POST를 방지 할 수 있다.(이건 포워드에서 더 잘 알아보자.) REDIRECT하는 컨트롤러 예시12345678910111213141516171819... @GetMapping(&quot;/redirect&quot;) public String getRedirect() &#123; return &quot;redirect:/result&quot;; &#125; @PostMapping(&quot;/redirect&quot;) public String postRedirect() &#123; list.add(++i); return &quot;redirect:/result&quot;; &#125; //리다이렉트하면 다음 메서드로 get요청이 간다 @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125;... FORWARD포워드는 “서버가 포워딩한 URL이 매핑된 메서드를 실행하고 그 결과값을 클라이언트에게 보여준다.” 즉 서버가 클라이언트에게 해당 URL을 GET 요청으로 다시 하라고 하는 것이 아닌,자기가 해당 URL 매핑된 메서드를 찾아서 실행한다!! 이때 중요한 건 처음 클라이언트가 보낸 요청 그대로 유지한다는 점이다.리다이렉트는 처음 클라이언트가 보낸 요청은 종료하고, 보내고 싶은 URL로 새로운 GET 요청을 통해 접근했지만,포워드는 처음 클라이언트가 보낸 요청을 끝내지 않고 서버가 보내고 싶은 URL로 처음 요청을 유지한 상태로 접근한다. FORWARD의 특징포워드는 새로운 요청을 생성하지 않는다.다만 다른 URL에 매핑된 메서드에 접근할 뿐이다. 그래서 POST요청이 온 상황에서 포워드하면,포워드한 URL로 POST method로 매핑된 메서드에 접근하려고 한다.즉 기존 요청의 HTTP method를 유지한 상황에서 접근한다. 기존의 요청이 보존된 상황이므로, 스프링의 모델 같은 값이 다른 URL로 포워딩되도 유지된다. 이때 중요한 건 클라이언트 요청 처리 과정에 포워드가 포함된다는 사실이다.(리다이렉트는 클라이언트의 처음 요청을 종료시키고 새로운 GET 요청을 만들었다. 즉 분리된다.)그래서 포워딩하고 나서도 클라이언트의 URL은 처음 요청했던 URL과 동일하다. 그 상태로 새로고침을 하면, 맨 처음 클라이언트의 요청을 다시 시작하는 것이다.즉 POST를 클라이언트가 요청하고, 서버가 view 관련 URL로 포워딩 시킨다고 했을 때, 클라이언트는 view를 볼 수 있지만, URL은 클라이언트가 POST 요청하던 그대로이다.이 상태에서 새로고침을 하면 다시 클라이언트의 POST 요청 -&gt; 서버가 veiw 관련 URL 포워딩 과정을 다시하게 된다. 즉 POST를 반복해서 하게 된다!!!! FORWARD하는 컨트롤러 예시12345678910111213141516171819202122232425... @GetMapping(&quot;/forward&quot;) public String getForward() &#123; return &quot;forward:/result&quot;; &#125; @PostMapping(&quot;/forward&quot;) public String postForward() &#123; list.add(++i); return &quot;forward:/result&quot;; &#125;//이전 요청에 따라 매핑된다. @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125; @PostMapping(&quot;/result&quot;) @ResponseBody public String postResult() &#123; return &quot;post method&quot; +getListString(); &#125;... 직접 테스트 해보기컨트롤러 클래스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Controllerpublic class RedirectController &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = 0; public String getListString() &#123; StringBuilder sb = new StringBuilder(); list.stream().forEach(integer -&gt; sb.append(integer)); return sb.toString(); &#125; @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125; @PostMapping(&quot;/result&quot;) @ResponseBody public String postResult() &#123; return &quot;post method&quot; +getListString(); &#125; @GetMapping(&quot;/test&quot;) public String test() &#123; return &quot;test&quot;; &#125; @GetMapping(&quot;/redirect&quot;) public String getRedirect() &#123; return &quot;redirect:/result&quot;; &#125; @PostMapping(&quot;/redirect&quot;) public String postRedirect() &#123; list.add(++i); return &quot;redirect:/result&quot;; &#125; @GetMapping(&quot;/forward&quot;) public String getForward() &#123; return &quot;forward:/result&quot;; &#125; @PostMapping(&quot;/forward&quot;) public String postForward() &#123; list.add(++i); return &quot;forward:/result&quot;; &#125;&#125; JSP 화면123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;/redirect&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;리다이렉트&quot;&gt;&lt;/form&gt;&lt;form method=&quot;post&quot; action=&quot;/forward&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;포워드&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"응집도와 결합도","slug":"java/object/object2","date":"2021-11-28T15:45:28.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/29/java/object/object2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/java/object/object2/","excerpt":"","text":"응집도와 결합도응집도모듈 내부 요소가 연관된 정도.모듈의 내부 요소가 한 목적을 위해 긴밀하게 협력하는 정도. 높을 수록 좋다. 좀더 구체적으로 설명하면, 하나의 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도하나 바꾸려고 할 때, 모듈 전체를 바꿔야 되면 응집도가 높은 것. 하나의 변경이 일어날 때, 모듈 하나만 바꿔서 해결 가능하면, 응집도가 높은 것. 즉 특정 요구 사항을 변경하려고 한다면,그 요구 사항과 관련된 코드는 하나의 모듈에 모여있어야 한다. 그 요구 사항과 관련된 코드를 찾기 위해 소스 코드 전체를 구석구석 찾으면 안된다!! 결합도한 모듈이 다른 모듈에 대해 얼마나 많은 정보를 갖고 있는지.의존성 정도를 나타냄. 다른 모듈에 대해서는 최소한의 정보만 가지고 있는게 좋다.낮을 수록 좋다. 좀더 구체적으로 설명하면, 한 모듈이 변경하려 할 때 다른 모듈도 바뀌어야 하는 정도.하나 바꾸려고 하는데 다른 애들도 다 바꿔줘야되면 결합도가 높은거다.(구현된 클래스에 의존하지 말고 인터페이스에 의존하라는 말도 결합도를 낮추기 위해서 등장한다.) 물론 바꿀 일이 거의 없는 객체는 결합도가 높아도 괜찮다. 캡슐화와 관계캡슐화는 변할 수 있는 내용은 외부에서 알 수 없게 감추는 것이다. 일반적으로 응집도와 결합도의 문제는 캡슐화를 잘 설계하면 동시에 해결된다. 캡슐화가 잘된 걸까? (public Getter, setter)1234567891011public class Movie &#123; private Money free; public Money getFee() &#123; return fee; &#125; public void setFree(Money fee) &#123; this.fee = fee; &#125;&#125; 이렇게 private 매개변수를 해놓고, getter, setter를 해놓으면 캡슐화가 잘 된걸까? 답은 아니다!!! 게터 세터는 객체 내부 상태에 어떤 정보도 캡슐화하지 못한다. 사실상 그냥 public으로 열어둔거나 다름없다.외부에서 Movie 객체를 접근할 때 이미 Money 객체가 있다는 걸 알게된다. 이런 경우는 객체가 가지는 데이터에 중점적으로 설계해서 이런 일이 생긴다.객체는 문맥을 고려한 책임을 기반으로 설계되어야 한다. 높은 결합도결합도는 하나의 모듈을 변경하려 할 때 다른 모듈도 다 바뀌어야 하는 정도이다. 캡슐화를 지키지 못해서 결합도가 높아지는 경우를 보자. 12345678910public class ReservationAgency &#123; public Reservation reserve(Screening screening, Customer customer, int audienceCount) &#123; ... Money fee; //Money에 의존 if (discountable) &#123; fee = movie.getFee().minus(discountAmount).times(audienceCount); &#125; ... &#125;&#125; 다음 예시에선 Money타입의 fee에 요금 정보를 저장하고 있다.근데 만약 Money가 아닌 다른 타입에 fee를 저장하고 싶으면 어떻게 되는가? Money 대신 다른 타입을 수행할 수 있도록,getFee()를 수정하고 -&gt; minus()를 수정하고 -&gt; times()를 수정해야 한다 Money를 바꿀 뿐인데 다른 객체의 메서드들이 다 변해줘야 한다. 이는 movie의 getFee()가 사실상 객체에 fee와 관련된 내용이 있음을 알리는, 즉 캡슐화 하지 못해서 생긴 사례다. 낮은 응집도변경되는 이유가 각자 다른 코드들을 하나의 모듈 안에 뭉쳐 놓으면, 변경과 관련없는 코드도 영향을 받을 수 있다. 할인 정책을 선택하는 코드와 할인 조건을 검증하는 코드가 한 모듈에 있다고 하자.할인 정책을 추가하려고 하면, 할인 조건을 검증하는 코드는 변경과 큰 상관은 없지만 영향을 받는다. 응집도가 낮으면 변경 하나를 하려고 할 때 코드 구석구석을 고쳐야 할 수 있다. 응집도가 낮다는 건 자신과 관련있는 코드가 다른 엉뚱한 곳에 있을 수 있다는 의미이기도 하기 때문이다. 단일 책임 원칙 한 클래스가 변경되려면, 하나의 이유여야 한다는 것이다.즉 응집도 있게 설계해서 그 클래스가 엉뚱한 일에도 영향 받지 않도록 설계되어야 함을 의미한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}]},{"title":"12. 자바의 상속 내부 원리 (부모의 private 변수는 자식이 직접 접근 가능할까)","slug":"java/java-basic/java12","date":"2021-11-28T14:27:33.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/11/28/java/java-basic/java12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/28/java/java-basic/java12/","excerpt":"","text":"부모의 private 멤버 변수는 자식이 직접 접근할 수 있을까?답은 No다. 자식 객체가 생성되면, 부모 객체는 생성 될까? 답은 Yes다 이를 검증하기 위해 코드를 짜보자. 예시코드부모 클래스123456789public class Parent &#123; public Parent() &#123; System.out.println(&quot;Parent!&quot;); &#125; private String privateString = &quot;private&quot;; protected String protectedString = &quot;protected&quot;; String defaultString = &quot;default&quot;; public String publicString = &quot;public&quot;;&#125; 부모 객체가 생성되면, 부모 생성 문구를 출력하도록 했다.그리고 접근 지시자 별 문자열을 멤버로 가지고 있다. 자식 클래스123456public class Sub extends Parent&#123; public Sub() &#123; //super(); 부모의 기본 생성자가 생략되어 있다. System.out.println(&quot;SUb class!&quot;); &#125;&#125; 자식 객체는 생성자만 가지고 있다. 이때 자식클래스는 부모의 private 멤버 변수와 생성자를 상속받지 않는다.즉 privateString을 제외한 멤버변수를 자식 클래스도 직접 접근 가능하다.자식 객체를 생성하면, 자식의 생성자가 실행된다. (이때, super()에 의해 부모 생성자 먼저 실행된다!) 그렇다고 자식 객체를 만들 때, 부모 객체와 자식 객체가 각각 생기는 게 아니다.자식 객체를 만들어도 하나의 객체를 가진다. 다만 자식 객체가 생성 되기 전에 부모 객체가 생성되고, 부모 객체의 멤버가 초기화된다.그 다음 자식 생성자가 실행되면서 부모 객체가 생성된 것에 자식 객체가 추가로 씌여진다. 쉽게말하면 (Object 객체 생성자 실행 -&gt; 부모 객체 생성자 실행 -&gt; 자식 객체 생성자 실행) 이런 식으로 실행되고,이 세가지 클래스에 있는 멤버들은 한 객체(자식)에 초기화된다. 그렇다면 다음 코드를 실행하면?1234567public class Application &#123; public static void main(String[] args) &#123; Parent first = new Parent(); Parent second = new Sub(); Sub third = new Sub(); &#125;&#125; 다음과 같다! 12345Parent!Parent!SUb class!Parent!SUb class! 참고 사이트 https://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"9. 템플릿 메서드 패턴","slug":"java/design-pattern/dp9","date":"2021-11-27T12:14:40.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/11/27/java/design-pattern/dp9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/27/java/design-pattern/dp9/","excerpt":"","text":"템플릿 메서드 패턴템플릿 메서드 패턴은 특정 역할의 책임을 한 메서드에 여러 메서드를 조합*(이게 템플릿!)*으로 정해놓는 패턴이다. 템플릿 메서드를 구성하는 메서드들은 역할에 속하는 객체마다 다르게 구현될 수 있다. 활용 예시우리는 여러 DB에 연결해야 한다. 우리가 연결한 DB는 모두 다음과 같은 절차를 따른다고 하자.해당 DB드라이버 찾기 - DB에 로그인 - DB에 연결 이때 DB마다 사용하는 드라이버가 다르다. 이 상황에서 템플릿 메서드 패턴을 활용해서 문제를 해결해보자. 템플릿 메서드를 포함한 추상 클래스일단 추상 클래스 안에 주어진 템플릿을 구현한 메서드를 만들어보자!이때 각 DB마다 달라지는 부분은 추상 메서드로 다형성을 확보한다. 123456789101112131415public abstract class DataConnection &#123; //템플릿 메서드 public final void process() &#123; findDriver(); login(); connectDB(); &#125; public abstract void findDriver(); public abstract void connectDB(); public final void login() &#123; System.out.println(&quot;로그인을 실행합니다...&quot;); &#125;&#125; 추상 클래스를 상속하는 자식 클래스이제 DB마다 클래스를 상속해서 구현하자.추상 메서드를 DB 요구 조건에 맞게 구현하면 된다. 우리는 MySQL과 H2를 예시로 구현해보자 1234567891011public class MySQLConnection extends DataConnection&#123; @Override public void findDriver() &#123; System.out.println(&quot;MySQL 드라이버를 찾습니다.&quot;); &#125; @Override public void connectDB() &#123; System.out.println(&quot;MySQL과 연결합니다.&quot;); &#125;&#125; 1234567891011public class H2Connection extends DataConnection&#123; @Override public void findDriver() &#123; System.out.println(&quot;H2 드라이버를 찾습니다.&quot;); &#125; @Override public void connectDB() &#123; System.out.println(&quot;H2 드라이버를 연결합니다.&quot;); &#125;&#125; 결과 확인이제 적용해보자. 123456789public class Application &#123; public static void main(String[] args) &#123; DataConnection dataConnection = new MySQLConnection(); dataConnection.process(); dataConnection = new H2Connection(); dataConnection.process(); &#125;&#125; 123456MySQL 드라이버를 찾습니다.로그인을 실행합니다...MySQL과 연결합니다.H2 드라이버를 찾습니다.로그인을 실행합니다...H2 드라이버를 연결합니다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"객체지향의 역할, 책임, 협력","slug":"java/object/object1","date":"2021-11-26T11:36:16.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/26/java/object/object1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/26/java/object/object1/","excerpt":"","text":"역할, 책임, 협력하나의 프로그램을 만들기 위해서는 다양한 객체가 자신의 로직을 실행해서 전체 기능을 완성한다. 중요한 건, 다양한 객체가 한 기능을 만들기 위해 메시지 를 주고 받으며 상호작용한다는 사실이다. 이처럼 어플리케이션의 기능을 완성하기 위해 여러 객체가 상호작용하는 것을 협력이라고 한다. 각 객체들이 수행하는 자신의 로직을 책임이라고 하고, 객체들이 협력 안에서 수행하는 책임이 모여 객체가 수행하는 역할을 구성한다. 협력두 객체 사이의 협력은 한 객체가 다른 객체에 도움을 요청하면서 시작된다.메시지 전송은 객체 사이의 협력을 만드는 유일한 커뮤니케이션 수단이다. 즉 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 행위다.협력은 역할을 수행하기 위한 특정 책임을 잘 수행할 수 있는 다른 객체에게 위임하는 행위다. 협력과 자율성메시지를 수신한 객체는 메서드를 실행해 요청을 실행한다.이때 협력을 요청한 객체는 응답하는 객체가 어떤 방식으로 메시지를 처리할지 알지 못한다.요청하는 객체가 해당 책임에 대해 지나치게 개입하면 안된다! (다른 객체의 내부구현에 손대지말라.)(ex. 협력에 참여하는 객체의 인스턴스 변수에 직접 접근하는 경우는 해당 객체의 자율성을 훼손 -&gt; private 키워드로 캡슐화) 객체의 행동과 상태객체는 어떤 협력에 참여할 지에 따라 상태와 행동이 정의되어야 한다.즉 협력이 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.협력이 달라지면 객체의 행동도 달라질 수 있다. 협력없는 행동은 아무 의미 없다! 그렇다면 상태는 왜 존재하는가?상태는 행동에 사용되기 때문에 존재한다. 즉 협력은 객체의 행동을 정의하고객체의 행동이 필요한 정보에 따라 객체의 상태가 결정된다. 결국 협력은 객체의 모든 것을 설계하는 문맥을 제공한다. 책임책임은 협력에 참여하기 위해 객체가 수행하는 행동이다. 책임을 지는 객체는 책임을 완수하기 위해 필요한 정보를 알고 있어야 한다.혹은 그 책임을 할 수 없는 객체가 그 책임이 필요한 경우, 그 책임을 할 수 있는 객체를 알고 있어야 한다. 즉 책임은 단순한 행동을 해야 하는 것 뿐만 아니라, 그 행동에 필요한 정보도 알고 있어야 하는 것을 의미한다. 객체지향에서 제일 중요한 것이 객체에게 적절한 책임을 지게 하는 것이다. 책임 할당책임 할당을 위한 기본적인 방법은 그 책임을 수행하기 위해 필요한 정보를 가장 잘 아는 전문가에게 책임을 주는 것이다. 이제 이 책임을 할당하는 과정을 살펴보자. 하나의 큰 메시지를 정의한다.(시스템이 사용자에게 제공하는 큰 기능을 하나의 책임으로 본다) 메시지를 정의했으면 그 메시지를 처리할 객체를 고른다.(이때 메시지가 크기 때문에 그 객체 혼자서 처리 못한다.) 그 객체가 처리하지 못하는 책임은 다른 전문가(!)를 찾아서 메시지를 전달한다. 이 과정을 2번과 3번을 반복한다. 책임 주도 개발위 과정을 책임 주도 개발로 표현하면 다음과 같다 일단 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 본다.(시스템의 책임을 파악) 이제 하나의 큰 책임을 더 작은 책임으로 잘게 분해한다. 분해된 책임들을 객체들에게 할당한다. 책임을 수행하던 객체가 다른 객체의 도움이 필요하면 적절한 객체 혹은 역할을 찾는다. 해당 객체가 참여하게 되면서 두 객체는 협력하게 된다. 역할역할은 특정한 협력 안에서 수행하는 책임의 집합.실제로 협력에서 객체에게 책임을 할당한다기 보다는 역할에 책임을 할당한다고 보는 게 좋다. 역할은 유연하고 재사용 가능한 협력을 얻을 수 있게 한다.역할은 다른 것으로 교체할 수 있는 책임의 집합이다. 즉 동일한 책임을 가진 여러 객체가 있다면, 그것을 추상화 한 것이 역할이다. 영화 예매를 예시로 들면,영화 요금을 할인 하는 두 가지 방식이 있다고 하자.하나는 요금의 퍼센트로 할인하는 방식이고,(10퍼센트 할인..)다른 하나는 예매 표 중 일부 값을 할인하는 방식이 있다.(두 표사면 한 표는 할인..) 이 두 방식 모두 객체로 표현된다면, 이 두 객체는 요금을 할인한다는 동일한 책임을 가진다.그렇다면 우리는 이 같은 책임을 하나의 역할로 추상화하여 표현할 수 있다.이렇게 하면 할인 방식에 따라 협력을 일일히 만들지 않고, 역할이 할인 정책을 추상화하여 담당하게 된다. (자바에서 역할을 구현하는 방식은 추상 클래스와 인터페이스를 사용한다.) 객체냐 역할이냐그렇다면 동일 책임을 지는 다른 객체가 없는,즉 하나의 객체만이 해당 책임을 지는 경우에도 그 객체를 역할로 추상화 해줘야 할 까? 답은 아니다. 책임 수행하는 대상이 한 종류면, 간단하게 객체로 간주해도 좋다.다만 책임 수행하는 객체가 여러 종류면, 역할로 간주하라. 사실 설계 초반에는 객체와 역할을 명확히 하긴 힘들다.다양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작해라.애매하고 확실하지 않은 경우는 객체로 시작하자. (진행하면서 역할로 대체하면 된다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}]},{"title":"우아한테크코스 4기 프리코스 1주차 회고","slug":"java/woowa-tech-course/utecoprecourse1","date":"2021-11-26T05:48:15.000Z","updated":"2022-02-24T14:17:30.669Z","comments":true,"path":"2021/11/26/java/woowa-tech-course/utecoprecourse1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/26/java/woowa-tech-course/utecoprecourse1/","excerpt":"","text":"우아한 테크코스 4기 프리코스 1주차1주차 문제 깃허브 링크https://github.com/woowacourse/java-baseball-precourse 문제 간단 요약우리가 흔히 아는 야구게임을 자바로 구현하는 게 1주차 문제다.세개의 수를 입력받고 해당 자릿수에 맞는 숫자를 입력한 경우 스트라이크 추가,자릿수는 맞지 않지만 맞는 숫자를 포함한 경우 볼 추가해서 결과를 반환한다. 3 스트라이크. 즉 정확히 맞출 경우 게임을 종료하고,다시 게임을 시작을 할 수 있도록 해야한다. 마주한 문제들요구사항 작성하기일단 우테코 프리코스는 가장 먼저 요구사항을 작성해야 한다.요구 사항을 기능 중점으로 정리해서 README.md를 작성해야 하는게 첫 단계다. 처음에 필자는 그냥 우테코에서 작성된 요구사항을 마구잡이로 요구사항을 만들었는데,나중에 코드를 작성하려고 했더니, 어떤 요구사항 먼저 해결해야 할 지 막막했다. 그래서 내가 고민하고 고안해낸 요구사항 분석하는 방법은 다음과 같다. 가장 먼저 전체적인 프로그램의 흐름을 이해한다. 요구사항은 기능 관점에서 작성한다. 요구사항은 의존 관계가 가장 느슨한 것 먼저 우선순위로 작성한다. 1주차 프리코스의 문제에서는 목표 숫자를 난수로 만드는게 가장 의존 관계가 느슨하다. 이게 무슨 말이냐면, 목표 숫자를 난수로 만드는 기능은 다른 기능의 힘을 필요로 하지 않는다는 의미다. 최대한 각 기능들이 서로의 역할을 간섭하지 않도록 하라. 일단 한 기능에서 예외처리를 담당하면, 다른 기능에서는 예외처리 책임을 질 필요 없다. 예외처리를 해야 될 경우 예외처리를 담당하는 기능과 협력하도록 하자. 이렇게 요구사항 목록을 작성하고 나면, 프로그래밍을 하는 과정에서 빼먹는 요구사항을 최소한으로 줄일 수 있다.또한 요구사항 구현 순서를 어느정도 정리하고 작성하기 때문에 구현을 더 원활하게 할 수 있다. 깃 사용우테코 프리코스는 깃 커밋을 신중하게 작성해야 한다.그래서 깃을 어떻게 사용하는지가 굉장히 중요하다. 기능은 따로 브랜치를 만들어서 격리된 상황에서 구현하라. 기능을 만들다가 되돌리기 쉽다. 커밋 메시지를 잘 지켜서 작성한다. 다른 사람이 쉽게 이해할 수 있도록 하기 위함이다. 커밋은 기능 관점에서 작성해야 한다. 지나치게 세세하게 하지도 않고, 지나치게 적게 하지 않기 위함이다. 코드 작성우아한 테크코스에서는 최대한 간략하게 코드를 작성하도록 한다.일단 메서드가 한 역할을 잘하도록하고, 그 메서드가 15줄이 넘지 않도록 하는게 중요하다. 필자의 경우, 전체적인 기능을 정리하고 나서,이 기능들을 어떤 클래스가 책임질 지,혹은 메서드를 어떻게 나눌 것인지가 정말 어려웠다. 후기프리코스에 참여해보니, 내가 그동안 얼마나 코드를 대충 짰는지 체감하는 경험이 됐다.혼자 코드를 짜다보면 의식의 흐름대로 코드를 짜게 되는 경우가 많다.그러다보면 한 메서드에 수많은 기능이 의존하게 되고, 유지보수도 극악에 향하게 된다. 프리코스의 요구사항을 만족하는 방식으로 프로그래밍 하다보니 자연스럽게 책임을 나누게 되고,그 책임을 수행하는 여러 객체들의 협동으로 기능을 완성했다.평소 코딩할 때는 생각해보지 못했던 부분을 경험할 수 있어 재밌었다. 프리코스는 코딩하는 법을 알려주지 않는다. 다만 무엇을 만들라 한다.그런데 하다보면 알게 된다. 아무도 알려주지 않지만 스스로 알게 된다. 내가 모르는 건 스스로 찾아서 해결하게 된다. 그리고 그 정보를 체득하기 위해 노력하게 된다. 프리코스를 시작하기 전, 교육을 기획한 자바지기님은 프리코스를 우아한 테크코스를 통과하기 위한 것으로 생각하지 말고,더 좋은 개발자가 되기 위한 과정으로 여겨줬으면 좋겠다고 하셨는데, 이번 프리코스를 통해 더 좋은 개발자가 될 수 있을 거 같다.다음 프리코스도 더 기대가 된다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}]},{"title":"자바 코딩 규칙(Java Code Conventions)","slug":"java/java-basic/java11","date":"2021-11-20T14:23:18.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/11/20/java/java-basic/java11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/20/java/java-basic/java11/","excerpt":"","text":"자바 소스 파일 구조시작 주석 package 문 import 문 Class 혹은 Interface 선언 시작 주석모든 소스 파일은 다음과 같은 시작 주석을 써줘야 한다. 123456789/* *클래스 이름 * *버전 정보 * *날짜 * *저작권 주의 */ package문 import문일반적으로 패키지문을 먼저 쓰고, 임포트문을 다음에 써준다. 두 문 사이에는 공백을 써준다. 123package com.yangdongjue;import java.util.*; class와 interface 선언클래스와 인터페이스 선언 순서를 알아보자 문서화 주석(/** … */) 클래스/인터페이스 문(public class …) 구현 주석(/* … */) 클래스(static) 변수public - protected - default - private 순으로 나열 일반 변수클래스 변수와 동일하게 나열 생성자 메서드접근자가 아닌 기능에 의해 구성되어야 함. 한줄의 길이 한줄의 길이는 최대 80자다. 만약 하나의 식이 한 줄에 안들어가면? 줄 나누기를 해주자. 줄나누기 콤마 후에 두 줄로 나눈다. 12someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2, VeryLong veryLongExpress3); 연산자 앞에 두 줄로 나눈다.이때 연산자 레벨이 맞도록 나눠 줘야 한다. (괄호의 경우…) 12VeryLong veryLong = veryLong1+(veryLong2+veryLong3) +veryLong4; 메서드 선언에서 줄 나누기를 할 때는 한번 더 들여써준다.메서드 구현부와 헷갈리면 안되기 때문이다. 1234someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2, VeryLong veryLongExpress3) &#123; ...(메소드 구현부) &#125; 주석주석은 코드 개요와 코드 자체로는 알 수 없는 추가 정보를 제공하기 위해서 쓰인다.주석은 프로그램을 이해하기 위한 내용을 다뤄야 한다.코드 상에 이미 표현된 중복 정보는 다루지 말아야 한다. 자바 주석은 구현 주석과 문서화 주석으로 나뉜다. 구현 주석 블록 주석파일, 메서드, 클래스 등에 설명 할 때 사용.클래스나 인터페이스 속에서 파일이나 메서드가 시작되기 전에 써줘야 하고,해당 메서드나 파일의 들여쓰기를 반영해야 한다. 123/* *블록 주석을 작성하자~ */ 한 줄 주석짧은 주석은 뒤에 따라오는 코드를 설명.뒤 코드와 동일한 들여쓰기 적용.윗 코드와 한칸 띄어서 사용 12345if (condition) &#123; /* 한 줄 주석 */ int a = 1;&#125; 꼬리 주석아주 짧은 주석이 필요한 경우 설명하는 코드와 같은 줄에 작성. 12345if (condition) &#123; return true; /* condition에 해당 */&#125; else &#123; return false /* condition에 해당히지 않음 */&#125; 줄 끝 주석한 줄을 통째로 주석 처리하거나, 일부를 주석 처리 할때 사용.코드를 주석처리 할 때 여러줄을 주석하는 건 가능하지만, 그외는 여러줄 주석을 금한다. 1234567891011if (condition) &#123; //줄 끝 주석은 이렇게 쓸 수 있다. int a = 1;&#125; else &#123; return false; //줄 끝 주석을 여기에도 쓸 수 있다.&#125;//if (condition) &#123;// int a = 2;//&#125; 문서화 주석문서화 주석은 다음 다섯가지를 분석한다. 자바 클래스 인터페이스 생성자 메서드 필드 다만 문서화 주석이 어울리지 않으면, 클래스 선언 후에 블록 주석 혹은 한줄 주석으로 표현한다. 123456/** * 이 클래스는 어떤 역할을 합니다. */public class Example &#123; ...&#125; 변수변수 선언123456/* 옳은 예시 */int a;int b;/* 괜찮지만 불편한 방식 */int a, b; 이때 중요한 건 한 클래스에 필요한 변수를 선언은 가장 처음에 하는게 좋다!!!!!그리고 지역 변수를 전역 변수와 같은 이름으로 선언하지 말자!!!! 1234567class Example &#123; int a = 1; if (condition)&#123; int a = 2; // 이렇게 쓰지 말라는 거다!!! &#125;&#125; 클래스 &amp; 인터페이스 선언 메서드 이름과 파라미터를 감싸는 괄호 시작 사이에는 빈 공간이 없어야 한다. 12345678public class Main &#123; int a; int b; int method() &#123; int c; &#125;&#125; 여는 중괄호는 클래스&amp;인터페이스&amp;메서드의 선언부 문장 끝에 위치한다. 닫는 중괄호는 구현부가 없는 경우가 아니면 여는 문장과 동일한 들여쓰기로 새로운 줄로 사용하자. 12345678class Main &#123; int a; int b;&#125;class Okay &#123;&#125;class Wrong &#123; int c; &#125; 클래스나 인터페이스 내부의 메서드는 분리되기 위해서 한 줄씩 띄어놔야 한다. 12345678class Main &#123; int a; int b; void firstMethod()&#123;&#125; void secondMethod()&#123;&#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"스프링 부트의 특징","slug":"spring/boot/boot12","date":"2021-11-19T02:56:33.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/11/19/spring/boot/boot12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/19/spring/boot/boot12/","excerpt":"","text":"스프링 부트의 특징스프링 부트는 스프링의 복잡한 xml 간편화와 빠른 개발을 위해 등장했다.부트는 웹을 위해 필요한 필수 라이브러리를 내장하고 있다.(톰캣 등) 스타터(starter) : 특정 모듈을 사용할 수 있도록 필요한 라이브러리를 모아놓은 라이브러리 모음 자동설정(AutoConfiguration) : 추가된 라이브러리나 모듈을 사용할 수 있도록 자동으로 빈 등록이나 프로퍼티 설정을 하는 것.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"12. 링크 계층","slug":"cs/network/network12","date":"2021-11-17T11:27:55.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network12/","excerpt":"","text":"a. 링크a-1. 링크 계층 소개 링크 계층(2계층) 프로토콜을 실행하는 장치를 노드라 함. 통신 경로상의 인접한 노드들을 연결하는 통신 채널은 링크 한 링크에서 전송 노드는 데이터그램을 링크 계층 프레임으로 캡슐화해서 링크로 전송한다. a-2. 링크 계층의 서비스 프레임화 : 네트워크 계층 데이터그램을 링크상으로 전송하기 전에 링크 계층 프래임에 캡슐화.header payload trailer 형식으로 캡슐화 링크 접속 : 매체 접속 제어(MAC) 프로토콜은 링크상으로 프레임을 전송하는 규칙에 대해서 명시함 신뢰적 전달(RDT) : 링크 계층의 신뢰적 전달 서비스도 확인 응답과 재전송 방식으로 가능*트랜스포트 계층이나 애플리케이션 계층과 달리 데이터를 재전송하는 방식과 달리*링크 계층 프로토콜은 오류가 발생한 링크에서 오류를 정정.왜 수송 계층과 링크 계층 모두 RDT가 필요하지? 링크 계층에서 잘 되도, IP에서 best-effort로 인한 손실이 발생가능. 그래서 수송 계층에서 RDT를 하는 것. 오류 검출과 정정 : 오류 검출은 송신 노드에서 프레임의 오류 검출 비트를 설정하고 수신 노드에서 오류 검사를 수행하게 하는 방식. 오류 정정은 프레임 안의 오류 검출, 프레임의 어느 곳에서 오류가 발생했는지를 찾아내는 것.(오류 검출과 비슷하게 구현) a-3. 링크 계층이 구현되는 위치링크 계층은 네트워크 인터페이스 카드로 알려진 네트워크 어댑터로 구현된다. 링크 계층 제어기로 링크 계층 서비스들의 대다수가 구현한다. 일부 링크 계층 기능은 호스트 cpu에 실행되는 소프트웨어에 구현되어 있다. 링크 계층은 하드웨어와 소프트웨어의 조합. 프로토콜 스택상에서 소프트웨어와 하드웨어가 만나는 부분에 위치. 송신 측의 제어기는 상위 계층에 의해 생성되어 호스트 메모리에 저장된 데이터그램을 링크 계층 프레임을 캡슐화한 후, 링크 접속 프로토콜에 따라 이 프레임을 통신 링크로 전송한다. 수신 측의 제어기는 프레임을 수신한 후 네트워크 계층 데이터그램을 추출한다. b. 오류 검출 및 정정 기술 비트 오류를 방지하기 위해 송신 노드에서 데이터 D에 오류 검출 및 정정 비트들(EDC)을 첨가한다. 수신자는 자신이 수신한 D’와 EDC’만으로 원래의 D가 D’와 동일한지 결정한다. 오류 검출 비트를 사용하더라도 여진히 미검출된 비트 오류가 있을 수 있다. b-1. 패리티 검사b-1-1. 단일 패리티 비트 데이터 D가 d개의 비트를 가지고 있다고 할 때, 패리티 비트를 하나 추가. 이 비트들에서 1의 개수가 짝수(혹은 홀수)가 되도록 설정한다. 수신자는 받은 데이터의 1 갯수가 홀수(혹은 짝수)이면 오류가 있음을 알게 된다. 그러나 짝수 개의 비트 오류가 발생하면 오류를 검출하지 못할 수도 있다. b-1-2. 2차원 단일 비트 패리티데이터 D를 i개의 행과 j개의 열로 나눠서 각 가로줄과 세로줄의 1 갯수가 짝수(혹은 홀수)가 되도록 패리티를 설정한다. 이 방식은 수신자가 단일 비트 오류의 발생을 검출할 수 있을 뿐 아니라, 열과 행의 인덱스 값을 사용해 잘못된 비트를 실제로 식별해 오류를 정정할 수 있다. b-2. 체크섬데이터 바이트를 16비트 정수 단위로 취해서, 더한 값의 1의 보수가 인터넷 체크섭이 되며, 이를 세그먼트 헤더에 넣어준다. 오버헤드가 적지만 오류 면에서 상대적으로 취약하다. b-3. 순환중복검사(CRC) 데이터 D가 비트 d로 이뤄져 있을 때, G로 표현하는 생성자로 알려진 r+1 비트 패턴에 대해서 합의한다. 송신자는 r개의 추가비트 R을 선택해서 D 뒤에 덧붙이며, d+r 비트 패턴은 모듈 -2연산(XOR 연산)을 이용하면 G로 정확히 나누어진다. 수신자는 d+r개의 수신 비트를 G로 나눈다. 나머지가 0이 아니면 오류가 존재하는 것. 예시로 해보자 일단 생성자 G를 1001로 약속하고,101110인 데이터 D에 2^r을 곱한 것을 G로 나눈 나머지를 R로 정한다. 그 이후 D*2^R XOR R을 수신자에게 보낸다 XOR 연산은 같은 자리 같은 숫자이면 0인 연산이다. 간단히 생각하면 D뒤에 R을 그냥 덧붙인 결과라 생각하자. 예시에 따르면 101110011이 된다. c. 다중 접속 링크와 프로토콜다수의 송수신 노드들의 공유되는 브로드캐스트 채널로의 접속을 조정하는 문제. 즉 다중 접속 문제에 의한 충돌을 해결해야 한다. 이런 전송을 조정하기 위한 것이 다중 접속 프로토콜. #out of band channel &amp; in band channel out of band = control과 data가 다른 채널로 전달 in band = control 과 data가 같은 채널로 전달 무선랜은 in-band channel c-1. 이상적인 다중 접속 프로토콜의 조건 단 하나의 노드가 전송하려 할 때, 그 노드가 R bps의 처리율을 갖는다. M개의 노드가 전송하려 할 때, 각 노드가 R/M bps의 처리율(평균적 의미)을 갖는다. 프로토콜이 분산되어 있어, 고장으로 시스템이 정지될 수 없다. 비용이 적게 든다. c-2. 채널 분할 프로토콜c-2-1. 시분할 다중화(TDM) TDM은 시간을 시간 프레임으로 나누고 또한 각 시간 프레임을 N개의 시간 슬롯으로 나눈다. 각 시간 슬롯은 N개의 노드에게 할당된다. 노드는 전송할 패킷이 있을 때마다 TDM 프레임에서 자신에게 할당된 시간 슬롯 동안 패킷 비트를 전송. 참가자들에게 고정된 시간을 주고, 말할 게 없어도 시간을 준다. 전송하고픈 노드가 하나라도 노드 전송률은 평균 R/N으로 제한. 노드가 전송 순서상 자신의 차례를 기다려야함. c-2-2. 주파수분할 다중화(FDM) FDM은 R bps의 채널을 다른 주파수로 나눠서 각 주파수를 N개 노드 중 하나에게 할당한다. TDM과 비슷한 장단점을 가짐. c-3. 랜덤 접속 프로토콜항상 채널의 최대 전송률인 R bps로 전송한다. 충돌이 생기면 충돌과 관련된 각 노드는 프레임이 충돌없이 전송될 때까지 자신의 프레임을 계속해서 재전송. 대신 그 프레임을 재전송하기 전에 랜덤 지연 시간 동안 기다린다. c-3-1. 슬롯 알로하 가정 모든 프레임은 정확히 L비트로 구성 시간은 L/R초의 슬롯들로 구성(즉 한 슬롯은 한 프레임 전송에 걸리는 시간과 같음) 노드는 슬롯의 시작점에서만 프레임을 전송하기 시작 각 노드는 언제 슬롯이 시작하는지 알 수 있게끔 동기화되어 있음 한 슬롯에서 2개 이상의 프레임이 충돌 시, 모든 노드는 그 슬롯이 끝나기 전에 충돌 발생을 알게 됨 작동 방식 노드는 전송할 새 프레임이 있으면 다음 슬롯까지 기다렸다가 전체 프레임을 전송 충돌이 없으면, 노드는 성공적으로 자신의 프레임을 전송한 것따라서 보낸 프레임을 다시 보낼 필요 없음 충돌하면, 노드는 그 슬롯이 끝나기 전 충돌을 검출, 노드는 그 프레임이 충돌 없이 전송 될 때까지 확률 p로 해당 프레임을 다음 스롯들에서 재전송한다.각 노드들은 자신의 동전을 던지며, 재전송할지 다음 슬롯에서 동전을 다시 던질지를 결정한다. 장점 활성노드가 채녈의 전속력 R로 계속해서 프레임을 전송할 수 있돌록 허용 상당히 분산(노드는 슬롯을 동기화시켜야) 매우 단순 활성 노드가 하나일 때 잘 동작 단점 여러 노드가 참여하면 충돌이 생겨 낭비가 생긴다. 모두가 전송을 자제해 슬롯이 비는 상황이 생길 수 있다. 효율성(여러개의 활성 노드가 있을 때 충돌없이 전송되는 시간 비율) N개의 노드가 확률 p로 슬롯 알로하로 패킷을 보낼 때 임의의 노드가 성공 확률은? Np(1-p)^(N-1) 최대 효율은 효율성의 극대화인데, 이 프로토콜의 최대 효율은 0.37.(겨우 37%의 슬롯만 낭비되지 않는다…) c-3-2. 알로하슬롯 알로하는 모든 노드가 슬롯의 시작점에서 전송을 시작할 수 있도록 동기화되어 있기를 요구 하지만 알로하 프로토콜은 슬롯이 없고 완전히 분산된 프로토콜 전송된 프레임이 하나 이상의 다른 전송과 충돌하면, 노드는 확률 p로 즉시 프레임을 전송한다. 주어진 노드가 성공적인 전송을 할 확률은 p(1-p)^2(N-1) 순수 알로하 프로토콜의 최대 효율은 1/2e 즉 슬롯 알로하의 절반… c-3-3. CSMA 말하기 전에 들어라 : 다른 사람이 말하고 있으면 말이 끝날 때까지 기다려라.네트워크에서는 이를 캐리어 감지 라고 한다. 다름 사람이 동시에 말하기 시작하면 말을 중단하라 : 네트워크에서 이것을 충돌 검출이라 함(송신 노드는 전송하면서 동시에 채널을 듣는다.)멈춘 후 랜덤 시간 동안 기다린 후 유휴 시 감지 및 전송 과정을 반복 하지만 브로드캐스트 채널의 종단간의 채널 전파 지연이 CSMA의 성능을 결정하는 데 중요함. 전파 지연이 길 수록 네트워크의 다른 노드에서 이미 시작된 전송을 캐리어 감지 노드가 감지 할 수 없는 경우 증가. c-3-4. CSMA/CD다중접속 프로토콜에 충돌 검출을 추가한 것. 쓸모 없는 프레임(충돌이 발생한 프레임)을 모두 전송하지 않게 됨. 링크 계층 프레임을 만든 후에 그 프레임을 어댑터의 버퍼에 저장 채널이 유휴한 것을 감지하면(채널로부터 어댑터로 들어오는 신호 에너지가 없으면) 프레임 전송을 시작한다.채널이 바쁜 것을 감지하면, 신호 에너지가 감지되지 않을 때까지 기다렸다가 프레임을 전송한다. 전송하는 동안 어댑터는 다른 어댑터로부터 신호가 있는지 감시한다. 전송 도중 다른 어댑터로부터 신호 에너지를 감지하면, 자신의 프레임 전송을 취소한다. 임의의 랜덤 시간(이진지수적 백오프)만큼 기다린 후 2단계로 돌아간다 #이진지수적 백오프 충돌을 n번 경험한 프레임을 전송할 때, {0,1,2…,2^n-1} 중 랜덤하게 선택한다. 새 프레임을 준비할 때 최근 발생했던 충돌을 고려하지 않는다. 효율성 prop : 신호 에너지가 임의의 두 어댑터 사이에서 전파되는 데 걸리는 최대 시간 trans : 최대 크기의 이더넷 프레임을 전송하는 데 걸리는 시간(10Mbps 이더넷에서 대략 1.2msec) c-4. 순번 프로토콜다중 접속 프로토콜의 두가지 특성 단 하나의 노드만이 활성화 되면 그 노드가 R bps의 처리율을 가져야 한다 M개의 노드가 활성이면 각 노드가 거의 R/M bps의 처리율을 가진다. 알로하와 CSMA는 첫번째 특성을 가지나 두 번째 특성은 없다. 순번 프로토콜을 개발하게 된 계기이다. 채널 나누기 MAC protocol : high load 일 때 효율적 공정, low load일 때 비효율(무조건 1/N을 분배) 랜덤 access MAC protocol : low load 일 때 효율, high load일 때 비효율(충돌 overhead) c-4-1. 폴링 프로토콜 노드 중 하나를 마스터 노드로 지정. 각 노드를 라운드 로빈 형식으로 폴링. 마스터가 노드1에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다. 노드 1이 모두 보내고 나면 노드 2에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다. 단점 폴링 지연(노드가 전송할 수 있음을 알리는데 걸리는 시간)으로 인해 활성 노드는 R bps보다 작은 전송률을 가진다. 마스터 노드가 고장 나면 전체가 작동 안하게 됨 c-4-2. 토큰 전달 프로토콜 토큰이라고 알려진 작은 특수 목적 프레임이 정해진 순서대로 노드 간에 전달된다. 토큰이 노드1-&gt;노드2-&gt;노드3 순으로 토큰을 전달한다. 노드는 토큰을 수신하면, 보낼 데이터가 있을 때만 토큰을 잡는다. 보낼 게 있으면 최대 개수 만큼 프레임을 보낸다. 노드하나가 실패하면 전체가 동작하지 않는다. d. 스위치 근거리 네트워크스위치 네트워크에서는 링크 계층 프레임을 전달하기 위해 IP 주소가 아닌 링크 계층 주소를 사용 d-1. 링크 계층 주소체계와 ARPd-1-1. MAC 주소호스트의 어댑터 혹은 라우터의 어댑터가 링크 계층 주소를 가진다. 다수의 어댑터를 가지고 있는 호스트나 라우터는 여러개의 링크 계층 주소를 가진다. MAC 주소는 6바이트(48비트) 길이이고, 16진수 표기법으로, 각 바이트는 2개의 16진수로 표현. 어떤 어댑터도 동일한 주소를 가지지 않는다!(IEEE에서 주소 할당) MAC 주소는 평면 구조를 가지며, 어댑터의 위치에 따라 변경되지 않음 마치 사람의 주민등록번호와 같다(ip는 위치에 따라 변하는 것처럼, 주소와 비슷하다) d-1-2. ARP 네트워크 계층 주소(ip)와 링크 계층 주소(MAC 주소) 사이의 변환(ARP는 링크 계층과 네트워크 계층의 경계에 있다고 봐야한다.) ARP는 동일한 서브넷상에 있는 호스트나 라우터 인터페이스의 IP 주소만을 해결한다. 호스터와 라우터는 자신의 메모리에 ARP 테이블을 가지고 있다. 테이블엔 &lt;IP 주소, MAC 주소, TTL&gt;이 있다. ARP 테이블을 보고 노드를 찾아 간다. 만약 송신 노드의 ARP 테이블에 목적지 노드에 대한 엔트리가 없다면? 먼저 송신 노드 ARP 패킷이라는 특수 패킷을 구성한다.ip주소와 mac 주소를 포함하는 필드를 갖고 있다. ARP 질의 패킷의 목적은 해결하려는 ip주소에 대응하는 mac 주소를 결정하기 위해모든 호스트와 라우터에게 질의하는 것. 송신 노드는 어댑터에게 ARP 패킷을 전달하여,브로드캐스트 주소(FF-FF-FF-FF-FF-FF)로 패킷을 전송하도록 지시서울시 xx구 xx동 xx아파트 101호에 사는 사람 주민번호가 뭔지 아는사람? 각 노드의 어댑터는 ARP 패킷을 자신의 ARP 모듈로 전달,모듈이 자신의 ip와 패킷 속 ip와 비교하여 일치할 경우 요구 정보를 반환. 질의를 한 호스트는 답변을 듣고, 자신의 ARP 테이블을 갱신 질의 메시지는 브로드캐스트로 전달되지만 응답 메시지는 표준 프레임으로 전송된다. ARP의 플러그 앤 플레이, 즉 노드의 ARP 테이블이 자동으로 구축된다. d-1-2-1. 서브넷에 없는 노드로 데이터그램 전송 라우터는 각 인터페이스 당 하나의 IP 주소를 가진다. 각 라우터 인터페이스는 ARP 모듈(라우터 안)과 어댑터를 가진다. 물론 각 인터페이스 별로 MAC 주소를 가진다. ARP로 라우터의 MAC 주소를 알아내 원래 목적지를 담은 데이터그램을 포함한 프레임을 전달한다 라우터의 어댑터의 링크 계층 프레임이 자신을 목적지로 했는지 확인 후 라우터의 네트워크 계층으로 보낸다. 라우터는 포워딩 테이블을 참조해 정확한 인터페이스를 결정한다 데이터그램을 새 프레임에 캡슐화해 서브넷 2로 전송한다. ARP로부터 목적지의 MAC 주소를 알아내 보낸다. d-2. 이더넷최초의 이더냇 랜은 노드를 연결하기 위해 동축 버스를 사용. 버스 토폴로지의 이더넷은 브로드캐스트 랜으로, 전송되는 모든 프레임은 버스에 연결된 모든 어댑터를 거치며 처리됨 이후 랜을 허브 기반의 스타 토폴로지를 사용하는 이더넷으로 대체했다. 허브는 프레임이 아닌 각각의 비트에 대한 처리를 하는 물리 계층 장치이다. 허브도 브로드캐스트 랜이므로, 여러 프레임이 수신되면 충돌이 발생해 재전송 해야한다. 허브 이후 중앙의 허브가 충돌이 없는 스위치로 대체되었다. d-2-1. 이더넷 구조 데이터 필드(46~1500바이트) : IP 데이터그램을 운반(다른 네트워크 계층도 가능), 46보다 작으면 채워서라도 보내야 하고, 1500바이트보다 많으면 데이터그램을 단편화해야함. 목적지 주소(6바이트) : 목적지 어댑터의 MAC주소 출발지 주소(6바이트) : 전송하는 어댑터의 MAC주소 타입 필드(2바이트) : 이더넷으로 하여금 네트워크 게층 프로토콜을 다중화(연계). IP 외의 다른 네트워크 계층 프로토콜을 사용할 수 있음을 의미 순환중복검사(CRC, 4바이트) 프리앰블(8바이트) : 첫 7바이트는 10101010값을 가짐. 마지막 바이트는 10101011이다. 첫 7개의 바이트는 수신 어댑터를 깨우고, 수신자의 클록을 송신자의 클록에 동기화시키는 역할을 한다. 8번째 바이트의 마지막 두 비트(연속으로 오는 1)는 어댑터로 하여금 중요한 것이 오고 있음을 알려준다. d-2-2. 이더넷 특징 비연결형 서비스핸드셰이킹하지 않고 이더넷 프레임에 데이터그램을 캡슐화해서 그 프레임을 랜으로 전송 비신뢰적인 서비스CRC를 통과해도 응답이 없고, 실패해도 응답이 없다. CRC를 실패하면 그냥 수신자가 폐기한다.CRC를 통과했는지 알 방법이 없다.(TCP가 이 역할을 대신한다.) d-3. 링크 계층 스위치스위치는 그 자체가 서브넷의 호스트와 라우터들에게 투명함. 호스트/라우터는 프레임을 스위치가 아닌 다른 호스트/라우터를 목적지로 해서 랜상으로 보내며,중간에 스위치가 프레임을 받아서 다른 노드에게 전달하는 것을 알지 못한다. d-3-1. 스위치의 전달 및 여과여과 : 프레임을 전달할지 혹은 폐기할 지 결정. 전달 : 전송될 인터페이스를 결정하고 해당 인터페이스로 내보내는 것. 여과와 전달은 스위치 테이블을 이용. &lt;MAC 주소, 그 MAC 주소로 가게 하는 스위치 인터페이스, 해당 엔트리가 만들어진 시점&gt; d-3-2. 스위치의 작동 방식목적지 주소 DD-DD-DD-DD-DD-DD를 가진 프레임이 스위치의 인터페이스 X에 도착했다고 가정 목적지 주소에 대한 엔트리가 스위치 테이블에 없을 경우 : 인터페이스 X를 제외한 모든 인터페이스에 프레임 복사본을 보낸다.(브로드캐스트) 목적지 주소가 인터페이스 X에 대한 엔트리가 있는 경우 : 이 경우, 다른 인터페이스를 전달할 필요가 없으며, 프레임을 여과를 실행하여 제거(DD-DD-DD-DD-DD-DD로 보내려면 인터페이스 X를 사용해야 될 경우 잘못된 상황이다.) 목적지 주소가 인터페이스 Y에 대한 엔트리가 있는 경우 : Y에 접속된 랜 세그먼트로 전달 d-3-3. 스위치의 자가학습*플러그앤플레이* 스위치 테이블을 자동으로 동적으로 자치적으로 구축하는 기능 스위치 테이블은 초기에 비어있다. 인터페이스로 수신한 각 프레임에 대해서 다음 정보를 저장한다.a. 프레임의 출발지 주소필드에 있는 MAC 주소b. 프레임이 도착한 인터페이스c. 현재시간 일정시간이 지난 후에도 스위치가 해당 주소를 출발지 주소로 하는 프레임을 수신하지 못하면 테이블에서 삭제한다. d-3-4. 스위치 vs 라우터 라우터 : 네트워크 계층 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 3계층까지 프레임 처리해야함 스위치 : MAC 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 플러그앤 플레이, 2계층까지만 패킷 처리 d-4. 가상 근거리 네트워크(VLAN)트래픽 격리 부족, 사용자 관리, 스위치의 비효율적인 사용을 해결하기 위한 기술. VLAN을 지원하는 스위치는 하나의 물리적 근거리 네트워크 기반 구조상에서 여러 개의 가상 근거리 네트워크들을 정의할 수 있게 한다. d-4-1. VLAN 트렁킹 트렁크 포트를 지정해 트렁크 링크를 통해 다른 스위치로 전달해준다. 프레임이 속한 VLAN을 식별해주는 4바이트 VLAN 태그를 헤더에 덧붙여 어떤 VLAN의 요청인지를 파악한다.(802.1Q) d-4-2. 802.1Q","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"11. 네트워크 계층 제어 평면(ICMP, SNMP)","slug":"cs/network/network11","date":"2021-11-17T11:27:48.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network11/","excerpt":"","text":"a. 인터넷 제어 메시지 프로토콜(ICMP)호스트와 라웉터가 서로 간에 네트워크 계층 정보를 주고받기 위해 사용된다. 대표적으로 인터넷 문제 식별을 할 수 있다. ICMP는 구조적으로 IP 바로 위에 있고 IP 페이로드에 담겨 전송된다. TYPE과 CODE값으로 상태를 구분해 인식한다. a-1. ICMP 메시지 타입 b. 네트워크 관리와 SNMP적절한 비용으로 요규사항을 만족시키기 위해, 네트워크와 구성요소 자원들을 감시, 테스트, 폴링, 설정, 분석, 평가, 제어하는 하드웨어, 소프트웨어, 인간요소 등을 배치하고 통합, 조정하는 것. 관리 서버는 네트워크 관리 활동이 일어나는 장소. 네트워크 관리 정보의 수집, 처리, 분석, 게시를 제어. 피관리 장치는 관리 대상 네트워크에 존재하는 네트워크 장치들. 피관리 장치 내부에는 피관리 객체들이 있다. 피관리 객체는 하드웨어 일부, 소프트웨어 요소에 대한 설정 매개변수들이다. 피관리 장치 내의 피관리 객체들에 관련된 정보들은 MIB에 저장된다. 피관리 장치에는 네트워크 관리 에이전트가 있어 관리 서버와 통신하며, 피관리 장치에 대한 행동을 취하는 프로세스이다. 네트워크 관리 프로토콜은 관리 서버와 피관리 장치들 사이에서 연결. c. SNMP관리 서버와 그 관리 서버를 대표하여 실행되고 있는 에이전트 사이에서 네트워크 관리 제어 및 정보 메시지를 전달하기 위해 사용 SNMP 관리 서버는 에이전트에게 요청을 수신하고 SNMP 에이전트는 이를 수행한 후 요청에 대한 응답을 보냄 에이전트가 요구받지 않았더라도 트랩 메시지를 관리 서버에게 전송. 트랩 메시지는 MIB 객체 값들을 변화시킨 예외 상황의 발생을 통지하기 위해 이용. 출처: https://nongue.tistory.com/165?category=866237 [가자미의 개발이야기]","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"10. 네트워크 계층 제어 평면 (소프트웨어 정의 네트워크(SDN) 제어 평면)","slug":"cs/network/network10","date":"2021-11-17T11:27:39.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network10/","excerpt":"","text":"a. SDN a-1. SDN 구조의 특징 플로우 기반 포워딩 : 스위치들에서 패킷 포워딩은 전송 계층, 네트워크 계층, 링크 계층 헤더의 어떤 값을 기반으로도 가능하다.IP 데이터그램의 포워딩이 온전히 목적지 주소만으로 이뤄지는 전통적 라우터 기반과는 매우 대조적. 데이터 평면과 제어 평면의 분리 : 데이터 평면은 네트워크 스위치로 구성. 이들은 자신의 플로우 테이블의 내용을 기반으로 비교와 실행을 수행. 제어 평면은 서버와 스위치의 플로우 테이블을 결정, 관리하는 소프트웨어로 이뤄진다. SDN의 제어 평면은 SDN 컨트롤러와 네트워크 제어 응용들의 집합으로 이뤄짐 데이터 평면 스위치, 컨트롤러, 네트워크 제어 응용들이 서로 다른 제조사나 기관에서 제공하는 분리된 개체이다. a-2. SDN 컨트롤러와 SDN 네트워크 제어 응용컨트롤러는 크게 세개의 계층으로 구성된다. 통신 계층 : SDN 컨트롤러와 제어받는 네트워크 장치들 사이의 통신컨트롤러와 장치들 사이에 정보를 전달하는 프로토콜.사우스바운드라는 컨트롤러 인터페이스(API)를 넘나는다. 네트워크 전역 상태 관리 계층 : SDN 제어 평면의 궁극적인 제어 결정제어 장치들의 플로우 테이블을 결정. 네트워크 제어 응용 계층과의 인터페이스 : 컨트롤러와 네트워크 제어 응용들과의 상호 작용노스바운드라는 인터페이스를 통해 네트워크 제어 응용들이 네트워크 상태 정보와 플로우테이블을 읽도록 함 논리적으로는 중앙 집중화된 것으로 보이지만, 실제로는 분산된 서버의 집합으로 구현된다. a-2-1. 오픈플로우 프로토콜통신 계층에서 동작하는 프로토콜. 컨트롤러와 스위치(혹은 오픈플로우 api를 구현한 다른 장치)와의 사이에서 동작. TPC 상에서 포트번호 6653을 사용. a-2-1-1. 오픈플로우에서 자주 사용되는 메시지컨트롤러에서 스위치로 전달 되는 주요 메시지 설정 : 스위치의 설정 파라미터를 문의하거나 설정 상태 수정 : 스위치 플로우 테이블의 엔트리를 추가/제거/수정 하거나 스위치 포트의 특성을 설정 상태 읽기 : 스위치 플로우 테이블과 포트로부터 통계 정보와 카운터 값을 요청 패킷 전송 : 스위치의 지정된 포트에서 특정 패킷을 내보내기 위해 사용 스위치에서 컨트롤러로 전달 되는 주요 메시지 플로우 제거 : 어떤 플로우 테이블 엔트리가 시간이 만료 되었거나, 상태 수정 메시지에 대한 결과로 삭제됨을 알림 포트 상태 : 포트의 상태 변화를 알리기 위해 사용 패킷 전달 : 플로우 테이블의 어떤 엔트리와도 일치하지 않는 패킷이나, 작업을 위해 컨트롤러로 패킷을 전달. a-3. 데이터 평면과 제어 평면의 상호 작용 예제 위 예제는 다익스트라 알고리즘이 최단 경로를 위해 사용되는 SDN 예시이다. 라우터별 제어 시나리오와는 두가지 차이점을 가진다. 다익스트라 알고리즘이 패킷 스위치 외부에서 별도의 어플리케이션으로 실행 링크 업데이트 정보를 서로 간이 아닌 SDN 컨트롤러에게 전송한다. 본 예시에서 s1, s2 사이의 링크가 단절되어 플로우 테이블을 수정해야 하는 상황이다. 링크 단절을 감지한 s1이 오픈 플로우의 포트 상태 메시지를 통해 SDN 컨트롤러에 링크 상태 변화를 알린다. SDN 컨트롤러는 링크 상태 관리자에게 알려 링크 상태 데이터베이스를 갱신한다. 다익스트라 링크 상태 라우틍을 담당하는 네트워크 제어 응용은 링크 상태 변화가 있을 경우 알려받도록 이전에 등록해두었다. 이 응용은 링크 상태의 변화를 알게 된다. 링크 상태 라우팅 응용이 링크 상태 관리자와 접촉해 갱신된 링크 상태를 가져와 새로운 최소 비용 경로를 계산한다. 컨트롤러의 플로우 테이블 관리자가 오픈플로우 프로토콜을 사용해 링크 상태 변화에 영향을 받는 스위치들의 플로우 테이블을 갱신한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"9. 네트워크 계층 제어 평면(OSPF, BGP)","slug":"cs/network/network9","date":"2021-11-17T11:27:30.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network9/","excerpt":"","text":"a. OSPFa-1. 자율 시스템 (AS)확장 문제 : 수억개의 라우터가 있는데, 각 라우터의 목적지 라우팅 정볼르 저장하려면 어마어마한 메모리가 필요하다 관리 자치 문제 : ISP는 자신의 네트워크를 원하는대로 운용하거나, 네트워크 내부 구성을 외부에 감추길 원한다. 이를 자율 시스템 (AS)로 해결한다. AS는 동일한 괄리 제어하에 있는 라우터의 그룹으로 구성된다. 이 AS들은 고유한 AS넘버로 구별된다.(ASN) 한 AS안에는 동일한 라우팅 알고리즘을 사용하게 되고, 이를 AS 내부 라우팅 프로토콜이라고 부른다. Intra-AS : AS 내부 프로토콜 Inter-AS : AS 외부 프로토콜 gateway router : 다른 AS와 연결되는 라우터 Inter-AS는 어떤 AS에 갔을 경우 도달할 수 있는 라우터를 자신의 AS 내 라우터들에게 알려주야 한다. a-2. 개방형 최단 경로 우선 프로토콜 (OSPF)intra AS 라우팅 프로토콜의 일종. 다익스트라 알고리즘을 사용하는 링크 상태 알고리즘. 라우터는 링크 상태를 AS 내부 모든 라우터에게 flood. 각 라우터는 전체 AS에 대한 완벽한 토폴로지 지도(즉 그래프)를 얻는다. OSPF는 링크의 가중치 설정 방법에 특정하지 않고, 주어진 링크 가중치에 대해 최소 비용 경로를 결정하는 방법을 제공 모든 링크 가중치를 1로 하여 최소 홉 라우팅을 하거나, 링크 용량에 반비례하는 가중치를 주어 적은 대역폭의 링크 사용을 최소화하는 라우팅을 할 수 있다. 보안 : 인증을 통해 신뢰할 수 있는라우터들만이 AS 내부의 OSPF 프로토콜에 참여 복수 동일 비용 경로 : 한 목적지에 동일한 비용을 가진 여러 경로가 존재할 경우, 이 경로들을 사용할 수 있음 ip 헤더의 Tos 필드를 사용해서 각 링크마다 다양한 cost를 사용할 수 있다. (hop갯수, 대역폭…) 멀티캐스트 라우팅과 유니캐스트 라우팅의 통합 지원 단일 AS 내에서 계층 지원 로컬 area, backbone으로 two-level hierarchy구조. link-state advertisement를 해당 area 안에서 진행. area border router가 area 외부의 라우팅을 책임짐 OSPF 영역은 backbone에 한정됨. boundary router가 외부 AS와 연결 b. ISP간의 라우팅 : BGP(Border Gateway Protocol, 경게 게이트웨이 프로토콜)패킷이 여러 AS를 지나야 할 때 어떻게 처리할 것인가? 모든 AS들은 BGP라고 불리는 Inter AS 라우팅 프로토콜을 사용함. BGP는 CIDR형식으로 표현된 주소의 앞쪽 접두부를 향해 포워딩한다. b-1. BGP의 역할\\1. 이웃 AS로부터 도달 가능한 서브넷 접두부 정보를 얻는다. -나는 존재하고 여기 있습니다. by 서브넷. -BGP는 인터넷의 모든 라우터들이 이 서브넷에 대해 알도록 한다. \\2. 서브넷 주소 접두부로의 가장 좋은 경로를 결정 -BGP의 경로 결정 절차에 따라 좋은 경로를 결정한다. b-2. BGP 경로 정보 알리기BGP의 추상적 연결 그래프 eBGP = 외부 BGP연결 iBGP = 내부 BGP연결 iBGP는 물리적인 링크와 항상 일치하지 않음 이때 x에 대한 도달 가능성 정보를 모든 라우터에게 알리는 작업을 가정해보자. 먼저 AS3이 AS2에게 BGP 메시지를 보내 x가 존재하고 AS3 안에 있음을 알린다. 그 다음 AS2는 AS1에게 “x는 존재하고 x로 가려면, AS2를 거쳐 AS3로 가야함”을 알린다. 이 과정에서 iBGP와 eBGP가 모두 사용된다. b-3. 최고의 경로 설정라우터가 BGP 연결을 통해 주소 접두부를 알릴 때 BGP 속성을 함께 보낸다. 접두부 + BGP 속성 = 경로 (BGP에서는 경로를 이렇게 정의) AS-PATH : 알림 메시지가 통과하는 AS들의 리스트. 메시지의루프를감지하고 방지. NEXT-HOP : AS-PATH를 시작하는 라우터 인테페이스의 IP 주소 이 두가지가 주로 사용. AS1의 라우터들이 라우터 X로 가는 경로가 있다고 할 때, NEXT-HOP은 2a로 향하는 인터페이스 IP 주소이고, AS-PATH는 AS3,X 와 AS2,AS3,X 이렇게 두가지를 광고로 받는다. 여기서 경로 선택은 정책에 따라 달라진다. b-3-1. 뜨거운 감자 라우팅가능한 모든 경로 중, 경로의 시작점인 NEXT-HOP 경로 비용이 최소가 되는 경로가 선택된다. 2d에서 x로 데이터를 보내려 할 때, 2d는 AS1,AS3,X 경로와 AS3,X 경로 두가지를 받는다. AS2 내부 프로토콜을 통해 얻은 라우팅 정보로 가장 적은 비용의 게이트웨이인 2a를 선택한다. 2a로 가는 인터페이스 i를 결정한 이후, 포워딩 테이블에 (i,x) 경로를 추가한다. 위 예시에 따르면 2d는 AS1,AS3,X 경로로 데이터를 전송한다. b-3-2. 경로 선택 알고리즘AS-PATH와 NEXT-HOP 뿐만 아니라 지역 선호도를 BGP 속성에 추가해 경로를 선택하는 라우팅 알고리즘 이때 지역 선호도는 네트워크 관리자의 정책에 따른다. 가장 높은 지역 선호값을 가진 경로를 선택하는데, 여러 개라면 이중 최단 AS-PATH를 가진 경로로 선택한다. 이러고도 여러 경로가 존재하면, 뜨거운 감자 라우팅을 실행해 경로를 선택한다. b-4. 라우팅 정책 A,B,C = 백본 제공자 네트워크 W,X,Y = 액세스 ISP ISP액세스 네트워크로 들어오는 모든 트래픽은 그 네트워크를 목적지로 해야만 한다 ISP액세스 네트워크에서 나가는 트래픽은 그 네트워크 안에서 생성된 것이어야만한다. 이때 X는 두 백본 제공자 네트워크와 연결되어 있는 다중 홈 액세스 ISP이다. X는 과연 어떻게 B와 C간의 트래픽을 포워딩하는것을 방지할 수 있을까? BGP 경로의 알림 방식을 제어함으로 해결된다. X는 B와 C에게 자기 자신을 제외하고는 어떤 다른 목적지로도 경로가 없다고 알림으로써 방지할 수 있다. A, B, C는 당연히 자신이 해도 되지 않을 트래픽(B-C를 지나는 트래픽에 A는 자신의 망을 내놓지 않을 것이다.)을 부담하지 않을 것이다. 이를 위한 규칙은 ISP 백본 네트워크를 통해 흐르는 트래픽은 해당 고객 네트워크를 출발지로 하거나 목적지로 해야한다는 것이다. 이는 iBGP 정책을 활용해 구현될 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"8. 네트워크 계층 :제어 평면(라우팅 알고리즘)","slug":"cs/network/network8","date":"2021-11-17T11:24:54.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network8/","excerpt":"","text":"a. 라우팅 알고리즘라우팅이 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것. 여기서 좋은 경로란 최소 비용 경로를 의미.(비용은 금전적, 시간적, 혼잡 등을 폭넓게 의미) a-1. 라우팅 알고리즘 그래프 라우팅을 표현하는 데 쓰이는 도식. 일반적으로 G=(N, E) 나타냄 N : 노드의 집합, E : 엣지의 집합. 노드는 패킷 포워딩 결정이 이뤄지는 지점인 라우터 엣지는 노드들을 연결하는 물리 링크 c(x, y) 는 노드 x, y간의 비용을 의미한다. 이 값이 무한대면 x와 y가 이웃하지 않는다는 것을 의미 에지 (x, y)가 E에 속하면 노드 y는 노드 x의 이웃 a-2. 중앙 집중형 라우팅 알고리즘(링크 상태 알고리즘)네트워크 전체에 대한 완전한 정보를 가지고 경로의 최소 비용을 계산 라우터들이 이웃에 대한 정보만 알고, 이를 네트워크 내부 라우터들에게 브로드캐스트해서 정보 전달 #브로드캐스트 vs 유니캐스트 유니캐스트는 한 곳에서 출발해서 한 목적지로 도착. 브로드캐스트는 한 곳에서 출발해서 여러 목적지로 도착. a-2-1. 다익스트라 알고리즘.링크 상태 알고리즘(모든 노드의 링크 cost를 알고 있음) D(v) : 목적지 v까지의 최소 비용 경로의 비용 p(v) : v까지 현재 최소 비용 경로에서 v의 직전 노드(v의 이웃) N’: 노드 집합. 어떤 v까지 최소비용 경로가 알려져있으면 v는 N’에 포함 12345678910111213Initialization : #초기화 N&#x27;=&#123;u&#125; #출발지 u for all nodes v: if v is a neighbor of u: then D(v) = c(u,v) else : D(v) = 무한대Loop find w not in N&#x27; such that D(w) is a minimum #N&#x27;에 포함되지 않은 노드 중 최소 경로인 w add w to N&#x27; update D(v) for each neighbor v of w and not in N&#x27;: D(v)=min(D(v), D(w)+c(w,v))until N&#x27; = N 이 방식은 각 노드에 대해서 최소 비용 경로상의 직전 노드를 알게됨. 직전 노드를 반복해서 구하다보면 최소 비용 경로를 구축가능. 이 방식에서 최악의 경우 얼마나 많은 계산이 필요한가? 첫번째 루프에서 출발지 제외 n개를 검사하여 하나를 골라 수행. 두번째 루프에서 n-1개를 검사해 하나를 골라 수행… 이런 식으로 총 n(n+1)/2개를 검사해야 함. 즉 **O(n^2)**의 복잡성을 가짐 하지만 이 방식은 혼잡에 따른 경로 진동이 발생가능. 경로에 골고루 분배되는게 아닌 한쪽에 쏠려서 진행. 1. 초기에 D가 A로 1을 보내려 하고, B가 A로 1을 보내려 하고, C가 A로 e만큼의 트래픽을 보내려 할 때, 경로의 cost가 계산되었다. 2. 1의 결과를 토대로 최소 경로를 다시 찾으면, C-D-A 쪽 링크에 트래픽이 쏠리게 된다. 3. 2의 결과를 토대로 최소 경로를 다시 찾으면, C-B-A 쪽 링크에 트래픽이 쏠리게 된다. 4. 3의 결과를 토대로 최소 경로를 다시 찾으면, C-D-A 쪽 링크에 트래픽이 쏠리게 된다…..이후 무한 반복하게 되겠지? a-3. 분산 라우팅 알고리즘자신과 이웃한 링크에 대한 정보만 가지고 시작. 반복된 계산과 이웃 노드와의 정보 교환을 통해 점차적으로 목적지까지의 최소 비용 경로 계산 a-3-1. 벨만-포트 식x부터 y까지 최소 비용 경로 비용 dx(y) x의 모든 가능한 모든 이웃 v 일때 벨만-포트 식 : **dx(y)= minv{c(x,v) + dv(y)}**이다. 이 식은 라우터들의 엔트리 설정에 도움이 된다. (어떤 지역의 라우터로 가려면 특정 라우터를 사용하는 것이 유리함을 알려줌) a-3-2. 거리 벡터 알고리즘(DV 알고리즘)Dx=[Dx(y): y in N] 노드 x에서 N에 속한 모든 다른 노드 y까지의 비용 추정값의 벡터. DV알고리즘에 의해 노드 x는 다음 정보를 얻게 됨 1. 모든 이웃 노드 v의 비용 c(x,y) 2. 노드 x의 거리 벡터 Dx 3. 이웃 노드들의 거리 벡터. Dv 노드 x가 이웃 w의 거리 벡터를 받으면, 벨만-포트 식을 사용해 자신의 거리 벡터를 수정 비동기적으로 거리 벡터를 교환하다보면, 비용 추정값 Dx(y)가 실제 최소 비용 경로의 비용 dx(y)에 수렴! 1234567891011121314151617Initialization: for all destination y in N: Dx(y) = c(x,y) #y과 이웃이 아니면 c(x,y)는 무한대 for each neighbor w: Dw(y)= ? for all destination y in N for each neighbor w send distance vector Dx = to wLoop wait util I see a link cost change to some neighbor w or until i receive a distance vector from some neigbor w for each y in N: Dx(y)= minv&#123;c(x,v) + Dv(y)&#125;if Dx(y) changed for any destination y: send distance vector Dx to all neighbors forever 링크 비용 변경 시-&gt;자신의 거리 벡터 갱신-&gt;최소 비용거리 비용에 변화시 이웃에 거리 벡터 보냄 a-3-3 링크 비용이 증감에 따른 전파속도의 차이가 존재한다. 감소하는 경우 \\1. y가 가진 정보는 Dy(x)=4, Dy(z)=1, Dz(y)=1, Dz(x)=5이다. \\2. x-y의 링크가 1로 감소함을 y가 인지해 Dy(x)=1 로 수정해 이를 이웃에게 알림 \\3. z는 변경된 벡터를 기반으로 Dz(x)를 5에서 2로 변경 \\4. y는 z로부터 변경된 벡터를 받지만 y의 최소비용은 변화하지 않음. 증가하는 경우 \\1. y가 가진 정보는 Dy(x)=4, Dy(z)=1, Dz(y)=1, Dz(x)=5이다. \\2. x-y의 링크가 60으로 증가함을 y가 인식했을 때, Dy(x)=Dy(z)+Dz(x)=1+5=6이 된다.(여기서 Dz(x)가 5로 설정한건 당연히 잘못된 것이다. 하지만 y는 현 시점에 그를 알아차리지 못한다.) \\3. z는 변경된 벡터를 기반으로 Dz(x)=min{c(z,x), Dz(y)+Dy(x)}를 5에서 7으로 바꾼다. \\4. y는 z로부터 변경된 벡터를 받아 Dy(x)를 6에서 8로 바꾼다.(z가 Dz(x)를 바꿨으니, Dy(x)=Dy(z)+Dz(x)의 값이 변한 것) 다시 z는 y로부터 변경된 벡터를 받아… zyzyzyz…..의 cost가 50=c(z,x)보다 커질 때까지 1~4를 반복한다.(44번 반복되어야 된다.)*(이렇게 테이블이 설정되면 y에서 x로 데이터를 보낼 경우 y는 z로 보내고 z는 y로 보내는 라우팅 루프가 발생한다.!!!!)* a-3-4. 포이즌 리버스(3개 이상의 노드가 참여하는 loop에는 적용 불가)라우팅 루프를 방지하는 방법. 만약 z가 y를 통해서 목적지 x로 가는 경로를 설정 시, z는 y에게 x까지의 거리가 무한대라고 알림. (상대방을 활용하여 특정 목적지로 가는 경우, 상대방이 나에게 특정 목적지에 대한 최소경로를 물으면 무한대라고 알려주기) \\1. y가 가진 정보는 Dy(x)=4, Dy(z)=1, Dz(y)=1, Dz(x)=5이다. \\2. x-y의 링크가 60으로 증가함을 y가 인식하여 Dy(x)를 구할 때, Dy(z)+Dz(x)=1+5무한대 c(y,x)인 60이 Dy(x)가 된다. \\3. z는 변경된 벡터를 기반으로 Dz(x)=min{c(z,x), Dz(y)+Dy(x)}를 50으로 바꾼다. \\4. y는 z로부터 변경된 벡터를 받아 Dy(x)를 60에서 c(y,z)+Dz(x)=1+50=51로 바꾼다. a-4. 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교 링크 상태 알고리즘 거리 벡터 라우팅 알고리즘 메시지 복잡성 n개의 노드, E개의 링크가 있을 때, O(nE)번 메시지를 전송 이웃 노드와 교환함. 여러 요인이 영향을 끼침 수렴 속도 O(nE)개의 메시지가 필요한 O(n^2) 알고리즘 라우팅 루프나 무한 계수 문제가 발생할 수 있음 견고성 경로 계산이 분산되어 진행, 나름 견고함 한 노드의 잘못된 계산이 전체로 확산 가능 a-5. 정적 라우팅 알고리즘, 동적 라우팅 알고리즘정적 : 고정된 기준에 따라 경로 계산(홉 갯수 등) 동적 : 변동하는 가치에 따라 경로 계산(혼잡도)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"7. 네트워크 계층(IP)","slug":"cs/network/network7","date":"2021-11-17T11:21:40.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network7/","excerpt":"","text":"a. IPv4 데이터그램 헤더 버전 번호 : 4비트. 데이터그램의 ip 프로토콜 버전 명시. 헤더 길이 : ip 데이터그램에서 실제 페이로드가 시작되는 곳을 결정.(데체로 헤더는 20바이트) 서비스 타입 : IPv4의 서비스 타입을 구별(실시간 데이터그램인가 아닌가 등) 데이터그램 길이 : 헤더를 포함한 전체 데이터그램 길이 식별자 , 플래그, 단편화 오프셋 : 단편화에 사용됨. TTL : 라우터가 데이터그램을 처리할 때마다 감소. TTL 필드 값이 0이 되면 라우터가 데이터그램을 폐기 프로토콜 : 데이터 부분이 전달될 목적지의 전송 계층의 특정 프로토콜을 명시 헤더 체크섬 : 비트 오류를 탐지. 출발지와 목적지 IP 주소 옵션 데이터(페이로드) b. IPv4 데이터그램 단편화MTU : 링크 계층 프레임이 전달할 수 있는 최대 데이터 양 문제 : 송신지와 목적지 간의 경로를 따르는 각 링크가 다른 링크 계층 프로토콜을 사용할 수 있고 각 프로토콜이 서로 다른 MTU를 가질 수 있게 됨. 해결 : IP 데이터그램의 페이로드를 두 개 이상의 더 작은 IP 데이터그램으로 분할하고 각자 링크 계층 프레임으로 캡슐화. 이렇게 나눠진 데이터그램을 조각(fragment)라고 부른다. 그렇다면 이렇게 나눠진 조각들을 언제 재결합 하는가? =&gt; end system에서 데이터그램 재결합! 목적지 호스트가 받은 데이터그램이 어떤 조각인지 파악하려면? =&gt; 헤더에 식별자, 플래그, 단편화 오프셋을 활용! b-1 식별자, 플래그, 단편화 오프셋식별자는 단편화된 데이터그램끼리는 같은 값을 지닌다. 플래그는 목적지 호스트가 데이터그램의 마지각 조각을 수신했음을 알리기 위한 장치. 마지막 조각은 0을, 아닌 조각은 1을 가짐. 단편화 오프셋는 조각의 분실방지와 순서대로 재결합을 위한 장치. 원본 데이터그램 내에 조각의 시작 위치를 나타냄.(예시에서는 8비트이므로 원본 위치에서 8을 나눈 값을 입력.) c. IPv4 주소체계(서브넷) 인터페이스 = 호스트와 물리적 링크 사이의 경계 십진 표기법 = 32비트 ip주소를 각 바이트를 십진수로 표현하고 각 바이트를 점으로 구별. 모든 호스트와 라우터는 IP 데이터그램을 송수신할 수 있으므로 각 호스트와 라우터 인터페이스가 IP 주소를 갖도록 함. 서브넷 = 인터페이들과 하나의 라우터 인터페이스로 연결된 네트워크 서브넷 마스크 = 32비트 주소 중 서브넷 주소를 가르키는 부분(/24일 경우 왼쪽 24비트가 서브넷 주소임) 네트워크 마스크 = 255.255.255.0 (이 네트워크 마스크와 and 연산을 하게 되어 나타나게 되는 주소가 서브넷) 하지만 서브넷은 여러 호스트를 라우터 인터페이스에 연결하는 것만을 의미하진 않음. 각 서브넷은 호스트나 라우터에서 각 인터페이스를 분리하여 생긴 고립된 네트워크를 의미. d. 클래스 주소체계클래스 주소체계 : ip 주소의 네트워크 부분을 8, 16, 24비트로 제한. 해당 서브넷 주소를 갖는 서브넷을 A, B, C 클래스 네트워크로 분류. 하지만 서브넷의 주소넷 부족 현상. 호스트 id 낭비 발생. e. CIDRip가 십진수 형태의 a.b.c.d/x로 표현. 이때 x는 ip주소의 네트워크 부분을 표시하며 프리픽스라 함. 따라서 x는 네트워크 id 32-x는 호스트 id를 담당. 라우터가 CIDR을 찾아갈때 포워드 테이블의 네트워크 마스크와 and 연산을 하여 목적지와 일치하는 prefix가 가장 길게 일치하는 것과 연결. e-1 CIDR 경로 집약여러 네트워크를 알리기 위해 하나의 네트워크 접두사를 사용하는 것. ex)32비트의 ip 주소를 할당하는 과정을 지켜보자. 먼저 8개의 조직을 가진 곳에 ip를 할당해야 된다고 가정하자. 이때 a라는 ISP가 큰 인터넷 연결을 위해 할당받는다. 현재 예시에서는 20비트를 할당받는다 하자. 그러면 우리는 자체 서브넷을 x.y.z.0/20으로 표현 가능하다. 그렇다면 이 조직들이 어떤 ip를 할당 받았는지를 알려야한다. 근데 이를 굳이 일일히 굳이 이 서브넷의 조직이 8개임을 굳이 알릴 필요가 없개된다. 그냥 x.y.z.0/20으로 표현해도 일맥상통한다. 즉 주소가 더 간편해졌다.(경로 집약되었다.) Fly-By-Night-ISP가 200.23.16.0/20만 알려도 된다. 이때 만약 어떤 조직이 다른 ISP로 연결되야 되는 경우는 어떻게 될까? 다른 ISP는 이제 자신의 서브넷 뿐만 아니라 자신에게 옮겨온 조직의 ip도 알려야한다. f. 특별한 IP주소0.0.0.0 = 새로운 호스트가 DHCP 서버에 주소 할당 요청할 때 255.255.255.255= 해당 네트워크의 모든 호스트가 수신. 해당 서브넷에서는 사용. 외부로는 전달 x 127.x.y.z = 네트워크 계층에서 하위로 전달하지 말고 다시 상위 계층으로 보내라는 의미. 사설아이피 : 해당 서브넷에서만 사용되는 아이피 directed broadcast adress : 라우터가 broadcast 해야할 때. 라우터의 네트워크 마지막 주소로 x.y.z.255 network address : 네트워크 블록에서 맨 처음 주소로. x.y.z.0 g. 동적 호스트 구성 프로토콜 (DHCP)자동으로 호스트에 IP 주소를 할당하는 기능. 각 서브넷은 DHCP 서버를 갖는다. DHCP 서버가 없는 서브넷은 DHCP 연결 에이전트(라우터)가 DHCP 서버 주소를 알려줘 DHCP를 이용할 수 있게한다. UDP 포트넘버 67을 사용 DHCP discover : DHCP 서버가 있나요? -DHCP 발견 메시지를 포함하는 IP 데이터그램을 서브넷에 연결된 모든 노드로 브로드캐스팅 -목적지 IP 주소를 255.255.255.255, 출발지 IP 주소를 0.0.0.0로 설정해서 브로드캐스팅 DHCP offer : 제가 DHCP서버입니다! 당신이 쓸 수 있는 IP주소를 드립니다. -DHCP 제공 메시지를 ip브로드캐스트 주소(255.255.255.255)로 서브넷에 모든 노드로 브로드캐스팅 -메시지에는 발견 메시지의 트랜잭션 ID, 클라이언트에 제공된 IP 주소, 네트워크 마스크, IP 주소 임대 기간을 포함 -여러 DHCP 서버가 ip를 제공할 경우 최적의 위치에 있는 서버를 선택 DHCP request : 좋아요 이 주소로 할게요! -받은 ip주소와 임대 기간을 확인차 전송 DHCP ack : 좋아요 이 주소 쓰시면 돼요! -요청된 파라미터를 확인차 전송 h. 네트워크 주소 변환 (NAT)ip 주소 할당량이 부족해지는 상황이 발생하면 어떻게 해결해야될까? NAT를 활용하여 사설 ip를 할당하는 것. NAT 가능한 라우터에 의해 public ip와 사설 ip가 나눠져 있는 걸 알 수 있다. 이때 NAT을 활용하는 라우터는 외부에서는 라우터가 아닌 하나의 IP 주소를 가지는 하나의 장비로 인식된다. 홈 네트워크의 여러 ip주소들은 DHCP로 할당받는다. 홈 네트워크 내부에 있는 장비들은 포트번호로 구별한다. 포트번호는 홈네트워크에서 전송할 때 NAT 변환 테이블로 할당한다. 하지만 외부의 클라가 NAT 안에 있는 서버에 접근할 수 없게 된다.(NAT 변환테이블은 NAT에서 데이터 보낼 때 할당되므로) \\1. NAT 변환 테이블에 필요한 포트를 미리 써놓기? =&gt; 유지보수가 힘들어진다. \\2. NAT 변환 테이블에 장치를 자동으로 등록 \\3. relay방식. 중간에 전달 서버를 만들어 중간 서버가 NAT 내부 IP와 포트번호 전달. i. IPv6IPv4의 32비트 주소 공간이 빠르게 고갈되어 등장한 128비트 프로토콜 간소한 헤더를 사용해 더 빨리 처리하도록 했다. 트래픽 클래스 : 특정 응용 프로그램의 우선 순위 부여 흐름 라벨 : 데이터그램 흐름을 인식 다음 헤더 : 전송 프로토콜을 구분 TCP, UDP 홉 제한 : 라우터가 데이터그램을 전달할 때마다 1씩 감소. 0보다 작아지면 데이터그램을 버림 IPv4에서 IPv6으로 전환하는 터널링. IPv6 사이에 있는 IPv4 라우터들을 터널로 칭함. IPv6의 데이터그램을 IPv4 데이터그램의 필드에 넣는다. j. 소프트웨어 기반 네트워크 SDN각 패킷 스위치의 검색 추가 작업 테이블을 보여주며 테이블은 원격 컨트롤을 통해 계산, 설치 및 업데이트 각 라우터마다 가지고 있는 플로우 테이블을 통해 다양한 행동을 취한다. 헤더세트와 일치하는 패캣을 카운터 세트에 업데이트하고 플로우 테이블 요소와 일치하면 행동을 처리 match+action : 서로 다른 종류의 장비를 통일 라우터 match = longest IP prefix + action = forward out a link 스위치 match = 목적지 MAC 주소 + action = forward or flood 방화벽 match = ip 주소와 TCP UDP 포트번호 + action = 수용 혹은 거부 NAT match = IP 주소와 포트 + action = 주소와 포트를 재작성","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"네트워크 면접 대비 스터디","slug":"cs/network/networkinterview","date":"2021-11-17T11:01:24.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/networkinterview/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/networkinterview/","excerpt":"","text":"1주차 1주차TCP/IP를 4계층으로 분석하라링크 계층OSI 7 계층에서 물리계층과 데이터링크 계층링크 계층은 기본적으로 프로토콜을 정의하고, 물리적 영역을 표준화.매체 접속 제어(MAC) 프로토콜이 링크상의 프레임 전송 규칙을 제어한다.(링크 접속 제어) 특히 RDT(신뢰적 전달)을 제공하는데, 전송 계층에도 RDT를 제공하지만 링크 계층에서도 제공하는 이유는,네트워크 계층인 IP에서 best effort로 인해 데이터 손실이 일어날 수 있기 때문. ARP (ip주소로 mac주소를 알아오는 거) -&gt; 홉단위로 ARP 인터넷 계층(네트워크 계층) (IP)IP는 경로를 알려주는 역할을 한다. IP는 비연결 지향이고 신뢰할 수 없는 프로토콜.그래서 링크 계층이나 전송 계층에서 RDT 를 확보해야 한다. 8비트 씩 4개로 32비트 주소체계를 가짐.255.255.255.255 이런 식으로 십진수로 표기함. CIDR 주소체계x.y.z.0/a 이렇게 뒤에 prefix를 표기하는데, 앞에서 프리픽스까지는 네트워크 id를 의미함.32-a는 호스트 id가 됨. NATip 주소가 부족해 지는 상황에서 로컬 네트워크는 사설 ip를 할당하는 것.외부에서는 포트 번호를 활용하여 각 ip에 접근 가능하다. IP, ARP, RARP, ICMP, OSPF※ ICMP : 패킷정보 실패시 ERROR를 알리거나 해결 가능한 힌트를 제공하며, 주로 ping, traceroute를 할때 사용됩니다. 전송 계층(TCP/UDP)데이터를 실제 송수신하는 역할. 네트워크 계층은 어떤 경로로 메시지를 전달하지를 결정전송 계층은 도착한 메시지를 어떻게 처리 할 것인지 결정(엔드시스템에 존재.) UDP는 비교적 간단하지만, 비연결 지향이고, 신뢰성없고, 순서가 뒤죽박죽으로 전달된다.핸드쉐이킹도 하지 않고, 상대편이 어떤 상태인지 관심없다.비트 손상이 일어날 수 있으나, 딜레이는 비교적 적은 편.(비디오, 오디오 서비스에서 활용.) TCP는 신뢰성있고 순서대로 전송을 지원하지만, 비교적 복잡한 과정을 거침(그래서 IP와 함께 사용.)한 연결에 한 리시버와 한 센더가 참여하고, 양방향 데이터 흐름을 가진다.연결 지향이라 핸드쉐이킹을 가지고(3way) 센더와 리시버의 상태 정보를 기억한다.센드 버퍼와 리시브 버퍼가 있어서 처리 속도가 전송 속도보다 느릴 경우 속도 조절(흐름제어). TCP 혼잡제어 방식 : AIMD(최소단위로 시작해서 하나씩 늘려서 보냄. 혼잡 발생시 기존 전송량의 절반을 보냄)와 slow start(최소단위부터 시작해서 2^n씩 늘려서 보냄. 혼잡 발생시 AIMD방식으로 제어) 소켓은 두 프로그램(프로세스)이 통신하기 위해 양 쪽에 생성되는 링크 단자(인터페이스)소켓은 어플리케이션 계층과 전송 계층 사이의 인터페이스.UDP, TCP 여부에 따라 소켓에 필요한 정보가 달라진다. 소켓 API 흐름클라이언트 : 소켓 열기(socket) -&gt; 서버에 연결 요청(connect) -&gt; 데이터 송수신(send, recv) -&gt; 연결 종료(close)서버 : 소켓 열기(socket) -&gt; IP주소와 포트 번호를 소켓에 결합(bind) -&gt; 연결 요청 대기(listen) -&gt; 요청이 오면 수락한 후 소켓 연결(accept) -&gt; 데이터 송수신(send, recv) -&gt; 연결 종료(close) 어플리케이션 계층서버와 클라이언트를 구현하는 계층(?)이 과정에서 데이터 송수신의 규칙이 만들어짐.(네트워크서비스, 메일서비스, 웹서비스 등 표준적인 인터페이스)OSI 7계층에서 세션, 프레젠테이션, 애플리케이션 계층에 해당HTTP, FTP, Telnet, DNS, SMTP 서버는 항상 연결되어 있고 고정적인 IP 주소를 가짐. 클라이언트의 요청에 대한 응답을 하는 곳.클라이언트는 간헐적으로 연결하고, 동적인 IP 주소를 가진다.(이동하는 경우), 통신의 시작점. TCP의 3(4) way handshaking에 대해 설명하라TCP 연결에서 데이터를 주고받기 이전에 서로가 준비 됐음을 확인하는 절차. SYN : 연결요청 플래그FIN : 연결중단 플래그ACK : 요청확인 플래그Seq : 시퀀스 통신을 시작할 때(3 way handshaking) 클라이언트가 자신의 seq를 x로 설정하고, SYN = 1, Seq=x를 헤더에 담아 서버에 보낸다.(저는 x부터 시작할 거고요, 연결을 원합니다.) LISTEN중이던 서버는 요청을 받으면, 자신의 seq를 y로 정하고,SYN =1 , Seq = y, ACK = 1, ACKnum = x+1을 헤더에 담아 보낸다.(잘 받았습니다. 저는 y부터 시작할 거고요, 저도 연결을 원합니다. ) 클라이언트는 서버의 응답을 듣고,ACK = 1, ACKnum = y+1를 헤더에 담아 서버의 응답을 확인했다고 전한다.(확인했습니다.) 통신을 끝낼 때(4 way handshaking) 클라이언트가 소켓을 닫고, FIN = 1, seq = x를 담아 전달 (제 x번째 요청은 통신을 끝내는 거에요.) 이제 클라이언트가 더는 데이터를 보낼 순 없지만 받을 순 있다.그리고 서버는 아직 연결을 종료하지 않았다. 서버는 ACK =1, ACKnum = x+1을 담아 보낸다.(서버는 여전히 데이터를 보낼 수 있다.)(일단 알겠습니다. 제가 보내야할 일을 끝내면 저도 통신 끝낼게요.) 클라이언트는 서버의 ACK를 통해 자신의 종료 요청을 전달된 것을 알게되고,이제 서버가 남은 일을 모두 끝낼 때까지 기다린다. 서버는 데이터를 모두 보내고 나면, FIN = 1, seq = y를 보낸다.(저도 이제 남은 일 다 끝났습니다. 이제 연결을 끝내죠.)이제 서버도 데이터를 보낼 수 없게 된다. 클라이언트는 서버의 종료 요청을 듣고, ACK =1 , ACKnum=y+1을 보낸다.(알겠습니다. 연결을 종료합니다.) 이때 중요한건, 자신의 ACK요청이 잘 전달됐는지를 확인하기 위해서 잠시동안 대기한다.ACK 요청이 전달되지 않으면 재전송해야 될 수 있기 때문이다.대기 후 연결을 종료한다. 난수인 seq를 보내는 이유 서버 측에서 패킷의 seq를 보고 패킷을 구분.난수로 보내야 패킷을 혼동없이 구분할 수 있음.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"스프링 프레임워크의 기본 개념 정리 (POJO, Ioc/DI, AOP)","slug":"spring/spring1","date":"2021-11-15T02:44:25.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/11/15/spring/spring1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/15/spring/spring1/","excerpt":"","text":"스프링 프레임워크의 기본 개념 정리 (POJO, Ioc/DI, AOP)POJO포조는 plane old java object란 의미인데, 필자도 처음에 이게 뭔 소린지 잘 이해가 안갔다.쉽게 말하면, 기본 자바의 기능 외에 다른 클래스를 사용하지 말자는 뜻이다.클래스나 메소드 시그니처를 개발자가 필요한 대로 만들어서 사용하자는 의미다. 서블릿으로 자바 웹 애플리케이션을 만들면, 서블릿의 구조를 따라서 만들어야 한다.예를 들면 이런 식이다. POJO가 아닌 경우123456789101112131415161718public class DeleteBoardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String seq = request.getParameter(&quot;seq&quot;); BoardVO vo = new BoardVO(); vo.setSeq(Integer.parseInt(seq)); BoardDAO boardDAO = new BoardDAO(); boardDAO.deleteBoard(vo); RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;getBoardList.do&quot;); dispatcher.forward(request, response); &#125;&#125; 자세히 보면 HttpServlet이라는 클래스를 상속하고,service 메소드를 오버라이딩해서 그 안에 비즈니스 로직을 작성하고 있다. 이때 비즈니스 로직에는 response 객체가 사용되지 않는다.(포워딩할 때만 사용된다.)그럼에도 불구하고 service 메소드의 고정적인 구조로 인해 response를 인수로 가져와야 한다. POJO는 이런 불필요한 구조를 탈피해서,개발자가 본인에게 필요한 비즈니스 로직을 구현할 때 필요한 만큼의 기본 자바 객체만 사용하도록 한다. POJO를 지키면 이런 식이 될 것이다. POJO인 경우12345678910111213@Controllerpublic class Cont&#123; @RequestMapping(&quot;/hello/&#123;seq&#125;&quot;) public String helloController(@PathVariable int seq)&#123; BoardVO vo = new BoardVO(); vo.setSeq(seq); BoardDAO boardDAO = new BoardDAO(); boardDAO.deleteBoard(vo); return &quot;getBoardList.do&quot;; &#125;&#125; IoC/DI 제어의 역전/의존성 주입Ioc 제어의 역전제어의 역전은 그냥 쉽게 말하면 이제 객체를 스프링 컨테이너라는 녀석이 한다는 의미다.(컨테이너는 나중에 더 알아보자.) 123456789101112131415161718192021@Controllerpublic class UserController &#123; @Autowired private UserService userService; @Autowired private AuthenticationManager authenticationManager; @GetMapping(&quot;/auth/joinForm&quot;) public String joinForm()&#123; return &quot;/user/joinForm&quot;; &#125; @GetMapping(&quot;/auth/loginForm&quot;) public String loginForm()&#123; return &quot;/user/loginForm&quot;; &#125; .... &#125; 스프링으로 작성된 컨트롤러의 일부 예시다.보면 @Autowired라는 어노테이션을 볼 수 있다. 이는 해당 변수에 스프링 컨테이너가 관리하고 있는 객체 중 적절한 것을 할당해달라는 의미이다.(좀 어려운 말로는 의존성을 주입한다고도 말한다.) 개발자가 일일히 객체를 싱글톤으로 만들어서 그 싱글톤 객체를 직접 불러와서 변수에 할당할 필요 없다는 의미다.스프링 컨테이너가 알아서 객체를 싱글톤으로 메모리에 로딩시켜놓고, 개발자가 요청하면 스프링 컨테이너가 알아서 할당해줄 것이다. DI 의존성 주입일단 이 어려운 용어를 이해하기 전에 의존성이 뭔지 좀 알아보자. 검색을 해보면 “A가 동작하기 위해서 B가 반드시 필요한 경우, A는 B에 의존한다.” 라는 의미인데,우리가 바로 위에 썼던 예시를 보면, UserService, AuthenticalManager라는 객체 두 개가 UserController 객체에 사용된다. 즉 UserController 객체는 이 두 객체에 의존한다는 의미다. 그런데 의존하려면, 두 객체가 필요하다.예시에서는 참조변수만 쓰여있다. 만약 객체를 가져오려면, 직접 new해서 객체를 만들거나,메모리 상에 있는 해당 객체를 직접 가져와야 할 텐데, 스프링에서는 스프링 컨테이너가 메모리 상에 있는 객체를 가져와서,해당 레퍼런스 변수에 할당해, 의존 관계를 만들어 준다는 의미다. 즉, 클래스 외부에서 적절한 객체를 찾아와서 해당 클래스와 의존성을 갖도록 주입한다는 의미다!! 스프링에서 의존성 주입하는 여러가지 방법 어노테이션 활용하기 @Autowired 레퍼런스 변수 위에 @Autowired 어노테이션을 붙이면 알아서 의존성이 주입된다.다만, 주입을 하기 전에 컴포넌트 스캔을 해야 한다. 12&lt;!-- 해당 패키지 하위에 있는 모든 어노테이션을 검사 --&gt;&lt;context:component-scan base-package=&quot;com.fastcampus.biz&quot;/&gt; xml 태그 활용하기 다음과 같이 xml에 빈등록 되어 있다고 하자.(web.xml이나 컨텍스트 xml) 123&lt;bean id=&quot;indexService&quot; class=&quot;com.baeldung.di.spring.IndexService&quot; /&gt; IndexService라는 클래스를 스프링이 관리하는 객체(빈)로 등록했다.이제 이 객체를 IndexApp이라는 클래스에서 사용하고자 한다고 가정해보자. a. 생성자로 의존성 주입하기 12345&lt;bean id=&quot;indexApp&quot; class=&quot;com.baeldung.di.spring.IndexApp&quot;&gt; &lt;constructor-arg ref=&quot;indexService&quot; /&gt;&lt;/bean&gt; 생성자로 레퍼런스 변수를 초기화 할 수 있다.IndexApp이 빈으로 등록 될 때, 설정한 대로 객체를 주입시켜서 객체 생성될 것이다. b. 프로퍼티로 의존성 주입하기 12345&lt;bean id=&quot;indexApp&quot; class=&quot;com.baeldung.di.spring.IndexApp&quot; &gt; &lt;property name=&quot;service&quot; ref=&quot;indexService&quot; /&gt;&lt;/bean&gt; 프로퍼티 태그로 해당 레퍼런스 변수에 의존성 주입할 수 있다.다만 setter메소드가 정의되어 있어야 한다. AOP 관점 지향 프로그래밍AOP를 이해하기 위해서는 일단 관점(Aspect)를 이해해야 한다. 요청을 처리할 때, 핵심 비즈니스 로직외에도 필요한 여러가지 공통된 처리가 있다.사용자가 권한이 있는지… 요청이 제대로 된 경우 사후처리 등… 이제 비즈니스 로직에 해당하는 메서드와 이런 공통된 처리들을 따로 분리해서 관리하자는게 시작이다.(관심 분리)그래야 개발자가 비즈니스 로직에 집중할 수 있고, 중복된 코드 작성도 줄어들 것이다. 개발자가 호출한 모든 핵심 비즈니스 로직 메서드를 조인 포인트 라고 한다. 조인 포인트 중 개발자가 필터링한 비즈니스 로직 메서드를 포인트 컷이라고 한다. 일괄적으로 적용해줘야하는 공통 처리는 어드바이스라고 한다.(어드바이스는 적용시기나 종류에 따라 다섯가지로 나뉜다.) 모듈들의 공통 처리를 담당하는 어드바이스 와 특정 모듈의 핵심 비즈니스 로직인 포인트컷 을 결합(위빙)한 것을 Aspect 라고 한다. AOP 구현 하기AOP 구현도 어노테이션 방법과 xml 태그 방법 두가지로 구현 가능하다. xml 태그로 AOP 구현 일단 어드바이스가 구현된 클래스를 먼저 구현하자(어라운드어드바이스를 예시이다.) 12345678910111213141516public class AroundAdvice &#123; public Object aroundLog(ProceedingJoinPoint jp) throws Throwable &#123; // JoinPoint를 상속한 ProceedingJoinPoint를 이용하면 클라이언트가 호출한 비즈니스 메소드 정보를 알 수 있다. String method = jp.getSignature().getName(); Object returnObj = null; StopWatch watch = new StopWatch(); watch.start(); // 실제 클라이언트가 호출한 비즈니스 메소드가 실행되는 시점 returnObj = jp.proceed(); watch.stop(); System.out.println(method + &quot;() 메소드 수행에 소요된 시간 : &quot; + watch.getTotalTimeSeconds() + &quot;(초)&quot;); return returnObj; &#125;&#125; 이때 주목할 점은 ProceedingJoinPoint jp를 매개변수로 받는다는 점이다.(이는 Around 어드바이스만의 특징이다. 다른 종류의 어드바이스는 JointPoint 객체를 매개변수로 받는다.) 그리고 어드바이스를 빈 등록한다. 123&lt;!-- 횡단관심(어드바이스)에 해당하는 클래스를 bean 등록한다 --&gt;&lt;bean id=&quot;AroundAdvice&quot; class=&quot;com.fastcampus.biz.common.BeforeAdvice&quot;/&gt;&lt;bean id=&quot;afterThrowing&quot; class=&quot;com.fastcampus.biz.common.AfterThrowingAdvice&quot;&gt;&lt;/bean&gt; 그리고 AOP 설정을 해준다. 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id=&quot;allPointcut&quot; expression=&quot;execution(* com.fastcampus.biz..*Impl.*(..))&quot;/&gt; &lt;aop:aspect ref=&quot;beforeAfter&quot;&gt; &lt;aop:before pointcut-ref=&quot;allPointcut&quot; method=&quot;beforeLog&quot;/&gt; &lt;aop:after-returning pointcut-ref=&quot;getPointcut&quot; method=&quot;afterLog&quot; returning=&quot;returnObj&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;afterThrowing&quot;&gt; &lt;aop:after-throwing pointcut-ref=&quot;allPointcut&quot; method=&quot;exceptionLog&quot; throwing=&quot;exceptionObj&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;around&quot;&gt; &lt;aop:around pointcut-ref=&quot;allPointcut&quot; method=&quot;aroundLog&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 이때 주목할 점은, 포인트컷을 정의하고, 애스펙트를 어드바이스와 포인트컷을 연결해준다. 어노테이션으로 AOP 구현하기 일단 어노테이션으로 하려면 다음 태그를 추가해야한다. 1&lt;aop:aspectj-autoproxy/&gt; 이제 포인트컷을 설정해보자(@Aspect를 붙여주자.)어노테이션 기반에서는 클래스를 만들어서 포인트컷을 설정할 수 있다. 1234567891011121314@Aspectpublic class BoardPointcut &#123; @Pointcut(&quot;execution(* com.fastcampus.biz..*Impl.*(..))&quot;) public void allPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz..*Impl.get*(..))&quot;) public void getPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz.board.*Impl.*(..))&quot;) public void boardPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz.user.*Impl.*(..))&quot;) public void userPointcut() &#123;&#125;&#125; 그러면 어드바이스를 다음과 같이 작성할 수 있다.@Service로 빈등록을 처리하고, @Aspect로 애스팩트 등록을 할 수 있다.자세히보면, 어노테이션으로 어드바이스 종류를 선언하고 포인트컷을 매개변수로 넣어준다. 123456789101112131415161718192021@Service@Aspect // Aspect = Pointcut(핵심 관심) + Advice(횡단 관심)public class AroundAdvice &#123; @Around(&quot;BoardPointcut.allPointcut()&quot;) public Object aroundLog(ProceedingJoinPoint jp) throws Throwable &#123; // JoinPoint를 상속한 ProceedingJoinPoint를 이용하면 클라이언트가 호출한 비즈니스 메소드 정보를 알 수 있다. String method = jp.getSignature().getName(); Object returnObj = null; StopWatch watch = new StopWatch(); watch.start(); // 실제 클라이언트가 호출한 비즈니스 메소드가 실행되는 시점 returnObj = jp.proceed(); watch.stop(); System.out.println(method + &quot;() 메소드 수행에 소요된 시간 : &quot; + watch.getTotalTimeSeconds() + &quot;(초)&quot;); return returnObj; &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[]},{"title":"8. 상태 패턴","slug":"java/design-pattern/dp8","date":"2021-11-13T06:34:25.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/11/13/java/design-pattern/dp8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/13/java/design-pattern/dp8/","excerpt":"","text":"상태 패턴객체의 특정 상태에 따라 객체의 행동이 달라지는 상황에서,객체의 상태를 본인이 체크해서 행동을 달리하는 것이 아니라,상태를 객체화해서 상태가 행동을 책임지도록 위임하는 패턴. 특정 상태를 캡슐화하는 인터페이스를 선언하고,원래 객체에서 해당 인터페이스를 구성하도록 설계한다. 상태 인터페이스를 구현한 여러 상태 객체들을 만들어서 활용한다. 활용 예시자동차에는 여러 주행 모드가 있다.우리가 설계하는 자동차 객체는 일반모드와 터보모드가 있다. 123456//자동차의 역할을 캡슐화하는 자동차 인터페이스public interface Car &#123; void drive(); void stop(); void setState(BasicCarState state);&#125; 이제 자동차 인터페이스를 구현해보자.이때 중요한건 자동차의 상태를 구성하는 방식으로 구현체를 설계해야 한다. 12345678910111213141516171819202122//자동차 인터페이스를 구현한 기본자동차 구현체public class BasicCar implements Car&#123; private BasicCarState state; public BasicCar()&#123; state = NormalState.getInstance(); &#125; @Override public void drive() &#123; state.driveState(this); &#125; @Override public void stop() &#123; state.stopState(this); &#125; @Override public void setState(BasicCarState state) &#123; this.state = state; &#125;&#125; 이제 자동차의 모드(상태)를 객체로 만들어보자.일단 자동차의 모드와 관련된 행동을 캡슐화하자. 12345//기본 자동차의 상태를 캡슐화하는 인터페이스public interface BasicCarState &#123; void driveState(Car car); void stopState(Car car);&#125; 캡슐화한 인터페이스를 구현해서 모드들을 만들어보자.필자는 상태 객체를 싱글톤으로 처리했다. 12345678910111213141516171819202122public class NormalState implements BasicCarState&#123; private static NormalState normalState; private NormalState()&#123;&#125;; public static BasicCarState getInstance()&#123; if(normalState==null)&#123; normalState = new NormalState(); &#125; return normalState; &#125; @Override public void driveState(Car car) &#123; System.out.println(&quot;Start Normal process...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Normal process...&quot;); &#125;&#125; 123456789101112131415161718192021public class TurboState implements BasicCarState&#123; private static TurboState turboState; private TurboState()&#123;&#125; public static BasicCarState getInstance()&#123; if(turboState==null)&#123; turboState= new TurboState(); &#125; return turboState; &#125; @Override public void driveState(Car car) &#123; System.out.println(&quot;Start Turbo process...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Turbo process...&quot;); &#125;&#125; 이제 우리가 설계한 자동차 객체를 실험해보자. 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Car avante = new BasicCar(); avante.drive(); avante.stop(); avante.setState(TurboState.getInstance()); avante.drive(); avante.stop(); &#125;&#125;/*Start Normal process...Stop Normal process...Start Turbo process...Stop Turbo process...*/ avante의 상태를 바꾸니 아반떼의 행동이 달라졌다. 상태 패턴과 전략 패턴의 차이점? 상태 패턴은 객체의 상태를 캡슐화해서 객체로 관리하는 패턴이다.이 상태는 원래 객체의 다른 행동에 영항을 미친다. 전략 패턴은 객체의 특정 행동(특히 행동을 수행하는 방식이 달리질 가능성이 많은 행동)을독립적으로 구성하는 패턴이다. 사실 실사용에서는 매우 비슷하게 보이지만,상태는 원래 객체의 다른 행동에도 큰 영향을 미치지만,전략은 변하기 쉬운 행동을 독립적으로 구성하는 것이라고 파악하자. 더 나아가기이번엔 활용 예시를 더 발전시켜보자. 자동차 객체에 연료 필드를 추가해 연료에 따라 자동차의 주행모드를 동적으로 변환시켜서 운행시켜보자. 먼저 자동차 추상 클래스를 만들어보자. 12345678910public abstract class Car &#123; public int fuel; public CarState carState; public abstract void drive(); public void setCarState(CarState carState)&#123; this.carState = carState; &#125;&#125; 자동차에 남은 연료를 표시하는 fuel필드가 추가됐고, setter 메서드를 구현해놨다. 이제 자동차의 다양한 주행 모드를 추상화하는 인터페이스를 만들어보자. 1234public interface CarState &#123; void driveState(Car car); void stopState(Car car);&#125; 주행모드로 주행하고 주행모드를 멈추는 역할 두가지를 수행한다.이제 다양한 주행모드를 구현해서 만들어보자. 1234567891011121314public class NormalState implements CarState&#123; final int fuelPerHour = 10; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive NormalState...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop NormalState...&quot;); &#125;&#125; 1234567891011121314public class TurboState implements CarState&#123; final int fuelPerHour = 40; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive Turbo state...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Turbo state...&quot;); &#125;&#125; 1234567891011121314public class EcoState implements CarState &#123; final int fuelPerHour = 3; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive EcoState...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Eco State...&quot;); &#125;&#125; 이 상태는 연료소비량을 나타내는 fuelPerHour를 상수로 가지고 있고,각 메서드를 구현했다. 이제 자동차 추상 클래스를 상속받은 클래스를 만들어서,drive 메소드를 구현해보자. 우리는 자동차 객체에 남은 연료량에 따라 동적으로 주행모드를 변화시키고 싶다. 1234567891011121314151617181920public class BasicCar extends Car&#123; public BasicCar()&#123; this.fuel = 100; this.carState = new NormalState(); &#125; @Override public void drive() &#123; if(fuel&lt;15&amp;&amp; ! (carState instanceof EcoState))&#123; carState.stopState(this); this.setCarState(new EcoState()); &#125; else if(fuel&gt;15 &amp;&amp; fuel&lt;80&amp;&amp; ! (carState instanceof NormalState))&#123; carState.stopState(this); this.setCarState(new NormalState()); &#125; else if(fuel &gt; 80 &amp;&amp;! (carState instanceof TurboState))&#123; carState.stopState(this); this.setCarState(new TurboState()); &#125; carState.driveState(this); &#125;&#125; 이제 마지막으로 테스트를 해보자. 123456789public class Test &#123; public static void main(String[] args) &#123; Car avante = new BasicCar(); avante.setCarState(new TurboState()); while(avante.fuel&gt;0)&#123; avante.drive(); &#125; &#125;&#125; 12345678910111213//실행결과Drive Turbo state...Stop Turbo state...Drive NormalState...Drive NormalState...Drive NormalState...Drive NormalState...Drive NormalState...Stop NormalState...Drive EcoState...Drive EcoState...Drive EcoState...Drive EcoState... 실행결과를 보면 자연스럽게 자동차 주행 모드를 변화시키는 것을 알 수 있다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"운영체제 스터디 및 실습! 1주차!","slug":"cs/os/linuxstudy1","date":"2021-11-08T21:50:37.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/09/cs/os/linuxstudy1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/09/cs/os/linuxstudy1/","excerpt":"","text":"시스템콜이란 무엇일까?위키백과에 따르면, 운영 체제의 커널이 제공하는 서비스를 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스를 의미한다.쉽게 풀어쓰면 응용 프로그램에서 커널의 서비스를 사용하는 방법이 시스템콜이다. 운영체제의 커널이 제공하는 함수를 어플리케이션이 요청에 따라 적절한 커널 함수를 실행시켜주는 역할을 한다.어플리케이션은 커널 자원에 맘대로 접근하면 안되니, 시스템콜을 호출해서 커널 함수를 호출시키고, 커널 함수로 자원을 요청할 수 있다. 시스템콜 분석하기커널 소스를 분석하려면 원래 vim에 ctags와 cscope를 붙여서 분석하는게 정석이라고 한다. 하지면 이번엔 간단하게 다음 사이트에서 리눅스 소스코드를 확인해보자 Linux sorce code 이 사이트를 들어가보면 여러 폴더들이 있는데 폴더의미는 다음과 같다. Documentation : 리눅스 커널 내용 문서화Licenses : 라이센스 관련 내용Arch : 아키텍처에 종속된 내용Block : 블록 IO 처리 관련 내용Certs : 인증관련 내용Crypto : 암호화 관련 내용Drivers : 디바이스 드라이버 관련 내용fs : 파일시스템 관련 내용Include : 커널 헤더 관련 내용Init : 부팅 과정에서 사용되는 초기화 내용ipc : ipc관련 내용 (메시지큐, 세마포어, 쉐어메모리 등..)kernel : 중요 커널 내용(fork, exec, exit, ire, DMA…)Lib : 커널에서 사용되는 라이브러리(압축이나 자료구조 관련.)Mm: 메모리 관리 관련 내용Net : 네트워크 스택 관련 내용Samples : 커널 기술을 응용한 샘플Scripts : 커널 개발에 사용하는 스크립트Security : 보안관련 내용Sound : 소리 출력 관련tools : 커널 검증 도구 관련virt : kvm 가상화 관련 내용 물론 이걸 굳이 모두 세세히 알 필요는 없다! 예를 들어서 x86 계열의 시스템콜은 **/arch/x86/entry/syscalls/**에서 볼 수 있다. 1234567891011121314151617181920212223## 64-bit system call numbers and entry vectors## The format is:# &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;## The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls## The abi is &quot;common&quot;, &quot;64&quot; or &quot;x32&quot; for this file.#0 common read sys_read1 common write sys_write2 common open sys_open3 common close sys_close4 common stat sys_newstat5 common fstat sys_newfstat6 common lstat sys_newlstat7 common poll sys_poll8 common lseek sys_lseek9 common mmap sys_mmap10 common mprotect sys_mprotect11 common munmap sys_munmap12 common brk sys_brk 여기서 재밌는건 예를 들어 read 시스템콜을 호출하면 커널 함수 sys_read가 매핑된다. 123456789asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);asmlinkage long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);asmlinkage long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen); Sys_read(…)는 프로토타입으로 나와있는데 이건 커널함수가 독특한 정의 방식을 따르기 때문이다. SYSCALL_DEFINEn 정의방식n은 자연수라고 할때, SYSCALL_DEFINE1 , SYSCALL_DEFINE2… 이런식으로 표현가능하다. 이때 n은 해당 함수의 함수 갯수를 의미한다. 다시 sys_read의 경우를 보자. 1asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count); 이렇게 프로토타입이 선언되어 있으면, 다음과 같다고 봐야한다. 123sys_read(read, unsigned int fd, char _user *buf, size_t, count)&#123; ....&#125; 결국 do_sys_read()함수를 호출해서 read루틴을 처리한다. 다양한 시스템콜 분석해보기","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[]},{"title":"인터페이스와 추상클래스의 차이(feat. 데코레이터 패턴)","slug":"java/java-basic/javainterface","date":"2021-11-07T10:02:30.000Z","updated":"2022-02-20T23:39:04.656Z","comments":true,"path":"2021/11/07/java/java-basic/javainterface/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/07/java/java-basic/javainterface/","excerpt":"","text":"인터페이스와 추상 클래스의 차이를 잘 느낄 수 있는 예제를 가져왔다. 데코레이터를 인터페이스로 구현해본다고 하자. 인터페이스로 데코레이터를 구현한다면?패션 모델에게 각종 의류를 데코레이터로 적용하는 예시를 인터페이스로 구현해보자. 12345//모델의 역할은 런웨이를 하는 것.public interface Model &#123; void runway();&#125; 1234567//모델인터페이스를 구현한 한국모델 구현체(클래스)public class KoreanModel implements Model&#123; @Override public void runway() &#123; System.out.println(&quot;한국 모델이 런웨이를 시작합니다.&quot;); &#125;&#125; 모델과 구현체를 만들었다. 이제 데코레이터 인터페이스를 도입해보자.데코레이터는 모델을 포함하고 있으며 모델을 대신할 것이다. 12345//의류데코레이터는 모델이 옷을 입도록 한다.public interface ClotheDecorator extends Model&#123; void wearClothes();&#125; 12345678910111213141516171819//의류 데코레이터를 구현한 의류 클래스public class Shirts implements ClotheDecorator&#123; Model model; public Shirts(Model model)&#123; this.model = model; &#125; //우리가 원하는 추가 기능이다. @Override public void wearClothes() &#123; System.out.println(&quot;셔츠를 입었습니다!&quot;); &#125; //모델을 대신해야 하기 때문에 이 메소드가 구현되어야 한다. @Override public void runway() &#123; model.runway(); wearClothes(); &#125;&#125; 1234567891011121314151617//이번엔 바지를 구현해보자! 전체적인 방식은 비슷하다.public class Pants implements ClotheDecorator&#123; Model model; public Pants(Model model)&#123; this.model = model; &#125; @Override public void wearClothes() &#123; System.out.println(&quot;바지를 입었습니다!!&quot;); &#125; @Override public void runway() &#123; model.runway(); wearClothes(); &#125;&#125; 123456public class Test &#123; public static void main(String[] args) &#123; Model yang = new Pants(new Shirts(new KoreanModel())); yang.runway(); &#125;&#125; 근데 자세히 보면 Shirts와 Pants에 중복된 부분이 있다…! 1234Model model;public Pants(Model model)&#123; this.model = model;&#125; 이 부분이 중복된다. Model model을 인터페이스에 넣으려면 반드시 상수가 되어버리니 우리가 원래 사용하려던 방식과 안맞는다…그리고 생성자를 인터페이스에 추가해줄 수도 없다…. 추상클래스로 중복된 부분을 제거해보자.데코레이터 인터페이스를 데코레이터 추상 클래스로 바꿔보자. 1234567891011121314public abstract class ClothDecorator implements Model &#123; Model model; public ClothDecorator(Model model)&#123; this.model = model; &#125; public abstract void wearCloth(); @Override public void runway()&#123; model.runway(); wearCloth(); &#125;&#125; 이 추상클래스를 자세히보면, 두가지 역할을 한다. 멤버 변수 모델을 생성자로 초기화 runway메소드의 로직을 구현 그래서 설계가 뻣뻣해지는 경향이 있다. 하지만 추상 클래스로 데코레이터를 작성하면 구현 클래스들이 좀 더 간략해지긴 한다. 123456public class Hat extends ClothDecorator&#123; public Hat(Model model) &#123; super(model); &#125; @Override public void wearCloth() &#123; System.out.println(&quot;모자를 썼습니다!!!&quot;); &#125;&#125; 123456public class Shoes extends ClothDecorator&#123; public Shoes(Model model) &#123; super(model); &#125; @Override public void wearCloth() &#123; System.out.println(&quot;신발을 신었습니다!!!&quot;); &#125;&#125; 멤버 변수 선언과 로직 구현을 추상클래스가 해주니 구현 클래스가 간략해졌다. 하지만 추상 클래스가 너무 많은 역할을 하는 건 아닌지 생각해봐야 한다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"405 Not Allowed 해결하기","slug":"cs/web/http405error","date":"2021-11-01T05:25:13.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/11/01/cs/web/http405error/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/01/cs/web/http405error/","excerpt":"","text":"405 Not AllowedHttp status code 중 405는 특정 Http method가 혀용되지 않는다는 의미다. 문제 배경서블릿 프로젝트에서 입력 페이지에서 데이터를 입력받아 post로 데이터를 넘겨주고해당 데이터가 유효하면 다른 url로 리다이렉트 하고,그렇지 않으면 다시 입력 페이지에서 데이터를 입력받도록 구성했는데 405 문제가 생겼다. 문제가 발생하는 이유와 증상들1. 데이터 유효에 따라 다르게 발생일단 유효한 데이터를 입력해서 post 요청하면 문제가 발생하지 않는데,유효하지 않은 데이터를 입력하는 경우 이런 문제가 발생했다. 2. 무한 반복되는 로그post대신 get으로 로직을 짜도 문제가 발생했다. 유효하지 않은 데이터를 입력받으면 리다이렉션이 너무 많이 일어나는 에러가 발생했다. 로그를 살펴보니 끝없이 데이터의 유효성 검사를 하고 있었다.분명, 다시 데이터를 입력받아야 정상 로직인데, 입력을 받지도 않고 유효성 검사를 무한 반복하고 있었다. 3. 같은 URL로 요청 두 개가 전달.또한 브라우저에서 개발자 모드로 살펴보니, 내가 의도한 url로 post 요청과 get 요청 두개가 요청되고 있었다.post는 내가 의도한 게 맞는데, get은 내가 의도하지 않은 요청이다. 문제 원인데이터의 유효값을 체크하여 리다이렉트 하는 곳에서 문제가 있었다. 12345678910111213@WebServlet(name = &quot;LoginServlet&quot;, value = &quot;/login.do&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; .... //데이터 유효성 확인 후 리다이렉트 if(user!= null) &#123; response.sendRedirect(&quot;/ServletProject2_war_exploded/board.do/list&quot;); &#125;else&#123; response.sendRedirect(&quot;login.do&quot;); &#125; &#125;&#125; 이게 문제가 되는 코드다. 데이터가 유효하지 않으면 login.do로 리다이렉트하고 있다.이러면 login.do로 get요청을 하게된다. 그런데 나는 login.do를 처리하는 LoginServelt 클래스에 post만 처리 할 수 있도록 했다.405 code는 이런 상황에서 발생한 것이다. 그리고 get으로 로직을 다시 짰을 때 무한 리다이렉션이 일어나는 이유는login.do로 유효하지 않은 데이터 받음 -&gt; 유효하지 않으니 login.do get요청 -&gt; login.do로 빈 쿼리파라미터 받음-&gt; 유효하지 않으니 login.do get 요청… 이렇게 무한 반복되서 그랬다. 문제 해결다음과 같이 코드를 고치면 된다. 12345678910111213@WebServlet(name = &quot;LoginServlet&quot;, value = &quot;/login.do&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; .... //데이터 유효성 확인 후 리다이렉트 if(user!= null) &#123; response.sendRedirect(&quot;/ServletProject2_war_exploded/board.do/list&quot;); &#125;else&#123; response.sendRedirect(&quot;login.html&quot;); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}]},{"title":"private 생성자나 열거 타입으로 싱글턴임을 보증하라","slug":"java/effective-java/effective3","date":"2021-10-21T15:54:57.000Z","updated":"2022-03-03T15:32:26.357Z","comments":true,"path":"2021/10/22/java/effective-java/effective3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/22/java/effective-java/effective3/","excerpt":"","text":"싱글턴의 단점싱글턴은 인스턴스를 하나만 생성할 수 있는 클래스를 말한다.그런데 이 싱글턴 클래스를 사용하는 클라이언트를 테스트하기 어렵다.특히 인터페이스를 구현하는 방식으로 만들어진 싱글턴이 아니면 mock 객체로 테스트 하기 어렵다. mock객체? 테스트하고 싶은 객체의 핵심 책임만 검증할 수 있도록 만들어진 객체이다.원래 객체가 수많은 협력을 하고 있는데 반해, mock객체는 단순히 자신의 역할만 가지고 있을 뿐이다.싱글톤은 자기 자신이 다른 수많은 객체와 협력해야 한다.(하나뿐이므로) 그래서 협력을 제외한 mock객체 테스트가 불가능하다는 의미다. public static final 방식123456public class Yang&#123; public static final Yang INSTANCE = new YANG(); private Yang()&#123;...&#125; ....&#125; private 생성자는 맨 처음 public static final 인스턴스를 생성할 때 한번만 호출된다. 리플렉션 API의 AccessibleObject.setAccessible을 사용해서 private 생성자를 호출하는 경우가 있을 순 있는데,그런 경우를 대비하면 생성자를 수정해서 예외처리를 하면된다. 간결하게 싱글턴임을 알 수 있다.(static final이면 절대 다른 객체를 참조할 수 없으니..!) 정적 팩터리 메서드1234567public class Yang&#123; public static final Yang INSTANCE = new Yang(); private Yang()&#123;...&#125; public static Yang getInstance()&#123;return INSTANCE;&#125; ....&#125; 위와 비슷하지만, 정적 팩터리 메서드를 추가했다. 이로 얻는 장점은 싱글턴이 아니게 바꿀 수 있다. 정적 팩터리 메서드 내용을 바꾸면 언제든지 싱글턴이 아니게 만들 수 있다. 정적 팩터리 메서드를 제네릭 싱글턴 팩터리로 만들 수 있다! 정적 팩터리 메서드 참조를 공급자로 사용할 수 있다! Yang::getInstance 를 Supplier&lt;Yang&gt;으로 사용할 수 있다! 다만 위의 장점이 필요한게 아니면 public field 방식을 써라! 싱글턴 클래스 직렬화의 문제Public static final 필드나 정적 팩터리 메서드를 사용해서 싱글턴 클래스를 직렬화하려고 Serializable을 구현하면 문제가 생긴다.직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 생긴다. 이걸 막기 위해서는 모든 인스턴스 필드를 일시적(transient)라고 선언하고 readResolve 메서드를 추가해야 한다. 123private Object readResolve() &#123; return INSTANCE; //진짜 객체를 반환하고 가짜 객체는 가비지 컬렉터에 맡긴다.&#125; 열거 타입 활용하기직렬화 상황이나 리플렉션 공격에서 자유로운 방법은 열거 타입을 활용하는 거다.그래서 대부분의 상황에서는 열겨 타입으로 싱글턴을 만드는게 가장 좋다.다만, 상속을 활용해야 되는 경우 사용할 수 없다. (인터페이스 구현은 가능하다.) 1234public enum Yang &#123; INSTANCE; //기타 메서드...&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}]},{"title":"mysql PID에러(The server quit without updating PID file)","slug":"cs/database/mysqlpid에러","date":"2021-10-21T14:29:08.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/10/21/cs/database/mysqlpid에러/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/21/cs/database/mysqlpid%EC%97%90%EB%9F%AC/","excerpt":"","text":"mysql이 갑자기 에러가 났다…주요 증상은 다음과 같다. 123mysql.server startStarting MySQL.. ERROR! The server quit without updating PID file (/usr/local/var/mysql/MUHN2-031.local.pid). 12345mysqld start2021-10-21T13:40:56.896075Z 0 [ERROR] [MY-010273] [Server] Could not create unix socket lock file /var/lib/mysql/mysql.sock.lock.2021-10-21T13:40:56.896105Z 0 [ERROR] [MY-010268] [Server] Unable to setup unix socket lock file.2021-10-21T13:40:56.896439Z 0 [ERROR] [MY-010119] [Server] Aborting2021-10-21T13:40:57.857715Z 0 [System] [MY-010910] [Server] /usr/local/Cellar/mysql/8.0.27/bin/mysqld: Shutdown complete (mysqld 8.0.27) Homebrew. PID에러가 발생해서 별의 별 짓을 다해봤다. 프로세스 인스턴스 종료하기 애초에 프로세스가 실행되지도 않았음 디렉토리 권한 설정하기 효과 없음 필요한 디렉토리를 직접 만들어주기 효과 없음 재설치 효과 없음 이렇게 난항을 겪는 와중 재설치 했을 때 로그를 읽어보니 해답이 보였다. 12A &quot;/etc/my.cnf&quot; from another install may interfere with a Homebrew-builtserver starting up correctly. 즉 예전에 설치했을 때 생긴 cnf가 있으면 서버 구동에 문제를 일으킬 수 있다는 안내문이다. 그래서 sudo rm /etc/my.cnf 해줬더니 작동됐다….","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}]},{"title":"생성자에 매개변수가 많으면 빌더를 고려하자","slug":"java/effective-java/effective2","date":"2021-10-16T13:08:41.000Z","updated":"2022-03-03T15:35:49.660Z","comments":true,"path":"2021/10/16/java/effective-java/effective2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/16/java/effective-java/effective2/","excerpt":"","text":"점층적 생성자 패턴자바빈즈 패턴빌더 패턴 점층적 생성자 패턴클래스에 멤버 변수가 많다면, 수많은 생성자(점층적 생성자 패턴)가 가능하다. 12345678910class Clazz&#123; int a; double b; String c; .... public Clazz(int a)&#123;&#125; public Clazz(int a, double b)&#123;&#125; public Clazz(int a, double b, String c)&#123;&#125; ...&#125; 근데 이런 방식은 굳이 초기화 하고 싶지 않은 변수도 입력해줘야 된다.입력해야 될 매개변수가 적으면 나쁘지 않지만, 매개변수가 많아지면 코드 가독성을 해친다. 자바빈즈 패턴매개변수가 없는 생성자로 객체를 만들고, 세터 메서드를 호출해 원하는 매개변수 값을 설정하는 방식. 123456789class Clazz&#123; private int a; private double b; private String c; public void setA(int a)&#123;this.a = a;&#125; public void setB(double b)&#123;this.b = b;&#125; public void setC(String c)&#123;this.c = c;&#125;&#125; 단점 이 방식은 한 객체를 만들 때 메소드를 여러개 사용해야 되고, 완전히 초기화가 되기 전엔 일관성이 무너지게 된다.또한 클래스를 불변으로 만들 수 없다. (만들고 나서 인스턴스 멤버에 접근해서 수정할 수 있어야 하므로..) 12345Clazz clazz = new Clazz();clazz.setA(1);clazz.setB(3.5);clazz.setC(&quot;hi.&quot;);//이제 객체 초기화 끝...! 빌더 패턴점층적 생성자 패턴과 자바빈즈 패턴의 장점만 취한 방식이다. 원하는 클래스 안에 정적 클래시로 빌더를 만들고, 빌더 기본 생성자(혹은 정적 팩토리 메서드)에 필수 매개변수를 받고, 나머지 선택 매개변수들은 빌더가 제공하는 세터 메서드로 초기화 해준다. 원하는 멤버들을 모두 초기화했을 경우, 불변객체를 반환하는 build 메서드로 완성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Employee&#123; //가능한 모든 멤버 변수들. private final int age; private final int wage; private final String name; private final String company; private final String role; public Employee(Builder builder)&#123; age = builder.age; wage = builder.wage; name = builder.name; company = builder.company; role = builder.role; &#125; public static class Builder &#123; //멤버 변수 중 필수로 들어가야 할 변수. private final String name; private final String role; //선택 매개변수 기본값으로 초기화 한다. private int age = 0; private int wage = 0; private String company =&quot;&quot;; //빌더의 기본 생성자. 필수 매개변수를 받아야 객체 생성이 가능하다는 의미다. public Builder(String name, String role)&#123; this.name = name; this.role = role; &#125; //선택 매개변수 setter 메서드 public Builder age(int age)&#123; this.age = age; return this; &#125; public Builder wage(int wage)&#123; this.wage = wage; return this; &#125; public Builder company(String company)&#123; this.company = company; return this; &#125; //build메서드 public Employee build()&#123; return new Employee(this); &#125; &#125;&#125; 이 코드를 기반으로 코드를 짜면 다음과 같다. 1Employee kim = new Employee.Builder(&quot;kim&quot;, &quot;backend&quot;).age(12).company(&quot;naver&quot;).build();","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}]},{"title":"생성자 대신 정적 팩터리 메서드를 고려하라.","slug":"java/effective-java/effective1","date":"2021-10-15T13:38:49.000Z","updated":"2022-02-20T23:26:57.555Z","comments":true,"path":"2021/10/15/java/effective-java/effective1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/15/java/effective-java/effective1/","excerpt":"","text":"정적 팩터리 메서드란 무엇인가정적 팩터리 메서드의 장점은 무엇인가정적 팩터리 메서드의 단점은 무엇인가정적 팩터리 메서드 네이밍 컨벤션 일반적으로 public 생성자를 통해 클래스의 인스턴스를 만든다.하지만 정적 팩터리 메서드를 통해 만들면 여러 이점이 있다. 정적 팩터리 메서드란 무엇인가?static으로 선언되었고, 객체를 반환하는 메서드를 말한다. 책에 나온 예시인 valueOf를 보자 123public static Boolean valueOf(boolean b)&#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 이렇게 정적으로(static) 선언되어서 다음같이 사용할 수 있다. 12boolean bool = true;Boolean boolWrapper = Boolean.valueOf(bool); 정적 팩터리 메서드의 장점은 무엇인가? 이름을 가질 수 있다. 생성자는 여러 매개변수를 가질 수 있지만 이름은 클래스명이 전부라 구분이 어렵다. 정적팩터리는 메소드의 이름을 다양하게 할 수 있어서 구분을 쉽게 할 수 있다. 1234567891011121314151617181920212223242526class Student&#123; int age; double score; //정적 팩토리 메서드 static Student ageOf(int age)&#123; return new Student(age); &#125; static Student scoreOf(double score)&#123; return new Student(score) &#125; //생성자 public Student(int age)&#123; this.age =age;&#125; public Student(double score)&#123; this.score = score;&#125;&#125;//아래 매개변수로 판단하기는 헷갈린다!Student a = new Student(30);Studnet b = new Student(4.5);//메소드 명을 보니 분명하게 판별할 수 있다!Student c = Student.ageOf(30);Student d = Student.scoreOf(4.5); 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다. 위 valueOf 메소드는 미리 만들어진 static Boolean 객체를 반환한다. 정적 팩토리 메서드는 객체를 요청할 때 굳이 객체를 만들어 주지 않아도 된다.(싱글톤처럼 활용도 가능하다.) 12345678910class Boolean&#123; //정적 상수 객체들 public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); //static final 객체를 반환하는 정적 팩터리 메서드 public static Boolean valueOf(boolean b)&#123; return b ? Boolean.TRUE : Boolean.FALSE; &#125;&#125; 반환 타입의 하위 타입 객체를 반환할 수 있다. 인터페이스에 정적 메서드를 선언하면 구현 클래스에 대한 내용을 공개 안해도 그 객체를 반환 할 수 있다. 12345678public interface Person&#123; public static Person whoTeaches()&#123; return new Teacher(); &#125; public static Person whoLearns()&#123; return new Student(); &#125;&#125; 12public class Student implements Person&#123;...&#125;public class Teacher implements Person&#123;...&#125; 123//Teacher 클래스나 Student 클래스를 몰라도 해당 클래스 객체들을 사용할 수 있다!!Person kim = Person.whoTeaches();Person lee = Person.whoLearns(); 매개변수에 따라 매번 다른 객체를 반환할 수 있다. 인터페이스의 정적 팩터리 메서드의 반환 객체가 인터페이스를 구현하기만 하면 어떻게 되든 상관없다.(캡슐화.) 인터페이스를 구현한 구현체를 반환하는 규칙만 지킨다면, 추후에 수정하기도 용이하다. 123456public interface Person&#123; public static Person isOld(int age)&#123; if (age&gt;65) return new OldPerson(int age); else return new YoungPerson(int age); &#125;&#125; 12345678public class OldPerson implements Person&#123; int age; public OldPerson(int age)&#123;this.age = age;&#125;&#125;public class YoungPerson implements Person&#123; int age; public YoungPerson(int age)&#123;this.age = age;&#125;&#125; 123//사용자는 어떤 객체가 만들어지는지 알 필요가 없다.Person kim = Person.isOld(75); //OldPerson객체Person lee = Person.isOld(23); //YoungPerson객체 정적 팩터리 메서드의 단점은 무엇인가? public이나 protected 생성자 대신 정적 팩터리 메서드를 사용하면, 상속이 불가능해진다. 상속 관계를 만들려면 public, protected 생성자가 있어야 한다. 개발자가 이해하기 어렵다. 정적 팩터리 메서드는 클래스나 인터페이스에 있어서 생성자보다는 알기 어렵다. 정적 팩터리 메서드 네이밍 컨벤션 from : 매개변수 하나 받아서 해당 타입의 인스턴스 반환 of : 여러 매개변수 받아 적합한 타입의 인스턴스 반환 valueOf : from, of의 더 자세한 버전 getInstance : (매개변수를 받아 매개변수를 가진) 인스턴스를 반환한다. create / newInstance : 새로운 인스턴스를 만들어 반환한다. instance 대신 다른 클래스의 이름을 적으면 다른 클래스의 인스턴스를 반환한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}]},{"title":"완전탐색","slug":"cs/algorithm/theory/완전탐색","date":"2021-10-15T01:54:02.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/10/15/cs/algorithm/theory/완전탐색/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/15/cs/algorithm/theory/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/","excerpt":"","text":"완전탐색이란문제 유형복잡도 파악 완전탐색이란모든 경우를 탐색하는 방법.부분점수를 얻기 좋으나 시간 복잡도가 일반적으로 높은 편. 완전탐색 문제를 접근할 땐 고를 수 있는 값의 종류 파악 중복을 허용하는지 순서를 중요시 하는지 위 세가지를 파악해자. 문제 유형완전탐색 문제는 크게 4가지로 나눌 수 있다. N개에서 중복 허용해서 M개를 순서 있게 나열하기 N개에서 중복 허용하지 않고 M개를 순서 있게 나열하기 N개에서 중복 허용해서 M개를 순서 없이 고르기 N개에서 중복 허용하지 않고 M개를 순서 없이 고르기. 즉 완전탐색 문제는 두 개의 양의 정수를 구하고, 배열이나 리스트에 나열하는 방법의 개수를 묻는 방식으로 푼다. 복잡도 파악완전 탐색은위 유형마다 시간 복잡도 / 공간 복잡도를 정리해보자 중복허용, 순서중요 : O(N^M) , O(M) 중복불허, 순서중요 :O(N!/(N-M)!), O(M) 중복허용, 순서불허 : O(N^M), O(M) 중복불허, 순서불허 : O(N!/M!(N-M)!), O(M) 대체로, 순서를 신경쓰는 경우가 더 복잡하다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"운영체제 면접대비 스터디","slug":"cs/os/운영체제면접대비","date":"2021-10-14T05:53:10.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/10/14/cs/os/운영체제면접대비/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/14/cs/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84/","excerpt":"","text":"목차1주차프로세스와 스레드의 차이쓰레드의 동기화 이슈교착 상태와 기아 상태메모리 계층 2주차메모리 할당 방식메모리 단편화메모리 할당 알고리즘가상 메모리요구 페이징페이지 교체 알고리즘 3주차페이징세그멘테이션상호배제 방식뮤텍스세마포어 4주차PCB와 프로세스 컨텍스트컨텍스트 스위칭사용자 수준 스레드 vs 커널 수준 스레드fork와 vfork의 차이점 5주차RaceCondition시스템콜vs서브루틴 1주차프로세스와 스레드의 차이정의 프로세스 : 메모리에 올려져 실행 중인 프로그램쓰레드 : 프로세스 안에서 실행되는 흐름 단위 공유자원 차이 프로세스 : 프로세스들 끼리는 IPC를 제외하면 공유를 허용하지 않음쓰레드 : code, data, heap은 서로 공유. stack은 서로 독립적.(각자의 흐름을 가져야 함) *프로세스 구조* code : 컴파일된 코드가 저장(프로그램 끝날 때 해제) Data : 선언된 변수가 저장되는 영역 (전역변수, static, 프로그램 끝날 때 해제) BSS(초기화 안된 전역변수) / DATA(초기화 된 전역변수) heap : 동적으로 할당된 메모리가 저장 stack : 함수와 관련된 인자나 변수 저장 (다양한 레지스터 사용!) *IPC* 프로세스 간 상태 확인 및 데이터 송수신할 때 사용. 프로세서마다 공유하는 커널 공간을 통해 데이터를 쓰고 읽음. IPC 비용이 커서 멀티 프로세스보다 멀티 스레드를 활용하기도 함. *Context Switching* 프로세스의 상태 정보를 저장하고 복원하는 과정 PCB : 프로세스의 상태를 저장한 구조체(program counter와 stack pointer 등 다양한 레지스터 저장)스위칭 될 때마다 PCB를 저장하고 로드.서로 자원이 공유되지 않으니, 스위칭 연산이 비싸다. 쓰레드보다 프로세스 바꿀 때가 더 든다. 왜 ? 쓰레드는 공유 자원이라 바꿀게 스레드보다 더 적다. 약점 프로세스 : 서로 자원 공유가 제한됨 IPC 연산 비용 일일히 자원 할당하는 시스템콜 비용 쓰레드 : 하나만 잘못되도 프로세스 전체에 악영향 동기화 이슈 *멀티 프로세스 vs 멀티 쓰레드* 멀티 프로세스 여러 cpu가 동시에 여러개의 프로세스 처리 메모리 침범 막아서 안전성 높음 작업량이 많으면 컨텍스트 스위칭으로 인해 성능이 저하 멀티 스레드 하나의 프로세스에서 여러 스레드가 각자 하나의 작업을 처리 자원 공유로 빠른 작업 가능 스레드 하나가 망하면 한 프로세스가 다같이 망함 쓰레드의 동기화 이슈상호배재(mutex) 한 스레드가 공유 자원에 접근하면 다른 스레드가 접근 못하게 하기 임계 자원(crtical resource) : 접근 제한 자원 임계 영역(critical section) : 접근 제한 코드. 영역 세마포어(semaphore) 공유 자원에 정해진 수의 사용자만 접근 허락 교착 상태와 기아 상태교착 상태(dead lock) 여러 쓰레드가 서로 상대방의 작업이 끝나길 기다리느라 다음 작업을 못하는 상황 기아 상태 우선순위가 낮은 프로세스가 계속 경쟁에 뒤쳐져 원하는 자원을 계속 못받는 상태. 이슈 해결 방법 교착 상태 예방 : 원인을 제거 회피 : 발생하지 않도록 알고리즘 도입 은행원 알고리즘 / 자원할당 알고리즘 회복 : 문제가 발생한 프로세스를 중단, 메모리 해제 무시 : 해결할 때 생기는 비용이 너무 비싸면 무시 예방이 가장 낭비가 심하다. 기아 상태 우선순위 수시로 바꿈 FIFO 기반 스케줄러로 바꿈 *교착 상태의 원인* 상호배제 : 다른 프로세스도 갖고 싶은 걸 자기만 가지려함 점유대기 : 자원을 가지고 있으면서 다른 자원을 대기 비선점 : 자원을 가진 프로세스의 자원을 못 뺏음 순환대기 : 다음 프로세스가 원하는 걸 가지고 있음. 메모리 계층레지스터 - 캐시 - 메모리 - 하드디스크 메모리를 필요에 따라 나눈 계층(오른쪽으로 갈 수록 CPU가 느리게 접근) 레지스터CPU 요청 처리에 필요한 정보를 임시 저장하는 기억장치 캐시데이터나 값을 미리 복사해놓는 임시 저장소. 메인 메모리RAM, ROM으로 구성된 명령, 자료를 기억하는 장치.cpu에서 직접 접근가능 하다는게 하드디스크와 다름 하드디스크비휘발성 순차적 데이터 저장소. 느리지만 저렴.직접 사용하지 못하고 시스템콜로 메모리에 옮겨서 사용. 계층이 필요한 이유 디코딩 속도 큰 메모리 용량은 디코딩하는데 많은 시간 소요. 메모리가 작으면 빠르게 디코딩해서 접근 가능 참조의 지역성 자주 쓰이는 데이터는 계속 더 자주 쓰임 경제성 빠를 수록 비싸서 저렴한 메모리를 효율적으로 활용해야함. 2주차메모리 할당 방식**연속 할당 방식 **프로그램 전체를 한 공간에 연속적으로 할당. 정적 분할과 동적 분할 정적 분할 : 메모리 영역을 고정된 크기로 미리 나눠놓고 맞는 프로세스를 집어넣는 방식. 내외부단편화 모두 일어남.동적 분할 : 프로세스에 맞게 메모리 영역을 할당함. 외부단편화가 생길 수 있음. 비연속 할당 방식프로그램을 페이지로 나눈 후, 여러 곳에 흩어져서 할당. 메모리 단편화프로세스를 메모리에 올릴 때 생기는 메모리 낭비 현상.대표적으로 외부 단편화와 내부 단편화가 있다. 외부 단편화 어떤 프로세스보다 전체 물리 메모리의 남은 공간이 더 많아도,물리 메모리의 남은 공간들이 연속적이지 못해서 프로세스를 메모리에 올리지 못하는 상황 내부 단편화 물리 메모리의 남은 공간에 어떤 프로세스를 할당하고 남은 공간이다른 프로세스를 받아들이지 못해 낭비되는 상황 메모리 단편화 해결하기 COMPACTION 압축 비어있는 공간을 연속적인 공간으로 재배치.현재 프로세스들을 다른 곳(하드디스크 등)에 복사했다가 다시 메모리에 올려야 함병목현상이나, IO 문제가 발생 가능하다. -&gt; 외부 Coalescing holes( 공간 통합) 프로세스가 끝나고 메모리에서 사라지면, 새로 생긴 빈 공간을 주위 빈공간과 합침.좀 더 큰 프로세스가 올 수 있게 만들고 오버헤드가 낮음 메모리 할당 알고리즘멀티 프로세스 환경에서 여러 프로세스가 동시에 실행된다.단편화 문제를 줄이기 위해 메모리를 할당하는 알고리즘. BEST FIT : 현재 물리 메모리의 빈 공간을 모두 탐색해서 가장 낭비가 적은 공간에 프로세스 올림 FIRST FIT : 현재 물리 메모리에서 프로세스를 올릴 수 있는 빈 공간 중 가장 먼저 찾은 공간에 프로세스 올림 WORST FIT : 현재 물리 메모리 남은 공간들 중 프로세스를 할당하고도 남은 공간이 가장 큰 공간에 프로세스 올림(남은 공간에 다음에 올 프로세스가 들어올 가능성을 생각한 것.) 평가 효율성 : BEST FIT, FIRST FIT &gt; WORST FIT복잡도 : FIRST FIT &gt; BEST FIT , WORST FIT FIRST FIT의 50퍼센트 규칙 전체 메모리에 N개의 블록이 할당되었다고 했을 때 0.5N개의 블록이 외부 단편화되어 사용할 수 없음.총 (1.5N 중 0.5N, 즉 1/3만큼 사용할 수 없게 된다.) 가상 메모리메모리에 로드되어 실행 중인 프로세스가 가상의 메모리 공간을 참조해 거대한 물리 메모리를 사용하는 것처럼 보이게 하는 방식. 프로세스를 모두 메모리에 할당하기엔 한계가 있다.(리눅스의 프로세스 크기가 4기가.)CPU가 프로세스의 모든 공간을 사용하지는 않는다. 자주 사용하지 않는 부분은 하드디스크에 저장가상 주소로 통해 메모리에 접근. 프레임 : 물리 메모리를 구성하는 가장 작은 단위페이지 : 가상 메모리를 구성하는 가장 작은 단위 MMU : CPU가 가상 메모리에 접근하고 싶을 때 가상 주소를 실제 물리 주소로 바꾸어 접근 페이지 폴트 : 프로세스의 페이지 중 일부가 RAM에 올려지지 않은 상황. 요구 페이징페이지 폴트가 발생하면, 가상 메모리에서 해당 페이지를 찾아야 함.(요구페이징)CPU는 프로세스 페이지의 주소를 페이지 테이블에 기록했음. 페이지 테이블의 가상 주소를 보고 요청하면, MMU가 실제 물리 주소로 변환해서하드디스크에 있는 페이지를 물리 메모리에 올려야 한다. 페이지 교체 알고리즘가상 메모리에서 페이지를 가져왔는데, 메모리에 남는 프레임이 없어서 올리지 못하는 경우,메모리의 다른 페이지를 빼서 가상 메모리에 넣고, 가져온 페이지를 물리 메모리에 넣어야 한다. OPT : 앞으로 안쓸거 같은 페이지를 교체 FIFO : 가장 먼저 할당된 페이지를 교체 LRU least recently used : 오랫동안 덜 쓴 페이지 교체 - 지역성(로컬리티) LFU least fre: 사용 빈도가 적은 페이지 교체 NUR : 최근에 사용안한 페이지 교체 3주차페이징비연속할당 방식, 고정 분할 기법의 일종으로 프로세스를 여러 개의 페이지로 나눠 메모리에 흩어져서 할당됨외부 단편화를 막을 수 있지만, 페이지 크기가 커질 수록 내부 단편화도 커짐.(필요한 메모리보다 할당된 메모리가 더 큰 경우) 페이징을 하기 위해서는 mmu와 페이지테이블이 필요하다. 세그멘테이션페이징은 물리적으로 동일한 크기로 분할하는 기법이지만세그멘테이션은 논리적인 기준으로 분할하는 기법이다.세그멘테이션은 각 세그멘트가 크기가 달라서 메모리에 할당하고 해제하는 과정에서 외부 단편화가 날 수 있다. 외부 단편화를 방지하기 위해 세그멘트를 페이징하는 paged segmentation 기법을 사용한다. 상호배제 방식공유 자원 접근을 제한하는 방식. 뮤텍스여러 프로세스/스레드가 공유 자원에 접근하는 상황을 막는 상호 배제 락 매커니즘.임계 구역(공유 자원)에 하나의 프로세스/스레드만 접근 가능함 세마포어여러 프로세스/스레드 중 정해진 프로세스/스레드 갯수만큼만 접근을 허락하는 매커니즘.대기 중인 프로세스/스레드가 공유 자원을 사용할 수 있는 지 계속 검사하는 과정이 발생 가능(바쁜 대기) 세마포어는 뮤텍스가 될 수 있는데, 뮤텍스는 세마포어가 될 수 없다!!!세마포어는 소유가 불가능한데, 뮤텍스가 소유가 가능하다. 4주차PCB와 프로세스 컨텍스트프로세스 메타데이터CPU는 프로세스 메타데이터로 프로세스를 식별.Process ID, Process State, Program Counter, Process Context 등…Program Counter = 다음에 실행될 명령어의 주소를 저장. PCB(Process Control Block)프로세스 관리를 위한 메타데이터를 저장하는 자료구조. 커널이 관리 프로세스 컨텍스트CPU가 해당 프로세스를 실행하기 위한 프로세스 데이터 모음.CPU는 레지스터를 기반으로 코드를 실행하므로,프로세서의 상태와 관련된 레지스터 집합을 프로세스 컨텍스트라고 이해. 컨텍스트 스위칭하나의 프로세스가 CPU를 사용하고 있을 때,하던 프로세스 작업을 중단하고 다른 프로세스 작업을 하기 위해,진행 중이던 프로세스의 컨텍스트를 PCB에 저장하고,다음 프로세스를 진행하기 위해 PCB에서 해당 컨텍스트를 가져와 작업을 진행한다. 프로세스와 쓰레드 컨텍스트 스위칭프로세스 : PCB에 프로세스 컨텍스트를 저장.쓰레드 : 프로세스 내부의 TCB에 컨텍스트를 저장. 컨텍스트 스위칭이 일어나는 경우 인터럽트 발생 CPU 사용 허가 시간 모두 소모 입출력 대기해야 하는 경우 사용자 수준 스레드 vs 커널 수준 스레드커널 수준 스레드커널이 생성해서 관리하는 스레드.커널이 직접 관리하므로 권한이 많지만, 그만큼 오버헤드가 일어남 한 프로세스에 여러 쓰레드를 할당하면, 한 스레드가 블락되도 다른 스레드로 대신하면 됨. 커널에서 관리하다 보니, 컨텍스트 스위칭도 발생. 오버헤드가 일어남 사용자 수준 스레드사용자 모드에서 동작하는 스레드.사용자 레벨에서 스레드 전용 라이브러리를 이용해서 여러 스레드를 생성.(자바에서 스레드 함수 이용하던지..) 스케줄링을 커널이 하지 않고 스레드 라이브러리에 따라 스케줄링. 이 스레드들은 커널의 기능을 사용하지 못하고,커널도 이들의 존재를 모른다. fork와 vfork의 차이점.forkUNIX 계열에서 새로운 프로세스 만드는 함수자식 프로세스가 부모 프로세스를 복제하는 방식 vfork부모 프로세스와 자식 프로세스가 페이지 테이블 공유.복사하지 않고 공유하므로 생성 속도가 빠르지만,공유된 자원을 두고 경쟁할 수 있다. -&gt; 부모 프로세스는 자식이 exit하거나 execute할 때까지 block 5주차Race Condition공유 자원에 여러 프로세스가 동시에 접근하려고 경쟁하는 상황결과의 순서를 기대할 수 없다 Race Condition attackSetuid(소유자 권한으로 실행)으로 설정된 파일이 실행 중일 때,생성된 임시파일과 같은 이름의 파일에 심볼릭링크를 만들어서 원본 파일을 지우고새로운 임시 파일이 생성될 때, 심볼릭 링크를 통해 파일 내용을 변경. 시스템은 변경된 파일을 새롭게 생성된 파일로 착각하고 프로세스 진행. 레이스컨디션 대응 가능하면 임시파일 생성 금지 파일 생성 시, 동일 파일 존재 시, 파일 생성 혹은 쓰기를 금지 만들려는 파일에 링크가 걸려있으면 실행중단 임시파일이 공격자에 의해 삭제되지 않도록 함(umask를 최하 022정도로 유지. 쓰기 권한 제거) 시스템콜 vs 서브루틴커널은 하드웨어를 제어하는 일종의 API.시스템콜은 커널의 서비스를 호출하는 명령어.서브루틴은 프로그래밍 할때 사용하는 대부분의 API. 서브루틴이 시스템콜을 호출하고 -&gt; 시스템콜이 커널을 호출.-&gt;커널의 수행 결과를 시스템콜로 전달-&gt;시스템콜이 다시 서브루틴에게 보냄","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"10. 객체 지향의 사실과 오해 마인드맵 정리","slug":"java/java-basic/java10","date":"2021-10-11T07:54:26.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/10/11/java/java-basic/java10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/11/java/java-basic/java10/","excerpt":"","text":"클릭하면 크게 보실 수 있습니다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"7. 어댑터 패턴","slug":"java/design-pattern/dp7","date":"2021-10-09T09:33:00.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/10/09/java/design-pattern/dp7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/09/java/design-pattern/dp7/","excerpt":"","text":"어댑터 패턴한 클래스의 인터페이스를 사용하고자 한 다른 인터페이스로 변환한다.쓰고자 하는 인터페이스를 구현한 클래스에 바꾸고 싶은 클래스의 객체를 구성한다. 닭과 오리를 만들어서 날고 울 수 있게 하고 싶다.그러나 두 객체의 행동이 약간 다르다. 1234public interface Chicken &#123; void kokkio(); void fly();&#125; 1234public interface Duck &#123; void quak(); void fly();&#125; 이 두 인터페이스를 구현하는 두 클래스가 있다. 1234567891011public class KoreanChicken implements Chicken&#123; @Override public void kokkio() &#123; System.out.println(&quot;꼬끼오!!!&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;푸득...&quot;); &#125;&#125; 1234567891011public class KoreanDuck implements Duck&#123; @Override public void quak() &#123; System.out.println(&quot;꽥!!&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;푸드득~!&quot;); &#125;&#125; 이제 닭을 오리처럼 행동을 요구하고 싶다.오리 인터페이스를 구현하는 어댑터를 만들어보자이 어댑터는 치킨 객체를 구성하고 있다. 12345678910111213141516public class ChickenAdapter implements Duck&#123; Chicken chicken; public ChickenAdapter(Chicken chicken)&#123; this.chicken = chicken; &#125; @Override public void quak() &#123; chicken.kokkio(); &#125; @Override public void fly() &#123; chicken.fly(); &#125;&#125; 이제 어댑터를 사용해서 오리와 닭을 둘다 동일한 메소드로 요청하자! 123456789101112public class Test &#123; public static void main(String[] args) &#123; Duck koreanDuck = new KoreanDuck(); koreanDuck.quak(); koreanDuck.fly(); Chicken koreanChicken = new KoreanChicken(); Duck adaptedChicken = new ChickenAdapter(koreanChicken); adaptedChicken.quak(); adaptedChicken.fly(); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"6. 싱글톤 패턴","slug":"java/design-pattern/dp6","date":"2021-10-01T04:21:35.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/10/01/java/design-pattern/dp6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/01/java/design-pattern/dp6/","excerpt":"","text":"싱글톤 패턴인스턴스가 하나 뿐인 객체를 만드는 패턴!어디서든 그 인스턴스에 접근할 수 있게하는 패턴! 왜 쓰는가?굳이 여러개가 필요 없는 클래스의 객체가 여러개 생기면 메모리를 불필요하게 차지하게 된다.이런 클래스들의 객체를 하나로 유지하도록 설계해서 메모리를 효율적으로 사용하게 한다. 혹은 설정이나 보안같이 중요한 내용을 담는 클래스는 여러개의 객체를 만들면 안정성을 해친다. 전역변수 쓰면 되잖아요 전역변수는 시작하면서 생성(JVM마다 다름). 필요하지 않을 때 생성될 수 있음. 고전적인 싱글톤 패턴12345678910public class Singleton &#123; private static Singleton uniqueObject; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(uniqueObject == null)&#123; uniqueObject =new Singleton(); &#125; return uniqueObject; &#125;&#125; 유일한 객체는 private static으로 정적으로 만들자. 객체에 대한 접근은 public static한 메소드로 하자. 메소드가 현 객체의 유무를 파악해서 객체를 만들어 반환. 멀티 스레드 문제 만약 여러개의 스레드가 getInstance메소드에 접근하면 어떻게 될까? (1번 스레드와 2번 스레드가 getInstace를 호출한 상황…)1번 getInstance -&gt; 2번 getInstance -&gt;1번 객체 유무 판별(없다고 판단) -&gt; 2번 객체 유무 판별(없다고 판단) -&gt;1번 객체 생성 -&gt; 2번 객체 생성(문제 발생!!!!!!) -&gt;1번 객체 반환(1번 객체 반환) -&gt; 2번 객체 반환(2번 객체 반환) 즉 두 스레드가 반환한 객체는 서로 다른 객체다!!!! 스레드 문제 해결하기 getInstance를 synchronized하기. getInstance 호출 시 끝날 때까지 다른 스레드 정지. 하지만 매번 객체에 접근할 때마다 동기화하는건 속도 문제 발생 가능 getInstance의 속도가 중요하지 않은 경우 사용. 인스턴스를 필요할 때 만들지 말고 처음부터 만들기123456public class Singleton &#123; private static Singleton uniqueInstance = new Singleton(); private Singleton(); public static Singleton getInstance()&#123;return uniqueInstance;&#125;&#125; 이 방법은 JVM에서 클래스가 로딩될 때 인스턴스를 생성! 게으른 홀더 방식내부 클래스를 따로 선언해서 그 안에 객체를 저장하는 방식이다.클래스 로더가 이 클래스를 읽을 때 객체 생성된다.1234567public class Singleton2 &#123; private Singleton2()&#123;&#125; public static class LazyHolder&#123; private static final Singleton2 uniqueInstance = new Singleton2(); &#125; public static Singleton2 getInstance()&#123;return LazyHolder.uniqueInstance;&#125;&#125; synchronized를 사용하지 않아 성능도 좋고, 다른 키워드를 사용하지 않아도 되서 직관적이다. 주의 할 점 만약 여러개의 클래스 로더를 사용할 경우 여러개의 객체가 생성될 수 있다!구체 클래스에 의존하여 인스턴스를 찾게 되므로, DIP, OCP를 위반할 가능성이 있다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"5. SOLID 원칙","slug":"java/design-pattern/dp5","date":"2021-09-30T04:23:53.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/09/30/java/design-pattern/dp5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/30/java/design-pattern/dp5/","excerpt":"","text":"SOLID확장과 유지보수를 쉽게 만드는 객체지향 프로그래밍 설계의 다섯가지 원칙. S : 단일 책임 원칙(SRP)한 설계 부품(클래스, 함수..)는 하나의 책임만 가져야 한다.약은 약사에게 진료는 의사에게…한 부품에 여러 기능이 있으면, 내부 메소드들이 의지하는 부분이 많아진다.즉 결합도가 높아지고, 그 부품에 대한 책임 높아진다. -&gt; 유지보수가 힘들어진다. 123456789101112131415161718class ICanDoEverything&#123; public void plus(int a, int b)&#123; System.out.println(a+b); &#125;; public void display(Displayable file)&#123;file.play();&#125; public void singASong(Singable singer)&#123;singer.sing();&#125;&#125;public class SRPTest &#123; public static void main(String[] args) &#123; ICanDoEverything hero = new ICanDoEverything(); Displayable file = new Jpg(); Singable singer = new RealSinger(); int a1 = 1; int a2 =2; hero.display(file); //책임 1 hero.singASong(singer); //책임 2 hero.plus(a1, a2);//책임 3 &#125;&#125; 숫자 두개를 더하고, 파일을 받아 실행하고, 가수를 불러 노래도 시킬 수 있는 ICanDoEverything 클래스가 있다!이 클래스의 객체 hero는 main메서드에서 3가지 책임을 하고 있다.근데 만약 이 클래스의 한 메서드에서 문제가 생기면 어떨까?객체 hero의 3가지 책임이 모두 실행할 수 없게 된다!!!(그 책임이 문제와 큰 관련이 없어도 말이다) O : 개방-폐쇄 원칙(OCP)기존의 코드를 변경하지 않고(close) 기능을 수정하거나 추가 할 수 있어야 한다.(open)자주 변경되는 내용은 따로 분리하고, 자주 변경되지 않는 부분은 다른 부분이 변경 되더라도 영향을 덜 받아야 한다. 123456789101112131415161718192021222324252627282930313233343536373839package SOLID;interface Displayable &#123; public void play();&#125;class Jpg implements Displayable&#123; @Override public void play()&#123; System.out.println(&quot;jpg displayed&quot;); &#125;&#125;class Gif implements Displayable&#123; @Override public void play()&#123; System.out.println(&quot;gif displayed&quot;); &#125;&#125;class FileDisplayer&#123; Displayable file; public void setFile(Displayable file)&#123; this.file = file; &#125; public void play()&#123; file.play(); &#125;&#125;public class ImageDisplay &#123; public static void main(String[] args) &#123; FileDisplayer fileDisplayer = new FileDisplayer(); Displayable file = new Jpg(); fileDisplayer.setFile(file); fileDisplayer.play(); file = new Gif(); fileDisplayer.setFile(file); fileDisplayer.play(); &#125;&#125; 여기서 변화할 내용은 play메소드이다.인터페이스로 play 메소드를 인터페이스로 추상화했다. L : 리스코프 치환 원칙자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.즉, 부모의 자리에 자식이 와도 문제 없어야 한다!또한 자식이 부모의 기능을 재정의 하지 않고 확장하는 것이 좋다. 12345678910111213141516171819202122class Account &#123; int accountNum = 123456; String owner= &quot;yang&quot;; int balance = 1000; int getBalance()&#123; return this.balance; &#125;&#125;class SavingAccount extends Account&#123; int interestRate = 2; int getBalance()&#123; return this.balance * this.interestRate; &#125;&#125;class Bank&#123; Account account = new Account(); account.getBalance(); //1000반환 account = new SavingAccount(); account.getBalance(); //2000반환!&#125; 자식 클래스가 메소드를 재정의해서 같은 코드더라도 다른 결과를 일으키는 문제가 있다. I : 인터페이스 분리 원칙자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.(영향 받지 않아야 한다.)하나의 큰 인터페이스보다 구체적인 여러 인터페이스가 낫다. 123456789101112131415161718192021interface Everything&#123; void run(); void sing(); void swim();&#125;class Singer implements Everything&#123; @Override public void run() &#123; System.out.println(&quot;Singer can run?&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;Singer can sing a song!!&quot;); &#125; @Override public void swim() &#123; System.out.println(&quot;Singer can swim....?&quot;); &#125;&#125; 노래를 하는 Singer클래스는 여러 기능을 포함하는 큰 인터페이스를 구현하고 있다.이에 대한 부작용으로 Singer클래스는 자신이 해야할 역할 외에도 다른 기능을 구현해야 하게 된다. 123456789101112131415interface Singable&#123; void sing();&#125;interface Runnable&#123; void run();&#125;interface Swimable&#123; void swim();&#125;class RealSinger implements Singable&#123; @Override public void sing() &#123; System.out.println(&quot;Singer can sing a song~!&quot;); &#125;&#125; 인터페이스를 구체적으로 나눴더니, Singer클래스가 필요한 역할만 구현할 수 있게 됐다! D : 의존 역전 원칙(DIP)의존 관계를 맺을 때, 변하기 쉬운 것보다 변화하기 어려운 것에 의존해라!변화하기 쉬운 것 -&gt; 구체적으로 구현된 것변화하기 어려운 것 -&gt; 추상화 된 것(인터페이스, 추상 클래스) 즉 의존관계를 맺을 때, 실제 구현된 클래스가 아닌 인터페이스나 추상 클래스과 맺으라는 뜻!! 역전? 즉 원래 변하기 쉬운 것에 상위 모듈이 의존하면 : 변화할때마다 상위 모듈도 따라 변화해야 함!그러나 인터페이스 같이 변하기 어려운 것에 상위 모듈이 의존하면?하위 모듈은 인터페이스에 의존하도록 하여(역전!),수정을 아무리 해도 상위 모듈이 인터페이스를 의존하는 한 문제는 없다! 12345678910111213public class ImageDisplay &#123; public static void main(String[] args) &#123; FileDisplayer fileDisplayer = new FileDisplayer(); Displayable file = new Jpg(); fileDisplayer.setFile(file); fileDisplayer.play(); file = new Gif(); fileDisplayer.setFile(file); fileDisplayer.play(); &#125;&#125; 아까 사용했던 예시에서 보면, 실제 구현된 Jpg 클래스의 메소드를 부르는게 아닌,Diplayable 인터페이스의 메소드를 호출하는 방식으로 의존관계를 만든다!!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"29. 백준 1080번 행렬(그리디)","slug":"cs/algorithm/problem/al29","date":"2021-09-27T04:33:09.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/27/cs/algorithm/problem/al29/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/27/cs/algorithm/problem/al29/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1080 이 문제는 그리디로 접근해야 한다.그리디는 현재 상황에서 최선을 고르는 과정을 반복해서 답을 찾아가는 것 근데 나는 개인적으로 저 정의보다 다음과 같이 이해하는게 빨랐다.그리디는 뒷 일을 생각하지 않는 거다!! 풀이법 이 문제에서도 풀이법은“처음부터 답안과 비교해 다른 원소를 만나면 그 원소를 바꾼다.” -&gt; 현재 상황의 최선그리고 문제 조건에 따라 뒤에 따라오는 원소들(3x3배열 만큼)도 바꾼다. -&gt; 이건 어찌되던 지금 신경 안씀 검증 자 이게 진짜 작동하는지 검증해보자!!!그리디 검증은 최적해를 구하는 임의의 알고리즘을 가정하고, 이 것이 우리 방법보다 좋지 않음을 보이면 된다. 임의의 배열 arr이 있다고 할 때우리의 풀이로 3번 연산하면 목표 배열을 만들 수 있다고 하자.(이 세 값을 a1, a2, a3라 하자.) 임의의 알고리즘의 최소 연산 2개라고 가정하고, 연산이 일으키는 위치 b1, b2가 있다고 하자. 이때 주어진 배열이 목표 배열과 다른 가장 처음 위치는 a1이다.연산을 통해 a1의 위치를 바꿀 수 있는 원소는 a1 자신과, a1보다 왼쪽에 있거나, 위에 있거나, 왼쪽 대각선에 있는 원소일 것이다.그러나 a1 이전에 있는 원소들은 이미 목표 값과 맞는 원소들이다. 즉 하나의 값을 맞추기 위해 이미 맞는 원소들 바꾸게 되어, 더 연산하게 된다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344package week4;import java.util.*;import java.io.*;public class No1080&#123; static int N; static int M; static char [][] arr1; static char [][] arr2; public static void change(int a, int b)&#123; for(int i = 0 ; i &lt; 3 ; i++)&#123; for(int j = 0 ; j &lt; 3 ; j++)&#123; if(arr1[a+i][b+j] == &#x27;0&#x27;) arr1[a+i][b+j] = &#x27;1&#x27;; else arr1[a+i][b+j] = &#x27;0&#x27;; &#125; &#125; &#125; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader( new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); N = Integer.parseInt(st.nextToken()); M = Integer.parseInt(st.nextToken()); arr1=new char[N][M]; arr2=new char[N][M]; int result = 0; for(int i = 0 ; i &lt; N ; i++)&#123; arr1[i] = bf.readLine().toCharArray(); &#125; for(int i = 0 ; i &lt; N ; i++)&#123; arr2[i] = bf.readLine().toCharArray(); &#125; for(int i = 0 ; i &lt; N-2 ; i++)&#123; for(int j = 0 ; j &lt; M-2 ; j++)&#123; if(arr1[i][j]!= arr2[i][j])&#123; change(i,j); result++; &#125; &#125; &#125; if (!Arrays.deepEquals(arr1,arr2)) System.out.println(-1); else System.out.println(result); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"https://yangdongjue5510.github.io/tags/greedy/"}]},{"title":"11. 카카오 로그인 OAuth2.0 개념","slug":"spring/boot/boot11","date":"2021-09-24T05:25:56.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/24/spring/boot/boot11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/24/spring/boot/boot11/","excerpt":"","text":"실제에는 나라는 사람은 한명인데, 수만은 웹사이트마다 회원가입하면, 인터넷 속 나는 엄청 많아진다…그래서 네이버, 카카오 계정으로 다른 사이트를 사용할 수 있게하자! 장단점 장점 : 인증처리를 우리가 안해도 됨단점 : 각 사이트에서 필요한 정보가 네이버나 카카오 정보에 없을 수도 있음… OAuth (Open Auth)인증 처리를 대신해주는 기능. 인증 처리 과정사용자가 웹서버에서 카카오 로그인 요청을 카카오 API서버로 보낸다.정상 요청이면, 웹서버에 특정 코드를 담아서 콜백한다.웹서버는 해당 코드를 받으면, 해당 사용자가 카카오 로그인에 성공했음을 알게된다. 정보 접근 위임 과정특정 사용자가 카카오 로그인을 통해 인증 됐음을 전제웹 서버에서 카카오로 특정 사용자의 코드를 보내면서 권한을 요청하면,카카오 API서버는 코드를 검사해서 카카오 자원서버로 접근할 수 있는 토큰을 웹서버에 준다.이 토큰은 웹서버가 특정 사용자의 정보로 접근할 수 있도록 한다. 이 과정에서 용어를 정리해야 한다.요청하는 사용자 -&gt; 리소스 오너웹 서버 -&gt; 클라이언트카카오 API서버 -&gt; 인증 서버카카오 자원 서버 -&gt; 리소스 서버 스프링에서 OAuth2.0 스프링에서는 facebook, google을 공식적으로 OAuth를 제공한다.OAuth2 client 라이브러리를 사용하면 쉽게 사용할 수 있다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"21.[블로그 프로젝트] 글 삭제, 수정 구현하기","slug":"spring/blog/blog21","date":"2021-09-21T08:15:36.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/21/spring/blog/blog21/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/21/spring/blog/blog21/","excerpt":"","text":"삭제하기BoardService에 메소드 추가1234@Transactionalpublic void deletePost(int id)&#123; boardRepository.deleteById(id);&#125; ApiController에 메소드 추가하기12345@DeleteMapping(&quot;api/board/&#123;id&#125;&quot;)public ResponseDto&lt;Integer&gt; deleteById(@PathVariable int id)&#123; boardService.deletePost(id); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림&#125; board.js로 버튼 눌렸을 때 요청하기.12345678910111213141516deleteById : function()&#123; //ajax 호출 시 비동기 호출 var id = $(&quot;#id&quot;).text(); $.ajax(&#123; type : &quot;DELETE&quot;, url : &quot;/api/board/&quot;+id, dataType: &quot;json&quot; &#125;).done(function (resp) &#123; alert(&quot;글삭제 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);&#125; detail.js에서 세션 검증 추가123&lt;c:if test = &quot;$&#123;board.user.id == principal.user.id&#125;&quot;&gt; &lt;button id=&quot;btn-delete&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt;&lt;/c:if&gt; principal에 저장된 세션 정보와 게시물의 작성자가 동일할 때만 버튼 생성. 수정일단 버튼을 눌렀을 때 입력받을 수 있는 페이지로 넘어가도록 하자 컨트롤러에 메소드 추가12345@GetMapping(&quot;/board/&#123;id&#125;/updateForm&quot;)public String updateForm(@PathVariable int id , Model model)&#123; model.addAttribute(&quot;board&quot;, boardService.postDetail(id)); return &quot;board/updateForm&quot;;&#125; 모델에 우리가 고칠 포스트의 내용을 넣고, updateForm 페이지를 띄움 updateForm.jsp 구현123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;input type=&quot;hidden&quot; id=&quot;id&quot; value=&quot;$&#123;board.id&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input value=&quot;$&#123;board.title&#125;&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter title&quot; id=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;textarea class=&quot;form-control summernote&quot; rows=&quot;5&quot; id=&quot;content&quot;&gt;$&#123;board.content&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-update&quot; class=&quot;btn btn-primary&quot;&gt;글수정 완료&lt;/button&gt;&lt;/div&gt;&lt;%--summernote--%&gt;&lt;script&gt; $(&#x27;.summernote&#x27;).summernote(&#123; tabsize: 2, height: 300 &#125;);&lt;/script&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 여기서 버튼을 눌렀을 때 작동할 내용을 스크립트에 적자. board.js에 추가하기12345678910111213141516171819202122232425262728293031323334353637383940414243let index = &#123; init : function()&#123; $(&quot;#btn-update&quot;).on(&quot;click&quot;,()=&gt;&#123; this.update(); &#125;); &#125;, update : function()&#123; let id = $(&quot;#id&quot;).val(); let data = &#123; title: $(&quot;#title&quot;).val(), content: $(&quot;#content&quot;).val(), &#125;; $.ajax(&#123; type : &quot;PUT&quot;, url : &quot;/api/board/&quot;+id, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;글수정 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 2개의 데이터를 json으로 변경해 insert요청! &#125;,``` ### 서비스에 메소드 추가```java @Transactional public void updatePost(int id, Board requestBoard)&#123; Board board = boardRepository.findById(id) .orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;글 수정 실패 : id를 찾지 못함&quot;); &#125;); //영속성 로드 board.setTitle(requestBoard.getTitle()); board.setContent(requestBoard.getContent()); &#125; REST 컨트롤러에 메소드 추가12345@PutMapping(&quot;/api/board/&#123;id&#125;&quot;) public ResponseDto&lt;Integer&gt; update(@PathVariable int id , @RequestBody Board board)&#123; boardService.updatePost(id, board); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"20.[블로그 프로젝트] 게시물 상세보기","slug":"spring/blog/blog20","date":"2021-09-21T07:22:05.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/21/spring/blog/blog20/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/21/spring/blog/blog20/","excerpt":"","text":"BoardService에 postDetail 추가하기123456public Board postDetail(int id)&#123; return boardRepository.findById(id) .orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;글 상세보기 실패 : id를 찾지 못함&quot;); &#125;);&#125; findById를 사용하면 쉽게 처리할 수 있다~ 컨트롤러에 메소드 추가123456@GetMapping(&quot;/board/&#123;id&#125;&quot;)public String findById(@PathVariable int id, Model model)&#123; model.addAttribute(&quot;board&quot;, boardService.postDetail(id)); return &quot;board/detail&quot;;&#125; borad/detail.jsp 파일을 반환해야 한다. index.jsp 수정하기123456789&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards.content&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;/board/$&#123;board.id&#125;&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; 상세보기를 하이퍼링크로 연결하도록 하자. detail.jsp 만들기12345678910111213141516171819202122&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;button class=&quot;btn btn-secondary&quot; onclick=&quot;history.back()&quot;&gt;돌아가기&lt;/button&gt; &lt;button id=&quot;btn-update&quot; class=&quot;btn btn-warning&quot;&gt;수정&lt;/button&gt; &lt;button id=&quot;btn-delete&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt; &lt;br /&gt; &lt;div&gt; &lt;h3&gt;$&#123;board.title&#125;&lt;/h3&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div&gt; &lt;div&gt;$&#123;board.content&#125;&lt;/div&gt; &lt;/div&gt; &lt;hr/&gt;&lt;/div&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 돌아가기, 수정, 삭제 버튼을 만들고, 모델의 글 제목과 글 내용을 가져온다.(아직 수정과 삭제를 구현하지 않았다. 추후에 해보자.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"19.[블로그 프로젝트] 인덱스 글목록 페이징","slug":"spring/blog/blog19","date":"2021-09-17T04:40:45.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/17/spring/blog/blog19/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/17/spring/blog/blog19/","excerpt":"","text":"서비스 구현 - 컨트롤러 연결 - jsp 수정 BoardService 수정하기123456789101112import java.util.List;//스프링이 컴포넌트 스캔을 통해서 Bean에 자동 등록. IoC를 해줌@Servicepublic class BoardService &#123; @Autowired private BoardRepository boardRepository; @Transactional(readOnly = true) public Page&lt;Board&gt; postList(Pageable pageable) &#123; return boardRepository.findAll(pageable); &#125; //찾아서 페이지에 맞도록 분류하고 페이지 객체로 반환&#125; 페이지 설정을 담은 객체인 Pageable을 인수로 받아, Pageable에 맞도록 데이터를 분류한 Page객체를 반환. BoardController 수정하기123456789101112@Controllerpublic class BoardController &#123; @Autowired private BoardService boardService; @GetMapping(&#123;&quot;/&quot;, &quot;&quot;&#125;) public String index(Model model, @PageableDefault(size=3, sort = &quot;id&quot;, direction = Sort.Direction.DESC)Pageable pageable)&#123; model.addAttribute(&quot;boards&quot;, boardService.postList(pageable)); return &quot;index&quot;; &#125;&#125; 스프링에서 html로 데이터를 가져올 때는 Model이 필요하다.그리고, Pageable에 페이지 설정을 저장해서 인수로 전달한다. model에 서비스에서 수정한 postList를 boards와 함께 속성을 추가한다.그리고 index를 반환해서 뷰리졸버가 index.jsp를 찾아 출력하도록한다. index.jsp 수정12345678910111213141516171819202122232425262728293031323334&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards.content&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt;&lt;%-- 플렉스 성질을 가진 객체를 가운대로 모으기.--%&gt;&lt;%-- 버튼 누를때마다 페이지 이동 --%&gt; &lt;c:choose&gt; &lt;c:when test = &quot;$&#123;boards.first&#125;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number-1&#125;&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number-1&#125;&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test = &quot;$&#123;boards.last&#125;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number+1&#125;&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number+1&#125;&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/ul&gt;&lt;/div&gt;&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; page객체는 해당 페이지가 처음인지를 알리는 first, 마지막을 알리는 last, 내용인 content가 있다.첫 페이지면, previous 버튼을 비활성화하고 마지막 페이지는 next 버튼을 비활성화 한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"6. 네트워크 계층(라우터)","slug":"cs/network/network6","date":"2021-09-17T04:06:01.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/17/cs/network/network6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/17/cs/network/network6/","excerpt":"","text":"a. 네트워크 계층의 목적.세그먼트를 받아서 데이터그램으로 만들고, 각 라우터들이 헤더필드를 검사하여 알맞은 곳으로 데이터를 전달.forwarding : 라우터의 입력부터 출력까지 필요한 기능들routing: 소스로부터 목적지까지의 경로를 결정(routing algorithms) b. Data Plane과 control planedata plane : 라우터가 자신이 가진 정보(routing table, forwarding table)를 활용해 경로 결정하는 기능(routing, forwarding)control plane : 소스-목적지에서 어떤 라우터를 만나게 할 것인가를 결정.(traditional routing algorithms과 software defined networking(sdn)방식 존재) b-1. traditional routing algorithms방식각 라우터마다 가지고 잇는 라우팅 알고리즘이 control plane에서 상호작용하여routing table을 각 라우터마다 만들어낸다.데이터가 각 라우터에 올 때마다, 라우터는 라우팅테이블을 활용해 경로를 결정한다.(data plane) b-2. SDN 방식따로 만들어진 remote controller(control plane에 속함)가 각 라우터(data plane)에 있는 control agents(ca)를 제어. 각 라우터들은 서로 상호작용하지 않음.(중앙집중 방식)flow of datagram : datagram의 집합. 라우터a. 라우터 라우터를 간단하게 도식화한 그림이다.녹색, 청색, 적색 네모가 묶인 것을 네트워크 인터페이스라고 부른다.들어오는 통로를 input ports, 나가는 통로를 output ports라고 부른다.라우팅 프로세서에 의해 스위칭패브릭이 아웃풋 포트를 지정해 보낸다.(포워딩) b. input port fucntions line termination : 라우터의 물리 계층. 전자기 신호를 비트로 바꿔주는 역할data link layer : 데이터들을 모아 한 프레임으로 만듬(프레이밍), 그 외에도 많은 역할.(이더넷도 여기에 포함)ip (빨간색 박스) : lookup, (포워딩 테이블을 보고 포워딩 해야할 곳을 찾는 행위), forwarding, queueing(보낼 정보들을 저장.) *이때 lookup&amp;forwarding은 목적지만 활용하는 경우(destination-based), 헤더의 다른 필드를 활용하는 경우(generalized. sdn) b-1 matching : 현재 내가 전달해야되는 패캣의 헤더에 있는 목적지 주소와 포워딩 테이블을 매칭Longest prefix matching : ip주소를 2진수로 표현하여, 앞부터 하나씩 비교하여, 더 길게 일치하는 것을 선정. b-2. Switching fabric메모리 방식 : 입력값을 메모리에 저장하여 출력 하는 곳에서 읽어들임.버스 방식 : 복도처럼 길을 뚫어놓은 상황. 동시에 여러 곳에서 전송할 수 없음. 대기시간이 길어짐.크로스바 방식 : 스위치를 사용하여 사용할 경우에만 해당 경로에 스위치를 켜서 작동시킴. b-3. input port queuing입력 쪽에서 큐잉을 사용하면 효과적이긴 하지만..Head of the Line(HOL) 블로킹 문제가 생김. 세번째 입력포트에서 초록색 데이터는 자기 앞의 빨간색 때문에 쓸데없이 기다리고 있다.만약 세번째 입력포트에서 초록색과 빨간색을 서로 바꾸면 그런 딜레이는 사라질 것. c. output ports input port랑 거꾸로 작동한다고 생각하자.output queuing은 congestion을 일으킬 수 있고 delay나 lost가 생길 수 있다.queuing은 저장한 데이터를 순서를 정해 내보낼 수 있다.(스케줄링) c-1 Scheduling mechanisms, priority버퍼가 얼마나 찼을때 어떤 걸 버릴 것인가, 어떤걸 언제 보낼 것인가를 정함priority scheduling :우선순위에 따라 버퍼를 여러개 운영하여 우선순위를 먼저 보냄. Round Robin scheduling : 온 순서대로 하되, 한쪽 데이터만 보내지 않고 골고루 보내는 방식 Weighted Fair Queuing : Round Robin을 기반으로 하되, 데이터들을 가중치를 부여하여 차이를 두는 방식","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"5. 수송계층","slug":"cs/network/network5","date":"2021-09-16T13:03:49.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/16/cs/network/network5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network5/","excerpt":"","text":"a. 수송 계층 ex. TCP, UDP일반적으로 교환 노드에는 존재하지 않음.(방화벽 같은 예외가 있다.)엔드 시스템에만 존재 보낼 때 조각으로 나눠서 각 조각마다 헤더를 붙여서 보낸다.받을 때는 순서대로 받지는 않는다. 받는 쪽이 수송 계층을 통해 순서를 파악한다. b. 수송 계층 vs 네트워크 계층네트워크 계층 : 어떤 경로로 메시지를 전달할 것인가수송 계층 : 도착한 메시지를 어떤 프로세스로 처리할 것인가.(프로세스들은 포트번호로 구분한다.) c. 인터넷 수송 계층 프로토콜순서대로 전달, 높은 신뢰성(오류 제어)(TCP)-순서 없이 오거나, 잘못된 메시지가 오거나(비트오류),-아예 도중에 메시지가 잃어버리거나, 같은 메시지를 여러번 받거나…=&gt;TCP는 이를 해결할 능력이 있음.순서 없이 전달, 낮은 신뢰성(UDP)두 기능 모두 속도나 딜레이를 보장하지 못한다. d. 멀티플렉싱/디멀티플렉싱 프로세스가 소켓을 통해 요청을 전달하는데,요청들을 하나로 적절한 헤드로 담아 전달한다. 이를 멀티플렉싱이라 한다.이렇게 전달된 헤더를 해석하여 적절한 행동을 하는 것을 디멀티플렉싱이라 한다.디멀티플렉싱은 목적지 수송지 포트 넘버를 통해 어떤 프로세스에 전달해야할지를 파악한다. UDP의 경우(disconnection demux) : 목적지의 포트넘버를 파악해서 포트와 연결된 소켓으로 UDP세그먼트를 전달TCP의 경우(connection-oriented demux) : 소스 ip, 소스 포트넘버, 목적지 ip, 목적지 포트넘버가 모두 일치해야 전달 e. UDP중간 손실이나 순서가 달라져도 특별한 액션을 취하지 않는다.connectionless의 특징.받는 쪽의 프로세스가 작동 중인지 확인하지 않음(no handshaking)(연결설정을 위한 초기지연이 없다)UDP 세그먼트들은 각자 독립적으로 다뤄진다.(세그먼트들이 같이 온 세그먼트인지 관심x)ex. DNS, SNMP 비트 손상에 민감하지 않지만 딜레이에 민감한 어플리케이션에 자주 활용(비디오, 오디오 스트림)신뢰성 향상을 위해서는 어플리케이션 계층에서 해결해야 한다.헤더가 단순한 구조. 사이즈가 작고 구현이 쉬움 f. UDP 헤더32비트 2개이므로 8바이트.length는 헤더를 포함한 UDP 세그먼트의 바이트 길이.checksum는 오류 발생을 확인sender는 자기가 보낸 메시지를 특정 알고리즘의 결과값과 같이 보내고,receiver는 자기가 받은 메시지를 특정 알고리즘에 넣은 결과값과 같이 온 결과값을 비교하여 오류를 검증1의 보수 연산을 통해 메세지의 합과 알고리즘 결과값의 합이 0이 되는 결과값을 반환.1,2,3,-6 =&gt; 0,3,3,-6으로 오는 경우 오류가 발생했지만 checksum으로는 못잡아낼 수 있다. RDTa. 신뢰성있는 데이터 전송의 원칙패켓에 있는 헤더의 특정 정보를 해석을 통해 정보가 제대로 왔는지 확인한다.먼저 어플리케이션 계층에서 수송계층의 RDT의 rdt_send()를 요청하면RDT에서는 정보를 패캣으로 나눠 담고이를 네트워크 계층의 unreliable channel에게 udt_send() 요청을 하게 된다.네트워크를 거쳐 정보가 수송계층에 도착하게 되면 rdt_rcv()요청이 이뤄지고,패캣의 헤더 부분을 실행하고 문제가 없으면 데이터만 꺼내서 deliver_data()요청으로 어플리케이션에게 전달한다. b. FSM (Finite State Machines)로 rdt 프로토콜 기술state : 프로그램이 실행되는 단계화살표 : 프로그램의 상태 변화event : 언제 상태변화가 이뤄지는가action : 상태변화에 따라 프로그램이 수행할 동작 c. rdt 1.0 (오류 없는 상황 가정)비트오류도 없고, 패캣 손실도 없고, out of order(순서오류)도 없다고 가정.수송 계층의 부분만 표현. d. rdt 2.0 (비트오류가 발생할 수 있는 경우)receiver가 재전송을 요구하거나(ARQ), 원본을 추측하여 수정해 사용한다.(FEC)ARQ방식이 일반적.리시버는 ACKs나 NAKs를 센더에게 반환한다.acknowledgements(ACKs) : 문제없음.negative acknowlegements(NAKs) : receiver가 특정 패캣에서 문제 확인=&gt;재전송요구. e. rdt 2.1하지만 데이터가 아닌 컨트롤 메시지(ack, nak)에 문제가 생기면??센더는 이런 문제를 알아차리지 못함. 이를 막기 위해 센더가 각각의 패캣에 시퀀스 번호를 붙여서 보낸다.(짝수번일땐 0, 홀수번일땐 1)리시버는 동일한 번호로 오는 패캣을 버리는 방식으로 운용하게 된다.이를 stop and wait(보내고 응답기다리고 응답오면 보내기이라 한다. f. rdt 2.2rdt 2.1에서 NAK를 안쓰고 ACK만 쓰는 것(기능적으로는 동일)ACK를 보낼때 시퀀스번호를 같이 보내는 방식으로 운용 g. rdt 3.0 (패캣 손실이나 오류 발생할 경우)센더가 패캣을 보내고 타이머를 통해 ACK가 오지 않을 경우 재전송.rdt 3.0은 오류 처리에는 탁월하지만, 성능이 문제다. 리시버의 신호를 기다리는 동안 회선을 낭비하는 셈.따라서 이런 낭비를 막기위해서는 pipelined protocol. 즉 ack를 받지 않고 데이터를 여러번 보내는 프로토콜이 필요하다. h. Pipelined protocolACK를 받지 않고도 다음 패캣을 보냄 n개의 패캣을 ACK없이도 보내되, ACK가 안오면 다시 재전송해야되므로,센더는 ACK가 모두 올 때까지 패캣을 send buffer에 저장하고 있어야한다. h-1. Go-back-NACK를 반환할 때 ACK의 시퀀스 끝번호에 해당하는 ACK만 보냄(3개의 패캣을 받으면 3번 ACK만 보냄)(그렇다면 3번까지의 패캣은 잘 전송됐음을 의미) 센드버퍼(윈도우 사이즈)에 ack없이도 보낼 수 있는 패캣들이 존재하고,보냈지만 ack를 아직 받지 않은 패캣 중 가장 오래된 패캣의 순서 번호를 send_base.아직 보내지 않고 대기 중인 패캣 중 가장 빠른 패캣의 순서 번호를 nextseqnum.센더는 ACK를 받지못한 패캣 중 가장 오래된 패캣(send_base)을 기준으로 타이머를 설정함타이머가 만료되면(오랫동안 ACK가 안오면,) ACK를 받지못한 패캣 모두를 재전송한다. 리시버는 오류 없이 순차적으로 받은 패캣 중 시퀀스 넘버가 가장 큰 값을 ACK로 보낸다.expectedseqnum만 변수로 저장.순서에 맞지 않은 패캣은 그냥 버려버리고 ack를 다시 보내줌(버퍼 없음) h-2. Selective RepeatGBN의 불필요한 패캣 버림을 줄이고, 필요한 경우만 재전송하는 방식으로 효율성을 높임 GBN과 다른점은 리시버도 윈도우사이즈(버퍼)를 갖는다는 점.ACK를 반환할 때 개별적으로 반환.센더는 ACK를 받지 못한 개별적인 패캣으로 타이머를 설정.리시버는 전달받지 못한 패캣 시퀀스를 기억하고 있고 센더는 각 패캣의 타이머에 따라 패캣을 다시 보낸다. h-2-1 Selective repeat dilemma(GBN에서도 발생) 만약 시퀀스 넘버를 0,1,2,3으로 채택해 사용한다고 가정.(2비트일때 표현 가능한 수가 0123)윈도우 사이즈는 자연스럽게 3 마지막에 센더가 재전송한 pkt0을 리시버가 4번째 패캣으로 받아들일 문제가 생긴다!!!이것을 해결하려면 윈도우 사이즈를 줄여야한다.=&gt;시퀀스 넘버에 쓰이는 비트 수 = n일때, 윈도우 사이즈는 2^(n-1)=&gt;2비트인 경우, 윈도우 사이즈는 2로 해야함=&gt;GBN의 경우 2^n-1 TCPa. TCP의 특징 간단요약point to point : 한 리시버와 한 센더가 참여.신뢰성(rdt지원), in order 지원pipelined 형식(버전에 따라 gbn, selective 형식 지원)센드 버퍼와 리시브 버퍼 존재한 연결에서 양방향 데이터 흐름connection oriented(handshaking) 센더와 리시버의 상태정보를 기억.flow controlled 처리 속도보다 전송 속도가 빠를 경우 속도를 조절. b. TCH 헤더 sequence number, ack =&gt; rdt에 사용되는 기능시퀀스 번호와 ack는 바이트 단위당 1씩 늘어간다.head len(head length) : 디폴트 헤드 20바이트 + option의 길이를 확인. option의 존재 유무 파악UAPRSF =&gt;모두 1비트(0과 1 값만 가질 수 있음)U 잘 안쓰임.A ack가 유효한가?P 잘 안쓰임.R reset. 연결리셋 연결강제종료S sync. 연결F final. 연결종료recieve window : 리시버가 현재 받을 수 있는 데이터 량. 플로우컨트롤에 활용check sum : udt에서 check sum과 동일한 기능urg data pointer : 잘 안쓰임option : 있을 수 있고 없을 수도 있는 가변기능(특별한 경우 아니면 잘 안쓰임) c. TCP timerTCP는 데이터에 대한 ack가 정해진 시간내에 오지 않으면 보낸 패캣을 재전송한다. 이때 정해진 시간을 재는 타이머를 너무 길게, 너무 짧게 설정하면 피해를 본다길게 하면, rtt(데이터가 전송되고, ack가 오는 데 걸리는 시간)이 끝나도 다른 패캣을 보내지 않기 때문에 시간적인 손해를 본다.짧게 하면, 정상적으로 ack가 오고 있는데 패캣을 재전송하는 불필요한 작업을 하게 될 수 있다. TCP는 timer를 여유있게 하는편.SampleRTT(측정값)를 다 모아 정규분포 95%의 신뢰도로 타이머를 설정. 하지만 매번 SampleRTT는 매번 달라져 정규 분포 모양이 달라짐.=&gt;SampleRTT 수집방식은 사용할 수 없음.대신 exponential weighted moving average를 사용 EstimatedRTT (특정 시점에서의 RTT의 가중평균)를 통해 대략적인 평균 RTT를 예상. 이를 활용해서 타이머는 EstimatedRTT에 약간의 여유를 줘서 준다.여기서 약간의 여유는 DevRTT(분산값)을 이용한다.즉 TimeoutInterval = EstimatedRTT + 4*DevRTT로 한다. a. TCP의 rdt(신뢰성 있는 데이터 전송)TCP는 ip의 위에서 rdt 서비스를 제공한다.(ip는 신뢰성 없음)​-pipelined 방식 사용(gbn selective 선택 사용)-cumulative ack(누적 ack 방식 사용)-보냈는데 ack를 받지 못한 패캣에 해당하는 타이머 하나를 운용​ b. TCP sender​초기에 NextSeqNum과 SendBase를 초기화.상위 계층이 데이터 전송을 요구할 때, nextseqnum에 해당 되는 데이터를 세그먼트 생성하고,nextseqnum을 생성된 데이터 만큼 뒤로 보내고 타이머 실행. 타이머가 다 되면,​보냈는데 ack를 못받은 데이터 중 시퀀스 넘버가 가장 작은 놈을 다시 보내고 타이머 재시작.ack를 받으면 sendbase를 ack까지 옮김만약 아직 받지 못한 ack가 있다면 타이머를 시작하고 그렇지 않으면 타이머 종료​ c. TCP ack generation event at receiver TCP receiver action 예상한 패캣이 오고 해당 패캣 이전까지는 ack 보냈음 혹시 다른 패캣이 올지 모르니 500ms 기다린 후 안오면 해당 ack를 보냄. 예상한 패캣이 왔는데 해당 패캣 이전에 ack를 안보낸 패캣이 있음 즉시 cumulative ack(누적ack)를 보냄 예상한 패캣보다 시퀀스 번호가 큰 패캣이 온 경우(gap detected) 바로 중복된 ack를 보냄.(지금까지 잘 받은 ack, 리시버가 기다리는 시퀀스 넘버이기도.) 갭을 채우는 패캣이 왔을때 바로 해당 ack를 보냄 ​ d. TCP fast retransmit타이머가 커질 수록 재전송할 때까지 기다리는 시간이 길어지게 된다.=&gt;이런 시간을 줄이려는게 fast retransmit 센더가 여러 세그먼트를 계속해서 보낼 때, 만약 어떤 세그먼트가 없을 경우 리시버는 동일한 ack를 중복해서 계속 보내게 된다.​이럴 경우 센더가 세번의 중복 ack를 받을 경우​타이머를 기다리지 않고 ack를 받지 못한 시퀀스번호가 가장 작은 세그먼트를 바로 재전송한다.​ e. TCP flow control센더가 보내는 양이 리시버가 처리하는 양보다 너무 많으면 이를 조절하는 기능​리시버는 헤더의 receiver window라는 곳에 현재 TCP 리시버 버퍼(RcvBuffer)에남은 공간(rwnd)이 얼마나 있는지를 작성해서 ack에 담아 전송함.​​ e. TCP connection management리시버와 센더가 서로간의 상태정보(초기 시퀀스넘버, 센더버퍼 사이즈, 리시버버퍼 사이즈)를 연결을 시작할 때 서로 교환하지만 TCP는 2way handshaking을 사용하지 않음=&gt; 응답을 보내고 대답을 듣는 시간이 가변적임.​리시버의 재전송시간이 센더의 타이머보다 늦다보니, 센더가 연결 요청을 다시보내게 되고,다시 보내게 된 연결에 따라 data를 전송하게 된다.(x를 보내야 되는데 x+1을 보내게 됨)이렇게 데이터를 전송한 이후 연결을 닫으면 재전송한 연결요청의 답을 들을 수 없게 된다.그래서 TCP는 3way handshaking을 함​​헤더에 있는 syn을 통해 연결 유무를 판단하고, 양방향 연결을 함.(x,y는 임의의 값)이때 acknum=x+1은 비록 연결요청에는 데이터 값이 없지만, 요청 자체가 1비트라고 여겨서 acknum에 +1된것.3 way handshaking은 연결을 닫을 때도 특이하다.​​클라이언트가 먼저 연결을 종료한다고 가정한 상황이다.헤더에 있는 fin을 활용해 연결 종료 의사를 밝힌다.이것이 전달되면 서버도 ack를 통해 클라이언트의 연결 종료 의사를 확인한다.(이때 중요한 건 서버 쪽은 연결을 종료하지 않았다는 것이다. 단지 클라이언트가 연결, 즉 전송을 종료했을 뿐이다.)​그리고 마지막으로 서버도 종료 의사를 전달하여 클라이언트가 받았을 때 클라이언트는 잠시동안 대기한다.왜냐면 클라이언트가 보낸 종료ack가 서버에 잘 전달 안됐을 수 있기 때문이다.(잘 전달되지 않으면 서버는 종료의사를 다시 재전송하게 된다.) TCP 혼잡제어a. 혼잡혼잡의 원인 : 라우터에 들어오는 양이 처리량보다 더 커서. 딜레이가 길어지고, 패켓을 잃을 수 있음.라우터의 버퍼가 무제한이라고 가정하면. 데이터 전송이 계속 커질 수록, 데이터 전송 능력(throughput)능력은 같이 오르다가 한계 이후는 정체된다.하지만 현실엔 다름(라우터 버퍼가 유한함)실제로 유효하게 받은 데이터 처리량을 goodput이라고 한다. 혼잡이 발생하면 라우터에서 로스가 발생-수신자가 재전송-이럴 경우 재전송 데이터는 goodput에는 포함되지 않음.즉 혼잡이 발생하면 goodput과 throughput이 차이가 나게 된다! 여러 센더가 라우터들을 공유하면서 정보를 전송할 때g호스트 D가 B를 향해 데이터를 주고, A가 C를 향해 데이터를 전송한다고 가정.이때 R1라우터를 같이 사용하게 된다. 이때 A가 데이터 전송량을 늘리게 되면? B가 받는 정보량이 줄어들게 된다. 그리고 R1에서 생긴 패캣로스를 다시 재전송하게 되면 R4는 억울하게 정상적으로 했던 일을 다시 또 하게된다.이를 upstream trasmission cpacity의 낭비라고 한다. b. 혼잡 제어TCP의 혼잡제어는 해당 라우터를 사용하는 모든 참가자가 다같이 속도를 내리는 방식. b-1. additive increase multiplicative decrease AIMD방식congestion avoidance 상태에서 적용(전송이 어느정도 진행되고 있을 때 너무 많은 데이터전송을 막음)센더는 네트워크의 혼잡도를 잘 모르니 작은 데이터 먼저 한번 보내보고, 잘 보내졌음을 알게되면, 더 많은 데이터를 보내보고,이 또한 잘 보내졌으면, 더욱 많은 데이터를 보내고…(딜레이나 로스가 발생하게 되면 전송률을 낮춰서 다시 반복) 센더는 cwnd(혼잡제어 방식에 있어서 보낼 수 있는 데이터량), rwnd(플로우컨트롤에 의해 보낼 수 있는 양)), sender widow(rdt에서 보낼수 있는 데이터량) 중 가장 작은 값만큼 데이터를 보내기로 정한다. TCP sending rate = cwnd/RTT(대략적으로) b-2. TCP slow startslow start는 센더가 맨 처음 데이터를 한 세그먼트만 보내보는 것을 의미.잘 보내졌으면 두 세그먼 트를, 그 다음엔 네 세그먼트를… 이런식으로 2^n를 하며 전송 데이터를 늘려감.이렇게 데이터를 늘려가다가 혼잡하게 되면, AIMD로 제어. 초기엔 cwnd= 1 mss(최대로 보낼 수 있는 세그먼트량)매 RTT마다 두배로 늘림. c. 데이터 전송 줄이기timeout이 발생하거나, 중복된 ack가 세번오면 로스로 간주한다.timeout이 발생 시(TCP Tahoe, 구버전), 전송량(cwnd)를 1mss로 재설정함. 다시 slow start 과정을 진행시킴.slow start 이후로 어떠한 임계값(threshold, 정해진 변수)보다 전송량이 커지게 되면, 선형적으로 증가함.TCP Tahoe는 항상 cwnd를 1mss로 만듬(다른 방식을 지원 안하니..)중복 ack가 세번 온 경우(TCP RENO , 신버전), 전송량(cwnd)를 절반으로 낮춤. 그리고 나서 선형적으로 증가(slow start)아님. 상태 이벤트 TCP 센더 대응 비고 Slow Start(SS) 전에 보낸 데이터의 ack를 정상적으로 받음 cwrd가 threshold보다 큰 경우 CA로 변환 매 RTT마다 cwrd를 두배로 Congestion Avoidacne(CA) 전에 보낸 데이터의 ack를 정상적으로 받음 매 RTT마다 cwrd를 1 mss씩 증가(additive increase) SS or CA 중복된 ack를 세번 받음 (로스 감지) threshold를 cwrd의 절반으로 cwrd를 threshold로 하고 CA로 변환 Fast Recovery(threshold부터 증가) SS or CA timeout(로스 감지) threshold를 cwrd의 절반으로 cwrd를 1mss로 하고 slow start 상태로 전환 slow start 진행 SS or CA 중복된 ack duplicate ack 카운트만 증가 cwrd나 threshold는 변경 안함 d. TCP throughputthroughput = 시간당 전송률TCP의 throughput은 복잡하므로 간단한 가정이 필요. slow start 상태는 제외, 항상 보낼 데이터가 존재함을 가정. w=로스가 발생할때 cwrd평균 cwrd는 3/4w평균 throughput은 3w/4rtt이때 가정을 제외하고 현실적인 Throughput은 이때 L은 로스 발생 확률이다. e. TCP Fairness TCP는 여러 사용자가 라우터를 이용하면 결과적으로는 동일한 양의 리소스를 사용하게 된다.두 TCP사용자가 한 라우터를 이용하고, 라우터의 처리양이 100이라고 할 때,(60,20)-전송량 증가-(80,30)-로스발생(값 절반으로 나눔)-(40,15)….이런식으로 가면 결국 (50,50)이됨. e-1 TCP Fairness의 한계UDP와 라우터를 공유하는 경우-UDP가 자원을 더 가져갈 수 있음! TCP를 여러개 사용할 때(여러 프로세스 사용)-여러 TCP를 운용하는 호스트가 자원을 더 가져갈 수 있음! e-2 Explicit Congestion Notification혼잡이 아닌 다른 경우에 ack를 받지 못하는 경우도 존재한다.근데 이런 경우에도 속도를 줄이는 것은 비효율적! 이를 해결하기 위해 네트워크에서 혼잡을 일으킨 호스트에게 혼잡임을 알리게 하자.IP헤더의 Tos필드에 혼잡여부를 기록해서 센더에게 전달! 하지만 많이 사용되지 않음(모든 라우터가 이 기능을 갖춰야하기때문에..)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"4. 어플리케이션(쿠키, 캐쉬, DNS, CDN, 이메일)","slug":"cs/network/network4","date":"2021-09-16T12:44:47.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/16/cs/network/network4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network4/","excerpt":"","text":"a. 쿠키 User-server state : cookies서버가 유저의 상태를 기억하기 위한 쿠키(주문내역 등)맨 처음 유저가 브라우저로 사이트를 방문할 경우 생성이후 해당 브라우저로 사이트 방문시 쿠키를 통해 특정 액션을 취함. b. 쿠키의 네가지 구성요소1. HTTP 응답메시지에 있는 쿠키 헤더라인2. 다음 HTTP 요청 메시지에 있는 쿠키 헤더라인3. 사용자의 브라우저가 관리하는 쿠키파일4. 웹사이트의 백엔드 데이터베이스하지만 보안 상의 위험이 존재. c. 웹 캐쉬(프록시 서버)목적 : 클라이언트의 요구가 근본 서버에 관여하지 않고 안정화하자.(origin server가 클라이언트와 거리가 멀 경우..)프록시 서버(캐쉬)에 주변 클라이언트가 자주 사용하는 데이터를 저장해놓음만약 프록시 서버에 없는 내용을 클라이언트가 요구할 경우,프록시 서버는 origin서버에 해당 데이터를 요구캐쉬는 클라이언트와 서버의 역할을 모두 수행캐쉬 사용 시 응답 시간을 줄이고, 액세스 링크의 트래픽을 줄임 d. Conditional GET캐쉬나 클라이언트에 컨텐츠가 있는 상황에서오리진 서버의 컨텐츠가 변경되었을 경우 동기화를 하기 위한 기능if-modified-since 로 request해서 변경된 데이터를 요구할 수 있다.변경된 값이 존재할 경우 200(OK), 그렇지 않을 경우 304 Not Modified e. E-mail세가지 큰 요소 유저 에이전트-메일서버-SMTP(simple mail transfer protocol)유저 에이전트: 메일을 읽고 , 수정 수행. 서버에 저장된 메시지를 가져오거나 보냄.메일 서버 : 유저로부터 메일을 받음. 보낼 메일들을 메세지 큐에 담음.SMTP : 메일 서버 간 연결해주는 역할 f. SMTPreliably transfer를 위해서 TCP를 이용. 포트 번호 25번direct transfer : 서버끼리 통신은 직접한다.transfer는 세가지 단계를 거친다 (handshaking-transfer-closure)메세지는 반드시 7비트 ASCII코드로 이뤄져야한다.SMTP는 persistent연결을 사용메세지 종료는 마침표(.)로 결정. g. HTTP와 SMTP의 비교HTTP는 클라이언트의 요구를 서버가 응답하는 것(pull)SMTP는 클라이언트의 데이터를 서버가 받아 저장하는 것(push) 둘 다 ASCII 커맨드/응답 상호작용과 status code를 사용.HTTP는 매 오브젝트를 캡슐화해서 하나의 응답 메시지로 보냄SMTP는 여러 오브젝트를 한번에 싹 가져온다. h. 메일 메세지 포맷 i. 메일 액세스 프로토콜-메일 서버에 직접 접근하지 않고 내 pc에서 처리하는 프로토콜-pop3 : 권환확인, 메시지 불러오기, 메시지 삭제 등 지원download and delete (서버에서 불러오면 서버는 비움)download and keep (삭제해도 복사본을 서버가 갖고 있기) -imap : 서버에서 모든 메시지를 보관, 클라이언트가 접속해서 사용동기화에 유리, 메시지 중 일부만 보기 가능. DNSj. DNS : domain name system각각의 노드들을 식별하기 위한 id가 필요하다.대표적인 예시로 ip 주소(32비트)를 활용한다.www.something...com이라는 는 주소로 들어갈 경우DNS가 이 도메인주소를 ip주소로 변환하여 컴퓨터들이 인식할 수 있게한다.분산데이터 : 계층적인 구조를 갖는 네임서버들어플리케이션 계층 프로토콜 : UDP를 사용 k. DNS : serviceshost aliasing : 실제 이름을 줄여서 사용할 수 있게 해준다.예를 들어 www.abcd.ef...com을 www.abcd.com 으로도 접속 가능하게 지원한다. mail server aliasing : 메일서버도 별명을 활용할 수 있다.load distribution : 하나의 웹서버가 모든 요청을 다루기 보다 여러 웹서버가 나눠서 다루는 게 효과적.하나의 도매인에서 여러 ip로 나타내게 하여 요청을 나눠서 다룰 수 있음. 왜 DNS는 분산 형식을 가질까?하나로 모았을 경우 DNS 하나가 망가지면 모두 접속하기 어려워짐한 DNS에 너무 많은 트래픽이 몰림유지보수에도 불리 l. DNS : 계층구조예시. amazon.com을 입력했을 경우1. Root DNS 서버가 TLD DNS 서버 중 com DNS 서버를 찾아 전달2. com DNS 서버는 amazon.com의 DNS 서버를 찾아줌3. amazon.com DNS 서버는 해당 ip를 찾아줌그 외로 local DNS name 서버가 있음.-사용자와 근접하게 작동. 계층 구조에는 포함 안됨.-사용자가 어떤 도매인을 입력하면 해당 도매인에 캐쉬가 있는지 확인하고-있으면 해당 ip를 반환하고, 없을 경우 프록시로 동작하여 쿼리를 계층구조로 요청을 보냄 n. DNS 작동 방식iterated query : local DNS 프록시 역할로 여러 서버와 연결 recursive query : local DNS가 계층 구조에 일을 넘김 m. DNS 캐싱이전에 접속했던 쿼리에 대한 ip를 일정기간동안 기억하고 있다.일정 기간(TTL) 이후 해당 매핑을 지운다.자주 방문하는 쿼리의 TLD서버를 local name 서버가 캐시해놓는다. o. DNS 레코드RR : DNS에 저장되는 데이터의 형식RR format: (name, value, type, ttl)type에 따른 형식 변화-type=A : name은 호스트이름, value는 ip주소-type=NS : name은 도매인주소, value는 authoritative name server의 호스트이름-type=CNAME : name은 alias name(별명), value는 canonical name(원래 이름)-type=MX : name은 메일서버의 alias name, value는 canonical name p. DNS 프로토콜identification : 어떤 query에 대한 응답인지를 구분해주는 역할flag : QR(1비트) : 쿼리인지 응답인지Op code(4비트) : 0(일반적인 쿼리 혹은 응답), 1(inverse query), 2(서버 상태 요청), 4(주의), 5(업데이트) q. DNS에 새로운 레코드 삽입-DNS reigistar 사업자에게 도매인과 해당 ip를 매핑 P2Pr. pure P2P 구조-항상 켜져있는 서버가 존재하지 않음-end system 끼리 직접 통신하게 된다.-이 end system을 peer라고 부른다.-한 서버가 여러 end system에게 전송하는 거 보다 end system끼리 자료를 주고 받게 하는 P2P가 더 확장성이 있음. s. Bit-torrent파일을 256kb의 청크로 나눠 peer들 끼리 청크를 주고 받는 형식traker는 피어들이 누구인지, 누가 참여하고 있는지를 추적하는 장치.만약 새로운 피어가 들어왔을 때 이 피어는 트래커를 통해 어떤 피어와 연결해야하는지를 알 수 있다.청크는 내 이웃 피어들에게서 가져오는데, 이때 청크는 가능한 희귀한(피어들이 덜 가지고 있는) 청크를 가져온다.청크를 보내는 기준은 나에게 많은 청크를 보내준 피어에게 청크를 보내주는 식이다.10초마다 청크 수송신 상황을 점검하고, 30초마다 랜덤한 피어에게 무조건으로 청크를 보내준다. CDNt. DASH (Dynamic, Adaptive, Streaming over HTTP)서버에서는 비디오 파일을 여러개의 청크로 나누고청크들을 여러 방법으로 인코딩하고 저장 manifest file : 다양하게 저장된 청크들이 어디에 저장됐는지(URL) 알려주는 파일 클라이언트에서는 서버-클라이언트 대역폭(다운로드 속도)을 측정해서속도에 따라 manifest가 적당하게 인코딩된 청크 위치를 찾아 보내준다. u. CDN지역적으로 여러개의 서버를 두고 중앙서버로 연결.enter deep : 네트워크 엣지에 CDN을 설치하는 방법. 유저와 가깝고 성능도 좋지만..CDN의 수가 많아지고 관리하기도 힘들다 bring home : 네트워크 엣지가 아닌 ISP코어에 저장하는 방법","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"3. 어플리케이션 계층","slug":"cs/network/network3","date":"2021-09-16T12:31:20.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network3/","excerpt":"","text":"a. 네트워킹 어플리케이션 제작서로 다른 엔드시스템에서 네트워크를 통해 소통하며 작동한다.일반적으로 네트워크에 대해 몰라도 어플리케이션 제작 가능 b. 클라이언트-서버 구조서버 : 항상 연결, 영구적 IP주소, 더 많은 양을 처리하기 위해선 데이터 센터 구비클라이언트 : 간헐적으로 연결, 다이나믹 IP주소 사용(위치에 따라 변경), 직접 통신하진 않음. 통신의 시작 c. P2P(peer to peer) 구조항상 연결된 서버가 없는 구조.엔드시스템끼리 직접 통신 가능자가확장성(self-scalability) : 더 많은 peer가 참여하면 처리 능력도 높아진다.peer들이 연결됐다가 해제됐다가 빈번. 관리 어렵고 IP주소가 자주 바뀜 d. 프로세스어플리케이션 프로그램이 호스트에서 실행되는 것을 프로세스라 함.동일한 호스트 내에서 두 프로세스가 소통할 때 : inter-process communication다른 호스트끼리 프로세스들이 소통할 때 : exchanging messages e. 소켓소켓은 쉽게 API로 이해하자.소켓은 어플리케이션 하위 계층(네트워크 링크…)를 몰라도 호스트끼리 연결될 수 있게 돕는다.메세지만 내가 작성하고 나머지 연결하는 일은 소켓이 한다. f. 포트넘버IP는 호스트의 위치를 나타내는 주소라고 했다.그런데 호스트에도 다양한 프로세스가 존재하는데내가 받은 메시지가 어떤 프로세스에 줘야하는 지는 포트넘버를 통해 이뤄진다. g. 어플리케이션 프로토콜의 역할헤더의 메시지 타입 정의(request인지 response인지)메시지의 어디까지를 헤더로 하고 어디까지를 페이로드로 정할지.(필드 지정)메시지의 정의(100110를 request로 정의하자..)언제 어떻게 메시지를 보내고 답변하는 규칙 수립 h. 어플리케이션 프로토콜의 종류오픈 프로토콜 : RFC에 정의된 프로토콜, 상호연동성 확보, ex.http, smtp사설 프로토콜 : 서비스만하고 프로토콜은 공개하지 않는 경우 ex.스카이프… i. 어플리케이션이 필요로 하는 요소1. data integrity : 정확한 메시지 전달해야 하는지, 그 정도는 아닌지를 파악2. timing : 딜레이가 낮은 것이 중요한지(실시간 게임)3. throughput(bps) : 일정한 속도로 전송받아야 하는지 (스트리밍 서비스)4. security j. TCP UDP 간단하게 알아보기TCP는 data integrity를 제공그 외는 제공하지 않으므로 어플리케이션에서 해결해야 한다.(ex.버퍼링)UDP는 data integrity를 미제공 k. SSL보안을 담당하는 어플리케이션 SSL수송 계층(TCP, UDP)에서는 보안을 지원하지 않아서 SSL같은 어플리케이션에서 해결해야 한다. l. webweb : HTML 베이스, 여러가지 오브젝트 포함URL을 통해 식별(http://www.someschool.edu(호스트이름)/someDept/pic.gif(패스이름)) n. httphttp : hypertext transfer protocolTCP를 사용. 포트번호 80번을 사용.stateless =상태를 기억하지 않음=서버는 클라이언트를 기억하지 않는다. 이전에 통신됐던 클라이언트도 기억해내지 못한다. m. http 종류non-persistent HTTP연결할 때 하나의 오브젝트만 TCP를 통해 전달할 수 있음여러개의 오브젝트를 전달하려면 여러번 연결을 해야함 persistent HTTP한 TCP연결로 여러 오브젝트를 보낼 수 있음 o. http 연결RTT = 패캣이 클라에서 출발해 서버를 거쳐 다시 클라로 올 때 걸리는 시간. HTTP 연결하려면..초기 TCP연결을 위한 최초 RTT요청 HTTP와 응답 HTTP2RTT(persist HTTP)2RTT+file transmission time(non-persist HTTP) p. HTTP 요청 메시지ASCII 형식에 따름.헤더예시 일반적인 헤더 모양 q. 업로딩 형식 입력method 부분에 어떤 것이 오느냐에 따라 달라진다.POST method : input을 entity body에 넣어서 전달GET method(URL method) : input을 request line의 URL에 넣어서 전달(겟 메소드를 사용시 주소창에 ?와 &amp;이 생김) r. 메소드 타입HTTP/1.0 : GET, POST, HEADHTTP/1.1 : GET, POST, HEAD, PUT, DELETE s. HTTP 응답 메시지 t. HTTP 응답 상태 코드첫번 째 줄 두번째 요소를 담당.OK(200) 요구 전달완료. 요구한 오브젝트가 있음Moved Permanently(301) 요구한 오브젝트가 이동되었음. 해당 위치를 담았음Bad Request(400) 서버가 요구 메시지를 이해하지 못했음Not Found(404) 요구 문서를 서버에서 찾을 수 없음505 HTTP Version Not Supported","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"2. 프로토콜","slug":"cs/network/network2","date":"2021-09-16T12:24:09.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network2/","excerpt":"","text":"a. 프로토콜 레이어각 레이어는 순차적으로 서비스를 진행.보내는 쪽에서는 상위-하위 계층 순, 받는 쪽에서는 하위-상위 순으로 진행된다.상위 계층은 하위 계층에게 서비스를 요청, 하위 계층은 상위 계층에게 서비스 제공.이때 보내는 쪽과 받는 쪽이 같은 계층에 위치한 레이어끼리는 peer라고 부른다.각 peer끼리는 헤더와 페이로드를 공유. 헤더에는 송수신지의 내용이 담겨있음. b. 왜 레이어링을 사용하는가복잡한 시스템을 유지보수하기 유리함.한 레이어를 바꾼다고 해도, 다른 레이어에는 큰 영향을 안줌.레이어링은 계층들이 가장 근접한 계층들끼리 서비스를 요청하고 제공하는 시스템인데,최근 들어 몇몇 계층을 생략하고 서비스를 요청하고 제공하는 시스템을 구축하기도.(크로스 레이어, 기존의 레이어링이라고 보기 힘듬.) c. 인터넷 프로토콜 스택어플리케이션 : 네트워크 어플리케이션을 지원 ex.HTTP, FTP, SMTP, WWW, E-mail…수송 : 프로세스간의 데이터를 주고 받는 기능을 지원 ex. TCP, UDP네트워크 : 소스부터 목적지까지 데이터그램의 경로를 결정 ex. IP, routing protocol링크 : 근접한 네트워크를 처리 ex. 이더넷, wifi, PPP물리 : 전자기 신호와 비트를 변환이 프로토콜의 각 계층마다 여러가지 경로(plane)이 존재하는데,데이터 플레인(data plane) : 사용자가 실제로 보내는 데이터가 지나가는 경로컨트롤 플레인 : 프로토콜의 작동 제어를 담당하는 서비스가 지나가는 경로매니지멘트 플레인 : 컨트롤 플레인과 유사. 컨트롤 플레인보다 긴 시간동안 작동 제어한다고 이해. d. ISO/OSI 레퍼런스 모델표준화 모델. 기존의 인터넷 스택에 presentation, session을 추가한 모델(인터넷 스택에서는 어플리케이션에 포함)presentation : 데이터가 어떤 방식으로 이뤄져있는지 분별. ex. 인코딩 방식, 압축 방식 등…session : 송수신지의 동기화, 예기치 못한 전송 중단을 대비한 체크포인트 및 복구 등을 담당 e. 캡슐화메세지는 각 계층의 인접한 peer끼리 control plane에 따라 제어된다.source의 link 계층 peer는 switch의 link가 되고source의 network 계층 peer는 router의 network가 된다.각 peer들은 헤더를 추가하거나 읽으면서 메세지를 제어한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"1. 네트워크 구조와 인터넷","slug":"cs/network/network1","date":"2021-09-16T12:12:51.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network1/","excerpt":"","text":"1. 인터넷이란 무엇인가.a. 네트워크 하드웨어PC, 서버, 스마트폰 등 = 호스트(엔드 시스템)호스트를 연결해주는 선 = 통신 링크(커뮤니케이션 링크)ex.광섬유 등… bandwidth(전송률)이 중요.교환 노드(패켓 스위치, 허브) : 자체로는 데이터를 발생시키지 않지만 중간에 위치한 것.통신 링크가 여러개.ex. 라우터, 스위치, 공유기 b. 인터넷ISP (internet service provider): 인터넷 사업자. sk, kt…인터넷 : 다양한 ISP들을 서로 연결 “network of networks”프로토콜 : 데이터를 주고받기 위해 네트워크를 제어하는 규약ex. TCP, IP, HTTP인터넷 표준 : 프로토콜을 정하는 행위. ex. RFC, IETF c. 서비스 차원의 인터넷다양한 서비스들의 인프라프로그래밍 인프라 제공 : 누구나 인터넷을 통해 프로세서를 개발 가능ex. 소켓. d. 프로토콜포맷/순서/송수신 위치/다양한 상황에 따른 행동규칙 등을 정해놓은 규약. 세밀한 관점의 네트워크 구조네트워크 엣지(엑세스 네트워크) : 어떤 사용자(호스트)와 정보를 주고받는 첫 교환노드와 연결된 노드집합.네트워크 코어 : 엣지를 제외한 나머지. 사용자들이 보지 못하는 내부 노드들.클라이언트 : 데이터를 요구하는 호스트서버 : 데이터를 제공하는 호스트 e. 엑세스 네트워크와 피지컬 미디어유선이냐 무선이냐에 따라공유된 것이냐 아니냐에 따라전송 속도가 유의미하게 달라진다. f. 호스트 : 데이터 패켓을 보내는 것패켓 : 데이터를 보내기 위해 여러 조각으로 나눠지는 단위전송속도 R, 용량 L 일 때 걸리는 시간은 L/R※호스트(비트)-&gt;(피지컬 미디어에 따라 다양한 방법으로 전자기 신호로 변화)-&gt;(비트로 다시 변화)호스트 g. 네트워크 코어교환노드로 구성. 최종 목적지를 파악하고 어디로 보내야 될 지를 결정 후 전달.패켓 스위치 : 예약 없이 보내는 스타일 ex. 인터넷서킷 스위치 : 예약 하고 보내는 스타일 ex. 집전화 h. 패캣 스위칭한 패캣이 모두 전달될 떄까지 저장한 다음 목적지로 전송.end-end delay = 출발지에서 목적지까지 걸리는 지연시간 = 2L/R큐잉 딜레이 : 여러 호스트가 패캣을 보낼 때 교환 노드가 이를 저장하고 있는 상황.*예약하지 않고 막 들어오다 보면, 대기열이 생긴다.-한정적인 메모리를 사용. 꽉차게 될 경우 큐잉 로스가 발생 가능. i. 교환 노드의 주 기능라우팅 : 경로를 결정하는 하는 기능*라우팅 테이블 : 어떤 목적지로 가기 위한 경로를 적어놓은 표*라이퉁 알고리즘 : 경로를 알아내는 알고리즘포워딩 : 패캣헤더를 인식하여 알맞은 목적지를 향해 패캣을 보내주는 행위 j. 서킷 스위칭수신과 발신지의 경로를 예약하여 나만 이용할 수 있음큐잉 딜레이가 발생하지 않음.실시간이 중요한 경우 서킷 스위칭을 사용. k. 패킷 스위칭과 서킷 스위칭의 비교.패킷스위칭은많은 이용자들이 사용할 수 있게 한다.활성화 시간비율이 낮을 떄 유리하다.서킷스위칭은적은 이용자들이 사용할 때 유리하다.활성화 시간비율이 높을 수록 유리하다.(이 경로를 예약한 시간대비 실제로 이용하는 시간)ex.tv, 라디오는 24시간 계속 정보를 보냄… l.서킷스위칭 FDM vs TDM 주파수를 어떻게 나누느냐에 따라 달라짐. j. 인터넷 구조 : 네트워들의 네트워크다양한 액세스 ISP(회사, 가정, 대학 등…)들을 서로 연결하려면?글로벌 ISP를 만들어 교환 노드에 연결한다.이런 글로벌 ISP들이 여러개가 생겨나면서 서로 연결하는 peering link와 IXP(internet exchange point)를 만든다.지역단위 네트워크는 액세스 넷과 글로벌 ISP 사이에서 연결하는 역할을 한다.컨텐츠 제공자 네트워크 : 넷플릭스 구글 같은 존재. 이미 존재하는 네트워크를 사용하기 보다 자기들이 글로벌 ISP역할을 자처함. k. 페켓 딜레이와 로스다양한 호스트가 한 라우터로 패캣을 전송하면,패캣을 다음 노드로 전송할 수 있을 때까지 패캣 조각을 저장하여 딜레이 발생전달된 패켓의 양이 라우터 버퍼가 저장할 수 있는 양보다 많을 때 로스가 생긴다. l. 패켓 딜레이 : 트랜스미션 딜레이와 프로파게이션 딜레이트랜스미션 딜레이 : 패캣길이/대역폭, 한 라우터에서 패캣을 전송할 때 생기는 딜레이프로파게이션 딜레이 : 피지컬링크 길이/프로파게이션 속도, 한 라우터를 떠나 다른 라우터를 도착할 때까지 딜레이 n. 큐잉 딜레이링크 대역폭 : R패켓 길이 : L평균 패캣 전달되는 양 : aLa/R이 1에 근접하면 큐잉 딜레이 발생1보다 크면 로스 발생, 딜레이 무한대 m. traceroute딜레이와 라우트의 작동을 알아보는 기능한 경로에 있는 라우터들마다 3번의 프로브를 보내 응답시간을 체크 n. Throughput어떤 특정한 시간에 얼마나 많은 비트를 전송할 수 있는지를 나타내는 비율.쉽게 말해 링크의 전송능력.정보를 전달 할 때 쓰루풋이 큰 링크에서 작은 링크로 흐르는 것이 유리(딜레이가 발생하기 때문)bottleneck link : end-end path 에서 가장 저조한 throughput을 가진 링크","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"osi 7계층","slug":"cs/network/network0","date":"2021-09-16T12:12:50.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network0/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network0/","excerpt":"","text":"응용 계층(application) 사용자가 접근 할 수 있는 계층 네트워크 활동에 대한 기본적인 인터페이스 제공 사용자가 볼 수 있는 유일 게층 표현 계층(presentation) 응용 계층과 주고 받은 데이터를 인코딩/디코딩 보안을 위해 암호화와 복호화 형식 보유 세션 계층(session) 통신하기 위한 세션을 생성, 유지, 중단 모든 통신 장비를 연결, 관리 연결이 단방향인지 양방향인지 결정 TCP/IP 세션을 담당 전송 계층(transport) 하위 계층이 데이터를 안전하게 전송하도록 함(신뢰) 연결 지향 프로토콜, 비연결 지향 프로토콜을 제공 흐름 제어, 분할, 재조립, 오류 관리 포함 네트워크 계층(network) 물리적인 네트워크 사이의 라우팅 담당 라우터가 이 계층에서 작동 논리적인 주소(IP)를 관리, 패킷을 분할, 프로토콜 인식, 오류 탐지 데이터링크 계층(datalink) 물리적인 네트워크 사이의 데이터 전송 담당 물리적 장비를 식별하는 주소 지점 체계와 데이터 오류 확인 담당 브리지와 스위치가 이 계층에 해당 물리 계층(physical) 데이터가 전송될 때 사용되는 물리체계 전압, 허브, 어댑터 등 모든 하드웨어의 물리적, 전자적 특성 정의 아날로그 &lt;–&gt; 디지털 변환을 담당","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[]},{"title":"18.[블로그 프로젝트] 인덱스페이지 글목록 표시하기","slug":"spring/blog/blog18","date":"2021-09-15T05:52:22.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/15/spring/blog/blog18/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/15/spring/blog/blog18/","excerpt":"","text":"화면 구성일단 index.jsp를 수정하자. 123456789101112131415&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt;&lt;/div&gt;&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; JSTL을 이용해서 for each문을 사용했다.이제 인덱스 분기 처리를 해야되는데, 이걸 하기위해 DB에서 내용들을 가져오는 일을 서비스에 구현해야 한다. 글 조회를 서비스에 구현1234567public class BoardService &#123; @Autowired private BoardRepository boardRepository; public List&lt;Board&gt; postList() &#123; return boardRepository.findAll(); &#125;&#125; 이제 분기처리를 하자 컨트롤러에서 분기처리12345678@Autowiredprivate BoardService boardService;@GetMapping(&#123;&quot;/&quot;, &quot;&quot;&#125;)public String index(Model model)&#123;//스프링에서 데이터를 가져올 땐 Model이 필요!! model.addAttribute(&quot;boards&quot;, boardService.postList()); return &quot;index&quot;; //그냥 컨트롤러는 return시 viewResolver가 작동! -&gt; 해당 인덱스 페이지로 모델의 정보를 들고 이동!&#125; 스프링에서 데이터를 가져올 땐 Model이 필요하다!Model은 컨트롤러에서 생성한 데이터를 view로 전달할 때 사용한다.model에 boards변수로 board리스트를 할당한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"17.[블로그 프로젝트] 글쓰기 구현","slug":"spring/blog/blog17","date":"2021-09-14T06:55:01.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/14/spring/blog/blog17/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/14/spring/blog/blog17/","excerpt":"","text":"BoardControllerBoardController에 글쓰기 버튼을 눌렀을때 분기처리 메소드를 만들자. 12345//USER 권한 필요@GetMapping(&quot;/board/saveForm&quot;)public String saveForm()&#123; return &quot;board/saveForm&quot;;&#125; 화면 구성그리고 views폴더에 board 디렉토리를 만들고 saveForm.jsp를 만들자.부트스트랩에서 타이틀과 textarea를 가져오고글작성 템플릿을 위해 서머노트를 사용하자. header.jsp에서 summernote를 임포트하자!head태그에 다음 코드를 넣어주자. 123&lt;%-- summernote--%&gt;&lt;link href=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-bs4.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-bs4.min.js&quot;&gt;&lt;/script&gt; 그리고 부트스트랩과 서머노트를 적용한 saveForm을 작성하자. 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;Title&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter title&quot; id=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;Content:&lt;/label&gt; &lt;textarea class=&quot;form-control summernote&quot; rows=&quot;5&quot; id=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-save&quot; class=&quot;btn btn-primary&quot;&gt;글쓰기 완료&lt;/button&gt;&lt;/div&gt;&lt;%--summernote--%&gt;&lt;script&gt; $(&#x27;.summernote&#x27;).summernote(&#123; tabsize: 2, height: 300 &#125;);&lt;/script&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 글쓰기 완료 버튼이 form 바깥에 둠으로써, 글 데이터를 폼데이터가 아닌 json데이터로 전달한다는 걸 알 수 있다. 글작성 버튼 누르면 작동되는 js파일 구현이제 board.js를 작성해서, 글내용이 json으로 변환되서 전달해야 한다. 123456789101112131415161718192021222324252627282930313233343536let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. // $(&quot;#btn-login&quot;).on(&quot;click&quot;,()=&gt;&#123; // this.login(); // &#125;);//btn-login을 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; title: $(&quot;#title&quot;).val(), content: $(&quot;#content&quot;).val(), &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //글쓰기를 요청 type : &quot;POST&quot;, url : &quot;/api/board&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;글쓰기 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 2개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); 이제 버튼이 클릭되면, 아약스로 /api/board로 json 데이터를 보낸다.그러면 해당 uri에 맞는 분기처리를 해줘야 겠다!작성된 글을 데이터베이스에 저장하려면 사용자 정보, DB 레포지토리, 글작성 서비스가 필요하다.이제 JPA로 레포지토리를 만들어보자. JPA레포지토리로 Board 테이블 연결하기1234public interface BoardRepository extends JpaRepository&lt;Board, Integer&gt; &#123; //기본적인 CRUD는 모두 가지고 있음.&#125; 글작성 서비스 만들기1234567891011@Servicepublic class BoardService &#123; @Autowired private BoardRepository boardRepository; @Transactional public void writePost(Board board, User user)&#123; board.setCount(0); board.setUser(user); boardRepository.save(board); &#125;&#125; 서비스에 글작성 트랜잭션을 구현했다.이제 분기처리를 해보자. BoardApiController로 분기처리123456789101112@RestControllerpublic class BoardApiController &#123; @Autowired private BoardService boardService; @PostMapping(&quot;/api/board&quot;) public ResponseDto&lt;Integer&gt; save(@RequestBody Board board, @AuthenticationPrincipal PrincipalDetail principal)&#123; boardService.writePost(board, principal.getUser()); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;&#125; save메소드는 바디로 글 정보를 얻고, 시큐리티 세션에 있는 PrincipalDetail을 매개변수를 받아왔다.이를 통해 트랜잭션 메소드에 글내용과 글쓴 유저정보를 인수로 담아 보내고,그 결과를 반환한다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"2. 데이터의 종류(진수, 보수, 논리 게이트)","slug":"cs/struct/struct2","date":"2021-09-14T05:13:54.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/09/14/cs/struct/struct2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/14/cs/struct/struct2/","excerpt":"","text":"보수특정 비트의 최대값을 만드는 a+b가 존재한다면, a와 b는 서로 1진 보수 관계다.2비트의 최대값은 11이다. 10 + 1은 서로 1진 보수다 최대 표현자리 수(modulus)를 형성하는데 서로 보완관계를 이루는 a b를 2진 보수 관계라 한다.1진 보수에 1 더하면 2진보수다. 쉽게 말하면 a = 0011일때, b가 1진보수면 1100이고, 2진보수면 1진보수에 1더한 1101이 된다. 재밌는 사실은 4비트로 수를 표현한다고 할 때 0=0000이다.0의 1진보수는 1111이지만, 2진보수는 10000이다. 즉 5비트가 되버린다!!!!그래서 0의 2진보수는 없도록 설정했고,총 16가지 숫자 중에 0이 보수가 없으므로, 2진보수는 음수가 하나 더 많다.(-8은 1000으로 표현, 하지만 8은 4비트로 표현안된다.)(한편 1진보수는 0의 보수 -0이 존재해서 홀수짝수 갯수가 일치한다.)1진보수로 표현한 4비트 =&gt; (0, 17, -1-7, -0)2진보수로 표현한 4비트 =&gt; (0, 17, -8, -7-1) 보수를 연산에 이용하기(1의 보수 활용) 보수는 뺄셈을 덧셈으로 처리할 수 있다.32-12 =&gt; 32+87(12의 1진보수) = 119이다.119에서 맨앞 숫자(캐리비트)를 제거하고나서 덧셈하면즉 19+1 = 20이 된다! 만약 캐리비트가 발생하지 않는 경우는?32-4032+59 = 91 여기서 1진보수를 취하고 부호를 바꿔주면 된다!-9!! 이진수로 해보면,1011 - 0010 일때,1011 + 1101= 11000 여기서 캐리비트를 제거하고 덧셈하면,1000+0001 = 1001.즉 1011 - 0010 = 1001이 된다. 1011 - 11101011 + 0001 = 1100 여기에 부호를 바꾼 1진보수를 구한다.1011 - 1110 = -0011 정수고정 소숫점을 가지는 수.(소수점의 위치가 어디인지 항상 정확하게 인지)정수도 소숫점을 가진다. 다만 floating하지 않고 고정되어 있을 뿐. 부호화 절대치(signeagnitude) : 부호를 나타내는 비트. 맨 앞 비트가 담당 0이면 양수 1이면 음수 +0과 -0이 둘 다 존재하는 한계 =&gt; 2진 보수를 활용해서 해결 10진수 정수 표현 Unpacked decimal : 1바이트마다 십진수 한 숫자 표현. 입출력용(연산x) Packed decimal : 1바이트마다 십진수 두 숫자 표현. 연산용(입출력x) 소수부동 소수점을 가지는 수.총 32비트를 (부호1+지수7+기수20) 이런식으로 분배.. 소수를 이진법으로 하기 소수를 나타내려면 일단 2를 곱해서 정수 부분이 해당 소숫점 자리 수가 된다.그리고 정수부분(캐리비트라고도 한다)을 버린 나머지를 다시 2를 곱해서 반복한다.이렇게 해서 0이 될때까지 하면 이진법으로 표현된다. 예를 들어 0.625는0.6252 = 1.25 이므로 소수점 첫자리 수는 10.252 = 0.5 이므로 소수점 두번째 자리는 00.5* = 1.0 이므로 소수점 세번째 자리는 1그리고 남은수가 0이므로 과정이 종료되고,0.625의 이진법 표현은 0.101이 된다!!! 한계 그러나 0.3 같은 수는 이진법 표현식으로는 한계가 있다.0.6 -&gt; 1.2 -&gt; 0.4 -&gt; 0.8 -&gt; 1.6 -&gt; 0.2…이렇게 순환반복된다… 이런 상황에서 자료형에 따라 허용된 자리 수까지 표시한다.즉 정확하게 표시가 안된다!!!!!!!! BCD 코드입출력을 위해 10진수를 2진수로 표현해놓은 것.(일일히 2진수로 변환하기 싫어서 만든 것.) 논리 게이트논리 연산을 수행하는 전자소자.입력 받은 변수에 따라 정해진 논리 함수를 수행해서 결과값 반환하는 하드웨어 직렬 연결 스위치는? AND 표현과 동치!병렬 연결 스위치는? OR 표현과 동치!배타적 논리합(XOR) 서로 값이 다를때 1! 1비트 덧셈 구현 예시 각 1비트인 a,b로a + b를 구현해보자. C는 캐리비트고, s는 그 나머지다.a b C s0 0 = 0 00 1 = 0 11 0 = 0 11 1 = 1 0 자 이제 a,b,C,s 간 논리 게이트 관계를 따져보자.C는 a, b가 모두 1일 때 1이다. 즉 a AND b = Cs는 a, b가 서로 다를 때 1이다. 즉 a XOR b = s결과적으로 보면 논리연산자로 산술적 연산인 덧셈이 표현가능하다는 거다!이 결과를 논리 게이트로 표현하면 다음과 같다 부울 대수논리 회로의 형태와 구조를 기술하는 수학적 이론 교환법칙 AB = BA (and) A+B = B+A (or) 결합법칙 A(BC) = (AB)C (A+B)+C = A+(B+C) 분배법칙 A(B+C) = AB+AC 드모르간 법칙 (부득이하게 여집합을 !로 표현.) !(A+B) = !A!B !(AB) = !A+!B 이 법칙들을 적용해 부울 식을 최대한 간편화 할 수 있다! 조합 논리 회로, 자료 기억 방법, 순차 논리 회로조합 회로 : 입출력을 가진 논리 게이트의 집합순차 논리회로는 게이트 뿐만 아니라 기억능력이 있는 플립플롭으로 구성.조합 회로가 연산을 수행한다고 할 때, 임시적으로 데이터를 잠깐 저장해야 할 일이 생긴다.그럴 때 플립플롭에 저장해놨다가 꺼내서 써먹는 방식이다. 대표적인 조합 회로 가산기 : 여러 입력값을 받아 결과물을 출력 멀티플렉서 : 여러 입력 중 하나만 골라서 출력 디멀티플렉서 : 하나의 입력을 여러개의 출력으로 나눠서 보냄 플립플롭 종류와 작동 방식 R-S 래치 : 두 값을 받아서 저장하고 수정할 수 있음.D 플립플롭 : 입력값 D에 따라서 수정, 유지를 할 수 있음 순차회로의 외부 출력은 외부 입력 + 플립플롭 현상태의 함수로 표현","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}],"tags":[]},{"title":"16.[블로그 프로젝트] 스프링 시큐리티 로그인","slug":"spring/blog/blog16","date":"2021-09-13T12:02:53.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog16/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog16/","excerpt":"","text":"시큐리티는 로그인 요청을 가로채간다.우리는 회원가입에 필요한 joinProc uri를 UserApiController에 정의했었다.그러나 로그인에 필요한 메서드는 만들지 않는다.왜? 시큐리티가 가로채가서 로그인을 실행하기 때문. SecurityConfigure 수정이제 로그인을 시큐리티가 실행할 수 있게 수정해보자. 12345678910111213141516@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() //csrf 토큰 비활성화 .authorizeRequests()//요청이 왔을 때 .antMatchers(&quot;/&quot;,&quot;/auth/**&quot;,&quot;/js/**&quot;,&quot;/css/**&quot;,&quot;/image/**&quot;) // /auth로 시작하는건 .permitAll() //모두 접근 가능 .anyRequest() //이 외의 다른 요청은 .authenticated() // 인증해야 접근 가능 .and() // 인증이 필요한 경우 .formLogin() // 로그인 할 수 있도록 한다. .loginPage(&quot;/auth/loginForm&quot;) //이 로그인 페이지에서 .loginProcessingUrl(&quot;/auth/loginProc&quot;) //시큐리티가 해당 주소로 오는 로그인 가로채고 수행 .defaultSuccessUrl(&quot;/&quot;); //요청이 성공하고 나서 해당 주소로 이동. //.failureUrl(&quot;/auth/loginForm&quot;);//실패시 해당 주소로 이동.&#125; .and()부터 로그인에 관련된 내용이다! config 패키지 하위에 auth 패키지 만들고 클래스 작성로그인하고 나면 시큐리티 세션에 사용자 정보가 UserDetails 형으로 저장된다고 했다.이때 UserDetails는 인터페이스로, 이를 구현한 클래스가 필요하다. 그래서 유저 정보를 담을 PrincipalDetail를 UserDetails의 추상메소드를 구현해서 만들어보자 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.cos.blog.config.auth;import com.cos.blog.model.User;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.ArrayList;import java.util.Collection;public class PrincipalDetail implements UserDetails &#123; private User user; public PrincipalDetail(User user)&#123;&#125;; //계정이 어떤 권한을 가졌는지. @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; Collection&lt;GrantedAuthority&gt; collectors = new ArrayList&lt;&gt;(); collectors.add(()-&gt;&#123;return &quot;ROLE_&quot;+user.getRole();&#125;);//role 앞에 ROLE_붙이는건 규칙!!! return collectors; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUsername(); &#125; //계정이 만료됐는지 리턴(true: 만료안됨) @Override public boolean isAccountNonExpired() &#123; return true; &#125; //계정이 잠겼는지 리턴(true: 안잠김) @Override public boolean isAccountNonLocked() &#123; return true; &#125; //비밀번호가 만료됐는지 리턴(true: 만료안됨) @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; //계정활성화 @Override public boolean isEnabled() &#123; return true; &#125;&#125; 이제 로그인된 정보는 PrincipalDetail 객체에 담겨서 UserDetails 형으로 시큐리티 세션에 저장하도록해야 된다. PrincipalDetailService 만들기이제 해쉬화된 비밀번호가 db에 있다는걸 안다. 근데 입력받은건 그냥 패스워드이다.입력받은 패스워드를 동일한 해쉬방식으로 해쉬화해야 db에 있는 것과 비교할 수 있다. 일단 유저정보를 username으로 찾아서 반환하는 서비스를 만들어야 한다.(비밀번호는 시큐리티가 알아서 검사한다.)username으로 정보를 찾아내는 메소드는 JPA에 없으므로 우리가 만들어야한다.UserRepository에서 추상메소드를 만들어보자. 1Optional&lt;User&gt; findByUsername(String username); 이제 해당 메소드를 활용해서 서비스를 만들어보자. 1234567891011121314151617@Service //Bean등록public class PrincipalDetailService implements UserDetailsService &#123; //username과 password를 가로채서 처리할때 //password는 알아서 처리하니까 //username만 DB에 있는지 확인하면 된다. @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User principal = userRepository.findByUsername(username) .orElseThrow(()-&gt;&#123; return new UsernameNotFoundException(&quot;해당 사용자를 찾을 수 없습니다.&quot;+username); &#125;); return new PrincipalDetail(principal); //이때 시큐리티의 유저정보 저장됨! 유저정보가 없다면, user, 콘솔창 비번이 유저정보로 저장될 것이다. &#125;&#125; 이제 이 서비스는 유저 이름을 받아서 레포지토리에 있는 유저정보를 찾아와서 PrincipalDetail로 담아서 반환한다!이제 시큐리티 세션에 PrincipalDetail에 유저정보가 담겨서 로드된다!! SecurityConfig에서 configure 추가하기이제 유저이름을 통해 유저정보를 찾았으니, 이 유저정보의 암호를 동일한 해쉬로 비교하는 configure메소드를 만들어보자. 123456@Autowiredprivate PrincipalDetailService principalDetailService; @Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(principalDetailService).passwordEncoder(encodePWD());&#125; 이제 암호 해쉬기준도 알려줬으니, 로그인은 시큐리티가 알아서 할 것이다! 컨트롤러에서 세션 호출하기 매개변수로 @AuthenticationPrincipal PrincipalDetail principal를 전달해주면됨 12345@GetMapping(&quot;/&quot;)public String index2(@AuthenticationPrincipal PrincipalDetail principal) &#123; System.out.println(&quot;로그인한 사용자 아이디 &quot;+principal.getUsername()); return &quot;index&quot;;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"10. CSRF 와 XSS","slug":"spring/boot/boot10","date":"2021-09-13T11:27:58.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/13/spring/boot/boot10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/boot/boot10/","excerpt":"","text":"XSS자바스크립트를 공격!글 쓰기 같은 내용에 스크립트 태그로 잔뜩 연산시키는 공격.보통 태그를 작성 못하게 막는데, Lucy XSS filter로 막을 수 있다. CSRF쿼리 파라미터로 특정 데이터를 조작할 수 있는 URI가 있을 때,보통 시큐리티로 관리자만 접근 가능하게 해놓는데,해커가 자신의 뜻대로 작성한 URI를 관리자가 클릭하게 만드는 행위. 이런 행위를 막기 위해서는 데이터를 조작하는 URI는 GET방식이 아닌 POST방식을 하는게 좋다. 혹은 CSRF 토큰을 사용한다.사용자가 요청하면 토큰을 생성해 세션에 저장한다.사용자는 요청할때마다 토큰을 보내서 서버가 이를 확인하고 정상임을 알아차린다.","categories":[],"tags":[]},{"title":"15.[블로그 프로젝트] 비밀번호 해쉬화 해서 회원가입","slug":"spring/blog/blog15","date":"2021-09-13T07:37:23.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog15/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog15/","excerpt":"","text":"시큐리티는 어떤 원리로 작동할까?스프링에서 로그인 요청을 하면 시큐리티가 이를 지켜보다가username과 password를 가로채간다.시큐리티는 가로챈 username과 password로 로그인을 진행시키고,시큐리티 세션에 해당 유저 정보 객체를 저장하고, DI하여 사용하도록 한다.(이때, 세션에 저장된 유저 정보는 UserDetails 객체다.) 그러면 우리가 다루려는 객체 형과 UserDetails가 안맞는 경우가 생긴다.(ex. User != UserDetails)-&gt; 우리가 다루려는 객체 형이 UserDetails를 상속-&gt; (User extends UserDetails) 또한 시큐리티가 로그인을 진행할 때, 그냥 비밀번호 자체를 주면 안된다. 해쉬화 해서 진행해야 로그인이 된다.(DB에도 비밀번호를 해쉬값을 저장한다.) SecurityConfig에서 인코더 객체 Bean등록.1234@Bean //IoC / BCryptPasswordEncoder객체를 스프링이 관리public BCryptPasswordEncoder encodePWD()&#123; return new BCryptPasswordEncoder();&#125; UserService 수정BCryptPasswordEncoder 객체를 DI하고,encode 메서드로 주어진 값을 해쉬화한다! 12345678910111213141516@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; @Autowired private BCryptPasswordEncoder encoder; @Transactional //메소드 속 여러 트랜잭션이 하나의 트랜잭션을 묶임 public void signUp(User user)&#123; String rawPassword = user.getPassword(); String encPassword = encoder.encode(rawPassword); user.setRole(RoleType.USER); user.setPassword(encPassword); userRepository.save(user);//잘못된 예외발생시 GlobalExceptionHandler가 예외처리 &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"14.[블로그 프로젝트] 스프링 시큐리티 체험, 로그인 페이지 커스터마이징","slug":"spring/blog/blog14","date":"2021-09-13T06:35:26.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog14/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog14/","excerpt":"","text":"Spring starter security일단 스프링 시큐리티를 이용하기 위해 pom.xml에 있는 관련 dependency를 모두 주석해제하자.그리고 전통적 방식 로그인 메서드를 주석처리하고 다시 사이트에 들어가려면…이렇게 시큐리티가 로그인 화면을 띄우게 된다. 이렇게 Spring starter security는 진입할 때 로그인 정보를 입력하도록 한다! 여기에아이디 : user비밀번호 :콘솔창에 Using generated security password: 뒤에 나온 걸 넣으면 된다. 이렇게 로그인하면 자연스럽게 세션에 적용된다. Spring security taglib일단 링크를 참고하자.header.jsp에서 태그라이브러리를 쓰기 위해 임포트하자. 1&lt;%@ taglib prefix=&quot;sec&quot; uri=&quot;http://www.springframework.org/security/tags&quot; %&gt; 그리고 밑에 다음과 같이 적어주자. 123&lt;sec:authorize access=&quot;isAuthenticated()&quot;&gt;//로그인 됐는지 확인 &lt;sec:authentication property=&quot;principal&quot; var=&quot;principal&quot;&gt;&lt;/sec:authentication&gt;&lt;/sec:authorize&gt; 로그인 됐는지 확인하고, 로그인됐으면 html의 principal변수에 세션의 principal 속성을 집어넣는거다. 스프링 시큐리티 로그인 페이지 커스터마이징일단 전통적인 방법의 로그인과는 달리 user.js로 로그인하지 않을 것이다. 폼으로 전달해줄 것이다.그러기 위해선 loginForm.jsp를 수정해줘야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%-- Created by IntelliJ IDEA. User: MUHN2-031 Date: 2021/09/07 Time: 9:39 오후 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix = &quot;c&quot; uri = &quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;sec&quot; uri=&quot;http://www.springframework.org/security/tags&quot; %&gt;&lt;sec:authorize access=&quot;isAuthenticated()&quot;&gt;//로그인 됐는지 확인 &lt;sec:authentication property=&quot;principal&quot; var=&quot;principal&quot;&gt;&lt;/sec:authentication&gt;&lt;/sec:authorize&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Yangdongjue blog&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-md bg-dark navbar-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Mudura&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapsibleNavbar&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapsibleNavbar&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;empty principal&#125;&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/auth/loginForm&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/auth/joinForm&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/board/Form&quot;&gt;글쓰기&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/Form&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/logout&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/div&gt;&lt;/nav&gt;&lt;br&gt; 그리고 이제 로그인하지 않아도 접근 그낭한 곳은 /auth를 붙인 uri라고 하고 login과 join은 auth를 붙여서 처리하자. config 패키지 - SecurityConfig 클래스프로젝트 폴더에 config 패키지를 만들고,SecurityConfig 클래스를 만들자. 123456789101112131415161718@Configuration //빈 등록(Ioc)@EnableWebSecurity //시큐리티 필터를 등록. 필터 설정을 메소드에서@EnableGlobalMethodSecurity(prePostEnabled = true) //특정 주소를 접근하면 권한/인증을 미리 체크하겠다는 의public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests()//요청이 왔을 때 .csrf().disable() //csrf 토큰 비활성화(테스트시에만!!!) .antMatchers(&quot;/&quot;,&quot;/auth/**&quot;,&quot;/js/**&quot;,&quot;/css/**&quot;,&quot;/image/**&quot;) // /auth로 시작하거나, static한 데이터는 .permitAll() //모두 접근 가능 .anyRequest() //이 외의 다른 요청은 .authenticated() // 인증해야 접근 가능 .and() // 인증이 필요한 경우 .formLogin() // 로그인 할 수 있도록 한다. .loginPage(&quot;/auth/loginForm&quot;); //이 로그인 페이지에서 &#125;&#125; 이제 인증이 필요한 주소 방문시 -&gt; 로그인 페이지인증 불필요한 주소 방문시 -&gt; 접근 허용이렇게 작동한다!!!csrf 토큰은 반드시 테스트에만 비활성화하라!!csrf가_뭔지_모른다면…","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"13.[블로그 프로젝트] 전통적인 로그인 구현","slug":"spring/blog/blog13","date":"2021-09-13T04:33:12.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog13/","excerpt":"","text":"loginForm.jsp회원가입을 구현했던 것과 비슷하게 진행한다.loginForm.jsp에서 button 태그를 form 밖으로 빼고, 스크립트 태그를 추가해 user.js를 읽을 수 있게 했다. 123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form &gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-login&quot; class=&quot;btn btn-primary&quot;&gt;로그인&lt;/button&gt;&lt;/div&gt;&lt;script src = &quot;/blog/js/user.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; user.js이제 user.js에 로그인 버튼이 눌렸을 때 액션을 만들어서 추가해줘야 한다. 이전에 만든 save와 비슷하게 만든다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. $(&quot;#btn-login&quot;).on(&quot;click&quot;,()=&gt;&#123; this.login(); &#125;);//btn-login을 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //회원가입을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;, login : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), &#125;; //ajax 호출 시 비동기 호출 $.ajax(&#123; //로그인을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user/login&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); UserRepository이제 UserService 서비스에 login 트랜잭션을 만들어야되는데, userRepository에 회원확인 할 수 있는 메소드를 만들어야 한다!!! JPA Naming 쿼리 메소드 이름을 통해 쿼리를 작성하는 효과를 얻기. 123//JPA Naming query //SELECT * FROM user WHERE username = ? AND password = ? User findByUsernameAndPassword(String username, String password); 이런 식으로 작성하면 우리가 원하는 쿼리와 동일한 역할을 하는 메소드를 만들 수 있다. 네이티브 쿼리 JPA Naming 쿼리와 같은 효과를 네이티브 쿼리로도 얻을 수 있다. 12@Query(value = &quot;SELECT * FROM user WHERE username = ?1 AND password = ?2&quot;, nativeQuery = true)User login2(String username, String password); 이런 방식은 쿼리가 복잡해질 때 유리하다. 서비스이제 우리에게 필요한 쿼리를 만들었으니 서비스에서 적용시켜보자. 1234@Transactional(readOnly = true)public User login(User user)&#123; return userRepository.findByUsernameAndPassword(user.getUsername(), user.getPassword());&#125; readOnly = true는 select 할 때 트랜잭션이 시작되고, 서비스 종료될 때 트랜잭션도 종료해서 정합성을 유지하는 역할을 한다. 컨트롤러 수정123456789@PostMapping(&quot;/api/user/login&quot;)public ResponseDto&lt;Integer&gt; login(@RequestBody User user, HttpSession session)&#123; System.out.println(&quot;UserApicontroller : login called&quot;); User principal =userService.login(user); if (principal != null)&#123; session.setAttribute(&quot;principal&quot;, principal); &#125; return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);&#125; 컨트롤러도 HTTPSession을 추가했다.로그인에 성공하면 세션에 principal를 추가한다.이 속성으로 서버가 사용자를 추측할 수 있게한다. 그리고 HTTPSession을 private로 따로 빼서 @Autowired해도 된다. 그러면 함수 인자로 전달안해도 된다. JSTL 라이브러리 추가하기이제 로그인 완료한 사용자의 헤더에는 로그인이 뜨면 안된다.이걸 처리하기 위해서 세션에 principal 속성을 확인하고, 이에 따라 분기 처리를 해줘야 한다. 따라서 JSTL의 태그 라이브러리를 사용할 것이다. 1&lt;%@ taglib prefix = &quot;c&quot; uri = &quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 이 코드를 header.jsp 맨위에 붙여놓고, 서버를 실행한다.그 이후, pom.xml에 가서 JSTL dependency가 잘 설정됐는지 확인한다. header.jsp 고치기JSTL의 태그 라이브러리에 따르면, 123456&lt;c:choose&gt; &lt;!-- if문 --&gt; &lt;c:when test=&quot;&quot;&gt; &lt;/c:when&gt; &lt;!-- else문 --&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 이런식으로 jsp 안에 조건문을 사용할 수 있다. 12345678910111213141516171819202122232425262728&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;empty sessionScope.principal&#125;&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/loginForm&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/joinForm&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/board/writeForm&quot;&gt;글쓰기&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/userForm&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/logout&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; 지금까지 전통적 로그인을 구현했다. 하지만 스프링에는 스프링 시큐리티를 이용하면 더 쉽게 구현 가능하다.(시큐리티를 이용할꺼면 만든거 주석처리해주자.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"9. 스프링의 전통적인 트랜잭션","slug":"spring/boot/boot9","date":"2021-09-12T08:15:34.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/12/spring/boot/boot9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/12/spring/boot/boot9/","excerpt":"","text":"스프링이 시작되면 톰캣 시작 web.xml 읽음 context.xml 읽고 DB 연결테스트되면 세팅 끝! 이러고 나서 요청이 들어오면,web.xml -&gt; 필터 -&gt; 스프링컨테이너[컨트롤러-서비스-레파지토리] -&gt; 영속성컨텍스트 -&gt; DB 전통적인 방식 (모두가 다같이 처음에 시작!) web.xml과 필터를 거치게되면… DB 연결 세션 생성(JDBC가 연결됨, CRUD가능) 트랜잭션이 시작. 영속성 컨텍스트 시작. 스프링 컨테이너로 오게되면… 컨트롤러에서 요청을 분기하고 요청에 맞는 서비스를 요청 서비스는 해당 트랜잭션들을 JDBC레파지토리를 통해 실행. 레파지토리의 메소드에 따라 영속성 컨텍스트에서 DB엔티티를 객체화해서 가져옴 객체화된 데이터를 서비스에서 수정하고 컨트롤러에 결과를 전달. 컨트롤러는 json이나 html을 반환 이때 트랜잭션이 종료된다. 영속성 컨텍스트는 값의 변경됨을 인식하고 DB에 flush해서 변경된 값으로 업데이트. 영속성 컨텍스트 종료 DB연결 세션을 종료. 기존방식 개산안과 그 문제점기존의 방식이 너무 쓸데없이 오래걸린다. 개선해보자. 기존방식 개선해볼까(문제가 있음.) 기존에는 컨트롤러로 요청이 넘어가기전에DB 연결 세션 생성 / 트랜잭션이 시작 됐는데,이걸 그냥 서비스가 호출될 때 실행하도록 개선 또, 컨트롤러가 종료될 때트랜잭션 종료 / DB연결 세션 종료 / DB flush 및 영속성 종료 됐는데,이걸 그냥 서비스가 종료될 때 실행되도록 개선 하지만 이렇게 하면 문제가 발생한다!만약 DB에서 MANY TO ONE 관계에서 MANY side에 있는 데이터를 가져오려고 할 때,영속성 컨텍스트는 해당 값을 DB에서 가져올 때 EAGER 전략을 취하면(디폴트 전략이 EAGER),MANY side에 해당하는 데이터 뿐만 아니라 ONE side에 해당하는 자료도 가져온다.그래서 데이터가 컨트롤러에 전달되서 영속성 컨텍스트가 종료되어도,MANY side 데이터나, ONE side 데이터 모두 다룰 수 있다. 만약 LAZY 전략으로 변경하면, ONE side에 해당하는 데이터를 가져오지 않는다.ONE side 데이터의 프록시 객체를 가져온다.(그냥 연결된 빈 객체다.)그래서 컨트롤러에 전달된 데이터는 MANY side 데이터랑 프록시 데이터 뿐이라,ONE side의 데이터를 다룰 수 없다.(게다가 컨트롤러에 전달될 때 영속성 컨텍스트가 종료되서 DB에 요청도 못한다.) OSIV (open session in view, session에 영속성 컨텍스트)아하! 이 문제를 해결하기 위해서 영속성 컨텍스트는 원래대로 컨트롤러가 반환할 때 종료하자!영속성 컨텍스트가 살아있다면, 프록시를 통해 JDBC, 트랜잭션이 종료됐었어도 스스로 JDBC 커넥션을 시작해서프록시에 해당하는 데이터를 가져올 수 있다!(그러고나서 JDBC 커넥션을 닫는다!)하지만 여전히 업데이트는 불가능…(트랜잭션이 종료되서…) 1hibernate.enable_lazy_load_no_trans: true application.yml에 우리가 이렇게 쓰면 문제점을 고친 방식으로 활용 가능하다.(디폴트)하지만 false로 하면 Lazy Loading이 불가능한 방식으로 작동한다. 정리하자면… 영속성 컨텍스트는 컨트롤러가 작동하면서 생성 및 종료!!트랜잭션과 JDBC 커넥션은 서비스가 작동하면서 생성 및 종료! Lazy Loading지금까지 살펴본 일들은, 다 Lazy Loading을 처리하기 위한 일들이다.Lazy Loading은 Eager와 달리, 지금 요청한건 가져오고, 얘랑 관련된건 나중에… 이런 느낌이다.그래서 프록시를 대신해서 가져오고, 프록시를 통해 관련된 데이터를 가져오라고 할 수 있다.(영속성 컨텍스트에 살아있을 때) 즉 영속성 컨텍스트를 언제 생성하고 언제 종료 시킬 것이냐에 대한 포스트였다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"2. DB 격리 수준","slug":"cs/database/database2","date":"2021-09-12T07:37:55.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/09/12/cs/database/database2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/12/cs/database/database2/","excerpt":"","text":"DB 격리 수준트랜잭션의 결과물을 데이터베이스에 적용시키는 기준을 의미 오라클의 READ COMMIT예를 들어 오라클에선 READ COMMIT이란 격리 수준을 가짐.READ COMMIT은 커밋된 것만 읽을 수 있다는 의미다. 만약에 특정 데이터를 수정한다면,원래 데이터는 undo 영역에 복사되고,해당 트랜잭션이 커밋되지 않은 동안 해당 데이터를 select하면,undo에 복사된 데이터가 반환된다.(즉 수정 내용이 적용되지 않는다.)특정 트랜잭션의 변경 사항이 적용되려면 트랜잭션이 끝나고 커밋되어야한다. 문제점 update를 해도 그 즉시 데이터베이스에 적용되지 않는다.즉 한 트랜잭션이 커밋되지 않은 상태에서 다른 트랜잭션이 개입하면예상과 다른 결과를 얻을 수 있다.(정합성이 깨짐, Phantom read) MySQL(InnoDB 스토리지 엔진)의 Repeatable Read자신보다 늦은 트랜잭션의 undo는 반영하지 않는 방식. 즉 한 트랜잭션이 먼저 select로 한 데이터에 여러번 접근한다고 할 때,중간에 다른 트랜잭션이 시작되어 해당 데이터를 수정하고 먼저 커밋되도,먼저 시작한 트랜잭션은 자기보다 늦게 시작한 트랜잭션의 undo를 반영하지 않는다.(즉 그냥 나보다 늦게 시작한 애가 바꾼건 신경 안쓴다.) 이 방식은 트랜잭션을 실행하고 있는 와중에는!데이터의 정합성을 지킬 수 있다!데이터를 조회하는 행위에도 트랜잭션처리를 해주면, 데이터 정합성을 지킬 수 있다","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[]},{"title":"28. 소수 판별 문제(제곱근, 에라토스테네스의 체)","slug":"cs/algorithm/problem/al28","date":"2021-09-11T07:43:30.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/11/cs/algorithm/problem/al28/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/11/cs/algorithm/problem/al28/","excerpt":"","text":"제곱근으로 판별소수를 판별할 때, 굳이 모든 수를 검사 하지 않아도 된다.주어진 수의 제곱근에 해당하는 수까지 검사하면 된다. 1234567boolean isPrime(int num)&#123; if(num == 1) return false; for(int i = 2 ; i &lt; Math.sqrt(num); i++)&#123; if(N%i == 0) return false; &#125; return true;&#125; 에라토스테네스의 체이건 제곱근과는 달리 값의 범위 안에서 소수를 찾는다.배열에 원하는 수 만큼 담아서 2를 만나면 그 뒤 2의 배수는 다 소수가 아니고,그 다음에 3을 만나면 소수처리하고 그 뒤 3의 배수는 다 소수가 아니고…이런식으로 구하려는 범위의 제곱근까지만 검사하면된다!!!! 1234567891011121314public static final int MAX = 100000;boolean[] findPrime()&#123; boolean isPrime = new boolean[MAX+1]; for(int i = 2 ; i &lt;= MAX; i++)&#123; isPrime[i] = true; &#125; for(int i = 2 ; i &lt;= Math.sqrt(MAX) ; i++)&#123; if(isPrime[j] == false) continue; for(int j = i * 2 ; j &lt;= MAX ; j+=i)&#123; isPrime[j] = false; &#125; &#125; return isPrime;&#125; 관련된 문제로 백준6588번 문제가 있다. 123456789101112131415161718192021222324252627282930313233343536import java.util.*;import java.io.*;public class Main &#123; public static final int MAX = 1000000; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); boolean[] isPrime = new boolean[MAX+1]; for(int i = 2; i &lt;= MAX; i++) &#123; isPrime[i] = true; &#125; for(int i = 2; i &lt;= MAX; i++) &#123; if(isPrime[i] == false) continue; for(int j = i * 2; j &lt;= MAX; j += i) &#123; isPrime[j] = false; &#125; &#125; while(true) &#123; int n = Integer.parseInt(bf.readLine()); boolean ok = false; if(n == 0) break; for(int i = 2; i &lt;= n/2; i++) &#123; if(isPrime[i] &amp;&amp; isPrime[n-i]) &#123; System.out.println(n + &quot; = &quot; + i + &quot; + &quot;+(n-i)); ok = true; break; &#125; &#125; if(!ok) System.out.println(&quot;Goldbach&#x27;s conjecture is wrong.&quot;); &#125; &#125;&#125; 이번 문제에서 제일 신기했던건 printf보다 println이 훨씬 빠르다는 것!!!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"1. MongoDB로 NoSQL 찍먹하기","slug":"cs/database/database1","date":"2021-09-09T11:05:01.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/09/09/cs/database/database1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/09/cs/database/database1/","excerpt":"","text":"데이터베이스와 파일시스템의 가장 큰 차이는?자기기술성파일 시스템은 파일을 특정 응용프로그램이 있어야 열 수 있다.db는 sql만 있으면 어떤 응용프로그램이든 열 수 있다.즉 sql은 자기기술성을 가진다. NoSQLNoSQL = Not only SQL = 데이터 접근 방식이 sql말고 다른 거도 가능함Document 타입 : key : value에서 value에 또다른 key value 집합이 들어올 수 있음.(중첩) 확장 가능성이나 스키마 없는 데이터 모델에 유리(데이터의 형태가 일정하면 RDB, 아니면 NoSQL)join을 지원하지 않음(reference 등으로 구현)트랜잭션이 없음.수평확장에 용이 NoSQL 사례 key: value 형식 - RedisDocument = MongoDBColumn = Cassandra MongoDBBSON(binary json)기반 key-value storejson 형태 문서Collection -&gt; Document -&gt; key:value data MongoDB 사용하기(파이썬 기준) pip install pymongopip install requestspip install jupyter[DB인스턴스생성]cloud.mongodb.com - db인스턴스생성 DB연결 123from pymongo import MongoClientclient = MongoClient(url, connect = False)client.DB이름.list_collection_names() DB, collection 할당 12db = client.&#123;DB이름&#125;new_Collection = db.&#123;CollectionName&#125; INSERT data 123456data = &#123; &quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;,&#125;new_Collection.insert_one&#123;data&#125;#여러개를 넣으려면, insert_many. SELECT쿼리에 넣은 기준에 따라 데이터 찾음 123query = &#123;&quot;key1&quot; : &quot;value1&quot;&#125;list(new_Collection.find_one(query))#key1이 value1인 데이터를 찾음 Operatorkey1 = value1 or key2 = value2인 경우.. 1234567query = &#123; $or : [ &#123;&quot;key1&quot; : &quot;value1&quot;&#125;, &#123;&quot;key2&quot; : &quot;value2&quot;&#125;, ]&#125;new_Collection.find(query)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[]},{"title":"1. 컴퓨터 구조에 대한 인트로.","slug":"cs/struct/struct1","date":"2021-09-09T04:05:53.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/09/09/cs/struct/struct1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/09/cs/struct/struct1/","excerpt":"","text":"왜 하드웨어 배워야 되는가?컴퓨터 기본 구조를 알아야 정확하고 깔끔한 코드를 작성할 수 있다. 컴퓨터란 무엇인가?compute(연산하다) + er(하는 사람,도구)고정된 연산만 제공하면 Calculator연산을 작성하고 저장하기도 하면 Computer 컴퓨터는 3가지로 나뉜다 입출력장치CPU : 연산(program counter, arithmetic logic unit으로 나뉨)Memory : 연산 내용 기록 CPU 구성 ALU : 실제 프로그램을 연산(논리, 산술 연산)Control Unit : CPU가 처리해야 할 명령어 해석 후 적절한 신호 발생Bus interface : 다른 하드웨어와 데이터 주고 받는 통로레지스터 : cpu가 요청처리하는데 필요한 데이터를 일시 저장하는 기억장치하드디스크-&gt;RAM-&gt;CPU 이렇게 데이터를 가져오는 거보다 레지스터에서 바로 가져오는게 훨씬 빠르다! 캐시 메모리 : 메모리가 cpu보다 느려서 메모리에서 자주 쓰는걸 캐시에 저장해서 cpu가 빠르게 사용(병목현상 해결) 아키텍쳐 이름의 의미 8비트가 한번에 집어넣을 수 있으면 8비트!32비트 기반 프로세서를 x86이라고 부르는데, 80386처럼 뒤에 86이 고정적으로 붙는 프로세스를 의미.64비트 프로세스는 AMD사가 지배하면서 AMD64 구조라고 이름을 붙이게 됨여기서 비트는 명령을 한번에 처리할 수 있는 레지스터의 비트 수! 명령어 세트 CISC복잡한 명령구조어드레싱에 강점(인덱싱)전력소모가 큼(고성능 컴퓨팅에 사용)Intel x86, AMD64… RISC간단한 명령어메모리 접근 횟수 적음저전력 프로세싱에 사용SPARC, ARM(모바일) 메모리 정보를 저장하는 공간 &amp; 코드+데이터RAM(random access memory 임의접근 메모리)자유롭게 읽고 쓰는 주기억장치메모리 주소로 위치에 접근어떤 위치든 같은 시간에 접근(random access, 임의 접근, 무작위가 아니라 어느 위치든 같은 속도로 접근가능하다는 뜻)휘발성 메모리.(컴퓨터 끄면 다 사라짐.) ROM(read only memory)전원이 끊겨도 정보를 유지하는 주기억장치비싸거나 느려서 안정적인 정보를 저장할 때 사용.BIOS, OS, Firmware 정보 저장에 사용 보조기억장치하드디스크나 SSD같이 대용량의 데이터를 저장하는 곳.속도가 느리지만 저렴하고 대용량의 데이터를 저장할 수 있다. 정보와 데이터의 차이정보 : 가공된 데이터데이터 : 정보를 만들기 위해 필요한 자료, 정보를 처리할 때 좀 더 편리한 형태로 바뀐 자료(이진, 디지털), 정보의 원재료 데이터 표현 및 단위수치 데이터 : 연산용 데이터비수치 데이터 : 입출력용 데이터(문자가 대표적)특수문자 : 입출력/연산용 데이터(암호를 위한 특수문자 등…)비트-바이트-킬로바이트-메가바이트-기가바이트… 폰노이만 구조저장소에 저장된 코드를 메모리로 복사해서 cpu에서 실행폰노이만 이전 : 다른 작업할때마다 하드웨어를 재설계!폰노이만 이후 : 소프트웨어만 교체하면 됨!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}],"tags":[]},{"title":"8. 스프링 부트의 서비스","slug":"spring/boot/boot8","date":"2021-09-08T11:52:21.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/08/spring/boot/boot8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/boot/boot8/","excerpt":"","text":"트랜잭션트랜잭션은 일이 처리되기 위해 데이터를 작성,수정하는 가장 작은 단위를 의미한다.여러 트랜잭션이 묶여서 하나의 트랜잭션이 될 수 있다.(유튜브 영상 찍기를 위해서 - 카메라 준비, 영상 찍기, 영상 편집 이렇게 세가지 트랜잭션이 된다.)(그리고 이 세가지 트랜잭션은 영상을 업로드하기 위한 트랜잭션으로 묶일 수 있다.) 여러 트랜잭션이 모인 것을 우리는 서비스라고 부른다. 서비스의 의미서비스는 여러가지 로직이 묶인 것이라고 이해하자.만약 송금 서비스라 한다면,보낸 사람의 잔고를 update하고, 받는 사람의 잔고를 update하는 두가지 로직이 묶인 것이다.서비스는 자신이 가진 모든 로직이 성공해야 commit을 한다. 즉 보낸 사람의 잔고를 update 했는데, 받는 사람의 잔고를 update 못했다면,송금 서비스는 두 로직 모두를 롤백 시킨다.이처럼 서비스는 여러 트랜잭션을 하나의 트랜잭션으로 묶어서 사용가능하다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"7. Ajax를 사용하는 이유?","slug":"spring/boot/boot7","date":"2021-09-08T10:03:28.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/08/spring/boot/boot7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/boot/boot7/","excerpt":"","text":"회원가입 같은 로직에서 Ajax를 사용하는 이유를 알아보자. 첫번째 이유 요청에 대한 응답을 html이 아닌 Data(json)을 받기 위해서! 만약 브라우저가 회원가입을 요청했다고 하자,요청을 받은 서버는 회원정보를 DB에 넣고, 브라우저에 응답을 보내줘야 하는데,회원가입 성공을 하면 메인화면 html을 보내줄 수 있다. 근데 클라이언트가 항상 브라우저일 수는 없다!예를 들어 앱의 경우 html을 받을 수 없다!앱의 경우 그냥 정상을 의미하는 데이터를 보내줘서 이를 앱이 처리한다. 즉 앱과 웹의 원하는 응답이 다르다!그러면 우리는 서버를 웹,앱 마다 새로 만들어줘야되는건가?아니다! 우리는 그냥 데이터를 응답하는 서버를 만들거다. 그렇다면 브라우저가 어떻게 이를 인식하는가?브라우저가 요청한 회원가입을 서버가 처리해 데이터를 브라우저에게 응답해주면,브라우저는 바로 메인화면을 보여달라는 요청을 보내도록 한다.그러면 서버는 html파일을 응답하고 브라우저는 그 파일을 표시하도록 작동한다. 앱은 그냥 데이터 받으면 자기가 메인화면을 띄울 수 있으므로(즉 html파일을 요청하지 않아도 되므로)즉시 메인화면으로 이동한다. 이렇게 앱과 웹에서 모두 데이터를 응답받을 수 있게 처리하는게 Ajax의 사용하는 이유다. 두번째 이유 비동기 통신을 하기 위해서(순서에 상관없이 처리) 순차적으로 작업을 진행할 경우, 시간이 오래걸리는 작업을 기다리느라(이를 peding이라함)다른 작업들은 기다리기만 하면 상당히 답답할 것이다.예를 들어 RAM과 HDD가 사용되는 작업(IO 등..)을 기다리느라CPU가 필요한 작업이 아무것도 못하게 되는 상황은 비효율적이다. Ajax는 작업을 순차적으로 진행하지 않는다.CPU가 필요하지 않은 작업은 다른 파트(RAM, HDD 등..)에 넘긴다.만약 CPU가 필요한 작업 중, 다른 파트의 작업이 필요한 경우(다운로드 받은 파일을 화면에 띄우기 등..)다른 파트에서 필요한 작업을 마무리 할 때까지 다른 작업을 하고 있거나, 대기하고 있는다.이런 작업 형태를 비동기적 작업이라고 한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"12.[블로그 프로젝트] Ajax를 활용한 회원가입 세팅","slug":"spring/blog/blog12","date":"2021-09-08T08:14:35.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/08/spring/blog/blog12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/blog/blog12/","excerpt":"","text":"JS 세팅resource - static에 js폴더를 만들고 그 안에 user폴더 생성한다.user폴더에 user.js를 만들고 다음같이 작성한다.그리고 jQuery를 사용해 다음같이 작성한다. 1234567891011let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; alert(&#x27;user의 함수 호출&#x27;); &#125;&#125;index.init(); 그리고 joinForm.jsp에 가서 button태그가 form에 있으면 submit이 같이 되기 때문에 button태그 바깥으로 빼준다.그리고 버튼 태그의 type 속성을 지우고, id = “btn-save”를 넣어준다.그리고 스크립트 태그로 우리가 만든 user.js 태그를 사용해서 연결한다. 12345 &lt;/form&gt; &lt;button id=&quot;btn-save&quot; class=&quot;btn btn-primary&quot;&gt;회원가입&lt;/button&gt;&lt;/div&gt;&lt;script src = &quot;/blog/js/user.js&quot;&gt;&lt;/script&gt; 이제 joinForm.jsp에서 스크립트 태그를 읽게되면, js파일의 init을 호출하게 되고, init은 save함수를 호출하게 되므로 user의 함수 호출이라는 알림이 뜨게 된다! 그러고 나서 user.js를 다음같이 데이터를 받아오도록 하고 브라우저 개발자 도구의 콘솔로 확인해볼 수 있도록 해보자. 12345678910111213141516let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125; console.log(data); &#125;&#125;index.init(); Ajax 요청으로 회원가입 처리하기Ajax를 왜 사용할까? 링크 user.js에 Ajax로 다음과 같이 작성하자. 12345678910111213141516171819202122232425262728293031323334let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //회원가입을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); 이 코드를 해석하면this.init은 btn-save를 가진 태그가 클릭되는지 감시하는 리스너를 활성화한다.클릭이 되면 this.save를 호출한다. this.save는 회원가입 페이지에서 입력한 3가지 변수를 가져와 js객체에 할당하고, Ajax로 서버에 회원가입을 요청한다. Ajax의 요청할 때 코드는 이런 의미다.어떤 종류의 요청인지?어떤 url로 요청할 것인가?(js오브젝트를 json으로)body에 어떤 데이터를 담아 보낼 것인가?body에는 어떤 형식의 데이터를 담았는가?응답을 받을 때 어떤 형식으로 오는가? 그리고 나서 성공했을 때의 done과 실패했을 때의 fail을 작성했다.done은 완료 메시지를 브라우저가 표시하고, 메인화면을 표시하도록 한다.fail은 자바 객체로 받은 error를 json으로 바꿔 브라우저에 표시한다. UserApiController 클래스이제 controller 패키지에 api 패키지를 만들고UserApiController 클래스를 만들어 메소드를 만들자. 1234567891011121314@RestControllerpublic class UserApiController &#123; @Autowired private UserService userService; @PostMapping(&quot;/api/user&quot;) public ResponseDto&lt;Integer&gt; save(@RequestBody User user)&#123; System.out.println(&quot;UserApiController save called&quot;); user.setRole(RoleType.USER); userService.signUp(user); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;&#125; 여기에는 dto와 service 개념이 필요한데,일단 dto 패키지를 만들어 ResponseDto클래스를 만들자. 12345678@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class ResponseDto &lt;T&gt;&#123; int status; T data;&#125; 이 객체는 데이터와 http 상태 코드를 저장하는 변수가 있다. 그리고 데이터베이스 트랜잭션을 담당하는 service는 링크를 참고하자.서비스도 service 패키지를 만들어서 UserService 클래스를 만들자. 1234567891011//스프링이 컴포넌트 스캔을 통해서 Bean에 자동 등록. IoC를 해줌@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; @Transactional //메소드 속 여러 트랜잭션이 하나의 트랜잭션을 묶임 public void signUp(User user)&#123; userRepository.save(user);//잘못된 예외발생시 GlobalExceptionHandler가 예외처리 &#125;&#125; 레포지토리를 DI로 가져와서, signUp메소드 속 트랜잭션들을 묶어서 처리한다. 요약이제 회원가입 페이지에 들어가면 user.js에 따라 버튼에 이벤트 리스너가 켜지고,내용을 넣고 회원가입 버튼을 누르면, 내용을 js객체로 담고 Ajax로 json으로 바꿔서 url로 요청한다. UserApiController에 있는 useService서비스를 실행시켜 데이터를 DB에 저장하고 ResponseDto에 http상태와 성공유무 알게 하는 정수 값을 반환한다.요청 성공/실패에 따라, 브라우저가 메시지를 나타낸다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"11.[블로그 프로젝트] 로그인, 회원가입 화면 만들기","slug":"spring/blog/blog11","date":"2021-09-07T12:21:33.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/07/spring/blog/blog11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/blog/blog11/","excerpt":"","text":"템플릿 구성하기우리 블로그에서 모든 페이지에서 푸터가 동일하게 적용될 수 있도록 템플릿을 구성해보자.스크립트 태그를 바디가 끝나는 태그 바로 위에 두자.(다른방식도 있으니 유의하자.)views 폴더 안에 layout 폴더를 만들고, footer.jsp, header.jsp를 만들자. 그리고 index.jsp에서 헤더에 해당하는 부분을 header.jsp로 옮기고,푸터도 index.jsp에서 푸터에 해당하는 부분을 footer.jsp로 가져온다. 그 대신 index.jsp에서 원래 헤더가 있어야 할 자리에 1&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt; 푸터가 있어야할 자리에는 1&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; 이 코드를 넣어주면 정상작동한다! 회원가입, 로그인 페이지 컨트롤러 메소드 만들기1234567891011@Controllerpublic class UserController &#123; @GetMapping(&quot;/user/joinForm&quot;) public String joinForm()&#123; return &quot;user/joinForm&quot;; &#125; @GetMapping(&quot;/user/loginForm&quot;) public String loginForm()&#123; return &quot;user/loginForm&quot;; &#125;&#125; joinForm.jsp, loginForm 만들기부트스트랩4 staked form을 활용.joinForm.jsp 12345678910111213141516171819202122232425262728&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/action_page.php&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email address:&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;Enter email&quot; id=&quot;email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;회원가입&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; loginForm.jsp 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/action_page.php&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;로그인&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"6. intelliJ의 Spring boot 프로젝트에서 JSP파일 생성이 안될 때 해결 방법","slug":"spring/boot/boot6","date":"2021-09-07T10:59:06.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/07/spring/boot/boot6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/boot/boot6/","excerpt":"","text":"자 intellJ로 Spring Boot 프로젝트를 다루는 와중 문제가 생겼다.JSP를 추가하기 위해 디렉토리를 만들었는데…여기 WEB-INF 폴더에서 new를 해도 JSP파일을 고를 수가 없다..! 그래서 혼신의 구글링을 통해 해결방법을 찾았다.File - Project Structure - Web Resource Directory에서 우리가 만든 디렉토리 경로를 추가해주면 된다!wow!참고링크","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}]},{"title":"5. 스프링 기본파싱전략과 JSON통신","slug":"spring/boot/boot5","date":"2021-09-07T08:17:14.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/07/spring/boot/boot5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/boot/boot5/","excerpt":"","text":"Get요청Get은 body에 데이터를 못 담는다.주소에 데이터를 담아 보낸다.데이터 형태는 key : value 형태이다. Post, Put, Delete 요청데이터를 담아보내야 할 것이 많다!body에 담아서 보낸다. form 태그 방식으로 post를 요청할 수 있지만,form은 get, post만 가능하므로자바스크립트로 요청하는게 일반적이다. 결국 자바스크립트로 ajax 요청 + 데이터는 json으로 통일해서 요청한다! 근데 스프링에는 form:form 태그가 있다.put, post, delete, get이 모두 가능하다.(그냥 있다고만 알자.) 스프링 컨트롤러의 기본 파싱전략(key : value 형태의 데이터, form태그 형식)스프링 컨트롤러는 기본적으로 key : value 형태로 파싱해서 변수에 할당한다.스프링은 key : value 형태 데이터를 자바 오브젝트로 파싱해서 받아주기도 한다.해당 자바 오브젝트에 setter가 없으면, key : value 데이터를 파싱하지 못한다.즉 오브젝트에 없는 요소를 넘겨줘도 문제가 일어난다는 의미다. key : value 형식이 아닌 데이터는 어떻게 파싱할까?json이나 text데이터를 스프링 컨트롤러가 받기 위해서는@RequestBody 어노테이션이 필요하다!!!@RequestBody를 붙이면 MessageConverter 클래스를 구현한 jackson라이브러리가 발동되면서데이터를 자바 오브젝트로 파싱해 받아온다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"10.[블로그 프로젝트] 부트스트랩으로 메인화면 만들기","slug":"spring/blog/blog10","date":"2021-09-07T07:56:17.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/07/spring/blog/blog10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/blog/blog10/","excerpt":"","text":"웹 UI를 구현할 때, 굳이 html, css를 모두 구현할 필요가 없다.Bootstrap이나 Materialize를 통해서 쉽게 구현할 수 있다. 우리는 w3school에서 bootstrap4의 collapsing the navigation bar의 코드를 복사한다. 이렇게 프로젝트 구조를 만들어서 index.jsp에 우리가 아까 복사한 내용을 덮어쓰운다.(3번째 줄부터 붙여써야한다.) 그리고 com.cos.blog 하에 controller 패키지를 만든다.그 패키지 안에 BoardController, UserController 클래스를 만든다.다음과 같이 작성해보자. 12345678@Controllerpublic class BoardController &#123; @GetMapping(&#123;&quot;&quot;,&quot;/&quot;&#125;) //아무것도 적지 않거나, /를 붙였을 때 모두 public String index()&#123; return &quot;index&quot;; &#125;&#125; 이렇게 작성 후 localhost:8000/blog/에 접속하면 우리가 아까 만든 index.jsp가 웹에 전달된다..! 그 비밀은 application.yml에 있다. 12345spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp 보다시피 html을 전달해줘야되는 경우, 미리 경로를 지정한 곳에서 파일을 가져가도록 했다. 부트스트랩에서 푸터와 카드 코드를 가져와 약간 수정을 해주면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%-- Created by IntelliJ IDEA. User: MUHN2-031 Date: 2021/09/07 Time: 8:06 오후 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Bootstrap Example&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-md bg-dark navbar-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/blog&quot;&gt;Mudura&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapsibleNavbar&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapsibleNavbar&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/login&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/join&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;&lt;/br&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;%--푸터자리--%&gt;&lt;div class=&quot;jumbotron text-center&quot; style=&quot;margin-bottom:0&quot;&gt; &lt;p&gt;🧑‍💻 created by Yangdongjue5510&lt;/p&gt; &lt;p&gt;💭 Backend Dev.&lt;/p&gt; &lt;p&gt;🌱 Powered by Spring Boot&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"27. 최소공배수, 최대공약수 (GCD, 유클리드 호제법)","slug":"cs/algorithm/problem/al27","date":"2021-09-06T23:49:20.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al27/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al27/","excerpt":"","text":"최대공약수, 최소공배수를 다룬 문제가 나오면 GCD나 유클리드 호제법을 반드시 알고 있어야한다!알아보자! GCD 최대공약수를 구하는 알고리즘두 수 중 작은 수가 0이 될 때까지 반복하면 된다.큰수는 작은수가 되고, 작은수는 큰수를 작은수로 나눈 나머지가 된다. 123456789//a&gt;bint GCD(int a, int b)&#123; while(b !=0)&#123; int r = a % b; a = b; b = r; &#125; return a;&#125; 실제 백준 문제로 확인해보자. 123456789101112131415161718192021import java.util.*;import java.io.*;public class Main&#123; public static int GCD(int a , int b)&#123; while(b != 0)&#123; int r = a%b; a = b; b = r; &#125; return a; &#125; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); int small = GCD(a, b); int big = (a*b)/small; System.out.printf(&quot;%d\\n%d&quot;,small,big); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"26. 백준 10799번 쇠막대기","slug":"cs/algorithm/problem/al26","date":"2021-09-06T23:32:27.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al26/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al26/","excerpt":"","text":"접근 아이디어 스택을 사용해서 “(“이 나올 때마다 push!“)”이 나올때마다 pop하고 나서 스택에 남은 요소 만큼 쇠막대기가 더해지거나 하나만 더해진다.이전에 “(“ 였으면 스택 요소 갯수만큼, 이전에 “)”였으면 그냥 1만 더해진다. 필요한 개념 삼항 연산자에 대해 알아보자.조건문 ? true일 경우 : false일 경우 1int add = prev == &#x27;)&#x27; ? 1 : stk.size(); 코드 12345678910111213141516171819202122232425import java.io.*;import java.util.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); char[] arr = br.readLine().toCharArray(); int result = 0; char prev = &#x27; &#x27;; for(char c : arr)&#123; switch(c)&#123; case &#x27;(&#x27;: stk.push(c); break; case &#x27;)&#x27;: stk.pop(); int add = prev == &#x27;)&#x27; ? 1 : stk.size(); result += add; break; &#125; prev = c; &#125; System.out.println(result); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"25. 백준 17413번 단어 뒤집기2","slug":"cs/algorithm/problem/al25","date":"2021-09-06T23:14:56.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al25/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al25/","excerpt":"","text":"접근 아이디어 &lt; &gt;안에 있는 단어를 그렇지 않은 단어와 다르게 처리해야 한다.그러나 언제 &lt; &gt;가 나올지 모르는게 문제다!그래서 “&gt;”를 기준으로 문장을 나누면 &lt; &gt; 문자열의 위치에 규칙이 생긴다.만약 &lt; &gt;가 있으면 항상 뒤 쪽에 있다는 것! 필요한 문법 이번엔 라벨을 사용해서 루프를 빠져 나왔다. 123456outerLable: for (int i = 0; i&lt;arr.length ; i++)&#123; char c = arr[i]; switch(c)&#123; case &#x27;&lt;&#x27;: break outerLable; 코드 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine(),&quot;&gt;&quot;,true); Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); StringBuilder sb = new StringBuilder(); while(st.hasMoreTokens())&#123; char[] arr = st.nextToken().toCharArray(); int tmp = 0; outerLable: for (int i = 0; i&lt;arr.length ; i++)&#123; char c = arr[i]; switch(c)&#123; case &#x27;&lt;&#x27;: break outerLable; case &#x27; &#x27;: while(stk.size()!=0) sb.append(stk.pop()); sb.append(&#x27; &#x27;); break; default: stk.push(c); break; &#125; tmp++; &#125; while(stk.size()!=0) sb.append(stk.pop()); for (int i = tmp; i&lt;arr.length ; i++) sb.append(arr[i]); &#125; System.out.println(sb); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"9. [블로그 프로젝트] update, delete 테스트","slug":"spring/blog/blog9","date":"2021-09-06T11:35:28.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/06/spring/blog/blog9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/blog/blog9/","excerpt":"","text":"update1. save 메소드를 활용한 update123456789101112131415@PutMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public User updateUser(@PathVariable int id, @RequestBody User requestUser)&#123; System.out.println(&quot;id :&quot;+id); System.out.println(&quot;username: &quot;+requestUser.getUsername()); System.out.println(&quot;password:&quot;+requestUser.getPassword()); System.out.println(&quot;email:&quot;+requestUser.getEmail()); User user = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;수정 실패하였습니다.&quot;); &#125;); user.setUsername(requestUser.getUsername()); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); userRepository.save(user); return user;&#125; Body에서 json 객체를 가져오기 위한 @RequestBody 어노테이션을 사용해서 객체에 할당한다. 일단 save메소드의 특징을 알아보자.객체를 DB에 저장할 때, 해당 id가 이미 있으면, 그 객체 그대로 update한다!즉 일부 속성을 변경하려 하면, 해당 id에 맞는 객체를 DB에서 찾아오고, 그 객체 필드를 수정하고 save해야 올바른 업데이트다.(이거 은근 귀찮다.) save 메소드 id 없이 사용되면 insertid를 넘겨주고, DB에 해당 데이터 있으면 updateid를 넘겨주고, DB에 해당 데이터 없으면 insert 2. @Transactional으로 update(더티 체킹)save하지 않아도 업데이트 된다. 객체를 찾아서 값만 변경하면 반영된다! 12345678910111213141516@Transactional@PutMapping(&quot;/dummy/user2/&#123;id&#125;&quot;)public User updateUser2(@PathVariable int id, @RequestBody User requestUser)&#123; System.out.println(&quot;id : &quot;+id); System.out.println(&quot;username: &quot;+requestUser.getUsername()); System.out.println(&quot;password : &quot;+requestUser.getPassword()); System.out.println(&quot;email: &quot;+requestUser.getEmail()); User user = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;update fail!!!!!!!&quot;); &#125;); user.setUsername(requestUser.getUsername()); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); return user;&#125; 더티체킹_좀더알기 delete삭제는 참 쉽다! 1234567891011//delete@DeleteMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public String delete(@PathVariable int id)&#123; try&#123; userRepository.deleteById(id); &#125;catch(EmptyResultDataAccessException e)&#123; return &quot;삭제 실패했습니다. 해당 id는 데이터베이스에 없습니다.&quot;; &#125; return &quot;삭제됐습니다! id: &quot;+id;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"4. 영속성 컨텍스트와 더티체킹","slug":"spring/boot/boot4","date":"2021-09-06T08:36:10.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/06/spring/boot/boot4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/boot/boot4/","excerpt":"","text":"영속성 컨텍스트?영속성 컨텍스트는 JPA안에 존재하는 개념인데,우리가 만든 컨트롤러에서 save메소드를 호출하게 되면, 영속성 컨텍스트에 1차 캐시라는 것이 생성되고,1차 캐시에 우리가 save메소드의 인자로 보낸 객체가 쌓인다.이 과정을 영속화 되었다고 한다. 이렇게 영속화된 객체를 실제 DB에 저장하는 행위를 flush라고 한다.근데 flush이후에 1차 캐시에는 여전히 해당 객체가 남아있다.나중에 영속화된 객체를 select하는 경우, 데이터베이스에 가지 않고 JPA의 1차 캐시에서 가져오기 때문이다. update하는 경우에도 비슷하다.DB에서 원하는 데이터를 1차 캐쉬에 영속화시키고,컨트롤러가 가져와 수정한다.수정이 끝난 객체를 다시 1차 캐쉬에 영속화 시켜야 하는데, 이때, 1차 캐쉬에는 이미 변경 전 데이터가 영속화되어있다.그리고 변경 후 데이터를 영속화(save메소드)시키려 할 때, 변경 전 데이터와 id값이 같으므로,그냥 변경 전 데이터를 변경 후 데이터처럼 수정 시키는 것으로 영속화를 대신한다. @Transaction 어노테이션 해당 메소드가 종료되면 자동으로 commit한다! (변경 여부를 파악하고 변경된 경우만 DB에 업데이트!)=&gt; 이 기능이 바록 더티 체크일반적으로 DB에서는 변경사항을 모았다가 한번에 반영하는 것을 의미하지만,JPA에서는 변경사항을 인식해서 반영하는 것을 의미한다.[더티체크_예시]","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"8. [블로그 프로젝트]select 테스트","slug":"spring/blog/blog8","date":"2021-09-06T06:12:26.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/06/spring/blog/blog8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/blog/blog8/","excerpt":"","text":"select1. 하나의 데이터 select하기!123456789101112131415161718192021@GetMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public User detail(@PathVariable int id)&#123; //1. User user = userRepository.findById(id).orElseGet(new Supplier&lt;User&gt;() &#123; @Override public User get() &#123; return new User(); &#125; &#125;); //2. User user2 = userRepository.findById(id).orElseThrow(new Supplier&lt;IllegalArgumentException&gt;() &#123; @Override public IllegalArgumentException get() &#123; return new IllegalArgumentException(&quot;해당 유저는 없습니다. id :&quot;+id); &#125; &#125;); //3.Ramda User user3 = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;해당 사용자가 없네요. id: &quot;+ id); &#125;); return user2; 일단 jpaRepository 메소드인 findById를 알아보자.findById는 id를 받아 optional 클래스를 반환한다.(null을 그냥 반환하면 문제가 생길 수도 있기 때문.)그래서 반환형에 안맞으니, 따로 처리를 더 해주자. 1번은 Optional 클래스의 orElseGet메소드로 값이 없는 경우를 처리한다.이때 orElseGet메소드는 supplier 인터페이스를 받으므로, user는 익명 클래스로 get을 오버라이딩해서 처리해줬다. 2번은 Optional 클래스의 orElseThrow로 값이 없는 경우에 예외를 발생시킬 수 있다.3번은 익명 클래스 대신 람다 표현식으로 간단하게 표현했다. 자바에서 자바 객체를 전달하는데 웹브라우저가 어떻게..? 자바 객체를 웹브라우저가 이해하려면 json으로 바꿔줘야한다!스프링 부트는 MessageConverter가 response시 작동해서Jackson 라이브러리를 호출해서 변환한다! 2. 전체 데이터 select1234@GetMapping(&quot;/dummy/users&quot;)public List&lt;User&gt; list()&#123; return userRepository.findAll();&#125; JpaRepository 인터페이스의 findAll메서드는 모든 데이터를 리스트 형식으로 반환한다.참 쉽죠? 3. 페이지로 데이터 select123456@GetMapping(&quot;/dummy/user&quot;) public List&lt;User&gt; list2(@PageableDefault(size = 2, sort = &quot;id&quot;,direction = Sort.Direction.DESC)Pageable pageable)&#123; Page&lt;User&gt; pagingUser = userRepository.findAll(pageable); List&lt;User&gt; users = pagingUser.getContent(); return users; &#125; @PageableDefault를 붙인 Pageable 인터페이스를 인자로 보내준다.@PageableDefault는 한 페이지 당 데이터 갯수, 정렬 기준, 정렬 방향(내림차, 오름차)findAll메서드에 Pageable인터페이스를 인자로 보내주면, 기준에 맞춘 페이지 객체들을 리스트로 만들어 반환한다.이 리스트를 getContent하면 우리가 가져오는 데이터 객체를 가져올 수 있다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"9. 어노테이션","slug":"java/java-basic/java9","date":"2021-09-05T00:48:35.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/05/java/java-basic/java9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/05/java/java-basic/java9/","excerpt":"","text":"어노테이션어노테이션은 자바 소스코드에 추가적인 정보를 제공하는 메타데이터이다.어노테이션 선언 방법을 알아보자 1. 마커 어노테이션표시만 해두는 어노테이션. 메서드 없이 선언하면 마커 어노테이션이 된다.@Override, @Deprecated 가 대표적 예시. 1public @interface Marker&#123;&#125; 이렇게 선언을 해놓으면, 12@Markerpublic class Main(String[] args)&#123;&#125; 2. single value 어노테이션하나의 값을 입력받을 수 있는 어노테이션. 1234public @interface Single&#123; int value(); //이 변수의 이름은 반드시 value //int[] value(); 이렇게 하면 여러 int값을 받을 수 있다.&#125; 이런 식으로 선언할 수 있다. 123456789101112131415161718192021package annotation;import java.lang.annotation.*;import java.lang.reflect.*;@Retention(RetentionPolicy.RUNTIME)@interface Single&#123; int value();&#125;public class Main &#123; @Single(10) public static void myMethod() throws NoSuchMethodException &#123; Main obj = new Main(); Method m = obj.getClass().getMethod(&quot;myMethod&quot;); Single single = m.getAnnotation(Single.class); System.out.println(single.value()); &#125; public static void main(String[] args) throws NoSuchMethodException &#123; myMethod(); &#125;&#125; 이렇게 사용할 수 있다! 3. multi value 오너테이션여러 개의 값을 저장할 수 있는 어노테이션이다. 12345public @interface MultiValue&#123; int id(); String name() default &quot;yang&quot;; String[] roles() default &#123;&quot;Student&quot;, &quot;backend&quot;&#125;;&#125; 이런 식으로 선언할 수 있다. 12@MultiValue(id = 1, name = &quot;yang&quot;, roles = &#123;&quot;a&quot;, &quot;b&quot;&#125;)public void myMethod()... 이런식으로 활용할 수 있다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"8. 객체지향 개념(상속, 업캐스팅, 오버라이딩, 인터페이스)","slug":"java/java-basic/java8","date":"2021-09-03T12:49:07.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/03/java/java-basic/java8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/03/java/java-basic/java8/","excerpt":"","text":"1. 상속extends로 특정 객체의 필드와 메소드를 상속받을 수 있다.이때, super클래스의 private 필드나 메소드는 자식클래스도 직접 접근할 수 없다. 그렇다면 자식 클래스는 상위 클래스의 멤버 변수를 어떤 원리로 사용할 수 있는 건가? 12345678public Super()&#123; className = &quot;super&quot;;&#125;....public Sub()&#123; //super();를 컴파일러가 추가해준다. className = &quot;Sub&quot;;&#125; 즉 자식 클래스의 생성자에는 상위 클래스의 디폴트 생성자를 컴파일러가 추가한다. 2. 업캐스팅 vs 다운캐스팅업캐스팅 : 서브 클래스 -&gt; 슈퍼 클래스서브 클래스 객체더라도 슈퍼 클래스의 필드, 객체만 사용가능. 1Super super = new Sub(); 다운 캐스팅 : 슈퍼 클래스 -&gt; 서브 클래스업캐스팅을 먼저 하고, 슈퍼 클래스를 괄호로. 1Sub sub = (Sub)super; 3. 오버라이딩 vs 오버로딩오버라이딩 : 같은 상속 관계 클래스 간의 같은 이름의 메서드를 재정의 123456789//super.javapublic void methodExample()&#123; ...&#125;//sub.java@Overridepublic void methodExample()&#123; ...&#125; 이때 리턴형, 메소드 이름, 매개변수가 같아야한다! 오버로딩 : 같은 이름 메소드를 매개변수 유형과 개수를 다르게 확장하는 행위 1234567//super.javapublic void methodExample()&#123; ...&#125;public void methodExample(int i)&#123; ...&#125; 4. 클래스 vs 인터페이스클래스 :생성자 가짐인스턴스화 가능다중 상속 가능여러 접근 제어자A는 B의 추상 클래스 = B is a kind of A 인터페이스 :생성자 가질 수 없음인스턴스화 불가능다중 상속 가능항상 publicA는 B의 인터페이스 = B is able to A 인터페이스 키워드 생략 1234(public) interface 인터페이스이름 &#123; (public static final) 변수타입 상수이름 = 값; (public abstract) 반환형 메서드이름(매개변수...);&#125; 괄호 안에 있는 키워드들은 우리가 생략해도, 컴파일러가 넣어준다. 인터페이스의 구현된 메소드 (default, static, private) static method구현된 메소드. 하지만 구현된 클래스에 상속되지 않는다!즉 인터페이스에서만 접근 가능한 메소드인 셈이다. default method이 친구도 구현된 메소드다. 근데 얘는 구현된 클래스에 상속된다.디폴트 메소드는 인터페이스를 구현한 클래스들이 나중에 인터페이스에 추가된 메소드를 구현하지 않아도 사용가능하도록 하기 위해 추가됐다. private method이 녀석도 구현된 메소드이다.static을 붙이기도 한다.근데 이 녀석은 구현된 클래스에 상속되지 않는다.이 녀석은 인터페이스 구현에 필요한 상세 내용을 캡슐할 때 사용된다. confilct 여러 인터페이스의 디폴트 메서드 간의 충돌이 발생하면?12345678910interface a&#123; default void method&#123;&#125;&#125;interface b&#123; default void method&#123;&#125;&#125;public class c implements a, b&#123; @Override public void method&#123;&#125;&#125; 오버라이딩으로 우리가 사용할 메소드를 재정의해야 컴파일 에러가 나지 않는다! 디폴트 메서드와 상위 클래스의 메소드 간의 충돌이 난다면?1234567class a&#123; public void method&#123;&#125;&#125;interface b&#123; default void method&#123;&#125;&#125;class c extends a implements b&#123;&#125; 이럴 경우 a의 method가 우선순위이므로, 수퍼 클래스의 메소드가 실행된다. Collections vs Collection Collection :콜렉션 프레임워크의 인터페이스각 자료구조들이 공통적으로 가지는 메서드들을 포함추상메소드, 정적메소드, 디폴트메소드 모두를 포함가능 Collections콜렉션 프레임워크 객체들을 유용하게 사용할 수 있는 유틸리티 메소드가 정의된 클래스모든 메소드가 정적메소드.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"7. [블로그 프로젝트] 회원가입을 위한 insert 구현하기","slug":"spring/blog/blog7","date":"2021-09-02T11:29:25.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/02/spring/blog/blog7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/02/spring/blog/blog7/","excerpt":"","text":"JpaRepository이제 DB에 insert하기 위해 프로그램을 작성해볼 것이다!먼저 com.cos.blog 패키지 하위에 repository라는 폴더를 만들자.그리고 그 안에 UserRepository 인터페이스를 만들자.이 인터페이스는 DB 저장소에 update할 메소드를 제공한다. 12345678910package com.cos.blog.repository;import com.cos.blog.model.User;import org.springframework.data.jpa.repository.JpaRepository;//자동으로 bean으로 등록//@Repository 생략가능public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; //기본적인 CRUD는 모두 가지고 있음.&#125; JpaRepository&lt;\\User, Integer&gt; : &lt;\\해당 테이블, 그 테이블의 기본키 객체 형&gt;이렇게 JpaRepository를 상속해서 만들면 CRUD에 해당하는 메소드를 이용할 수 있다.그리고 이렇게 처리를 하면 bean으로 자동으로 등록된다! 실제로 잘 되는지 한번 테스트 해보자. Insert 테스트우리는 dummyDataController를 만들어 우리가 만든 레포지토리 인터페이스를 실험해보자. 1234567891011121314151617181920212223242526272829303132333435363738package com.cos.blog.test;import com.cos.blog.model.RoleType;import com.cos.blog.model.User;import com.cos.blog.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DummyControllerTest &#123; @Autowired//해당 클래스가 메모리에 올려지면, 해당 변수 타입에 맞는 객체가 메모리에 있으면 변수에 할당.(DI, 의존성 주입) private UserRepository userRepository; @PostMapping(&quot;/dummy/join&quot;) public String join(String username, String password, String email)&#123; //x-www.form-urelencoded는 key-value형태로 받는데 이는 스프링이 함수의 파라미터로 밸류값을 다 저장해준다. //@RequestParam(&quot;username&quot;) String u...이런식으로 변수명을 유연하게도 가능! System.out.println(&quot;username: &quot;+username); System.out.println(&quot;password: &quot;+password); System.out.println(&quot;email: &quot;+email); return &quot;회원가입이 완료 되었습니다!&quot;; &#125; @PostMapping(&quot;/dummy/join2&quot;) public String join2(User user)&#123; //객체 형태로도 가능하다!(다만 데이터의 키값이 객체의 변수명과 일치해야 함 System.out.println(&quot;role: &quot;+user.getRole()); System.out.println(&quot;username: &quot;+user.getUsername()); System.out.println(&quot;password: &quot;+user.getPassword()); System.out.println(&quot;email: &quot;+user.getEmail()); System.out.println(&quot;createDate: &quot;+user.getCreateDate()); user.setRole(RoleType.USER); //User 클래스의 @DynamicInsert를 대신하는 문장. userRepository.save(user); //회원정보 저장. return &quot;회원가입이 완료 되었습니다!&quot;; &#125;&#125; @Autowired : 이 어노테이션이 담긴 클래스가 메모리에 올라가면, 이 어노테이션 밑 변수에 형에 맞는 객체를 주입(DI)이 어노테이션을 통해 저장소 객체를 변수에 할당할 수 있다.그리고 테이블 객체를 save메소드로 DB에 저장할 수 있다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"6. [블로그 프로젝트] 데이터 테이블 생성 및 관계 설정.","slug":"spring/blog/blog6","date":"2021-09-01T05:26:09.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/01/spring/blog/blog6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/01/spring/blog/blog6/","excerpt":"","text":"application.yml의 JPA일단 application.yml파일에 있는 jpa 관련 내용을 해석해보자. 12345678910jpa: open-in-view: true hibernate: naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl use-new-id-generator-mappings: false ddl-auto: create show-sql: true properties: hibernate.format_sql: true use-new-id-generator-mappings : true면 JPA가 사용하는 기본 넘버링 전략을 사용한다는 의미!ddl-auto : 매 서버를 시작할 때마다 있던 테이블은 지우고, 새로 만들거나(create), 있던 걸 업데이트(update)show-sql : 서버 콘솔에 쿼리를 표시hiberate.format_sql : 쿼리가 정렬되서 나오도록 표시physical-strategy : DB에 이름을 어떻게 저장할 것인가. (현재는 자바 객체 이름 그대로) 데이터 테이블 만들기현 프로젝트의 블로그의 댓글을 위해 user테이블, board테이블, reply테이블을 만들자.JPA로 데이터를 전달하기 위해, User, Board, Reply 클래스를 만들어서각 속성들을 private로 선언한다.이제 각 어노테이션에 대해 알아보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.DynamicInsert;import javax.persistence.*;import java.sql.Timestamp;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entity //User 클래스가 mysql에 테이블이 생성된다.//@DynamicInsert //null인 속성은 insert에서 제외한다.(null이 아닌 default값으로 채우겟다.) 어노테이션에 의존하기보다 로직으로 해결하자.public class User &#123; @Id//primary key @GeneratedValue(strategy = GenerationType.IDENTITY) //넘버링 전략, 프로젝트에 연결된 db의 넘버링 전략을 따라(identity전략) private int id; //시퀀스, auto-increment @Column(nullable = false, length = 30) private String username; @Column(nullable = false, length = 100) //해쉬때문에 넉넉히 잡음 private String password; @Column(nullable = false, length = 50) private String email; //@ColumnDefault(&quot;&#x27;user&#x27;&quot;) //&quot; &#x27;user&#x27; &quot;로 써야함! //private String role; //Enum을 쓰는게 좋지만, 지금은 String사용. @Enumerated(EnumType.STRING)//DB에는 RoleType이란게 없으니까 이 속성이 문자열임을 알 private RoleType role; //Enum을 쓰는 예시. ADMIN, USER @CreationTimestamp //시간이 자동 입력됨. private Timestamp createDate;&#125;package com.cos.blog.model;public enum RoleType &#123; USER, ADMIN&#125; @Entity : 해당 클래스를 JPA에서 테이블로 다루겠다!@Id : 해당 변수를 기본키로 설정@GeneratedValue(strategy = GenerationType.IDENTITY) : 프로젝트에 연결된 DB의 넘버링 전략을 그대로 사용한다.(따로 입력안해도 된다. 자동으로 할당)@Column(nullable = false, length = 10) : null을 허용하지 않고 길이가 10이하인 속성 선언@ColumnDefault(“~”) : 속성의 기본값을 설정 (문자열은 “‘문자열’”로 해줘야!)@Enumerated(EnumType.STRING) : 변수가 enum일때, DB에 저장될 형식 선언@CreationTimestamp : 시간을 생성해 변수에 할당. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.CreationTimestamp;import javax.persistence.*;import java.sql.Timestamp;import java.util.List;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entitypublic class Board &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(nullable = false, length = 100) private String title; @Lob //대용량 데이터를 다룰 때 사용 private String content; //섬머노트 라이브러리 &lt;html&gt;태그가 섞여서 디자인이 된다. @ColumnDefault(&quot;0&quot;) //default value private int count; //자바에서 객체를 저장하면, DB에서는 FK로 구현된다. //객체를 다루려면, 관계를 설정해줘야 한다. @ManyToOne(fetch = FetchType.EAGER) //Many = Board, One = User 한 유저가 여러 게시물을 작성 가능한 관계. //fetch 전략이 해당 클래스를 가져오면 반드시 가져온다.(게시물을 불러오면 user를 반드시 조인해서 불러와라!) @JoinColumn(name = &quot;userId&quot;)//데이터베이스는 객체를 저장할 수 없으므로 userId라는 값이 대신 테이블에 저장된다. private User user; //DB에서는 오브젝트를 저장할 수 없다. 그래서 FK를 사용. 반면 자바는 오브젝트를 저장할 수 있다. @OneToMany(mappedBy = &quot;board&quot;, fetch = FetchType.EAGER) //LAZY : board를 불러온다고 무조건 가져올 필요는 없다!(기본값으로 설정되어잇음) //EAGER : 게시물이 불러오면 무조건 조인해서 가져와야됨! private List&lt;Reply&gt; reply; @CreationTimestamp private Timestamp createDate;&#125; @Lob : 대용량 데이터를 사용할 때 사용.@ManyToOne : 관계를 설정(현재 클래스 to 대상 클래스)fetch = FetchType.EAGER : 해당 클래스를 가져올 때 조인해서 같이 가져오도록함fetch = FetchType.LAZY : 해당 클래스를 가져올 때 반드시 가져올 필요는 없음@JoinColumn(name = “~”) : 데이터베이스에 객체로 저장이 안되므로, 저장되는 속성이름을 지정mappedBy = “~” : 이건 외래키를 가진 객체가 해당 속성의 주인(즉 외래키를 가진 DB에 해당 속성이 있다는 의미. 단지 객체지향적 의미로 해당 클래스에 리스트로 객체들이 선언되있음.) 123456789101112131415161718192021222324252627282930313233343536package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.CreationTimestamp;import javax.persistence.*;import java.sql.Timestamp;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entitypublic class Reply &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(nullable = false, length = 200) private String content; @ManyToOne//Many reply to One board @JoinColumn(name=&quot;boardId&quot;) private Board board; @ManyToOne @JoinColumn(name = &quot;userId&quot;) private User user; @CreationTimestamp private Timestamp createDate;&#125; 여기보면 Reply가 BoardId 외래키로 가지고 있다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"7. 객체지향 입문(생성자, this, static)","slug":"java/java-basic/java7","date":"2021-09-01T05:25:42.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/01/java/java-basic/java7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/01/java/java-basic/java7/","excerpt":"","text":"1. 클래스 vs 객체 vs 인스턴스12345678public class CreditCard&#123; ... public static void main(String[] args)&#123; CreditCard card1, card2;//객체 card1 = new CreditCard();//인스턴스 card2 = new CreditCard();//인스턴스 &#125;&#125; 클래스는 class 키워드 뒤에 붙여진 CreditCard객체는 클래스의 타입으로 생성된 실체.인스턴스는 메모리에 할당된 객체. 2. 생성자객체에 구현되어 있는 생성자.디폴트 생성자(매개변수가 없는 생성자)는 생략되어 추가되어 있음. 생성자는 참조 데이터 타입에만 허용. 기본 데이터 타입은 객체가 아니므로 불필요. 3. 접근 제어자private : 같은 클래스 내부에서만 접근!default : 같은 패키지에서만 접근!protected : default + 상속 관계 클래스 접근가능!public : 어디서나 접근 가능~! 4. this 생성된 인스턴스의 메모리 주소 같은 클래스 내의 생성자. this(~~)이런식을 사용 자신의 주소 5. static여러 인스턴스가 공유하는 메소드, 변수, 클래스에 사용하는 키워드프로그램 실행 시 Method area에 생성되고, 프로그램 실행 종료 후 사라진다. 이때 static 메서드(클래스 메서드)는 인스턴스 변수를 사용할 수 없다!!!!(인스턴스 변수가 메모리에 아직 로딩되지 않았으므로.) 그리고 정적 메소드는 오버라이드 하면 안된다! 깊은 복사 vs 얕은 복사 얕은 복사 : 객체의 참조값을 복사!-&gt;원본이 변경되면 복사본도 변경!깊은 복사 : 객체의 실제 값을 복사-&gt;값이 변경되도 복사본은 상관 없음.System.arraycopy() : 얕은 복사.clone() : 깊은 복사 (원소 별로 new 인스턴스화) 객체는char[]기반 가변 문자열!AbstractStringBuilder 이런 걸 상속받아 만든다!!StringBuffer = 동기화 o (synchronized)StringBuilder = 동기화 x생성시 16trimToSize() = 실제 문자열만큼 용량을 줄임. 리플렉션 프로그래밍JVM에서 런타임동작을 감시하거나 수정할 수 있는 기능이 있는 프로그램 (스프링 프레임워크, 하이버네이트) 예를들면, 클래스 파일이 없어도, Class 클래스를 활용… static은 왜 오버라이딩 안되냐?","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"6. JVM 구조와 가비지 컬렉터","slug":"java/java-basic/java6","date":"2021-08-30T04:18:40.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/30/java/java-basic/java6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/30/java/java-basic/java6/","excerpt":"","text":"JVM 구조아시다시피, 자바는 운영체제의 종류와 무관하게 실행가능하다.자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 읽을 수 있는 기계어로 바꿔준다.JVM은 크게 4가지로 나뉜다. 1. Class Loader자바로 코드를 작성하면 java파일이 생성된다..java파일을 컴파일하면 .class파일(바이트 코드)이 생성된다.이렇게 생성된 .class파일들을 JVM이 할당받은 메모리 영역인 Runtime Data Area에 적재하는 역할을 Class Loader가 한다. 여러 종류의 클래스 로더 Bootstrap ClassLoader : jre의 lib폴더의 rt.jar 파일 속 기본 자바 API 라이브러리 로드. Extension ClassLoader : jre의 lib폴더의 ext폴더에 모든 확장 코어 클래스파일 로드. Application ClassLoader : 사용자가 만든 클래스파일 로드. 2. Execution EngineClass Loader가 적재한 클래스(.class 바이트 코드)를 기계어로 번경해 명령어 단위로 실행한다. 3. Garbage CollectorHeap, Stack, Method 메모리 영역에 생성된 객체들 중 참조되지 않은 객체를 찾아 제거한다. 4. Runtime Data AreaJVM의 메모리 영역. 어플리케이션을 실행할 때 쓰이는 데이터를 적재.이 영역도 여러갈래로 나뉜다. 자바 런타임 메모리 구조1. Method Area모든 클래스의 정보가 저장되는 공간.클래스의 필드와 메소드 정보, Constant Pool(상수 풀: 리터럴 상수 값, 객체 참조를 저장), static 변수 등을 생성하고 저장 2. Heap Area모든 인스턴스 오브젝트가 저장되는 공간.new 키워드로 생성된 객체가 저장되는 영역.메소드 영역에 있는 클래스만 생성이 가능. GC가 참조되지 않는 메모리를 확인하고 제거 3. Stack Area지역 변수, 파라미터, 리턴 값, 임시 값 등 저장되는 곳각 쓰레드마다 개별적으로 스택이 생성된다.메소드를 호출할 때 스택에 스택 프레임이라는 스택 메모리가 쌓이는 방식. 4. PC Register(CPU의 레지스터와 다름)쓰레드가 생성될 때마다 생성되는 영역.Program Counter, 즉 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장. 5. Native Method Stack자바 외 언어로 작성된 코드를 위한 메모리 영역. 여기서 heap, Method Area는 쓰레드끼리 공유하고,stack, pc register, native method stack은 서로 공유되지 않고 각자 생성한다. heap과 GC원래는 JVM이 관리하지만, 최신 자바는 OS과 관리해서할당받아 실행하지 않는다는 장점이 있다. Heap 영역은 5개 영역으로 나뉜다.eden, survivor1, survivor2, old, permanent Minor GC : New 영역에서 일어나는 GC최초에 객체가 생성되면 eden 영역에 생성된다.eden이 가득차면 survivor1 영역에 메모리 그대로 복사 후 survivor1 제외한 영역 객체 제거이후 eden, survivor1 모두 차면, 그 중에 참조되고 있는 객체가 있는지 확인참조되고 있는 객체만 survivor2로 이동 후 다른 영역 객체 제거위 과정을 여러번해서 survivor2에 남으면, old영역으로 이동시킨다. Major GC : old 영역에서 일어나는 GCold 영역에서 참조되지 않은 객체들을 모아 한번에 제거한다.제거되어 heap 중간중간 빈 공간을 다시 재구성해 채운다.(그래서 GC가 일어나면 GC를 다루는 쓰레드 이외엔 모든 쓰레드가 정지한다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"5. [블로그 프로젝트] Maven, Lombok, application.yml","slug":"spring/blog/blog5","date":"2021-08-26T11:11:05.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog5/","excerpt":"","text":"Maven자 만약에 우리가 프로젝트를 할 때 어떤 라이브러리를 사용한다고 하자.우리에게는 3가지 시나리오가 있다. 라이브러리를 다운받고, 각 프로젝트의 lib 폴더에 복사하기. 프로젝트 만들 때마다 복사해야 된다… 라이브러리를 외부에 두고 프로젝트들이 가져다 쓰기 하지만 배포할 때 라이브러리가 포함되지 않아서 힘들다.. 중앙 저장소에 라이브러리들을 저장하고, 프로젝트에 어떤 라이브러리를 쓸지 써놓기 pom.xml에 어떤 라이브러리를 쓸 지 써놓는다! 빌드 과정에서 pom.xml보고 라이브러리 다운받는다! Lombok(다운을 받아야하는데 이건 검색을 통해 해결해자!)일단 간단하게 알아보자 @Data : getter와 setter를 만듬 @AllArgsConstructor : 모든 클래스멤버를 인자로 받고 초기화하는 생성자 만듬 @RequiredArgsConstructor : 클래스 멤버 중 final 키워드가 붙은 멤버들만 인자로 받는 생성자 만듬 @NoArgsConstructor : 빈 생성자 만듬 yaml (yml)스프링 프로젝트의 전반적인 설정을 해놓는 파일.원래는 xml에 저장했으나 최근에는 yml을 주로 사용yaml은 json, xml보다 가벼움. 키와 밸류 사이에는 스페이스가 한칸 띄어져 있어야 한다!(중요!)json의 중괄호 대신, yml은 들여쓰기(스페이스 두번)으로 대체한다! application.yml스프링의 모든 설정을 다루는 파일.스프링 부트를 시작하기 전에 먼저 application.yml을 읽는다!web.xml, root-context.xml, servlet-context.xml의 합본! 우리 프로젝트의 application.yml에 다음을 복붙하자 1234567891011121314151617181920212223242526272829303132333435server: port: 8000 servlet: context-path: /blog encoding: charset: UTF-8 enabled: true force: true spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul username: 데베계정이름 password: 데베 비번 jpa: open-in-view: true hibernate: ddl-auto: create naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl use-new-id-generator-mappings: false show-sql: true properties: hibernate.format_sql: true jackson: serialization: fail-on-empty-beans: false server : 내 서버의 진입점을 정의. 비워놓을시 8080포트에 /로 초기화 mvc : jsp 연결을 위해 설정 @Controller는 파일을 리턴하는데, 기본경로가 “src/main/resources/static”이다. 이때 그냥 “file.html”을 리턴하면, “src/main/resources/staticfile.html”을 찾게된다. 그래서 “/file.html”을 리턴해줘야 올바른 경로를 찾는다. static 폴더는 브라우저가 인식가능한, css, html, js, png 등등.. 만 담는다. 컴파일이 필요한 동적파일(jsp 등)은 static에 넣으면 인식못한다. 그래서 mvc는 @Controller의 return이 어느 위치에서 찾을지를 설정한다.(위 예시에서는 views폴더에서 리턴값에 .jsp를 붙인 파일을 찾는다.)(이렇게 하면 톰캣이 jsp를 컴파일해서 브라우저에 전달한다.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"4. [블로그 프로젝트] 스프링 부트로 HTTP 데이터 전달하기","slug":"spring/blog/blog4","date":"2021-08-26T07:08:56.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog4/","excerpt":"","text":"HTTP는 어떻게 데이터를 전달할까? GET get은 URI의 쿼리 파라미터로 데이터를 전달한다.(? 뒤의 쿼리를 의미한다.)코드로 받아오는 방법은 두가지가 있다. @RequestParam : 메소드에 해당 어노테이션을 붙인 변수를 만들어서 받아온다! 클래스를 만들어서 가져오기 : 메소드에 해당 클래스 객체를 넣어주면 알아서 매핑되서 받아온다. 이때 변수 명이나, URI의 key값이 클래스 멤버 변수와 동일해야 한다!!! 12345@GetMapping(&quot;/http/get&quot;)//public String getTest(@RequestParam int id, @RequestParam String username...)public String getTest(Member m)&#123; return &quot;get id :&quot; + m.getId() + &quot;, username: &quot;+m.getUsername()+&quot;, password : &quot;+m.getPassword()+&quot;, email : &quot;+m.getEmail();&#125; GET 외의 api들(POST, PUT …) get을 제외한 api들은 다양한 데이터를 전달할 수 있다.그렇다면 어떻게 데이터를 보낼까?바로 body에 담아서 보낸다!! 그런데, body에서 전달하는 방식도 여러가지가 있다.포스트맨에서 확인해보자. x-www.form-unlencoded여기 보이는 x-www.form-unlencoded는 HTML에서 보이는 form태그 방식으로 데이터를 보낸다.이럴 경우에는 우리 코드 상의 메소드의 매개변수를 그냥 객체 형식으로 보내도 상관없다.form을 전제로 하기 때문에 자연스럽게 파싱된다. raw하지만 raw는 그렇지 않다. 우리 코드상의 메소드의 매개변수 앞에 @RequestBody를 붙여줘야 파싱한다.이때 raw도 그냥 raw가 아니라 다양한 MIME형식을 가질 수 있다.(text/plain , application/json) 123456 @PostMapping(&quot;/http/post&quot;) public String postTest(@RequestBody Member m)&#123; //json받기// public String postTest(@RequestBody String text)&#123; //text받기 return &quot;post id :&quot; + m.getId() + &quot;, username: &quot;+m.getUsername()+&quot;, password : &quot;+m.getPassword()+&quot;, email : &quot;+m.getEmail(); //return text; &#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"3. [블로그 프로젝트] 스프링 부트로 HTTP 체험해보기","slug":"spring/blog/blog3","date":"2021-08-26T06:39:51.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog3/","excerpt":"","text":"HTML을 체험하기 위해 필요한 POSTMAN 추후 알게 되겠지만, POSTMAN이라는 프로그램을 다운받자.(브라우저로 테스트하면 get요청밖에 확인가능하기 때문이다.)일단은 웹브라우저로 해보자. @RestController 와 @Controller@RestController는 사용자가 요청하면 데이터를 응답하는 어노테이션이다.@Controller는 사용자가 요청하면 HTML을 응답하는 어노테이션이라고 알자! 알맞은 패키지 아래에이제 BlogControllerTest 클래스를 만들어보자. 1234567891011package com.cos.blog.test;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BlogControllerTest &#123; @GetMapping(&quot;/test/hello&quot;) public String hello() &#123; return &quot;&lt;h1&gt;hello spring boot&lt;/h1&gt;&quot;; &#125;&#125; 이제 웹 브라우저 주소창에 http://localhost:8080/test/hello 를 입력하면반환값을 html로 해석한 페이지가 등장한다! 이제 다양한 요청을 처리하는 HttpControllerTest를 만들어보자 123456789101112131415161718192021222324package com.cos.blog.test;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HttpControllerTest &#123; @GetMapping(&quot;/http/get&quot;) public String getTest()&#123; return &quot;get&quot;; &#125; @PostMapping(&quot;/http/post&quot;) public String postTest()&#123; return &quot;post&quot;; &#125; @PutMapping(&quot;/http/put&quot;) public String putTest()&#123; return &quot;put&quot;; &#125; @DeleteMapping(&quot;/http/delete&quot;) public String deleteTest()&#123; return &quot;delete&quot;; &#125;&#125; 이제 http://localhost:8080/http/get 을 하면 get이라는 글자가 화면에 나온다!(와우!)근데 http://localhost:8080/http/post 를 해보면…?(어라?)에러가 뜬다!앞서 언급했듯이 이게 우리가 POSTMAN을 쓰는 이유다!이제 앞으로 포스트맨으로 결과를 확인하자!!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"2. [블로그 프로젝트] HTTP 1.1과 MIME type, MySQL프로젝트 연결하기","slug":"spring/blog/blog2","date":"2021-08-26T05:13:05.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/08/26/spring/blog/blog2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog2/","excerpt":"","text":"HTTPHTTP_더_알아보기HTTP는 문서를 전송하는 stateless 통신 프로토콜이다!종류는 다음과 같다!GET : 데이터 줘!POST : 데이터 추가해줘!PUT : 데이터 수정해줘!DELETE : 데이터 삭제해줘! 그렇다면 ‘어떤’ 데이터를 요청하거나 보낼지를 알려줄까?이는 쿼리 파라미터(URI의 ? 부분)를 쓰거나,MIME type으로 알려줄 수 있다! MIME typeHTTP는 데이터를 패킷이라는 단위로 나눠서 보낸다.이 패킷은 헤더+바디 인데, 헤더는 보내는 데이터에 대한 설명이고, 바디는 데이터를 담는다. 이때 헤더에는 우리가 보낼 데이터가 어떤 데이터인지를 알려주는 MIME type을 포함한다.MIME type은 type/subtype형태를 가진다.MIME_type_더알아보기 MySQL 연결하기MySQL를 제대로 설치했다면mysql -uroot -p 로 접근이 가능하고,mysql.server start로 데이터베이스를 시작할 수 있다. 이렇게 설치된 상황에서mysql -uroot -p로 mysql을 열고, 1234567-- 유저이름@아이피주소create user &#x27;cos&#x27;@&#x27;%&#x27; identified by &#x27;cos1234&#x27;;-- ON DB이름.테이블명-- TO 유저이름@아이피주소GRANT ALL PRIVILEGES ON *.* TO &#x27;cos&#x27;@&#x27;%&#x27;;CREATE DATABASE blog CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;use blog; 를 입력하면 우리가 활용할 db가 생성된다.그리고 디비 서버를 켜주자. 그런 다음 우리 프로젝트 폴더 중 resources 폴더 안에는application.properties라는 파일이 있다.이 파일의 확장자를 yml로 바꾼 다음에 이렇게 써주자. 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul username: 디비 계정 password: 디비 비밀번호 (yml은 json 형식이다. 그래서 properties보다 덜 써도 같은 효과를 본다.)(url은 시간 설정이라고 생각하자.)이렇게 하면 db 연결은 끝이다!!!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"1. [블로그 프로젝트] 개발 환경, 의존성 설정하기.","slug":"spring/blog/blog1","date":"2021-08-26T04:09:25.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/08/26/spring/blog/blog1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog1/","excerpt":"","text":"이번엔 스프링부트를 통해 블로그를 한번 만들어보자!유튜버 데어프로그래밍의 강좌를 보며 제작한다!!! 먼저 Oracle JDK SE와 MySQL을 설치해주자.JDK는 홈페이지에서 다운받고, MySQL은 맥의 homebrew로 설치가 가능하다!MySQL 설치 관련 링크 그리고 이클립스에서 스프링을 사용할 수 있게해주는 STS 툴 이라는 게 있다.나는 인텔리제이를 써서 생략하겠다. 그리고 어떤 에디터를 쓰든 utf-8으로 인코딩 설정을 해주자!!! utf-8? 자 1bit = 2^1 는 0과 1 즉 두가지 결과를 만들어낸다.8bit = 2^8 = 256 = 1 byte 이다. 자 이제 영어 알파벳을 생각해보자. 대소문자 다합쳐서 50여개다.여기에 숫자와 몇몇 특수기호를 합치면 꽤 많이 될 것이다.만약 256개 이하라면, 우리는 문자 1개당 하나씩 할당해주면모든 문자를 이진수로 표현할 수 있다! 근데 한글과 중국한자은 어떻게 한다는 말인가!한글은 대략 2byte가 필요하고, 한자는 3byte가 필요하다. 우리가 설정한 UTF-8은 3byte를 가진 문자체계다.즉 영어, 한글, 한자를 모두 소화할 수 있는 인코딩 체계라는 말씀!! 의존성 설정하기.이번 프로젝트에서는 maven으로 패키지를 관리한다.그리고 의존성에서 우리가 사용할 것들을 살펴보자. Spring boot Dev Tool : 스프링의 성능을 향상 시키고, 개발을 편리하게 돕는 도구 정도로 이해하자. Lombok : getter, setter같은 메소드를 어노테이션으로 퉁치는 기능을 제공해주는 도구 JPA : 자바 객체를 변환해서 데이터베이스에 저장할 수 있게 해주는 도구 MySQL Driver : MySQL을 사용할 수 있게 해주는 도구 Spring Web : 각종 어노테이션과 내장 톰캣을 사용할 수 있게해주는 도구 Spring Security : 세션, 권한 등 다양한 보안 기능을 제공하는 도구 사용할법하지만 사용하지 않는 의존성 기능들도 참고 삼아 알아보자. OAuth2 Client : 카카오톡 같은 소셜 로그인을 지원하는 도구(하지만 우리는 학습을 위해 직접 구현) 각종 템플릿 : 우리는 JSP를 사용할 거다.(스프링은 JSP를 제공하지 않으므로 따로 폴더파서 만들어줘야됨) 좀 더 디테일하게 말하면, 스프링 프로젝트의 source/temple 폴더에 JSP를 만들어도 인식을 못한다. 잠깐 주의사항 패키지를 다룰 때 패키지 위치를 정확하게 해줘야된다.java의 com.cos.blog안에 패키지를 넣어야 알맞은 IoC가 실행된다. 그리고 우리는 몇가지 의존성을 더 넣어줄꺼다.pom.xml이라는 파일이 있다. 여기에 각종 dependecies가 있는데 우리는 다음을 복붙해줄거다 1234567891011121314151617&lt;!-- 시큐리티 태그 라이브러리 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- JSP 템플릿 엔진 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- JSTL --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 그리고 우리는 MySQL, JPA, Security를 사용하지 않으므로, 주석처리해주자.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[]},{"title":"3. Spring boot 동작원리 with 데어 프로그래밍","slug":"spring/boot/boot3","date":"2021-08-25T04:43:08.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/08/25/spring/boot/boot3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/25/spring/boot/boot3/","excerpt":"","text":"스프링 부트 동작원리 톰캣 필터 권한, 인증, 인코딩… 디스패처 요청된 주소에 맞는 컨트롤러를 호출 &lt;얘네는 요청때마다 메모리에 로딩&gt;&lt;요청이 올 때까지 대기&gt;재사용하는 게 아니라 새 쓰레드를 사용함4. 컨트롤러 - 요청에 포함된 데이터 받음, 다른 서비스 호출..5. 서비스6. JPA 레포지토리7. 영속성 컨텍스트 데이터소스 DB와 연결 view Resolver 페이지를 만들어서 응답. 일반적인 컨트롤러일 때 작동 RestController일 땐 작동 x 세션 인터셉터 보안에 민감한 함수가 실행 직전에 요청자가 권한을 가졌는지 확인 소켓 통신과 http 통신 Socket : 운영체제가 가지고 있는 소통 창구 같은 것!한 포트에서 소캣을 열어서 다른 컴퓨터와 연결을 확인하고,다른 포트에서 소캣을 열고 스레드를 할당해 해당 연결을 진행하게 한다.그와 동시에 연결을 확인하는 소캣은 계속 열어두어서, 다른 컴퓨터가 연결 요청을 할 수 있다. 이런 소켓통신은 여러 컴퓨터가 계속 연결되어 있기 때문에 부하가 크다! 이런 단점을 해결하는게 stateless 방식의 http 통신!!http는 문서를 전달하는 방식이다.http는 한 소켓에서 요청을 받아서 응답을 해주고 해당 컴퓨터와 연결을 끊는다.부하가 적지만, 다시 연결하려면 매번 새로운 연결을 만들어야 한다.그리고 서버가 클라이언트를 기억하지 않는다.(웹서버는 이를 해결한다.) 1. 내장 톰캣을 가진다.웹서버(스프링에선 아파치)란?클라이언트가 원하는 자료들을 가지고 있고, 클라의 request를 받고, url,uri (자원을 요청하는 주소, 식별자에 접근하는 주소)에 따라적절한 자원(정적인 자원 static)을 응답해서 보낸다!하지만, 이 중에 만약 자바 코드(.jsp)로 이뤄진 자원을 요청받으면, 아파치는 이를 다루지 못한다.(웹 브라우저도 html, css, js 파일정도만 이해할 수 있으니까… 자바파일은 이해못한다.)그래서 이럴 경우 톰캣에게 이를 처리하도록 한다. 톰캣이란? 자바 파일(.jsp)를 컴파일하고, html로 만들어 아파치에게 돌려주는 역할을 한다.톰캣은 요청객체와 응답객체를 알아서 메모리에 생성한다. 2. 서블릿 컨테이너스프링은 url으로는 접근이 불가능하다. uri로 접근만 가능하게 했다.그래서 특정한 파일을 요청을 할 수 없다는 의미다!!결국 요청할 때는 무조건 자바를 거쳐야 된다.(즉 톰캣을 거쳐야!) 서블릿? 자바로 웹할 수 있게 한 것.서블릿 컨테이너? 서블릿의 집합(여기서는 톰캣을 의미.)서블릿 컨테이너에서는 최초 요청이 오면, 스레드를 생성해서 서블릿 객체를 만든다!(왜 스레드를 만드냐? 여러 요청이 동시에 올 수 있으니까!, 동시접근 허용.)우리가 최대 스레드를 20개라고 설정했으면 스레드가 20개가 될 때까지 새 스레드를 만들어서 서블릿 객체를 만든다. 이때 20개의 요청을 처리하여 20개의 서블릿 객체를 서블릿 컨테이너에 만들었다고 가정하면다음 요청때는 만들어진 서블릿 객체를 다시 재사용한다! 3. web.xml서버를 하나의 성으로 비유하면,web.xml은 서버의 문지기와도 비슷하다. -ServletContext의 초기 파라미터 : 일종의 암구호-Session의 유효시간 설정 : 들어온 사람이 누구인지, 얼마나 있을지-Servlet/JSP에 대한 정의 : 들어온 사람의 성 속 목적지를 인식(식별자 인식)-Servlet/JSP 매핑 : 들어온 사람의 성 속 목적지로 가는 길을 안내(식별자에 따른 자원 매핑)-Mime Type 매핑 : 들고오는 데이터 타입(mime type)을 성에 맞게 매핑-Welcome File list : 아무 이유 없이 온 사람들을 보내는 곳-Error Pages 처리 : 잘못된 목적을 가지고 온 사람들을 보내는 곳-리스너/필터 설정 : 잘못된 성을 온 사람이나, 맞지 않는 사람을 못들어오게 함(리스너는 문지기를 도와 같이 들어오는 사람을 특정한 조건을 확인하는 역할)-보안 4. frontController 패턴web.xml이 모든 servlet, jsp를 매핑하기 힘들다…그래서 특정 주소(.do)는 frontController가 먼저 나서서 처리한다.이렇게 가져온 요청들은 frontController가 직접 자원에 접근하도록 다시 요청한다!(내부에서는 자원에 직접 접근하는 요청이 가능하다.) 5. RequestDispatcher근데 다시 요청한다는게 어떤 의미인가?새로운 요청객체를 만드는게 아니라, 처음 만들어진 요청 객체를다시 내부에서 직접 접근하도록 사용한다는 것!(이 일을 RequestDispatcher가 한다.) 이렇게 하면 어떤 페이지에서 가져온 데이터를 다른 페이지로 넘어가도 그대로 가져갈 수 있게된다! 6. DispatchServlet스프링에는 DispatchServlet은 FrontController + RequestDispatcher라고 생각하자.얘 덕분에 우리는 굳이 frontController와 RequestDispatcher를 구현 안해도 된다. DipatchServlet이 프로젝트 패키지 내부의 모든 자바 파일을 뒤져서필요한 객체들(@Controller, @RestController…)을 자동 생성하고,이 객체들을 IoC로 관리된다.(대부분 필터들이다.) 7. 스프링 컨테이너ApplicationContextDispatchServlet이 만든 수많은 객체들을 관리하는 애가 스프링 컨테이너다.이 객체들은 ApplicationContext에 등록되어 관리된다.(IoC)우리는 new가 아닌 DI로 객체를 다룰 것이다. ApplicationContext는 두가지가 있다.(root-applicationContext, servlet-applicationContext)DispatchServlet은 각 스레드 별로 클래스들의 객체들을 만들지만 서로 다른 스레드라서 충돌은 일어나지 않는다.웹과 관련된 어노테이션을 찾아 메모리에 띄우는 파일인 sevlet-applicationContext이 객체를 생성한다. 다만 DB 같이 쓰레드들이 공유해야 하는 데이터는 ContextLoaderListener이 공유해서 사용하도록 한다.root-ApplicationContext 파일에 어떤 걸 공유해야 할 지 정해져 있고,ContextLoaderListener는 이 파일을 읽고, 공유해야 할 내용은 공유한다.(ContextLoaderListener는 DispatchServlet보다 먼저 실행된다.)sevlet-applicationContext에서 생성된 객체는 root-applicationContext에서 만들어진 객체를 참조 가능하지만,반대는 불가능하다~!(생성시점이 다르기 때문이다.) Bean FactoryBean Factory도 필요한 객체를 등록해놓은 곳인데, 다만 초기에 메모리에 로드되는게 아니고,필요할 때 getBean()으로 호출되어야 메모리에 로드된다.(IoC)ApplicationContext는 초기에 메모리에 로드되는 반면, Bean Factory는 그렇지 않은 lazy loading이다. 8. 응답 Handler Mapping (요청 주소에 따른 적절한 컨트롤러 요청)어떤 요청이 오면, 그 요청에 맞는 적절한 컨트롤러의 함수를 찾아 실행한다. 응답할 때는 html로 할 지, data를 응답할 지 결정해야 하는데,html로 할 때는 ViewResolver가 관여하고(반환값을 jsp파일명으로 인식!),data로 할 때는 MessageConverter가 작동하게 된다.(기본 컨버팅 값은 json이다.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"24. 백준 1406번 에디터","slug":"cs/algorithm/problem/al24","date":"2021-08-24T04:48:01.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al24/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al24/","excerpt":"","text":"이 문제는 참 고생 많이 했다 ㅋㅋ… 틀렸던 접근 1 주어진 문자열을 char 배열로 받은 다음, 이 녀석을 ArrayList에 저장하자.그 다음 arrayList를 하나더 추가해서 마치 스택처럼 사용하자.그렇게 모든 명령을 수행하고 나면두 arraylist에 저장된 요소들을 반복문으로 하나씩 출력하자. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; var bf = new BufferedReader(new InputStreamReader(System.in)); char[] charArr = (bf.readLine()).toCharArray(); //List list = Arrays.asList(charArr); //var wordStk = new ArrayList&lt;Character&gt;(Arrays.asList(charArr)); var wordStk = new ArrayList&lt;Character&gt;(); var testCase = Integer.parseInt(bf.readLine()); var tmpStk = new ArrayList&lt;Character&gt;(); for (char c : charArr) wordStk.add(c); for (int i = 0 ; i &lt; testCase ; i++)&#123; var cmdLine = new StringTokenizer(bf.readLine()); var cmd = cmdLine.nextToken(); if (cmd.equals(&quot;P&quot;))&#123; wordStk.add(cmdLine.nextToken().charAt(0)); &#125; else if (cmd.equals(&quot;L&quot;))&#123; if (wordStk.size() != 0)&#123; tmpStk.add(wordStk.get(wordStk.size()-1)); wordStk.remove(wordStk.size()-1); &#125; &#125; else if (cmd.equals(&quot;D&quot;))&#123; if (tmpStk.size() != 0)&#123; wordStk.add(tmpStk.get(tmpStk.size()-1)); tmpStk.remove(tmpStk.size()-1); &#125; &#125; else if (cmd.equals(&quot;B&quot;))&#123; if (wordStk.size() != 0)&#123; wordStk.remove(wordStk.size()-1); &#125; &#125; &#125; for (char c : wordStk) System.out.print(c); for (char c : tmpStk) System.out.print(c); &#125;&#125; 문제점들…근데 문제가 있다. Arrays.asList(char[])가 작동을 안한다…asList가 배열이나, 가변인자를 받기 때문이다. 가변인자란 여러 인자를 받으면, 이를 배열로 만들어서 인자로 활용하는 개념이다.즉 asList에 기본값을 가진 배열이 오면, List&lt;\\char[]&gt;이 온다..!(다르게 말하자면, 오토박싱이 이뤄지지 않는다. 개별의 값만 오토박싱한다.)그래서 기본값을 가진 배열은 asList로 다룰수 없다.(래퍼클래스 배열만 가능) 그리고 출력할 때도 문제가 있다.무지성으로 여러번 출력하는 거보다 한방에 모아서 출력하는게(StringBuffer) 훨씬 속도가 빠르다! 그리고 나는 자바에 스택이 있는 걸 깜빡하고 arrayList로 작성했는데,다시 찾아보니 스택을 지원했다. 그래서 스택으로 고쳐 써봤다. 고친 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;import java.io.*;import java.util.stream.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; var bf = new BufferedReader(new InputStreamReader(System.in)); var sb = new StringBuilder(); var charArr = bf.readLine().toCharArray(); var wordStk = new Stack&lt;Character&gt;(); var testCase = Integer.parseInt(bf.readLine()); var tmpStk = new Stack&lt;Character&gt;(); for (char c : charArr) wordStk.add(c); for (int i = 0 ; i &lt; testCase ; i++)&#123; var cmdLine = new StringTokenizer(bf.readLine()); var cmd = cmdLine.nextToken(); if (cmd.equals(&quot;P&quot;))&#123; wordStk.push(cmdLine.nextToken().charAt(0)); &#125; else if (cmd.equals(&quot;D&quot;))&#123; if (tmpStk.size() != 0)&#123; wordStk.push(tmpStk.pop()); &#125; &#125; else if (wordStk.size()==0) continue; else if (cmd.equals(&quot;L&quot;))&#123; tmpStk.push(wordStk.pop()); &#125; else if (cmd.equals(&quot;B&quot;))&#123; wordStk.pop(); &#125; &#125; for (char c : wordStk) sb.append(c); while(!tmpStk.isEmpty()) sb.append(tmpStk.pop()); System.out.println(sb); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"23. 백준 9012번 괄호","slug":"cs/algorithm/problem/al23","date":"2021-08-24T04:42:43.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al23/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al23/","excerpt":"","text":"문제괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 아이디어 괄호를 열 때마다 변수를 1 키우고, 괄호가 닫힐 때마다 변수가 1씩 줄이자. 이때 0보다 작아지면 잘못된 식임을 감지한다. 코드 1234567891011121314151617181920212223242526import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); var testCase = Integer.parseInt(bf.readLine()); for (int i = 0 ; i &lt; testCase ; i++)&#123; char[] arr = bf.readLine().toCharArray(); int openCount = 0; for (char c : arr)&#123; if (c == &#x27;(&#x27;) openCount++; else if (c == &#x27;)&#x27;)&#123; openCount--; if (openCount &lt; 0) break; &#125; &#125; if (openCount == 0) System.out.println(&quot;YES&quot;); else System.out.println(&quot;NO&quot;); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"22. 백준 9093번 단어 뒤집기","slug":"cs/algorithm/problem/al22","date":"2021-08-24T04:04:45.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al22/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al22/","excerpt":"","text":"문제문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. 단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다. 입출력입력 : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. 단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다.출력 : 각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다. 아이디어 받은 문자열을 공백 기준으로 나눈 다음, 각 문자열을 거꾸로 출력하도록 하자. 필요한 문법 StringTokenizer : 이 문제에 핵심 역할을 하는 클래스다.생성자가 StringTOkenizer(bf.readLine(),” “, false)세번째 요소에 true를 넣으면 구분자를 포함하여 토큰을 자른다!(false면 구분자를 제외한다.)그리고 다음 토큰이 존재하는 지 확인하려면 **hasNextTokens()**메소드를 사용해야 한다.(hasNext가 아님..) StringBuilder : String과 달리, 배열의 크기를 여유롭게 생성해 크기를 자유롭게 활용가능.문자열에 연산을 많이 해야하는 경우 사용하자.append() 특정값을 추가delete() 특정값을 삭제 코드 12345678910111213141516171819202122import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); int testCase = Integer.parseInt(st.nextToken()); for (int i = 0 ; i &lt; testCase ; i++)&#123; StringTokenizer inputStr = new StringTokenizer(bf.readLine(),&quot; &quot;,true); while(inputStr.hasMoreTokens())&#123; char[] wordChar = inputStr.nextToken().toCharArray(); StringBuilder sb = new StringBuilder(); for (int j = wordChar.length -1 ; j &gt; -1 ; j--)&#123; sb.append(wordChar[j]); &#125; System.out.print(sb); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"21. 백준 10828번 스택","slug":"cs/algorithm/problem/al21","date":"2021-08-22T06:09:21.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/22/cs/algorithm/problem/al21/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/22/cs/algorithm/problem/al21/","excerpt":"","text":"문제정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다. push X: 정수 X를 스택에 넣는 연산이다.pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 스택에 들어있는 정수의 개수를 출력한다.empty: 스택이 비어있으면 1, 아니면 0을 출력한다.top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. 아이디어 arrayList로 스택을 구현한다. 필요한 문법ArrayList remove(인덱스), get(인덱스), add(값), size() 메소드BufferedReader엔터를 경계로 입력받아 String으로 가져온다. 상대적으로 scanner보다 빠르다.선언할때 InputStreamReader(System.in) 객체를 생성자의 인수로 가져와서 사용한다.readLine으로 가져와서 사용한다.StringTokenizer문자열과 구분자(선택), true/false(선택)을 인수로 전달하면, 구분자 기준으로 문자열을 쪼개서 나눈다.true/false는 구분자를 하나의 토큰으로 취급할지, 다른 토큰에 포함시킬지를 결정한다.Integer.pareInt(~)문자열과 숫자를 인수로 전달하면, 해당 문자를 숫자에 맞는 진수법에 맞춰 정수화 한다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); var commandCount = Integer.parseInt(st.nextToken()); var stack = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i &lt; commandCount ; i++)&#123; var tk = new StringTokenizer(bf.readLine()); var command = tk.nextToken(); if(command.equals(&quot;push&quot;))&#123; var inputNum = Integer.parseInt(tk.nextToken()); stack.add(inputNum); &#125; else if(command.equals(&quot;pop&quot;))&#123; if (stack.size() != 0)&#123; var output = stack.get(stack.size() - 1); stack.remove(stack.size()-1); System.out.println(output); &#125; else System.out.println(-1); &#125; else if(command.equals(&quot;size&quot;))&#123; System.out.println(stack.size()); &#125; else if(command.equals(&quot;empty&quot;))&#123; if (stack.size() == 0) System.out.println(1); else System.out.println(0); &#125; else if(command.equals(&quot;top&quot;))&#123; if (stack.size() == 0) System.out.println(-1); else System.out.println(stack.get(stack.size()-1)); &#125; &#125; bf.close(); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"20. 백준 1004번 어린 왕자","slug":"cs/algorithm/problem/al20","date":"2021-08-21T13:41:45.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/21/cs/algorithm/problem/al20/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/21/cs/algorithm/problem/al20/","excerpt":"","text":"문제어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다.어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다.하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다.은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자.행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다. 아이디어 행성계를 원으로 생각했을 때, 출발점과 도착점 중 하나가 원 안에 있으면 반드시 그 행성계를 지난다.(그렇지 않으면 지나지 않는다.) 필요한 문법 Math.sqrt(double a) : double 값을 제곱근한 값을 반환Math.pow(double a, double b) : a를 b제곱한 값 반환 코드 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class No1004 &#123; public static boolean inOrOut(int x1, int x2, int y1, int y2, int r)&#123; if (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) &lt;= r)&#123; return true; &#125; return false; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int testCase = sc.nextInt(); int[] x = new int[2]; int[] y = new int[2]; for (int i = 0 ; i &lt; testCase ; i++)&#123; x[0] = sc.nextInt(); y[0] = sc.nextInt(); x[1] = sc.nextInt(); y[1] = sc.nextInt(); int planetCount = sc.nextInt(); int result = 0; for (int j = 0 ; j &lt; planetCount ; j++)&#123; int planetX = sc.nextInt(); int planetY = sc.nextInt(); int planetR = sc.nextInt(); if(inOrOut(x[0], planetX, y[0], planetY, planetR))&#123; if(!inOrOut(x[1], planetX, y[1], planetY, planetR))&#123; result += 1; &#125; &#125; else&#123; if(inOrOut(x[1], planetX, y[1], planetY, planetR))&#123; result += 1; &#125; &#125; &#125; System.out.println(result); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"2. Spring과 JPA의 특징 with 데어 프로그래밍","slug":"spring/boot/boot2","date":"2021-08-20T08:36:50.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/08/20/spring/boot/boot2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/20/spring/boot/boot2/","excerpt":"","text":"1. 스프링이란? by 데어 프로그래밍스프링은 프레임워크이다.스프링은 오픈소스이다.스프링은 IoC 컨테이너를 가진다.스프링은 DI 를 지원한다.스프링은 엄청나게 많은 필터를 가지고 있다.스프링은 엄청나게 많은 어노테이션을 가지고 있다. (리플렉션, 컴파일체킹)스프링은 MessageConverter를 가지고 있다. 기본값은 현재 Json이다.스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.스프링은 계속 발전중이다. IoC(Inversion of Control) 제어의 역전일반적인 java 객체를 new로 생성해서 개발자가 관리하는 게 아닌,Spring Container에 모두 맡긴다. 개발자가 관리하는게 아닌 프레임워크가 제어하므로, 제어의 역전이라 한다.개발자가 클래스들을 만들면, 스프링 컨테이너가 이를 읽고 나서 인스턴스화(힙 메모리 공간에 띄운다) 해서 관리한다.개발자가 코드로 new 할 필요가 없다는 의미다! DI(Dependecy Injection) 의존성 주입외부로부터 내가 사용할 객체를 주입받는다!(스프링 컨테이너가 주입해준다.)스프링 컨테이너는 하나의 인스턴스를 만들어 그 인스턴스를 공유해 사용하도록 한다.(익숙한데..? 그렇다 싱글톤 패턴!) DI 장점 의존성에서 격리, 코드 테스트에 용이하다 불가능한 상황을 Mock 같은 기술을 통해 안정적으로 테스트 가능 코드를 확장하거나 변경 할 때 영향 최소화(추상화) 순환참조 예방. 스프링의 필터톰캣을 거쳐서 스프링 컨테이너에 접근하려는 시도들 중 권한이 있는 것만을 통과하도록 필터를 사용할 수 있다.이때 톰캣에서 사용되는 필터는 web.xml에 filter로 생성되어 있고,스프링 컨테이너의 필터는 인터셉터라고 부른다.(AOP개념이 이때 사용되기도 한다. 천천히 공부하자!) 컴파일 체킹어노테이션도 일종의 주석인데, 컴파일러가 무시하지 않고, 컴파일러가 체크하도록 해놓은 표시같은거다!그래서 어노테이션에 맞지 않을 경우 컴파일러가 멈추도록 한다. 스프링에서는? 스프링의 어노테이션은 보통 객체를 생성하는 역할을 한다.@component(클래스를 읽어서 메모리에 로딩해라!),@Autowired(로딩된 객체를 해당 변수에 집어넣어!) 이런식이다. 스프링 컨테이너는 런타임동안 클래스 내부를 분석(리플렉션)해서 해당 클래스의메소드, 필드, 어노테이션을 찾아서 어떻게 작동해야할지를 정한다. MessageConverter서로 다른 언어가 서로 데이터를 주고 받으려면, 서로 합의한 형식을 주고 받기로 하자.우리는 이 합의로 한 형식을 JSON으로 사용하고 있다.즉 자바 시스템에서 파이썬 시스템으로 어떤 데이터를 보내고 싶어할 때는자바 - json - 파이썬 이런 식으로 전달된다. MessageConverter? 메세지컨버터(jackson이 기본)는 요청할 때 자바 오브젝트를 json으로 바꿔주거나응답받을 때 json을 자바 오브젝트로 바꿔주는 라이브러리다. BufferedWriter, BufferedReader를 용이하게 사용?보통 inputStream으로 1byte(8bit) 씩 읽어드리는데,효율적인 사용을 위해 BufferedReader로 가변적인 문장길이를 갖는 데이터를 쉽게 받을 수 있다. 스프링에서는 @ResponseBody라는 어노테이션을 쓰면 자연스럽게 BufferedWriter를 사용하고@RequestBody라는 어노테이션을 쓰면 자연스럽게 BufferedReader를 사용한다! 2. JPA란?JPA는 Java Persistence API 이다.JPA는 ORM 기술이다.JPA는 반복적인 CRUD 작업을 생략하게 해준다.JPA는 영속성 컨텍스트를 가지고 있다.JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)방언 처리가 용이하여 Migration하기 좋음. 유지보수에도 좋음.(다양한 dbms 제공)JPA는 쉽지만 어렵다. Java Persistence API?RAM은 휘발성 메모리다. 꺼지면 날라간다.그래서 우리는 하드디스크나 DBMS에 저장하는데, 이를 Persistence라고 부른다. JPA는 말 그대로, 자바로 만든 걸 persistence하게 저장할 수 있게하는 api이다. 근데 API가 뭐에요? 어플리케이션 프로그래밍 인터페이스다.즉 프로그램을 만드는 기준을 알려주는 것.이때 인터페이스라는 말은 기준을 제공하는 자와 기준에 따르는 자의 관계가 상하관계가 존재한다.(이것이 프로토콜과의 차이다.) JPA는 ORM?object를 데이터베이스에 넣는 방법론 중 하나. (일반적으로 데이터베이스 설계 - 이에 맞게 자바 클래스 모델링)데이터베이스의 형태와 자바 데이터타입이 다르기 때문에자바는 클래스로 데이터베이스의 형태를 자바에 모델링한다. (JPA는 먼저 클래스 설계 - 이에 맞게 데이터베이스 생성)자바가 클래스로 데이터베이스로 만들고 싶은 형태를 만든다.그러면 자연스럽게 데이터베이스에 클래스 형태에 맞도록 모델링된다. 예를 들면 db는 객체를 저장하지 못하지만, 자바는 가능하다.자바에서 객체와 자료형으로 데이터를 저장하면 JPA가 이를 db에 맞도록 변환해서 db에 저장한다! CRUD 작업 코드 생략(일반적 상황 - 매 쿼리마다 일어나는 반복적인 행동)자바가 db에 접근해서 세션을 오픈하고자바가 db에 쿼리를 보내고, db는 그에 맞는 데이터를 보낸다.이때 자바는 db가 보낸 데이터를 이해 못하므로, 이를 이해하기 위한 중간 작업을 한다.이 작업이 끝나면 세션을 닫는다. (JPA 도입 - 위 모든 행동들을 하나의 함수로 해결!) 영속성 컨텍스트영속성은 어떤 데이터를 영구적으로 저장할 수 있게 한다는 의미.컨텍스트는 어떤 대상의 모든 정보를 의미한다. 영속성 컨텍스트는 db에 저장하기 위해 필요한 모든 정보를 의미한다.자바와 db사이에서 이를 조율하는 역할로 이해하면 편하다.자바가 데이터를 가져와서 수정하면,영속성 컨텍스트가 이를 반영하고, db의 내용도 업데이트 해주는 등 db를 위한 모든 일은 영속성 컨텍스트를 통해 이뤄진다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"13. 부팅","slug":"cs/os/os13","date":"2021-08-18T12:25:03.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/18/cs/os/os13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/os/os13/","excerpt":"","text":"부팅컴퓨터를 켜서 동작시키는 절차. 부트 프로그램운영체제 커널을 저장소에서 특정 주소의 물리 메모리에 복사하고, 커널의 처음 실행 위치로 PC를 가져다 놓음ROM : 꺼져도 내용이 기억되는 특별한 RAM 바이오스를 메모리에 올리고 바이오스가 컴퓨터 초기화 저장매체의 MBR(master boot record)에 가서 부트 로더를 메모리로 가져옴부트 로더에 있는 파티션 테이블을 보고 어떤 파티션이 메인 파티션인지를 찾아낸다. 저장매체의 부트 섹터를 찾아가 부트 코드를 가져옴 부트 코드에 있는 커널 이미지(실행 파일)을 읽어옴","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"12. 파일 시스템","slug":"cs/os/os12","date":"2021-08-18T10:56:05.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/18/cs/os/os12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/os/os12/","excerpt":"","text":"파일 시스템운영체제가 저장매체에 파일을 쓰기 위한 자료구조, 알고리즘 파일 시스템은 왜 만들어졌을까? 비트 단위로 주소를 매겨서 사용하기에는 너무 비효율적!그렇다고 블록 단위(4kb)로 하자니 사용자가 각 블록의 고유번호로 관리하기 힘듬…그래서 추상적(논리적) 객체를 도입 : 파일사용자는 파일 단위로 다루고, 각 파일은 블록 단위로 관리하자! ~ 저장매체에 효율적으로 파일 저장하기가능한 연속적인 공간에 파일을 저장하는 게 좋다.하지만 각 파일들의 크기가 가변적이라, 불연속 공간에 파일을 저장해야 한다. 블록 체인 : 블록을 링크드 리스트로 연결(끝에 있는 블록 찾으려면 처음부터 찾아가야..) 인덱스 블록 : 각 블록에 대한 위치 정보를 기록, 한번에 어느 블록이든 찾아갈 수 있음 운영체제 별 파일 시스템 윈도우즈 : FAT, FAT32, NTFS블록 위치를 FAT라는 자료구조에 기록 리눅스(UNIX): ext2, ext3, ext4인덱스 블록 기법인 inode 방식 사용 파일 시스템과 시스템 콜 다양한 파일 시스템 방식에 상관없이 시스템콜을 사용해도 동일한 기능을 활용할 수 있도록 함.즉 시스템콜을 실행하면, 그 파일 시스템에 맞게 운영체제가 처리한다.실제로 어떻게 저장하는지는 약간 다를 수 있다. inode 방식 파일 시스템 파일 시스템 기본 구조 수퍼 블록 : 파일 시스템 정보 아이노드 블록 : 파일 상세 정보 데이터 블록 : 실제 데이터 파일 : inode 고유값과 자료구조에 의해 주요 정보 관리 ‘파일이름:inode’로 표현, 파일이름은 inode 번호와 매칭 파일 시스템은 inode를 기반으로 파일 엑세스 inode 기반 메타 데이터 저장 프로세스 생성 - process ID 부여 - PCB에 세부 정보 저장파일 생성 - inode 번호 부여 - inode 블록에 세부 내용(메타데이터) 저장이렇게 이해하자. inode 구조inode 기반 메타 데이터 : 파일 권한, 소유자 정보, 파일 사이즈, 시간 관련 정보(생성 시간), 데이터 저장 위치 등..위 사진에서 윗 4칸이 메타 데이터를 담고 있고,direct blocks에는 실제 데이터가 저장된 주소값 들이 저장되어 있다. direct blocks에는 대략 12개의 주소값을 저장하고 있는데, 한 블록마다 대략 4kb를 가질 때direct blocks이 처리할 수 있는 데이터량은 48kb밖에 안된다… 그래서 우리는 single indirect, double indirect, triple indirect를 도입하자.싱글 - 다이렉트 블록 포인터(1024개)더블 - 싱글(1024) - 다이렉트(1024 *1 024)트리플 - 더블(1024) - 싱글(1024 * 1024) - 다이렉트(1024 * 1024 * 1024)간접 4kb를 갖는데 대략 1024개의 주소를 가질 수 있다. 디렉토리 엔트리(덴트리)리눅스의 경우../home/ubuntu/link.txt 일 때, 각 디렉토리 엔트리를 탐색 (각 엔트리는 해당 디렉토리 파일, 디렉토리 정보를 가짐)맨 앞 슬래시는 루트 디렉토리라 하여, 해당 덴트리에서 home을 찾고 - ubuntu를 찾고 - link.txt를 찾아 실행하는 방식 가상 파일 시스템(Virtual File System)다른 파일 시스템이더라도 같은 시스템콜을 써도 잘 돌아가게 하는 시스템다양한 기기에도 파일 시스템 인터페이스를 통해 관리 가능하게 됨","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"1. GET API","slug":"spring/boot/boot1","date":"2021-08-18T08:02:00.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/18/spring/boot/boot1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/spring/boot/boot1/","excerpt":"","text":"학습목표스프링부트로 GET API의 path variable, query parameter를 처리한다. 들어가기 전에… resource 폴더의 application.properties는 포트설정을 할 수 있다. (server.port=9090)controller 패키지를 만들고 그 안에서 GetApiController 클래스를 만들어서 진행한다. 어노테이션 몇가지도 알고 시작하자.@RestController : 해당 클래스는 REST API를 처리하는 컨트롤러임을 알리는 어노테이션@RequestMapping(“/blah-blah”) : 이어져 오는 클래스나 메소드의 URI를 지정해주는 어노테이션.@GetMapping(“/blah) : GET 요청을 매핑해주는 URI 1234567891011121314package com.example.demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController //해당 클래스는 rest api 처리하는 컨트롤러@RequestMapping(&quot;/api&quot;) //RequestMapping은 URI를 지정해주는 Annotationpublic class ApiController &#123; @GetMapping(&quot;/hello&quot;) //http://localhost:9090/api/hello public String hello()&#123; return &quot;hello spring boot!&quot;; &#125;&#125; GET API이번 포스트에서는 GET 으로 쿼리 파라미터와 path variable을 설정해보자. Path variable1. path 변수 사용하기@GetMapping 안에 path = “/hello”를 넣어 사용해도 된다. 2. RequestMapping으로 GET 처리하기앞서 살펴본 대로 @GetMapping으로 GET 요청을 URI지정해줄 수 있다.그런데 이 기능을 @RequestMapping으로도 가능하다.다만, value = “/blah”, method = RequestMethod.GET을 인수로 넣어줘야 한다. 3. Path variable 처리하기주소에 변화하는 값을 처리해야 할 때가 있다.사람마다 다른 id를 URI에 넣어 사용할 때가 대표적인데,이때는 Mapping 인수에 변수를 {variable}로 넣자. 그리고 이어지는 메소드의 인수에 @PathVariable(아까 정한 변수이름 = “아까 정한 변수이름”) String pathName을 넣어주자.이때 pathName은 입력된 변수값이 된다. 코드로 확인하기 12345678910111213141516171819202122232425package com.example.demo.controller;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/api/get&quot;)public class GetApiController &#123; @GetMapping(path = &quot;/hello&quot;) //http://localhost:9090/api/get/hello public String getHello()&#123; return &quot;get Hello&quot;; &#125; @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET) //method 없으면, get, post, put, delete 모두 작동. public String hi()&#123; return &quot;hi&quot;; &#125; //http://localhost:9090/api/get/path-variable/&#123;name&#125; //&#123;name&#125;은 변화하는 값. 변화할 때마다 주소를 다 추가할 순 없어! @GetMapping(&quot;/path-variable/&#123;name&#125;&quot;) public String pathVariable(@PathVariable(name = &quot;name&quot;) String pathName)&#123; System.out.println(&quot;PathVariable: &quot;+pathName); return pathName; &#125;&#125; query parameter 쿼리 파라미터? 흔히 URI를 보면 ?를 찾을 수 있다. ? 이후가 쿼리 파라미터다.?이후 나오는 &amp;를 기준으로 나누면, key = value 형식이 된다. 1. Map을 활용해서 쿼리 파라미터 만들기@RequestParam 어노테이션을 활용해서 URI에서 파라미터를 가져올 수 있다.key = value 형식을 찾아 Map에 저장하게 된다. 2. 여러 변수 받기.메소드 인수부분에 여러 @RequestParam을 사용하면, 해당 키값과 일치하는 내용을 변수에 저장한다.이때 변수명은 당연히 키값과 일치해야 할 것이다. 3. 객체로 인수 받기일일히 2번 같은 방식으로 변수 만들려면 힘들다.다른 클래스 파일을 만들어서, 우리가 사용할 변수를 private로 만들고, 그 값을 다룰 getter, setter 메소드를 만든다.이후 컨트롤러에는 인수 자리에 그냥 객체처럼 만들면 된다.이때 중요한 점은, @RequestParam이 필요 없다는 것이다. 이 어노테이션이 없어도 스프링부트에서 객체가 오면 자연스럽게 파라미터로 인식한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.demo.controller;import com.example.demo.dto.UserRequest;import org.springframework.web.bind.annotation.*;import java.util.Map;@RestController@RequestMapping(&quot;/api/get&quot;)public class GetApiController &#123; //쿼리 파라미터 //http://localhost:9090/api/get/query-param?user=steve&amp;email=naver&amp;age=25 @GetMapping(path = &quot;query-param&quot;) public String queryParam(@RequestParam Map&lt;String, String&gt; queryParam)&#123; StringBuilder sb = new StringBuilder(); queryParam.entrySet().forEach(entry-&gt;&#123; System.out.println(entry.getKey()); System.out.println(entry.getValue()); System.out.println(&quot;\\n&quot;); sb.append(entry.getKey()+&quot; = &quot;+entry.getValue()+&quot;\\n&quot;); &#125;); return sb.toString(); &#125; //쿼리 파라미터 - 여러 변수 받기. @GetMapping(&quot;query-param02&quot;) public String queryPram02( @RequestParam String name, @RequestParam String email, @RequestParam int age )&#123; System.out.println(name); System.out.println(email); System.out.println(age); return name+&quot; &quot;+email+&quot; &quot;+age; &#125; //쿼리 파라미터 - DTO @GetMapping(&quot;query-param03&quot;) public String queryPram03(UserRequest userRequest)&#123; System.out.println(userRequest.getName()); System.out.println(userRequest.getEmail()); System.out.println(userRequest.getAge()); return userRequest.toString(); &#125;&#125; dto라는 패키지에 다른 클래스를 따로 만들었다. 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.demo.dto;public class UserRequest &#123; private String name; private String email; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;UserRequest&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[]},{"title":"19. 그래프 깊이우선탐색(DFS)","slug":"cs/algorithm/theory/al19","date":"2021-08-18T04:21:23.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/18/cs/algorithm/theory/al19/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/algorithm/theory/al19/","excerpt":"","text":"깊이우선탐색(DFS)현재 방문중인 노드와 연결된 이웃 노드 중 아직 방문하지 않은 노드 있으면, 그 노드를 다음에 방문.재귀함수로 작성, 마치 트리의 preorder방식과 비슷. psuedo code 12345678910DFS(v): mark v as visited node pre[v] = curr_time #pre리스트는 해당 노드에 첫 방문시각 기록 curr_time += 1 for each edge (v, w): if w is unmarked: parent[w] = v #parent리스트는 해당 노드에 접근 직전에 방문했던 노드 기록 DFS(w) post[v] = curr_time #post리스트는 해당 노드의 이웃이 모두 방문됐을 때 시간 기록 curr_time += 1 DFS 트리방문순서를 부모-자식 관계로 나타낸 트리.왼쪽 트리에 나타난 실선 화살표를 트리 에지라 하고, 오른쪽 트리에 나온 점선 화살표를 백 에지라고 부른다.즉 DFS의 에지는 트리 에지와 백 에지 두 종류로 나뉘고, 백 에지가 존재함은 사이클이 존재함을 의미한다. python 코드 노드 갯수와 엣지 갯수 입력 후,엣지를 입력 받았을 때. 방문한 노드를 순서대로 출력하고,[pre, post] 쌍을 출력한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def DFS(G, v): global curr_time # pre, post를 위한 time stamp # 그래프 G의 노드 v를 DFS 방문한다 visited[v] = True pre[v] = curr_time curr_time += 1 neighbor = [] for i in G: if v in i: if i[0] == v and visited[i[1]] == False: neighbor.append(i[1]) elif i[1] == v and visited[i[0]] == False: neighbor.append(i[0]) neighbor.sort() for j in neighbor: if visited[j] == False: parent[j] = v DFS(G, j) post[v] = curr_time curr_time += 1def DFSAll(G): # 그래프 G를 DFS 방문한다 for v in range(n): if visited[v] == False: DFS(G, v)# 입력 처리n, m = [int(x) for x in input().split()]G = [[] for _ in range(n)]# G 입력 받아 처리for _ in range(m): x = list(map(int, input().split(&#x27; &#x27;))) G.append(x)# visited, pre, post 리스트 정의와 초기화visited = [0]*npre = [1]*npost = [1]*nparent = [0]*n# curr_time = 1로 초기화curr_time = 1DFSAll(G)# 출력result = []for i in range(n): result.append([pre[i], post[i]])for p in range(len(pre)): minIndex = pre.index(min(pre)) print(minIndex, end=&#x27; &#x27;) pre[minIndex] = max(pre)+1print()for k in result: print(k, end=&#x27; &#x27;)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"4. 팩토리 패턴","slug":"java/design-pattern/dp4","date":"2021-08-18T00:54:52.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/08/18/java/design-pattern/dp4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/java/design-pattern/dp4/","excerpt":"","text":"팩토리 메서드 패턴인스턴스 생성에 대한 인터페이스(일반적 의미)를 만들어, 서브 클래스에서 어떤 클래스의 인스턴스를 만들지 결정하도록 설계하는 것. 추상 팩토리 패턴구현된 클래스 없이 관련된 클래스들을 만드는 인터페이스를 제공하는 패턴 배울 내용 요약 추상화에 의존해라. 구현된 클래스에 의존하지 말라. 예시 간단한 팩토리 예제신발 가게에서 신발 종류에 따라 생성해서 포장해보자! 먼저 신발 추상 클래스를 만들어보자.(얘를 상속해서 종류에 따라 만들거다.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Factory;public abstract class Shoes &#123; String modelName; int price; public abstract void prepare(); public abstract void wrap(); public abstract void box();&#125;package Factory;public class BasketballShoes extends Shoes&#123; @Override public void prepare() &#123; System.out.println(&quot;ready for the basketball shoes.&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping basketball shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing basketball shoes&quot;); &#125;&#125;package Factory;public class FootballShoes extends Shoes&#123; @Override public void prepare() &#123; System.out.println(&quot;prepare for football shoes&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping football shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing football shoes&quot;); &#125;&#125; 이제 객체를 만들 팩토리 클래스를 만들어보자. 12345678910111213package Factory;public class SimpleNikeFactory &#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; if (type.equals(&quot;basketball&quot;))&#123; shoes = new BasketballShoes(); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new FootballShoes(); &#125; return shoes; &#125;&#125; 자세히 살펴보면, new가 안에 들어있다. 이 팩토리 클래스를 사용하는 신발가게 클래스를 만들어보자. 12345678910111213141516171819package Factory;public class ShoeStore &#123; SimpleNikeFactory factory; public ShoeStore(SimpleNikeFactory factory)&#123; this.factory = factory; &#125; public Shoes orderShoes(String type) &#123; Shoes shoes; shoes = factory.createShoes(type); shoes.prepare(); shoes.wrap(); shoes.box(); return shoes; &#125;&#125; 이 경우도 팩토리와 가게가 HAS-A 관계임을 알 수 있다. 간단하게 결과를 알아보자. 12345678910package Factory;public class Tester &#123; public static void main(String[] args) &#123; SimpleNikeFactory factory = new SimpleNikeFactory(); ShoeStore store1 = new ShoeStore(factory); store1.orderShoes(&quot;basketball&quot;); store1.orderShoes(&quot;football&quot;); &#125;&#125; 이 정도가 간단한 예시고, 팩토리 메서드 패턴과 추상 팩토리 패턴을 더 알아보자. 팩토리 메서드 패턴 예제자, 이제 매장이 나이키 매장과 아디다스 매장이 있다고 가정하자.나이키 매장과 아디다스 매장마다 각자의 보여줄 메시지와 사은품으로 줄 아이템이 다르다고 할 때,이를 코드로 구현해보자. 즉 어떤 객체들이 만들어지는 과정과 가진 요소들을 분류해서 캡슐화! 일단 신발을 기본적으로 가져야 할 내용을 추상 클래스로 만들어보자 1234567891011121314151617181920212223package Factory;import java.util.ArrayList;public abstract class Shoes &#123; String modelName; String cushion; String signaturePlayer; ArrayList&lt;String&gt; shoeItem = new ArrayList&lt;&gt;(); public void prepare()&#123; System.out.println(&quot;ready for &quot;+ modelName); System.out.println(&quot;ready for &quot;+ cushion); System.out.println(&quot;this shoes are for &quot;+ signaturePlayer); for (String item : shoeItem)&#123; System.out.println(&quot;add &quot;+item); &#125; &#125; public String getModelName()&#123; return this.modelName; &#125; public abstract void wrap(); public abstract void box();&#125; 그리고 신발을 팔 가게들도 필요한 역할을 나타내는 추상 클래스도 만들어보자 123456789101112131415package Factory;public abstract class ShoeStore &#123; public Shoes orderShoes(String type) &#123; Shoes shoes; shoes = createShoes(type); shoes.prepare(); shoes.wrap(); shoes.box(); return shoes; &#125; public abstract Shoes createShoes(String type);&#125; 신발 클래스를 상속해서 우리가 만들고 싶은 구체적인 신발 클래스를 만들자 123456789101112131415161718192021222324252627282930313233343536373839package Factory;public class NikeFootballShoes extends Shoes&#123; public NikeFootballShoes()&#123; this.modelName = &quot;Nike Football&quot;; this.cushion = &quot;NO cushion&quot;; this.signaturePlayer = &quot;Ronaldo&quot;; this.shoeItem.add(&quot;nike football sticker&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping Nike football shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing Nike football shoes&quot;); &#125;&#125;package Factory;public class AdidasBasketballShoes extends Shoes&#123; public AdidasBasketballShoes()&#123; this.modelName = &quot;Adidas basketball&quot;; this.cushion = &quot;Boost cushion&quot;; this.signaturePlayer = &quot;Lillard&quot;; this.shoeItem.add(&quot;Adidas shoe string&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping Adidas basketball shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing Adidas basketball shoes&quot;); &#125;&#125; 이제 우리가 만들 신발 클래스를 만들었으니, 이 신발들을 만들 팩토리 클래스를 작성해보자.팩토리 클래스는 신발 가게 추상 클래스를 상속해서 만든다. 12345678910111213141516171819202122232425262728package Factory;public class NikeShoeStore extends ShoeStore&#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; if (type.equals(&quot;basketball&quot;))&#123; shoes = new NikeBasketballShoes(); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new NikeFootballShoes(); &#125; return shoes; &#125;&#125;package Factory;public class AdidasShoeStore extends ShoeStore&#123; @Override public Shoes createShoes(String type) &#123; Shoes shoes = null; if(type.equals(&quot;basketball&quot;)) &#123; shoes = new AdidasBasketballShoes(); &#125; else if(type.equals(&quot;football&quot;))&#123; shoes = new AdidasFootballShoes(); &#125; return shoes; &#125;&#125; 이제 잘 돌아가는지 확인해보자\u001f 1234567891011package Factory;public class Tester &#123; public static void main(String[] args) &#123; ShoeStore nikeShoeStore = new NikeShoeStore(); ShoeStore adidasShoeStore= new AdidasShoeStore(); adidasShoeStore.orderShoes(&quot;basketball&quot;); System.out.println(); nikeShoeStore.orderShoes(&quot;football&quot;); &#125;&#125; 결론 결론을 말하자면 자신이 만들고 있는 클래스가 바뀔 가능성이 있다면 팩토리 메소드 패턴 같은 기법을 써서 변경될 수 있는 부분을 캡슐화 하여야 한다. 신발공장 -(의존)-&gt; 신발 이었던 것을개별 신발 공장 -&gt; 신발공장 추상클래스 가 되고,신발공장 추상 클래스 -&gt; 신발 추상 클래스 이 되고,개별 신발 클래스 -&gt; 신발 추상 클래스 (의존성 뒤집기)이 된다. 즉 신발 특성이 신발 종류와 제조사에 따라 다르고, 신발 제작 방식이 제조사마다 다르므로신발과 신발 팩토리를 추상화해서 만들었다. 추상 팩토리 예제신발과 신발 공장 뿐만 아니라, 신발 재료 공장을 따로 만들어보자.신발 요소는 재조사 별로 사용하는 재료가 다를 수 있다고 가정할때,nike의 신발 요소 공장을 만들어봤다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package Factory;public interface ShoeIngredientFactory &#123; public Shoelace createShoelace(); public Outsole createOutsole(); public Cushion creatCushion(); public Colors[] createColors();&#125;package Factory;public class NikeShoeIngredientFactory implements ShoeIngredientFactory&#123; @Override public Shoelace createShoelace() &#123; return new NikeShoelace(); &#125; @Override public Outsole createOutsole() &#123; return NikeOutsole(); &#125; @Override public Cushion creatCushion() &#123; return NikeCushion(); &#125; @Override public Colors[] createColors() &#123; return new Colors[] = &#123;new BredColor()&#125;; &#125;&#125;이제 요소 팩토리에서 만든 요소들을 통해 신발을 만드는 신발 추상클래스를 만들자.이때 신발클래스는 요소 팩토리를 조합해서 만들어진다!```javapackage Factory;public abstract class Shoes &#123; String modelName; Cushion cushion; Outsole outsole; Shoelace shoelace; Colors colors[]; public abstract void prepare(); public String getModelName()&#123; return this.modelName; &#125; public void setModelName(String str)&#123; this.modelName = str; &#125; public void wrap()&#123; System.out.println(&quot;wrapping...&quot;); &#125; public void box()&#123; System.out.println(&quot;boxing...&quot;); &#125;&#125;package Factory;public class BasketballShoes extends Shoes &#123; ShoeIngredientFactory shoeIngredientFactory; public BasketballShoes(ShoeIngredientFactory shoeIngredientFactory) &#123; this.shoeIngredientFactory = shoeIngredientFactory; &#125; @Override public void prepare() &#123; this.cushion = shoeIngredientFactory.creatCushion(); this.shoelace = shoeIngredientFactory.createShoelace(); this.outsole = shoeIngredientFactory.createOutsole(); &#125;&#125; 자 이제 나이키 신발 요소 공장에서 신발 요소들을 만들어서 원하는 신발을 제작할 수 있는 나이키 매장을 만들어보자.(신발 가게 클래스는 이전과 동일.) 1234567891011121314151617package Factory;public class NikeShoeStore extends ShoeStore&#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; ShoeIngredientFactory shoeIngredientFactory = new NikeShoeIngredientFactory() if (type.equals(&quot;basketball&quot;))&#123; shoes = new NikeBasketballShoes(shoeIngredientFactory); shoes.setModelName(&quot;basketball&quot;); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new NikeFootballShoes(shoeIngredientFactory); shoes.setModelName(&quot;football&quot;); &#125; return shoes; &#125;&#125; 후! 힘들지만 다 살펴봤다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"17. Backtracking 활용 - Subste Sum 문제","slug":"cs/algorithm/problem/al17","date":"2021-08-17T06:46:12.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/17/cs/algorithm/problem/al17/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/cs/algorithm/problem/al17/","excerpt":"","text":"Subset sum주어진 집합의 부분집합의 원소 합이 특정 값이 되는 조건을 만족하는 집합을 찾아내는 문제.모든 집합을 찾아보는 건 2^n개임 DP로 푼다면?(안좋은 예시) 어떤 숫자가 포함될 경우와 그렇지 않은 경우를 모두 재귀적으로 표현 123456789subsetSum(A, i, S): #A는 배열, i는 포함 여부를 살펴보는 수의 인덱스 , S는 특정 값 if S == 0 : #조건에 맞는 경우 return True elif S &lt; 0 or i == -1 : #조건에 안맞는 경우 return False else: withNum = subsetSum(A, i-1, S-A[i])#A[i]가 부분집합에 포함되는 경우를 백트래킹 withoutNum = subsetSum(A, i-1, S)#포함되지 않는 경우 백트래킹 return withNum or withoutNum 즉 subsetSum(A, i, S) = subsetSum(A, i-1, S-A[i]) or subsetSum(A, i-1, S)마치 dp점화식처럼 보인다.DP[i][S] = DP[i-1][S-A[i]] or DP[i-1][S]이 dp테이블을 채우려면 O(n*S)인데 이것은 S가 큰 값으로 주어지면 큰 문제가 생긴다. 백트래킹으로 푼다면? 해당 원소가 부분집합에 포함 여부(1,0)를 기록하는 리스트 x를 사용 123456789101112subsetSum(k): #인덱스 k의 값이 포함되는지 판단 currentSum = 현재까지 선택된 원소들의 값 if k &gt;= len(A): if currentSum == S: print(X) else: #포함 미포함 두가지 가능성 모두 검사 #A를 오름차순으로 정렬했다고 가정 if currentSum + A[k] &lt;= S: #A[k]가 포함되려면, 포함했을 때 S보다 작거나 같아야됨 X[k] = 1 subsetSum(k+1) X[k] = 0 subsetSum(K+1)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"5. Class 클래스","slug":"java/java-basic/java5","date":"2021-08-17T06:10:14.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java5/","excerpt":"","text":"Class 클래스자바의 모든 클래스, 인터페이스는 .class 파일로 저장됨Class 클래스는 컴파일 된 class 파일을 로드하여 객체를 동적으로 로딩하고, 정보를 가져오는 메서드 제공 Class.forName(“클래스 이름”) 메서드로 클래스를 동적으로 로드 클래스 이름으로 직접 가져오기 인스턴스에서 가져오기1234567//1.Class c = Class.forName(&quot;java.lang.String&quot;);//2.Class c = String.class;//3.String s = new String();Class c = s.getClass(); 스트링 클래스의 정보를 c가 다룰 수 있게 된다.이제 c의 인스턴스를 생성하고 싶으면 c.newInstace()로 생성할 수 있다. 동적 로딩컴피일 시 데이터 타입이 정해지는 것이 아닌, 런타임 중에 정해지는 방법.데이터 타입을 유연하게 사용할 수 있지만, 오류 발생 가능성이 높고 속도도 떨어짐일반적으로 해당 자료형을 모를때 사용한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"4. 추상 클래스, 인터페이스","slug":"java/java-basic/java4","date":"2021-08-17T04:38:28.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java4/","excerpt":"","text":"추상 클래스구현 코드 없이 메서드 선언만 있는 추상 메서드를 포함한 클래스추상 클래스는 new 할 수 없음(인스턴스 생성 불가)추상 클래스의 추상 메서드는 하위 클래스가 상속하여 구현 인터페이스구현된 메서드가 없는 것(디폴트 메서드와 정적 메서드로 일부 구현된 메서드 존재 가능) 디폴트 메서드는 구현한 클래스들이 모두 공통적으로 갖게되는 메서드(오버라이딩 가능)정적 메서드는 인스턴스 생성 여부 상관없이 인터페이스 타입으로 사용할 수 있는 메서드private 메서드는 구현한 클래스가 사용하거나 오버라이딩이 안됨.(인터페이스 내부에서만 사용) 인터페이스는 기존 클래스와 다르게, 여러 인터페이스를 상속받을 수 있다.(다중상속 가능) 해당 클래스를 활용하기 위한 설명서 같은 역할(다형성에 유리) 모든 메서드가 추상 메서드임(public abstract)모든 변수는 상수로 선언됨(public static final)상속이 아닌 구현으로 해결. 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 할 수 있음 1Readable readable = new Reader(); 이때, 당연히 인터페이스의 내용만 사용가능함.클래스와 달리 여러 인터페이스를 구현할 수 있음","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"3. 다형성, 상속, 결합, 다운 캐스팅","slug":"java/java-basic/java3","date":"2021-08-17T04:06:28.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java3/","excerpt":"","text":"다형성하나의 코드가 여러 자료형으로 구현되어 실행되는 것.같은 코드에서 상황에 따라 다른 결과가 반환.상위 클래스에서 공통 부분을 구현하고, 하위 클래스에서 각 클래스에 맞는 기능 구현여러 클래스를 하나의 타입(상위 클래스)로 핸들링 가능 상속은 언제 사용할까IS-A관계(inheritance, 상속) 일반적(상위) vs 구체적(하위) 관계 상위 클래스 수정이 하위 클래스에 영향을 크게 미침 상속은 클래스간의 결합도 높음 계층구조가 복잡하면 비추. HAS-A관계(composition) 클래스가 다른 클래스를 포함하는 관계(변수로 선언) 상속을 사용하지 않아 결합도 낮은 편. 다운 캐스팅 업캐스팅된 클래스를 다시 원래의 타입으로 형 반환(원래 자기 클래스로) 하위로 형 변환은 명시적으로 해야 함12Customer vc = new VIPCustomer();VIPCustomer vCustomper = (VIPCustomer)vc; 변환할 때, vc가 VIPCustomer의 인스턴스가 아닌데 형변환을 하려고 한다면 에러가 일어난다. 원래 인스턴스의 형이 맞는지 확인하는 instanceof1234Customer vc = new GoldCustomer();if (vc instanceof VIPCustomer)&#123; VIPCustomer vCustomper = (VIPCustomer)vc;&#125; 위에서 언급한 오류 가능성을 체크하여 다운캐스팅하는 예시이다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"3. 데코레이터 패턴","slug":"java/design-pattern/dp3","date":"2021-08-17T00:14:02.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/17/java/design-pattern/dp3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/design-pattern/dp3/","excerpt":"","text":"데코레이터 패턴동적으로 객체에 부가적인 책임을 더하는 패턴.상속으로 확장하는 것이 아닌, 객체들의 결합으로 역할을 확장한다. 배울 내용 요약 클래스들은 코드 수정없이 새로운 동작과 협동할 수 있도록 확장되어야 한다. 예제 음료와 첨가물에 따라 가격과 음료 내용을 출력하는 프로그램을 만들어보자 먼저 음료를 추상화한 클래스를 만들어보자. 123456789package Decorator;public abstract class Beverage &#123; String description = &quot;Unknown Beverage&quot;; public String getDescription()&#123; return description; &#125; public abstract double cost();&#125; 첨가물을 추상화한 클래스를 만들어보자.이 클래스가 데코레이터 역할을 추상화하게 된다.이때 주목할 점은, 데코레이터도 Beverage임을 기억하라. 12345package Decorator;public abstract class CondimentDecorator extends Beverage&#123; public abstract String getDescription();&#125; 음료 클래스를 구체화하는 에스프레소, 하우스블랜드 클래스를 만들어보자. 123456789101112131415161718192021package Decorator;public class Espresso extends Beverage&#123; public Espresso()&#123; description = &quot;Espresso&quot;; &#125; public double cost()&#123; return 1.99; &#125;&#125;package Decorator;public class HouseBlend extends Beverage&#123; public HouseBlend()&#123; description = &quot;House Blend COffee&quot;; &#125; public double cost()&#123; return .89; &#125;&#125; 첨가물 클래스를 추상화하는 모카 클래스를 만들어보자.생성자를 잘 보면, 장식할 클래스를 인자로 가져온다는 걸 알 수 있다. 123456789101112131415package Decorator;public class Mocha extends CondimentDecorator&#123; Beverage beverage; public Mocha(Beverage beverage)&#123; this.beverage = beverage; &#125; public String getDescription()&#123; return beverage.getDescription() + &quot;, Mocha&quot;; &#125; public double cost()&#123; return .20 + beverage.cost(); &#125;&#125; 이제 잘 되는지 실험해보자! 123456789101112package Decorator;public class StarbuzzCoffee &#123; public static void main(String[] args) &#123; Beverage beverage = new Espresso(); System.out.println(beverage.getDescription() + &quot;$&quot; + beverage.cost()); Beverage beverage2 = new HouseBlend(); beverage2 = new Mocha(beverage2); System.out.println(beverage2.getDescription() + &quot;$&quot; + beverage.cost()); &#125;&#125; 배운 내용 확인하기 클래스들은 코드 수정없이 새로운 동작과 협동할 수 있도록 확장되어야 한다.기존의 음료에 첨가물을 추가할 때, 상속으로 새로운 클래스로 만들 필요가 없이, 그냥 데코레이터로 기존 음료를 인수로 전달하면 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"2. 옵저버 패턴","slug":"java/design-pattern/dp2","date":"2021-08-13T12:01:13.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/13/java/design-pattern/dp2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/13/java/design-pattern/dp2/","excerpt":"","text":"옵저버 패턴하나의 객체(서브젝트)가 변할 때, 자동으로 다른 여러 객체들(오브젝트)에게 영향을 동적으로 반영하는 일대다 관계 패턴이때 여러 오브젝트가 추가 될 수 있어야 한다. 배울 내용 요약 1. 서로 상호작용하는 객체들은 느슨하게 연결되어야 한다. 예제로 알아보자. NBA사무국에서는 선수들의 정보를 관리하고 있다.NBA방송국 NBC, TNT에서는 이 정보를 받아 방송하고 있다. 선수들의 정보가 변하게 될 때, 이 두 방송국에서 자동으로 정보를 바꾸고, 바뀐 정보를 방송하는 프로그램을 만들어보자. 일단 방송국들이 반영할 사무국에 대한 인터페이스를 만들어보자 1234567package Observer;public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125; 방송국들의 인터페이스도 만들어주자. 12345package Observer;public interface Observer &#123; public void update(float ppg, float rpg, float apg);&#125; 사무국의 인터페이스를 기반으로 사무국 클래스를 만들어보자. 123456789101112131415161718192021222324252627282930313233343536373839package Observer;import java.util.ArrayList;public class NBAData implements Subject&#123; private ArrayList observers; private float ppg; private float rpg; private float apg; public NBAData()&#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o)&#123; observers.add(o); &#125; public void removeObserver(Observer o)&#123; int i = observers.indexOf(o); if (i &gt;= 0)&#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++)&#123; Observer observer = (Observer)observers.get(i); observer.update(ppg, rpg, apg); &#125; &#125; public void measurementChanged()&#123; notifyObservers(); &#125; public void setMeasurements(float ppg, float rpg, float apg)&#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; measurementChanged(); &#125;&#125; 자, 이제 사무국은 값을 변경할 수 있고, arrayList에 옵저버(방송사)들을 추가하거나 제거하여, 자신의 변경사항을 방송국에게 전달해줄 수 있다.이번엔 방송국 클래스를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Observer;public class NBCDisplay implements Observer, DisplayElement&#123; private float ppg; private float rpg; private float apg; private Subject nbaData; public NBCDisplay(Subject nbaData)&#123; this.nbaData = nbaData; nbaData.registerObserver(this); &#125; public void update(float ppg, float rpg, float apg)&#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; display(); &#125; public void display() &#123; System.out.printf(&quot;This is from NBC!&quot;); System.out.printf(ppg+&quot;points &quot;+rpg+&quot;rebounds &quot;+apg+&quot;assists!!!!\\n&quot;); &#125;&#125;package Observer;public class TNTDisplay implements Observer, DisplayElement&#123; private float ppg; private float apg; private float rpg; private Subject nbaData; public TNTDisplay(Subject nbaData)&#123; this.nbaData = nbaData; nbaData.registerObserver(this); &#125; @Override public void display() &#123; System.out.printf(&quot;This is from TNT!&quot;); System.out.printf(ppg+&quot;points &quot;+rpg+&quot;rebounds &quot;+apg+&quot;assists~!\\n&quot;); &#125; @Override public void update(float ppg, float rpg, float apg) &#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; display(); &#125;&#125; 마지막으로 우리가 만든 녀석들이 잘 작동하는지 확인해보자! 12345678910111213package Observer;public class NbaBroadcast &#123; public static void main(String[] args) &#123; NBAData nbaData = new NBAData(); TNTDisplay tntDisplay = new TNTDisplay(nbaData); NBCDisplay currentConditionsDisplay = new NBCDisplay(nbaData); nbaData.setMeasurements(10.2f, 5.23f, 3.3f); nbaData.setMeasurements(20.4f, 12.4f, 7.4f); &#125;&#125; 배운 내용 확인하기 1. 서로 상호작용하는 객체들은 느슨하게 연결되어야 한다.우리는 인터페이스를 통해 옵저버와 서브젝트를 구현했다. 이들은 서로가 어떻게 구현됐는지 관심없다.그냥 서로가 약속한 인터페이스를 구현하면 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"1. 전략 패턴","slug":"java/design-pattern/dp1","date":"2021-08-12T10:24:17.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/12/java/design-pattern/dp1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/java/design-pattern/dp1/","excerpt":"","text":"전략 패턴변경 가능하고 독립적인 알고리즘의 구성으로 만든 패턴 특징 특정한 계열의 알고리즘을 정의 각 알고리즘을 캡슐화 이 알고리즘들을 해당 계열 안에서 상호 교체 가능 배울 내용 요약 1. 다양하게 변화할 법한 내용은 캡슐화하자.2. 구현이 아닌 인터페이스로 프로그래밍하자.3. 상속보다는 구성(IS-A, HAS-A, 구현을 구분하라) IS-A는 상속 관계로 표현되고, HAS-A는 구성으로 표현된다. 우리는 상속보다 구성을 택할 경우, 런타임 중에 동적으로 행동을 줄 수 있다. 예제로 알아보자 목적 : 다양한 농구 선수들이 플레이 내용을 출력하는 프로그램을 만들어보자 요구사항 : 농구 선수는 여러 포지션을 가질 수 있다. 농구 선수는 모두 슛과 드리블을 할 수 있다. 각 포지션 마다 독특한 슛과 드리블을 구사할 수 있다. 특정 농구선수는 여러 슛과 드리블을 구사할 수 있다. 이제 슛과 드리블을 인터페이스로 캡슐화 해서 구현해보자 player class 123456789101112131415161718package Strategy;public abstract class Player &#123; DribbleBehavior dribbleBehavior; ShootBehavior shootBehavior; public abstract void display(); //dynamically public void setShootBehavior(ShootBehavior sb)&#123; shootBehavior = sb; &#125; public void setDribbleBehavior(DribbleBehavior db)&#123; dribbleBehavior = db; &#125; public void performDribble()&#123; dribbleBehavior.dribble(); &#125; public void performShoot()&#123; shootBehavior.shoot(); &#125;&#125; 이제 인터페이스를 만들어서 캡슐화해보자~ 1234567891011package Strategy;public interface DribbleBehavior &#123; public void dribble();&#125;package Strategy;public interface ShootBehavior &#123; public void shoot();&#125; 이제 인터페이스에 따라 다양한 슛과 드리블 클래스를 만들자 12345678910111213141516171819202122232425262728293031323334353637package Strategy;public class ThreePointShoot implements ShootBehavior&#123; @Override public void shoot()&#123; System.out.println(&quot;from the downtown... It&#x27;s good!!!!!!&quot;); &#125;&#125;package Strategy;public class DunkShoot implements ShootBehavior&#123; public void shoot()&#123; System.out.println(&quot;here comes the hammer!!!!!&quot;); &#125;&#125;package Strategy;public class CrossOverDribble implements DribbleBehavior&#123; @Override public void dribble() &#123; System.out.println(&quot;what a dribble... wazzle dazzle!&quot;); &#125;&#125;package Strategy;public class HegiDribble implements DribbleBehavior&#123; @Override public void dribble() &#123; System.out.println(&quot;look at that hegi..&quot;); &#125;&#125; 이제 player 클래스를 구현하는 포지션 별 행동을 잘 구성하자! 12345678910111213141516171819202122232425package Strategy;public class Guard extends Player&#123; public Guard()&#123; dribbleBehavior = new CrossOverDribble(); shootBehavior = new ThreePointShoot(); &#125; @Override public void display() &#123; System.out.println(&quot;Here comes new Guard!&quot;); &#125;&#125;package Strategy;public class Foward extends Player&#123; public Foward()&#123; dribbleBehavior = new PowerDribble(); shootBehavior = new DunkShoot(); &#125; @Override public void display() &#123; System.out.println(&quot;Here comes new Forward...!&quot;); &#125;&#125; 자 이제 잘 작동하는지 한번 해보자. 123456789101112131415161718package Strategy;public class MiniPlayerSimulator &#123; public static void main(String[] args)&#123; Player curry = new Guard(); curry.display(); curry.performDribble(); //dynamically setter curry.setDribbleBehavior(new HegiDribble()); curry.performDribble(); curry.performShoot(); Player james = new Foward(); james.display(); james.performDribble(); james.performShoot(); &#125;&#125; 배운 내용 확인하기 1. 다양하게 변화할 법한 내용은 캡슐화하자. 슛과 드리블은 다양하게 나뉘므로 선수 클래스로부터 캡슐화 했다 2. 구현이 아닌 인터페이스로 프로그래밍하자. 슛과 드리블은 오버라이딩 같은 방식이 아닌, 인터페이스로 다향성을 구현했다. 3. 상속보다는 구성(IS-A, HAS-A, 구현을 구분하라) 가드가 삼점 슛과 크로스오버를 가진 것처럼 구성하였다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[]},{"title":"11. 가상 메모리와 페이징 시스템, 세그멘테이션 기법","slug":"cs/os/os11","date":"2021-08-12T04:56:15.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/12/cs/os/os11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/cs/os/os11/","excerpt":"","text":"가상 메모리실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음.(리눅스는 하나의 프로세스가 4기가를 차지함) 적은 메모리에서 여러 프로세스를 다루기 위해 등장한 개념이 가상 메모리! cpu가 한 프로세스의 모든 영역을 사용하지는 않는다,프로세스가 모두 4기가 씩을 부여 받더라도, 정작 사용하는 공간은 제한적이다.사용할 영역만 RAM에 저장하여 실행하는 방식으로 하면 메모리가 부족해도 여러 프로세스를 작동 시킬 수 있다. 가상 메모리의 기본 아이디어 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 바꿔주자. virtual address : 프로세스가 참조하는 주소 physical address : 실제 메모리 주소 MMU(Memory Managemnet Unit) cpu에 코드 실행 시, 가상 주소 메모리 접근이 필요할 경우, 해당 주소를 물리 주소 값으로 변환하는 하드웨어. 주소 변환을 빠르게 하기 위해 하드웨어 장치를 사용. cpu는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU가 물리 메모리 접근 페이징 시스템(paging system) 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리 하드웨어 지원 필요(intel x86(32bit)는 4kb, 2mb, 1gb 지원) 리눅스에서는 4kb로 paging 가상 메모리를 페이징 단위에 맞게 잘게 쪼개서 페이징 번호를 부여하고,page table에 해당 페이징에 맞는 물리 주소 매핑 정보를 저장한다. 4gb짜리 프로세스와 PCB에 page table 구조체를 가리키는 주소가 존재해서cpu가 어떤 가상 메모리 주소에 접근하면 해당 페이징에 맞는 page table에 접근해서,매핑 되어 있는 물리 주소를 얻어 물리 주소로 접근하는 방식이다. 내부 단편화 : 4kb씩 데이터를 나눈다고 했을 때 만약 1kb가 남으면…? 1kb도 4kb크기의 페이지로 할당.(공간 낭비) 페이징 시스템 구조1. page 혹은 page fram: 고정된 크기의 block 가상 주소 v = (p, d) p: 가상 메모리 페이지 번호 d: p안에서 참조하는 위치(변위 혹은 오프셋이라고도 부름)(페이지 안에서도 내가 접근할 위치의 값에 접근할 수 있도록 하는 것이 d)(즉 어떤 페이지의 시작 주소가 있을 텐데 그 페이지에서 d 만큼 내려오면 우리가 원하는 주소) 2. page table: 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표(CR3라는 레지스터에 page table 시작 주소가 담겨져 있다.) 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는 지 확인 page 번호가 있으면 이 page가 매핑된 첫 물리주소가 p’이 됨 page 번호가 있어도 해당 page가 램에 저장되지 않았을 수 있음(필요 없다고 생각해서) p’+d 가 실제 물리 주소가 됨 다중 단계 페이징 시스템32bit 시스템에서 한 프로세스가 4gb(리눅스 기준)인데,이를 4kb 기준으로 다 잘라서 다 테이블에 저장하려면 너무 비효율적이다. 따라서 페이징 정보를 단계를 나누어 생성하자.즉 필요없는 페이지는 생성하지 말자! 가상 주소를 page directory, page table, offset으로 만들어서필요 없는 페이지들은 페이지 테이블을 안 만들도록 할 수 있다~! MMU와 TLB(컴퓨터 구조)한번 가상 주소를 통해 얻은 물리 주소를 TLB라는 캐쉬에 저장해놓는다.만약 다시 동일한 주소를 요청하면, 해당 테이블을 찾아보지 않아도 TLB를 통해 얻을 수 있다. 이를 통해 메모리에서 접근하고 값을 찾는 과정을 줄일 수 있다. 페이징 시스템과 공유 메모리프로세스 간 동일한 물리 주소를 가르킬 수 있다.즉 서로 다른 프로세스 a, b의 내용이 같은 영역은 물리주소로 변환할 때 같은 물리 주소로 줄 수 있다. 엥? 서로 한 프로세스가 데이터를 변경할 수 있잖아요..?그렇다. 하지만 생각해보자. 만약 a 영역에서 물리주소를 얻어 데이터를 변경하려고 한다면?그때 메모리 상에 다른 물리주소를 복사해서 그 주소를 b에게 주고, 원래 물리 주소를 요청대로 수정하면 된다. 이런 방식을 통해 각 프로세스가 1기가 정도 점유하고 있는 커널 공간을 모두 같은 물리 주소로 변환해,용량 낭비를 줄일 수 있다. 프로세스 생성 시간도 줄어들고, 공유 공간을 물리 메모리를 공유로 효율적으로 쓸 수 있다. 요구 페이징(demanding paging, demanded paging)프로세스 모든 데이터를 메모리에 담지 않고, 실행 중 필요한 시점에만 메모리로 적재더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)(선행 페이징이 이와 반대되는 개념. 모두 메모리에 적재.) 페이지 폴트 인터럽트(page fault interupt)어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트.운영체제는 이 인터럽트를 받으면, 해당 페이지를 물리 메모리에 올리고 다시 작업을 실행시킨다.페이지 폴트는 인터럽트이므로, 앞서 배웠던 인터럽트 처리과정을 동일하게 발생시킨다. 스레싱(Thrashing) 페이지 폴트가 자주 일어나면, 시간이 오래 걸린다. 반복적으로 페이지 폴트가 발생해, 과도하게 페이지 교체작업이 일어나 실제로는 아무 일도 진행 안되는 상태. 자주 쓰일 것 같은 페이지는 미리 메모리에 올려 놓는게 좋다.(알고리즘) 페이지 교체 정책(page replacement policy)물리 메모리가 가득 찼는데 특정 페이지를 물리 메모리에 올려야 할 때어떤 페이지를 선택해 빼고 넣으려고 했던 페이지를 넣는다. FIFO 알고리즘 가장 먼저 들어온 페이지가 나가자! OPT 알고리즘 오랫동안 안 쓸 페이지를 내리자!(일반적인 OS에서는 예측 불가) LRU 알고리즘 가장 오래 전에 사용한 페이지가 나가자! LFU 알고리즘 지금까지 가장 적게 쓰인 페이지가 나가자! NUR 알고리즘 각 페이지마다 참조 비트, 수정 비트를 (R, M)으로 표현하여 (0,0)-&gt;(0,1)-&gt;(1,0)-&gt;(1,1) 로 우선순위로 나가라! 세그멘테이션 기법페이징과 비교해서 기억하는 정도만 보자.가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할(페이징은 일관된 크기로 분할) 세그먼트 가상 주소v = (s,d) s: 세그먼트 번호, d: 블록 내 세그먼트 범위 외부 단편화 : 세그먼트의 크기가 들어갈만한 연속적인 물리 공간이 없으면 문제가 생김.(크기가 지 맘대로다 보니…)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"16. Backtracking","slug":"cs/algorithm/theory/al16","date":"2021-08-12T04:11:49.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/12/cs/algorithm/theory/al16/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/cs/algorithm/theory/al16/","excerpt":"","text":"Backtracking답이 x1, x2, x3… 이런 형식으로 도출되는 문제에서, 유효한 답을 모두 찾는 경우 사용되는 알고리즘 기법 x1부터 차례대로 결정하면서 만약 어느 순간 조건에 맞는 답을 도출 못하는 상황에 마주하면,그 전 단계로 돌아가 다른 선택지로 다시 답을 찾아가는 방법이다. 이 기법은 굳이 더 알아보지 않아도 되는 경우를 확인하지 않도록 설계하는 것이 가장 중요하다. psuedo code 123456789def backtrack(k): if k &gt; n: print(x) else: for each possible value x of x[k]: if B(x[1], ... , x[k]) is valid: #B는 x1~xk가 해의 일부가 될 수 있는지를 검증 x[k] = x backtrack(k+1) 이런 방식은 미로 탈출하기 등에 적용할 수 있다. N queens 문제n X n 체스판에 n개의 퀸을 배치해야 한다.다만 각 퀸들의 공격권에 다른 퀸이 있으면 없도록 배치해야 할 때, 배치 가능한 방법 갯수를 구하라. x라는 배열이 각 퀸의 위치를 인덱스가 행을, 밸류값을 열로 나타낸다.이제 x[0] = 0은 (0,0)에 퀸이 존재함을 의미한다. 그러면 이제 backtracking을 위해 x[0] = 0 이라고 가정하자.x[1]는 0과 1이 될 수 없다.(세로줄 겹침, 대각선 겹침.)x[1] = 2인 경우는 일단 문제는 없으니 x[1] = 2 로 가정하고 넘어간다. x[2] 는 이제 0, 1, 2, 3 모두 될 수 없다.(두 퀸과 무조건 겹침)즉 조건을 만족할 수 없으므로, x[1]의 경우로 backtracking한다! 이런 과정을 통해 x[3]이 배치될 때까지 반복하면 backtracking을 통해 답을 찾을 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"15. 그리디 알고리즘 활용 - 허프만 코딩","slug":"cs/algorithm/problem/al15","date":"2021-08-11T10:38:21.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/11/cs/algorithm/problem/al15/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/algorithm/problem/al15/","excerpt":"","text":"허프만 코딩 문제(Huffman coding problem)아스키 코드 : 알파벳과 문자들을 0~255개의 숫자로 배정한 것. 즉 8bit로 표현.이렇게 표현된 8비트의 비트들을 고정길이코드(fixed-length code)라고 한다.(문자열 100개면 800비트가 필요하게 된다.) 이때 a e i o u 같은 모음들은 빈도수가 높고 q z y는 빈도수가 낮다.그렇다면, 자주 사용되는 문자의 아스키 코드 비트값은 줄이고, 그렇지 않은 문자들 비트 수는 늘리면 어떨까?이렇게 변한 길이의 코드를 가변길이 코드라고 하자. 즉 a가 100번, b가 30번, c가 5번이라고 하면,고정 길이코드로 할 경우, 모두 8비트로 부여할 경우 총 800 + 240 + 40 = 1080 비트가 필요 가변 길이코드로 부여하면, a = 0, b = 101, c = 100으로 할 경우,100 + 90 + 15 = 205 비트면 충분하게 된다. 하지만 만약 코드를 더 줄이고 싶으면 다음과 같이 하면 된다고 생각할지 모른다.a = 0, b = 1, c = 10 하지만 그렇게 된다면, 1001010을 baacc 혹은 caabab 등등 해석이 불분명해진다.따라서 각 문자에 비트를 구분가능하게 부여해야하는데, 이를 prefix-free code라고 한다.다시 말하면, 각 코드들은 앞부분이 다른 코드와 동일하면 안된다.(위 예시는 c의 앞부분이 b와 동일했다.) 트리 형태로 생각하기. 위에서 설명한 규칙들을 기반으로 트리를 만들면 위와 같다.여기서 짧은 코드를 할당받기 위해서는? 루트노드와 가까워야 한다!그렇다면 도대체 어떻게 구현한다는 것인가…!! 먼저 빈도 내림차로 문자들을 배열에 정렬하여 만들고,(위 사진은 그러지 않았다.)빈도가 작은 수끼리 빈도를 합쳐가면서 만들면… 우리가 앞서 본 트리와 비슷한 모양이 그려진다. 즉 코드로 구현하려면, 가장 작은 값과 두번째로 작은 값을 찾아 더해야 하는데… 이는 힙으로 구현 가능하다! 이제 우리가 알고싶은 특정 문자열의 총 비용은 모든 문자의 빈도수 X 트리에서 깊이 이다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"14. 그리디 알고리즘","slug":"cs/algorithm/theory/al14","date":"2021-08-11T07:17:39.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/11/cs/algorithm/theory/al14/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/algorithm/theory/al14/","excerpt":"","text":"그리디 알고리즘현재 상태에서 가장 좋은 선택을 반복해서 해를 구성하는 알고리즘 문제는 이 그리디 알고리즘을 통해 얻은 해가 진짜 최선의 선택으로 얻은 해이냐는 것인데,이를 증명하기 위해서는 귀류법을 통해 증명해봐야 한다. 즉 우리가 찾은 해가 해가 아님을 가정으로 하여 다른 해를 가정하여,그 해를 논리적으로 추론하여 모순을 찾아내면, 우리가 찾은 그리디는 증명된 것이다. 예를 통해 이해해보자. L = [1, 2, 3, 4, 5]라는 배열에서 원소의 합이 9 (= T)를 넘지 않도록 원소를 추출할 때, 가장 원소가 많은 경우는 몇 개인지 구할 때,우리는 당연히 가장 작은 원소부터 하나씩 더해가면서 합이 9가 넘어가기 전 원소들만 추출 할 것이다.(1,2,3. 즉 세개)(가장 작은 값부터 뽑는 방식으로 T까지 뽑으면(p) -&gt; 3개가 가장 최대 갯수이다.(q)) 이 논리를 검증하려면 ~q -&gt; ~p임을 증명하면 된다.즉 3개가 보다 더 많이 뽑을 수 있다고 가정했을 때 p가 모순을 일으키면 우리의 원래 p-&gt;q가 증명된 것이다. 우리는 3이라는 답을 우리의 논리(p)로 찾아냈다.이를 증명하기 위해 3보다 많은 갯수가 해가 존재한다(~q)고 가정해보자. 그렇다면 우리의 논리(가장 작은 값부터 뽑기, p) 찾은 값들 a1, a2, a3가 있을 것이고역의 해 b1, b2, b3, b4 …가 있을 것이다.(이때, a와 b 모두 오름차순이라 하자) 자 이제 a1+a2+a3 = X라 하고, b1+b2+b3 = Y라 하면,p에 의해 무조건 X &lt;= Y 이다. (p = 가장 작은 값부터 뽑는다.)그리고 문제 조건에 따라 Y + b4 &lt;= T이다. 그런데 p에 따르면X + a4 &gt;T 이고 a4 &lt;= b4 이다. 즉 종합해보면X &lt;=Y , a4 &lt;= b4 인데X + a4 &gt; T 인데 Y + b4 &lt;= T 인 모순적인 상황이 발생한다! 즉 우리의 그리디가 옳았다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"10. 쓰레드","slug":"cs/os/os10","date":"2021-08-11T04:09:16.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/11/cs/os/os10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/os/os10/","excerpt":"","text":"ThreadLigth Weight Process라고도 하는 데, 프로세스와 비슷하지만 프로세스보다 가벼운 존재다. 프로세스 : 프로세스끼리는 서로 데이터에 접근 불가스레드 : - 하나의 프로세스 안에서 여러 스레드 생성 가능 - 스레드들은 동시에 실행 가능 - 프로세스 안에 있으므로 해당 프로세스 데이터를 모두 접근 가능 쓰레드는 어떤 프로세스 안에서 code, data, heap 영역은 공유하지만,각자 개인의 스택 영역을 가진다.(프로세스의 스택 영역은 공유하지 않는다.) 멀티 프로세싱과 쓰레드멀티 태스킹 : 한 cpu가 여러 프로세스를 시분할 하여 돌아가며 작업 수행멀티 프로세싱 : 여러 cpu가 프로세스들을 병렬로 작업 수행. -&gt; 이 작업은 쓰레드를 여러개로 만들면 가능한 일! 쓰레드 장단점 장점 1. 사용자에 대한 응답성 향상만약 어떤 작업과 동시에 사용자와 커뮤니케이션 해야 되는 경우, 쓰레드를 사용하지 않으면, 해당 작업이 모두 끝나야 커뮤니케이션이 가능하다.반면 쓰레드를 사용하면 작업과 커뮤니케이션을 병렬적으로 처리 가능하다. 2. 자원 공유 효율 - IPC 작업 같은 프로세스 간 자원 공유를 위한 작업이 필요 없음 3. 작업이 분리되어 코드가 간결(이건 작성자에 따라 다르다.) 단점 1. 스레드 중 한 스레드만 문제 있어도, 프로세스 전체가 영향 받음 - 프로세스는 서로 독립되어 있어서, 서브 프로세스들 중 하나가 문제 생겨도 다른 서브 프로세스에 영향이 덜 감 - 반면 쓰레드는 해당 프로세스의 자원을 공유하기 때문에, 한 쓰레드의 오류가 큰 문제를 일으킴. 2. 스레드를 많이 생성하면 context switching이 많이 일어나 성능이 저하된다. - 스레드를 스케쥴링해야 하므로, context switching이 많이 일어나게 된다. 쓰레드 동기화 이슈동기화: 작업들 사이에 실행 시기를 맞추는 것여러 스레드가 동일한 자원을 접근해 수정할 경우 동기화 이슈가 발생. 여러 쓰레드가 한 변수를 읽고 쓰기를 한다고 상상해보자.이때 어떤 쓰레드A가 한 변수를 쓰고, 다른 쓰레드B가 읽는 순으로 진행되어야 하는데, 만약 B가 변수를 읽고 A가 변수를 쓰게 된다면?우리가 원하는 결과를 얻을 수 없게 된다. 자 g_count라는 변수가 0으로 초기화되어 있고, g_count = g_count +1 이라는 코드를 쓰레드1과 쓰레드2에게 각각 실행시켜최종적으로 g_count가 2라는 결과값을 얻고자 할 때 예상되는 동기화 이슈를 살펴보자.g_count = g_count +1 은 세가지 연산이 필요한다. (메모리에서 g_count값을 읽고, 레지스터에서 덧셈을 진행하고, 진행한 값을 다시 g_count 메모리에 저장.)근데 이때, 쓰레드1에서 덧셈만하고 저장하지 못한 채로 context switching이 일어나, 쓰레드2가 작업을 시작하면 문제가 생긴다! 동기화 이슈 해결 방안상호 배제(Mutual exclusion, LOKING 매커니즘) 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근 못하도록 막기! 임계 자원(critical resource) : 접근이 제한되는 자원 임계 영역(critical section) : 접근이 제한되는 영역(코드 상에서) 1234lock.acquire()for i in range(100000): g_count += 1lock.release() Mutex와 Semaphore Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어 갈 수 있음 Semaphore : 임계구역에 여러 스레드가 들어 갈 수 있음 counter를 두어서 동시에 리소스에 접근 할 수 있는 스레드 수를 제어 Semaphore 로직 P: 검사(임계영역에 들어갈 때) S &gt;= 1 이면, 임계 영역 진입 &amp;&amp; S -1 (S==0이면 대기) V: 증가(임계영역에서 나올 때) S+1 하고 임계 영역 나옴 S: 세마포어값(초기 값만큼 여러 프로세스가 동시에 임계 영역 접근 가능) 바쁜 대기(busy waiting) : 프로세스가 대기 중임을 코드로 표현하기 위해 루프를 사용함.즉 대기를 위해 cpu리소스가 사용되는 비효율적 상황 대기큐 : S가 음수일 경우, 바쁜 대기 대신 대기큐에 넣자! psuedo code 123456789101112131415161718192021222324P(S): wait(S)&#123; while S &lt;= 0 //대기(busy waiting. 기다리는데 cpu 자원 사용...) ; S--; //다른 프로세스 접근 제한&#125;V(S): signal(S) &#123; S++; //다른 프로세스 접근 허용&#125;//대기큐wait(S) &#123; S-&gt;counter--; if(S-&gt;count &lt;0) &#123; add this process to S-&gt;queue; block() //대기를 위해, 프로세스를 대기큐에 넣고 block 상태로... &#125;&#125;signal(S)&#123; S-&gt;count++; if (S-&gt; count &gt;= 1)&#123; remove a process P from S-&gt;queue; wakeup(P) //큐에서 프로세스를 꺼내서 깨운다! &#125;&#125; 교착상태(Deadlock)와 기아상태(Starvation) 교착상태 무한 대기 상태 : 복수의 작업이 서로 상대방 작업이 끝나길 기다리느라 다음 단계로 진행되지 않는 상황 스레드1은 lock하여 리소스 1을 사용하고 리소스 2를 사용하기 위해 대기하고,스레드2는 lock하여 리소스 2를 사용하고 리소스 1을 사용하기 위해 대기한다면?둘 다 다음 단계로 진행되지 않는다! 교착 상태 발생조건(모두 성립 시 교착상태 발생 가능) 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적 통제권 요구 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원 대기 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음 순환대기(Circular wait): 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다 이런 원인 중 일부를 해결하면 교착상태를 해결할 수 있다 기아상태 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태 교착상태와 차이? 교착상태 : 여러 프로세스가 동일 자원 점유를 요청할 때 발생 기아상태 : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 할당 안됨 예를 들면 어떤 변수를 10번 접근해서 변경하라는 명령을 100개의 쓰레드가 사용된다면, 일부 쓰레드는 영영 작업을 해보지 못할 것이다! 기아상태 해결 프로세스 우선순위를 수시로 변경 오래 기다린 프로세스의 우선순위 상향 우선순위가 아닌 요청순으로 FIFO 기반 요청큐 사용","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"9. 프로세스 구조와 프로세스간 커뮤니케이션","slug":"cs/os/os9","date":"2021-08-09T04:34:54.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/09/cs/os/os9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/09/cs/os/os9/","excerpt":"","text":"프로세스 구조프로세스 구조는 4가지 영역으로 나뉜다. 스택 : 최상단 스택 주소를 가리키는 EBP, 함수 결과를 반환해줄 주소(return address), 함수와 관련된 인자나 변수를 저장하는 영역 힙 : 동적으로 할당된 메모리를 저장하는 영역. (ex. malloc) 이 영역의 메모리 주소를 통해 힙에 저장된 내용을 다른 영역에서 사용! 데이터 : 선언된 변수가 저장되는 영역(전역변수가 저장된다.) 코드 : 컴파일된 소스코드가 저장되는 영역 스택에 쓰이는 레지스터들 :program counter, stack pointer, EBP, EAXprogram counter(pc)는 cpu 내부의 레지스터 중 하나로, 다음에 실행될 명령어의 주소를 가지고 있다. stack pointer는 cpu 내부 레지스터 중 하나로, 스택에 데이터가 채워진 위치를 가르킨다. EBP 얘도 레지스터인데, 우리가 함수를 작성할 때 함수 안에 다른 함수를 부를때마다 그 전에 stack pointer가 가르키던 주소를 스택에 집어넣고 EBP에도 저장한다.이를 통해 프로그램 진행 중 문제가 생겼을 때, 어떤 함수에서 문제가 발생했는지 알 수 있게 된다. EAX 얘도 레지스터인데, 스택에서 실행된 함수의 반환값을 저장하는 레지스터다! 데이터 영역은 두 가지로 나뉜다. (BSS, DATA)BSS : 초기화되지 않은 전역변수. DATA : 초기화된 전역변수 컨텍스트 스위칭스케쥴러가 어떤 프로세스를 실행하다가, 이를 멈추고 다른 프로세스를 실행시키는 행위를 컨텍스트 스위칭이라 한다!컨텍스트 스위칭은 빈번하게 일어나므로, 빠르게 실행하기 위해 어셈블리어로 작성되어 있는 경우가 많다. 이때 앞에 배웠던 program counter와 stack pointer이 저장하고 있는 두 주소값을해당 프로세스의 PCB(Process Control Block. 프로세스의 상태를 저장하는 구조체)라는 곳에 저장해 놓고!다른 프로세스로 넘어가서 작업을 시작하고 이 프로세스의 PCB에도 해당 값을 저장하고,이제 처음에 했던 프로세스를 이어서 하기위해, PCB에 있던 데이터를 가져와 cpu의 pc와 sp를 업데이트하고 디스패치(ready-&gt;running)한다! PCB에 저장되는 내용들리눅스 PCB 예시 Process ID Register value(PC, SP…) Scheduling info (Process state. running, block, ready…) Memory Info(memory size…) 프로세스간 커뮤니케이션(IPC, Inter Process Communication)프로세스들이 서로 마음대로 접근해서 바꾸면? 당연히 문제가 된다! 하지만 프로세스간 통신 해야 될 경우도 분명히 존재한다. 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행 이 때 프로세스간 상태 확인 및 데이터 송수신 필요. =&gt; 그래서 프로세스간 통신이 필요하다. 프로세스간 공유하는 파일 사용하기프로세스간 코드에 접근할 수는 없지만, 특정 저장매체를 공유할 수 있게 해서,한 프로세스가 전달할 내용을 파일에 쓰고, 다른 프로세스가 해당 파일을 읽는 방식이다. 하지만 실시간으로 원하는 프로세스에 데이터 전달이 어려움… 이때, 프로세스들은, 다른 영역이 아닌 커널 공간(이 부분은 다른 프로세스도 비슷하므로)를 공유해 사용한다.IPC는 쉽게 요약하면, 이 커널 공간을 통해 어떻게 공유할 지 결정하는 방법이라 할 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"13. 다이나믹 프로그래밍-3(LCS 문제)","slug":"cs/algorithm/problem/al13","date":"2021-08-05T12:11:41.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/05/cs/algorithm/problem/al13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/problem/al13/","excerpt":"","text":"LCS(최장공통부문자열) 문제부문자열은 문자열에서 0개 이상의 문자를 제외하고 남은 문자열을 의미YANG에서 A를 제외한 YNG같이… 하지만 AGY는 안된다! 공통 문자열은 두개의 문자열의 부문자열이 동일한 것을 말한다!이 문제는 가장 긴 길이의 공통부문자열을 찾는 문제이다! Xn 을 x1, x2, x3, … xn 즉 n개의 글자를 갖는 문자열이라고 하고,**LCS(i, j)**를 Xi와 Yj의 최장공통부문자열의 길이라고 한다면,xn과 yj(즉 두 문자열의 마지막 글자)가 같은 경우와 그렇지 않은 경우를 생각해야 한다. 만약 마지막 글자가 같으면, 그 글자를 제외하고 생각할 수 있다!즉 LCS(i, j) = LCS(i-1, j-1) + 1 이런 점화식이 가능하다! 하지만 마지막 글자가 다르다면?Xi와 Y(j-1). 즉 X전체와 Y에서 마지막을 제외한 문자열의 LCS값과X(i-1)과 Yj. 즉 X에서 마지막을 제외한 문자열과 Y전체의 LCS값 중 최대값을 구하면된다즉 LCS(i, j) = max(LCS(i, j-1), LCS(i-1, j)) 자 이제 이 점화식을 이차원 리스트로 표현할 수 있다!if xi==yj LCS[i-1][j-1] + 1if xi!=yj max(LCS[i][j-1], LCS[i-1][j]) 이렇게 대략적으로 테이블이 그려지면, 이제 특이 조건들을 찾아야 된다!예를 들면 LCS(0,x) 혹은 LCS(x,0) 같은 값들! 이들은 모두 0이다! 그 다음엔, 어떤 절차로 작은 값을 통해 큰 값을 구해낼지 추론해야 한다!이렇게 테이블을 모두 채우는데 O(mn)의 시간이 걸린다! 만약, 길이가 아닌 문자열 자체를 구하라하면, 테이블을 숫자로 채운 다음, 역으로 추론해가며 올라가자.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"8. 선점형 스케쥴러와 인터럽트","slug":"cs/os/os8","date":"2021-08-05T07:47:28.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/05/cs/os/os8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/os/os8/","excerpt":"","text":"선점형 스케쥴러하나의 프로세스가 다른 프로세스 대신에 프로세서(cpu)를 차지할 수 있다!어떤 프로세스가 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체가능! 비선점형 스케쥴러하나의 프로세스가 끝나지 않으면 다른 프로세스는 cpu 사용할 수 없음…자발적으로 wait으로 되거나, 혹은 실행이 끝났을 때만 다른 프로세스로 교체 가능!즉 cpu가 임의로 실행 중인 프로세스를 종료시키지 못한다. === 인터럽트 cpu는 명령 하나하나 실행 중일때, 다른 장치와 어떻게 커뮤니케이션 할까? cpu가 프로그램을 실행 중 일때, 장치, 혹은 예외 상황이 발생해 처리가 필요할 경우 cpu에 알려서 처리하는 기술.인터럽트는 특정 프로세스의 코드가 아닌 일종의 이벤트.이벤트에 맞게 운영체제가 처리한다! 인터럽터 필요 이유 선점형 스케쥴러 구현 어떤 프로세스가 running 중에 이를 중단시킬 때, 인터럽터가 필요. IO 디바이스와 커뮤니케이션 저장매체에서 처리 완료 시, 프로세스를 깨워야 함(block -&gt; ready) 예외 상황 핸들링 어떤 문제가 생겼을 때, cpu에서 이를 처리할 수 있도록 cpu에 알려줘야 함 인터럽트 종류1. 0으로 나누는 코드 실행 시 (Divide by Zero Interrupt) 12345int main()&#123; int zero = 0 int data = 1/zero; return 0;&#125; 이런 시도를 하게 되면, 운영체제가 해당 프로세스를 종료시키고, 인터럽트를 발생시킨다! 2. 타이머 인터럽트 - 선점형 스케쥴러를 위해 필요. 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다!cpu가 다른 프로세스를 실행 중이라 바쁠 때, 특정 시간마다 인터럽트를 일으켜 알려준다! 3. 입출력 인터럽트 - 프린터, 키보드, 마우스…. 인터럽트 종류 내부 인터럽트(소프트웨어 인터럽트) 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생. 0으로 나누거나, 사용자 모드에서 허용하지않는 명령 실행, overflow, underflow… 외부 인터럽트(하드웨어 인터럽트) 주로 하드웨어에서 발생되는 이벤트(프로그램 외부) 전원 이상, IO 관련 이벤트, Timer이벤트… === 인터럽트 내부 동작 구조시스템 콜 인터럽트 시스템 콜은 인터럽트를 활용해야 함. 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어 cpu에 실행 시켜야 함 기계어로 컴파일 될 때 시스템 콜 코드가 삽입된다.123mov eax, 1 //eax레지스터에 시스템콜 번호 넣고mov ebx, 0 //ebx레지스터에는 시스템 콜에 해당하는 인자값 넣고int 0x80 //소프트웨어 인터럽트 명령 호출하면서 0x80값 넘겨준다. 시스템콜 인터럽트 명령이 호출되면서 0x80값을 넘겨주고, cpu는 사용자모드에서 커널 모드로 전환 IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행 인터럽트 번호에 맞는 주소(코드)를 적어놓은 테이블 ex) 0x80 : system.call() 찾은 system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동 system_call()에서 시스템 콜 번호에 따라 매칭 되는 함수를 찾아서 실행 시킴 해당 시스템 콜 실행 후, 다시 커널 모드를 사용자 모드로 전환, 해당 프로세스의 다음 코드 진행. 인터럽트와 IDT인터럽트는 미리 정의되어 각 번호와 실행 코드를 가리키는 주소가 기록되어 있다. where? : IDT(Interrupt Descriptor Table)에 기록해 놨다. when? : 컴퓨터 부팅시 운영체제가 기록한다. what? : 운영체제의 내부 코드를 기록한다. 인터럽트와 프로세스의 관계 프로세스 실행 중 인터럽트 발생 현 프로세스 실행 중단 인터럽트 처리 함수 실행(운영체제) 현 프로세스 재실행","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"12. 다이나믹 프로그래밍-2(행렬 곱셈 문제)","slug":"cs/algorithm/problem/al12","date":"2021-08-05T06:38:27.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/05/cs/algorithm/problem/al12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/problem/al12/","excerpt":"","text":"행렬 곱셈 문제 n개의 행렬 곱셈을 최소 비용으로 푸는 문제 만약 무지성으로 pXq , qXr 인 두 행렬을 3개 for루프로 풀면, O(pqr)번 연산이 필요하다.이때 여러개의 행렬이 주어졌을 때는, 행렬을 어느 순서로 곱하느냐에 따라 기본 연산 횟수가 달라진다.a = 1x2, b=2x3, c=3x4 일때, (ab)c와 a(bc)의 차이는 1x2x3x1x3x4 vs 1x2x4x2x3x4 의 차이다. 그렇다면 어떤 곱셈을 먼저 해야 최소 비용으로 행렬의 곱셈을 구할 수 있을까? 우리는 다이나믹 프로그래밍으로 풀어보자.먼저 해의 성질은 분석해보자n개의 행렬이 있다고 했을 때,n개 곱셈비용은 어떤 행렬 i를 기점으로 곱셈 형식으로 된다.즉 (M1 x…x Mi) X (M(i+1) x…x Mn) 이런 식이 될 것이다. 그렇다면? 결국 Mn = pn x qn 이라고 했을때행렬의 곱셈 원칙에 따라, M1=p1 x p2, M2=p2 x p3… 이런 식이 되고,{p1 x p(i+1)} x {p(i+1) x p(n+1)} 인 꼴이 된다. 점화식을 구현해보자즉 M1 ~ Mn까지 최소 비용 = M1 ~ Mi 최소비용 + M(i+1) ~ Mn까지 최소비용 + 이 둘을 곱하는 비용{=p1 * p(i+1) * p(n+1)}T(1,n) = T(1,i)+T(i+1, n)+둘 곱하는 비용뭔가 점화식처럼 생겼다! 하지만 우리는 i가 어떤 수인지 모른다.. dp테이블을 구현해보자그려면 dp테이블을 사용해서 다 해보자!T에 두가지 수가 필요하므로, dp를 2차원 배열로 하여..dp[1][n] = min(dp[1][i]+dp[i+1][n]+p1 * p(i+1) * p(n+1))으로 해서i=1~n-1까지 대입해서 이 중 최소값을 찾으면 된다!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[]},{"title":"11. 다이나믹 프로그래밍-1","slug":"cs/algorithm/theory/al11","date":"2021-08-05T05:08:48.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/05/cs/algorithm/theory/al11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/theory/al11/","excerpt":"","text":"다이나믹 프로그래밍문제를 여러 작은 문제로 나누어 재귀적으로 해결하는 방법. divde and conquer와 차이점은? 큰 문제의 답이 작은 문제의 답들의 식으로 표현되지만,그 답을 얻을 때 재귀적으로 얻는게 아니라 미리 계산하여 기록해 놓은 값을 재귀 식에 따라 계산! 즉 원래 문제의 답을 작은 문제들의 재귀 식으로 표현하는 것이 핵심!!!!점화식을 찾아내고, 점화식에 필요한 값들만 중복 없이 리스트에 저장하여 문제를 해결하는 게 중요! 예를 들면, 계단 오르기 문제.한번에 계단을 하나 혹은 두개씩 오른다고 할 때n번째 계단에 오는 경우의 수는? k번째 계단에 오는 경우의 수 = k-1번째 계단에 오는 경우의 수 + k-2번째 계단에 오는 경의의 수 이다. (k-1에서 한칸 오르거나 ,k-2에서 두칸 오르는 것의 합)즉 T(k) = T(k-1)+T(k-2)인 점화식이 완성된다. T(1) = 1, T(2) = 2이므로, 이들을 리스트에 넣고, T(3) = 3 을 구한 다음,T(2), T(3)을 리스트에 기록 후, T(4) = 6을 구하고… 이런 식으로 T(n)까지 구해가는 게 다이나믹 프로그래밍이다! 최대 구간 합 문제랜덤한 n개의 수를 가진 배열이 주어지고, 이 배열에서 연속된 수의 합이 최대값을 구하라. divide &amp; conquer배열을 반으로 잘라서, 왼쪽, 오른쪽 혹은 가운데에서 최대값을 구함. 1234567891011121314151617181920def max_interval(A, l, r): if l &gt;= r : return A[l] m = (l+r)//2 L = max_interval(A, l, m) R = max_interval(A, m+1, r) #가운데 최대값 구하기 bigLeft =0 sumLeft =0 sumRight=0 bigRight=0 for i in range(m, l-1,-1): sumLeft+=A[i] if(sumLeft&gt;bigLeft): bigLeft=sumLeft for j in range(m+1, r+1, 1): sumRight+=A[j] if(sumRight&gt;bigRight): bigRight=sumRight M = bigRight+bigLeft return max(L, M, R) 이 방식은 T(n) = 2T(n/2)+ cn 이므로 ,O(n log n) 다이나믹 프로그래밍으로 풀기일단 다이나믹 프로그래밍을 풀기 위해 4가지 단계를 기억하자. 큰 문제를 작은 문제로 분할한다.(해를 분석하라는 의미!) 큰 문제의 해가 작은 문제 해 점화식으로 표현 dp테이블에 작은 문제의 해를 차근차근 저장 정확성을 증명. === 이 네가지 단계로 최대 구간 합 문제를 풀어보자 A[k]로 끝나는 최대 구간의 값은? A[k] + A[k-1]로 끝나는 최대구간합!!즉 T(k) = T(k-1)+A[k] 이제 dp테이블 S에 해를 저장해보자.S[k] = max(S[k-1]+A[k], A[k])이고,S[0] = A[0] 123456def max_interval_DP(A): S = [0] * len(A) S[0] = A[0] for k in range(1,n): S[k]=max(S[k-1]+A[k], A[k]) return max(S) 이 알고리즘은 O(n) 밖에 안된다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"10. Merge 정렬 알고리즘","slug":"cs/algorithm/theory/al10","date":"2021-08-05T04:05:18.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/05/cs/algorithm/theory/al10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/theory/al10/","excerpt":"","text":"Merge 정렬 알고리즘퀵 소트가 피벗을 어떻게 선택하냐에 따라 속도가 달라지는 단점을 상쇄하는 알고리즘 배열은 반으로 나눠 재귀적으로 정렬하고 정렬된 두 배열을 원소 하나씩 비교해서 병합하는 방식.주어진 배열만큼 새로운 배열을 사용해야 하기 때문에 not in-place 알고리즘이다. 먼저 중간 인덱스를 찾는다. 중간 인덱스를 기준으로 나눠서 두 배열을 재귀적으로 정렬한다. 정렬된 두 배열의 첫 요소부터 하나씩 서로 비교해서 더 작은 값은 새로 만든 배열에 추가한다. 추가된 요소의 배열은 다음 인덱스로 넘어가고, 다시 각 배열의 원소 하나와 비교한다. 어느 한쪽의 배열이 모두 비교될 때까지 반복한다. 어느 한쪽 배열이 모두 새 배열에 추가되고 나면, 다른 쪽의 배열을 다 새 배열에 추가한다. 원래 배열의 내용을 새 배열의 내용으로 덮어쓴다.1234567891011121314151617181920212223def merge_sort(A, first, last): #1.~2. if first &gt;= last : return middle = (first+last)//2 merge_sort(A,first, middle) merge_sort(A, middle+1, last) #3.~5. B = [] i = first j = middle+1 while i &lt;= middle and j &lt;= last: if A[i] &lt;= A[j]: B.append(A[i]) i+=1 else: B.append(A[j]) j+=1 #6.~7. for i in range(i, middle+1): B.append(A[i]) for j in range(j, last+1): B.append(A[j]) for k in range(first, last+1): A[k] = B[k-first] 수행시간T(n) = 2*T(n/2) + cn = O(n log n) 상황에 관계 없이 성립하므로, 퀵 소트보다 좋다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"7. 프로세스 상태와 스케줄러 알고리즘의 관계","slug":"cs/os/os7","date":"2021-08-04T08:19:51.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/04/cs/os/os7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/os/os7/","excerpt":"","text":"멀티 프로그래밍과 waitwait : 프로세스가 실행 중임에도 불구하고 cpu를 사용하지 않고 기다리는 시간멀티 프로그래밍은 wait 때문에 발생하는 비효율을 줄이는 스케쥴링 알고리즘!그렇다면 이렇게 효율적으로 하기 위해서는 어떻게 해야할까?어떤 시점에 어떤 프로세스를 실행시켜야 될지 판단해야 하는데.. 이때 중요한게 프로세스 상태다!프로세스 상태 running state : 현재 cpu의 실행하고 있는 상태 ready state : cpu 실행 가능 상태(대기 상태) block state : 특정 이벤트 발생 대기 상태(wait 상태) exit state : 프로세스가 활용한 리소스를 해제하고 종료하는 상태 특정 이벤트를 대기(block) 특정 이벤트를 확인후 준비 상태로 변환(ready) 스케쥴려가 해당 프로세스를 선택해 실행 상태로 전환(running) 특정 시간동안 실행하고 다른 프로세스를 실행시키기 위해 다시 준비 상태로 전환(ready) 하지면 여전히 CPU가 어떤 프로세스를 실행시켜야 할 때 상태 정보만으로는 부족하다! state queue 도입이를 위해 state queue를 도입한다.ready state queue, running state queue, block state queue를 만들어서 한 단위 시간에 많은 요청이 왔을 때, 이 요청들을 ready state queue에 넣고,그 중 먼저 하나를 빼와서 running state queue에 넣는다. 하지만 어떤 프로세스가 한 단위 시간에 다 끝나지 않는 경우가 있다.그렇다면 그 프로세스는 running 큐에 들어가고 나서 또 다시 ready 큐에 새롭게 삽입된다.(시식코너에서 한입하고 다시 줄서는 느낌..) 반면, running 도중, wait 상태에 들어간 프로세스는 block queue로 따로 빼서 관리한다.block에 있던 프로세스는 해당 wait이 끝나면, 다시 ready queue로 들어간다. 만약 프로세스들이 완료되거나, block 상태에 있다면, cpu는 ready queue에서 pop할 수 없다.이 상태를 cpu idle 상태라고 한다!. state queue 대신 우선순위 기반으로 할 경우 FIFO가 아닌 다른 방식(프로세스 간 우선순위에 따라)으로 진행될 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"9. Quick 정렬 알고리즘","slug":"cs/algorithm/theory/al9","date":"2021-08-04T06:10:36.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/04/cs/algorithm/theory/al9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/algorithm/theory/al9/","excerpt":"","text":"퀵 정렬 알고리즘이론적으로는 빠르지 않지만(O(n^2)), 실제로는 가장 빠른 정렬 알고리즘quick selection과 비슷한 원리임. not in-place quick sort algorithm 어떤 list A를 퀵 정렬 하려면… 피벗을 A[0]으로 잡고, S,M,L 세가지 배열을 선언함 A에 있는 모든 수들이 피벗보다 크면 L, 작으면 S, 같으면 M에 append =&gt;n-1번 비교 재귀적으로, quickSort(S)+M+quickSort(L)을 반환하면 끝이다. 123456789def notInPlaceQuickSort(A): if len(A)&lt;=1: return A pivot = A[0] S, M, L = [], [], [] #1. for x in A:#2. if x&lt; pivot : S.append(x) elif x&gt;pivot: L.append(x) else M.append(x) return notInPlaceQuickSort(S)+M+notInPlaceQuickSort(L)#3. 실행 시간은 T(n)= T(S)+T(L)+cn#여기서 cn은 n-1번 비교를 상수번 했다는 의미. 최악의 경우는 S, L 중 하나가 0이 되는것.T(n)=T(n-1)+cn = O(n^2) =&gt; 이렇게 될 확률이 낮다! 최선의 경우는 S, L이 균등하게 나뉘는 것T(n) = T(n/2)+T(n/2)+cn = O(n*log n) =&gt; 평균적으로 이렇게 시간이 걸림! 그런데, 지금 하는 방식은 배열을 복사해서 하는 방식. 즉 not in-place이다.in-place quick sort algorithm 다른 방식으로 구현해보자. 인수로 배열 A와, 퀵소트할 첫 인덱스와 끝 인덱스를 전달한다. quickSort(A, first, last) 새로운 배열을 사용하지 않고, A 안에서 분류하기 위해 left, right 변수를 도입한다. left는 가장 왼쪽 값(피벗을 제외한), right는 가장 오른쪽 값을 가르킨다. left, right = first+1, last left가 가르키는 수가 피벗보다 더 작으면 다음 수로 넘어간다. right는 가르키는 수가 피벗보다 더 크면 이전 수로 넘어간다.(이때 같은 경우도 넘어간다.) 이제 두 변수가 멈췄고, left가 right보다 작거나 같다면 두 수가 가르키는 값을 바꾼다 이제 left가 right보다 클 때까지 다시 4-6번을 진행한다. 이제 first+1 ~ right은 S가 되고, left ~ last는 L이 된다. 이제 S와 L 사이에 피벗을 집어넣으면 SML 분리가 끝난다. 이제 S와 L을 재귀적으로 퀵소트하면된다. 12345678910111213141516171819def quickSort(A, first, last): #1.~3. if first &gt;= last : return left, right = first+1, last pivot = A[first] #4.~7. while left &lt;= right: #7. while left &lt;= last and A[left]&lt;pivot: #4. left +=1 while right &gt; first and A[right] &gt;=pivot: #5. right -=1 if left &lt;= right: #6. A[left], A[right] = A[right], A[left] left += 1 right -=1 #8.~10. A[first], A[right] = A[right], A[first] quickSort(A, first, right-1) quickSort(A, right+1, last)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"8. 기본 정렬 알고리즘","slug":"cs/algorithm/theory/al8","date":"2021-08-04T04:56:38.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/04/cs/algorithm/theory/al8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/algorithm/theory/al8/","excerpt":"","text":"파이썬에서 제공하는 정렬 123A = [3,1,2,-5]A.sort() #[-5,1,2,3]A.sort(reverse = True) #[3,2,1,-5] 정렬 알고리즘의 두 가지 특성 stable vs unstable만약 [2,5,2,7]을 오름차 정렬했을 때 ,[2,2,5,7]로 정렬이 될 텐데, 이 두 개의 2가 입력 순으로 정렬되면 stable하다고 한다.(첫번째 2가 정렬해도 첫번째 2가 되는지) in-place vs not in-place상수 개의 변수를 사용하는지 여부를 말한다.추가 메모리 사용을 O(1) 사용하는 in-place 알고리즘이고, O(n)이면 not in-place이다. 정렬 알고리즘을 만들 때, stable &amp; in-place를 추구해야 한다. 간단하지만 느린 알고리즘 : 기본 알고리즘n-1번의 라운드를 통해 일일히 비교해 자리 바꾸는 방식의 알고리즘selection, bubble, insertion 이 있다. selection 매 라운드마다 정렬되지 않은 수 중 가장 큰 값을 찾는다. 그 값을 정렬되지 않은 수 중 가장 끝 수와 swap한다. 이 과정을 n-1번 한다. n*(n-1)/2 비교 + (n-1) 교환 1234def selection_sort(A,n): for i in range(n-1, 0, -1): m = A.index(max(A[0:i+1])) #정렬되지 않은 수 중 가장 큰 값의 인덱스 A[i], A[m]=A[m], A[i] bubble 매 라운드마다 맨 뒤부터 두 개의 수를 비교하여, 앞 수가 뒷 수보다 크면 둘을 swap한다. 이 비교를 끝까지 하면, 가장 작은 수는 맨 앞으로 가게 된다. 이 과정을 n-1번 한다. n*(n-1)/2 비교 + n*(n-1)/2 교환 12345def bubble_sort(A,n): for i in range(n): for j in range(n-1, i, -1): if A[j-1] &gt; A[j]: A[j-1], A[j] = A[j], A[j-1] insertion 맨 처음에는 앞 두개를 비교해서 정렬한다. 그 다음 라운드부터는 다음 수와 앞에 정렬한 수들과 비교해서 해당 수가 들어가야할 자리를 찾아 사이에 넣는다. 이런식으로 하면 처음에는 2개의 수가 정렬, 그 다음엔 3개의 수, 4개의 수…. 이 과정을 n-1번 한다. n*(n-1)/2 비교 + n*(n-1)/2 교환 123456789def insertion_sort(A,n): for i in range(1,n): m=0 for j in range(i-1, -1, -1): if A[j]&lt;A[i]: m=j+1 break for k in range(i, m, -1): A[k], A[k-1] = A[k-1], A[k] 이 세 알고리즘 모두 O(n^2)!모두 in-place하고, selection만 unstable하다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"10. 최단경로 알고리즘(벨만포트, 다익스트라)","slug":"cs/datastructure/ds10","date":"2021-08-03T10:52:04.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/08/03/cs/datastructure/ds10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/03/cs/datastructure/ds10/","excerpt":"","text":"최단 경로 알고리즘아주 중요한 그래프 문제.엣지에 가중치가 부여된 상황에서 특정 노드에서 다른 노드로 가는 최적의 경로를 찾는 문제. 특징 노드 s에서 v까지 최단 경로 중 엣지(u, v)가 포함되면, 이 경로에서 s부터 u까지 부분도 역시 최단 경로다.M(v)를 s에서 v까지 최단 경로라고 길이라고 하면,M(V) = M(u)+min(u,v) 인 셈이다! (DP식과 비슷하다?) 벨만포드 알고리듬relax라는 연산을 배워보자. 아주 중요하다! d[v] : M[v]를 저장하기 위한 배열 (무한대로 초기화)p[v] : s-v최단 경로에서 v직전에 오는 노드를 저장하기 위한 배열 1234def relax(u,v): if d[v] &gt; d[u] + cost(u,v): d[v] = d[u] + cost(u,v) p[v] = u 모든 노드 v에 대해 d[v]가 최단경로(M[v])를 저장할 때까지 relax를 반복! 만약 d[u] = M[u]일때, 엣지 (u, v)에 대해 relax 함수를 호출하면, d[v] = M[v]가 된다! 이런 식으로 하나하나 relax 해가면 어떤 특정 노드까지 최단 경로를 찾을 수 있다! 벨만 포드 알고리즘 psuedo code 123456def Bellamn-Ford(G = (V, E)): d = [inf]*n, d[s]=0 for i in range(1,n): for each edge e = (u, v): #매번 엣지마다 relax(u,v) return d (n-1) * all edges…벨만포드는 O(nm)=O(n^3)의 복잡도를 가진다. 다익스트라 알고리듬다익스트라 알고리즘에서는 현재까지 d[v]값 중 최소 값을 고르면 d[v] = M(v)이다.(greedy)d[v]가 결정되고 나서 인접한 이웃노드들에게 relax하면 그들의 d값도 다 갱신될 수 있다! 모든 d[v] 중 최소 값이 매번 필요하므로, minHeap, 즉 최소값이 최상단노드가 되는 힙이 필요하다!minHeap에는 deleteMin과 decreaseKey 연산이 필요하다. deleteMin: 말 그대로 힙의 최상단 노드를 제거하고 다시 힙정렬하는 연산 decreaseKey : 힙의 어떤 노드의 키값을 변경(인하)하고 힙정렬하는 연산 다익스트라 알고리즘은 각 노드까지 최단 경로 중 가장 작은 값을 제거 가장 작은 값의 노드 이웃노드를 상대로 벨만 포트 식 진행 이웃 노드들의 값이 달라지면 반영.(물론 더 작아진 경우만 반영) 모든 노드가 힙에서 사라질 때까지 다시 1번부터 반복 psuedo code로 구현해보자. 123456789101112131415def Dijkstra(G): n, m = numbers of nodes and edges of G s = source node, simply 0 d = [0, inf, inf, ... inf] parent = [0, None, None, ... , None] H = make_heap(nodes v of G with key d[v]) while len(H): #heap에 아무것도 없을때까지. u = H.deleteMin() #heap의 최상위 노드, 즉 최소값 제거 for each v adjacent to u : #최소값 갖는 노드와 인접한 노드 v if(u, v) is an edge of G: if d[u]+cost(u,v)&lt; d[v] : #벨만포트 식! d[v] = d[u] + cost(u, v) parent[v] = u H.decreaseKey(v, d[v]) # 값을 수정시키고 힙의 위치 알맞게 조절 return dist, parent 다익스트라 알고리즘의 수행시간?make_heap : n* insertwhile loop : n * deleteMinfor loop : m * decreaseKey=&gt; 어떤 힙을 쓰느냐에 따라 다르다! minHeap = O((n+m)log n)!FibonacciHeap = O(n log n + m) All to All shortest Path problem지금까지는 source to All 최단 경로를 구하는 알고리즘이었다. 이젠 모든 노드쌍에 대해 최단 노드를 구해보자. for each node s in V: Dijkstra(s) = O(다익스트라 연산 * n)= O(n * m * log n) =O(n^3) DP 방법. Floyd-Warshell 알고리즘 Floyd Warshell 알고리즘sp(a, b) = 노드 a, b의 최단 경로이고, d(a,b)는 해당 경로의 최단 경로 비용이라고 할 때, sp(i,j) = sp(i,k) + sp(k,j) 이므로,d(i,j) = d(i,k) + d(k,j)가 성립한다! =&gt;DP식! px(a, b)를 px(a, b) = p(x-1)(a, x)+p(x-1)(x, b)를 만족하는 중간 노드 값 x에 대한 식이라고 하면,pn(a, b) = p(n-1)(a, n) + p(n-1)(n, b)즉 dn(a, b) = d(n-1)(a, n) + d(n-1)(n, b) 혹은 d(n-1)(a,b). 이 두 값 중 최솟값이 되겟다. 이 식을 기반으로 n이 0일때, 1일때 dp테이블을 작성해 나아간다. 이를 간단하게 구현하는 과정을 설명하자면 d를 표현하기 위한 2차원 리스트(n*n)를 무한대로 초기화해서 선언 d 초기에는 만약 (i,j)가 엣지가 존재하면 d[i,j]를 해당 엣지 가중치로 할당 for k in range(1,n+1)로 4번을 루프 돌린다. 모든 (i,j)에 대해 d[i][j] = min(d[i][j], d[i][k]+d[k][j]) 이 과정을 마치고 나면 (i,j)에 대해 최소 경로를 얻을 수 있다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"9. 그래프","slug":"cs/datastructure/ds9","date":"2021-08-03T05:46:26.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/08/03/cs/datastructure/ds9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/03/cs/datastructure/ds9/","excerpt":"","text":"그래프G = (V, E)V = vertex set, E = edge set동그라미가 버택스(혹은 노드), 버택스를 잇는 링크를 엣지라 한다. degree(분지수) 어떤 노드의 이웃한 노드 갯수.어떤 그래프의 분지수는 그 그래프의 최대 분지수를 말한다. 인접하다는 의미는 두 노드가 링크로 서로 연결 되어있는 상태를 말한다. 경로는 노드를 중복하지 않고 지나가는 행위사이클은 노드를 중복하지 않고 출발점으로 다시 돌아오는 경로. 표현법인접행렬 : 노드 i 와 j에 엣지가 존재하면 G[i][j]=1(혹은 가중치), 없으면 0인접 리스트 : 1차원 배열 G로 표현, 노드 i에 인접한 노드들은 G[i]에 연결리스트로 표현 노드 갯수 = n, 엣지 갯수 = m일 때, 인접행렬O(n^2)만큼 메모리 사용.탐색은 O(1)인접한 모든 노드를 보려할때 O(n) 이때 인접노드가 많던 적던 모두 찾음노드 삽입은 O(1)노드 삭제는 O(1) 인접리스트O(n+m)만큼 메모리 사용.탐색은 O(n)인접한 모든 노드를 보려할때 O(n) 이때 인접노드가 적으면 연산도 짧아짐.노드 삽입은 O(1)노드 삭제는 O(n) 대부분 인접행렬은 상수 시간에 연산을 완료한다. 메모리 측면은 인접리스트가 유리하다. 그래프 순회그래프에는 DFS(깊이 우선 탐색), BFS(너비 우선 탐색) 두가지 방법이 존재한다. DFS방문한 노드와 연결된 이웃 노드 중 아직 방문하지 않은 노드가 있으면 그 노드를 다음에 방문.만약 안가본 노드가 없다면 방문하기전 노드로 가서 다시 검사한다.재귀함수로 작성하는게 일반적. 이런 그래프에서 a부터 알파벳 순서가 빠른 노드부터 방문한다고 하면A-B-D-F-E-C-G pseudo code로 이해해보자 123456789101112131415def DFS(V): mark V as visited node #visited[V] = True pre[V] = curr_time #record the first visiting time curr_time +=1 for each edge(V, W): #for all neighbor node if w is unmarked: parent[W] = V DFS(W) post[V] = curr_time #V에서 DFS완료된 시간 curr_time+=1def DFSALL(G): for all nodes in G: mark[V]= unvisited for all nodes V: if mark[V]!=visited :DFS(V) pre는 해당 노드에 처음 방문한 시간, post는 해당 노드에서 DFS가 완료된 시각(모든 이웃을 이미 방문).parent 리스트를 활용해서 트리 모양으로 그래프를 표현할 수 있다. 재귀를 사용하지 않고 스택을 통해 구현할 수 있다. 12345678910def DFS(s): #s 부터 DFS시작. stack.push((None, s)) #(부모노드, 현재 방문노드) 튜플을 추가 while stack is not empty: p, v = stack.pop() if v in unmarked: mark[v]= visited parent[v] = p for each edge(v, W): if w is unmarked: stack.push((v,w)) 노드의 엣지가 방향성을 갖는 방향 그래프도 알아두자 BFSBFS는 루트노드-루트의 이웃 - 이웃의 이웃… 이런 식으로 level by level로 방문한다.queue 자료구조로 비재귀 코드로 작성하는게 일반적이다.이런 그래프에서 방문 순서는 다음과 같다(A)-(B-C-E)-(D-F-G) psuedo code로 보자 1234567891011121314151617def BFS(G = (V,E)): #node 0에서 시작. #n은 노드의 갯수 visited = [False]*n parent = [-1]*n dist = [0]*n Q = Queue() for all source node s in G: Q.enqueue(s) while Q is not empty: v = Q.dequeue() #dequeue는 방문을 의미 visited[v] = True for each edge v.neighbor w: if no visited[w]: Q.enqueue(w) parent[w] = v dist[w] = dist[v] +1 출발 노드에서 다른 노드 v까지의 최단 경로 길이는 dist[v]에 저장.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"8. 균형이진탐색트리","slug":"cs/datastructure/ds8","date":"2021-08-02T12:09:55.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/08/02/cs/datastructure/ds8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/02/cs/datastructure/ds8/","excerpt":"","text":"균형이진탐색트로(BST)?이진트리는 search, insert, delete 연산들이 O(h) 시간이 걸린다는 걸 기억하자. 즉 이 연산들을 효율적으로 하려면 트리의 높이를 최소화해야 한다.이진트리에서 빼곡히 노드를 채워넣어 높이를 최소로 하면 대략 log n 정도가 되는데,균형이진탐색트리는 노드를 최대한 채워넣어 높이를 log n이 되도록 유지하는 자료구조다! 트리의 높이를 최소화하는 rotation 회전 연산 한쪽의 서브트리가 지나치게 아래로 치우쳐져있으면,해당 서브트리에서 반대쪽 서브트리로 회전을 시켜서 전체 트리 높이를 낮춘다. 12345678910111213141516171819202122def rotateRight(self, z): # left도 가능, z가 최상위 노드 x가 올라가는 노드 if not z = return x = z.left if x == None:return #이런 경우, left로 회전해야... b = x.right x.parent = z.parent #x를 맨위 노드로... if z.parent: #만약 z의 부모가 존재하면 부모와의 관계를 x로 다 바꿈 if z.parent.left == z: z.parent.left = x else: z.parent.right = x if x: x.right = z #최상위 노드가 x가 됐으니, 이제 z와 x의 관계를 설정 z.parent = x z.left = b #x의 오른쪽 서브트리가 z의 왼쪽 서브트리가 됨 if b : b.parent = z #b와 z의 관계를 새롭게 설정 #만약 z가 루트노드인 경우. if z == self.root and z != None: sefl.root = x AVL 트리균형이진트리의 일종. 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1 이하인 이진탐색트리 AVL 트리에서 삽입/삭제하면, 서브트리 높이 차가 1보다 커지는 경우 발생 가능.. 이럴 경우, 회전연산을 통해 높이를 다시 맞춰야 함.(rebalance) AVL은 BST의 일종이므로, BST의 Node 클래스에 height를 추가한 노드 클래스를 사용한다. class AVL(BST): #상속 def insert(self,key): v = super(AVL, self).insert(key) # BST클래스의 insert 함수 호출 삽입 insert(key) v = super(AVL, self).insert(key) 로 BST에서 정의한 insert를 실행 삽입연산에 따라 균형이진탐색트리의 균형이 무너졌을 경우, 삽입 위치부터 올라가며, 무너진 곳을 순서대로, x y z로 함. 트리의 균형을 맞추는 rebalance연산을 실행하고 원래 z의 자리에 올 노드를 w로 하자. rebalance 연산은 x y z의 형태에 따라 달라짐. 만약 w가 루트노드라면, self.root=w을 해주자. 결과적으로 O(log n)이다. 삭제 delete(u) v = super(AVL, self).deleteByCopying(u) 이때 삭제연산은 삭제하고 나서 삭제된 노드의 부모를 반환한다. v가 None이 될 때까지 루프. 만약 v가 균형이 깨지지 않았다면, v의 부모노드가 v가 된다. 만약 v가 균형이 깨진다면, v 위치 노드를 z로 하고, z의 자식 중, 깊이가 더 큰 쪽 노드를 y, y의 자식 중 깊이가 더 큰 쪽 노드를 x라 한다. 이제 rebalance 연산을 한다. x&lt;\\y&lt;\\z 일 경우 로테이션 한번, x&gt;y&amp;&amp;z&gt;y일 경우 로테이션 두번 한다. 6. 로테이션 후, 원래 z의 위치에 오는 노드를 v라 한다.7. 이제 v의 트리는 균형을 성공했지만, v의 부모 노드로 가서 동일한 과정을 해야 한다.8. w = v, v=v.parent로 하여 w는 v의 자식 노드가 되고, v는 위쪽으로 한칸 가서 동일한 작업을 한다. 결과적으로 최약의 경우에는 회전연산(상수시간)을 log n번 하게 되어, O(log n)이다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"병렬 데이터 처리와 성능","slug":"java/modern-java-in-action/modern7","date":"2021-08-01T05:43:01.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/08/01/java/modern-java-in-action/modern7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/01/java/modern-java-in-action/modern7/","excerpt":"","text":"병렬 스트림컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다. 예시만약 n을 입력받아 1부터 n까지 합계를 구하는 메서드를 구현한다고 하자. 12345678910111213public long sequentialSum(long n)&#123; return Stream.iterate(1L, i-&gt;i+1) .limit(n) .reduce(0L, Long::sum);&#125;//이걸 병렬로 처리하려면? 아주 간단하다!!!!!public long parrallelSum(long n)&#123; return Stream.iterate(1L, i -&gt; i+1) .limit(n) .parallel() //병렬 스트림!! .reduce(0L, Long::sum);&#125; parallel메서드는 순차 스트림을 병렬 스트림으로 만들고,sequential메서드는 병렬 스트림을 순차 스트림으로 만든다. 근데 이 두 메서드는 마지막으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.파이프라인에 parallel, sequential parallel 이렇게 마구잡이로 써도, 결국 가장 마지막에 나온 메서드가 병렬/순차를 결정한다. 하지만 병렬 스트림을 사용한다고 무조건 성능이 좋을까? 병렬 스트림이 오히려 순차 스트림보다 성능이 별로 좋아지지 않는 경우가 있다.위 예시도 실제로 돌려보면, 일반적인 반복문 버전, 순차적 스트림 버전, 병렬 스트림 버전 이렇게 세가지를 비교하면,반복문이 제일 빠르고, 순차적 스트림, 병렬 스트림 순이다. 왜 그럴까?일반적 반복문은 저수준으로 동작하고, 기본값을 박싱언박싱을 할 필요가 없어서 더 빠르다.그렇다면 같은 스트림이더라도 왜 병렬이 더 느렸는가? 이는 두가지로 요약된다. 반복 결과로 박싱된 객체가 만들어지는데, 숫자를 더하려면 매번 언박싱을 해야함. 반복 잡업은 병렬로 수행할 수 있는 독립 단위로 나누기 어렵다. 즉 해당 연산을 할 스트림 요소가 얼마나 되는지 컴퓨터는 모르니, 이를 청크로 나눌 수 없다는 의미다. 더 특화된 메서드 사용예를 들어 LongStream.rangeClosed 메서드를 사용하면 iterate 메서드에 비해 두가지 장점을 가진다. 기본형 long을 사용하므로 박싱언박싱 오버헤드가 사라짐. rangeClosed는 쉽게 청크로 분할할 수 있는 숫자 범위 제공한다. 즉 이런 예시를 보면 알 수 있듯이, 병렬화는 공짜가 아니다!효과적인 병렬화를 이뤄낼려면, 스트림을 재귀적으로 분할해야 하고, 각 서브 스트림을 서로 다른 스레드 리듀싱 연산으로 할당하고, 이 결과를 하나의 값으로 합쳐야 한다. 게다가 코어 간 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 설계해야 한다. 병렬 스트림의 올바른 사용법자 일단 기존의 방식대로 명령형 프로그래밍 방식으로, n까지 자연수를 더하면서 공유된 누적자를 바꾸는 프로그램이다. 12345678910public long sideEffectSum(long n)&#123; Accumulator accumulator = new Accumulator(); LongStream.rangeClosed(1, n).forEach(accumulator::add); return accumulator.total;&#125;public class Accumulator&#123; public long total = 0; public void add(long value)&#123; total += value;&#125;&#125; 위 코드를 병렬적으로 처리한다면, 큰일난다.공유된 total 변수에 다수의 스레드가 동시에 데이터에 접근하는 데이터 레이스 문제가 발생할 수 있다.즉 병렬 스트림과 병렬 계산을 사용할 때는 공유된 가변 상태를 피해야 한다. 올바른 병렬 스트림을 위한 지침 박싱을 주의하라(자바 8부터 제공하는 IntStream, LongStream, DoubleStream을 애용하자.) 요소의 순서에 의존하는 연산은 병렬 스트림이 효과적이지 않다.(limit, findFirst 등.. 요소가 상관없다면 unordered로 비정렬 스트림으로 하자) 만약 한 요소 당 연산 비용이 높아지면, 병렬 스트림이 효과적이다. 소량 데이터는 병렬 스트림이 효과보기 힘들다. 스트림을 구성하는 자료구조가 적잘한지 확인하라.(모든 요소를 손쉽게 파악할 수 있는 ArrayList가 LinkedList보다 유리하다.) 스트림의 특성과 중간 연산에 따라 분해 과정 성능이 달라진다.(중간연산에서 스트림을 분해하는 경우, 병렬처리가 더 손쉬워진다.) 최종 연산의 병합 과정 비용이 높으면, 병렬 스트림에서 얻은 이익이 각 서브스트림의 최종 연산 병합에서 상쇄된다. 포크/조인 프레임워크포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음,서브 태스크 결과를 합쳐서 전체 결과를 만들도록 설계됐다.서브태스크를 스레드 풀의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"인스턴스 생성과 힙 메모리","slug":"java/java-basic/java2","date":"2021-07-30T11:24:44.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/07/30/java/java-basic/java2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/java2/","excerpt":"","text":"인스턴스클래스는 객체의 속성을 정의하고 기능을 구현하여 만들어놓은 코드 상태. 이 클래스를 기반으로 new 키워드를 사용하여 인스턴스를 생성. 힙 메모리생성된 인스턴스는 **동적 메모리(heap memory)**에 할당된다. c/cpp에서는 프로그래머가 직접 사용한 메모리를 해제해줘야 하지만 자바는 garbage collector가 주기적으로 사용하지 않는 메모리를 수거 스택에서 지역변수로 선언된 레퍼런스(참조변수)가 new 키워드를 사용하면 힙에 인스턴스가 할당되고, 레퍼런스가 인스턴스를 가리키게 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"함수와 메서드","slug":"java/java-basic/java1","date":"2021-07-30T10:41:02.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/07/30/java/java-basic/java1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/java1/","excerpt":"","text":"함수 호출과 메모리1234567891011public static int add(int num1, int num2)&#123; int result; result = num1 + num2; return result;&#125;public static void main(String[] args)&#123; int n1 = 20; int n2 = 10; int total = add(n1, n2);&#125; 이런 식으로 코드가 짜여 있을 때, 스택 메모리에는 어떤 일이 생길까?? 일단 스택 메모리에 main함수가 놓이게 된다.그러면 main함수의 지역변수 n1,n2,total이 놓이게 되는데, 이때 add함수가 호출된다. add함수가 호출되면, main 함수 위에 add함수가 놓이게 되어 add 함수의 지역변수가 호출된다.(num1, num2, result) 스택 메모리이므로 나중에 들어온 add함수를 먼저 해결하고, main함수로 돌아가 마저 마무리하게 된다. 함수와 메서드의 차이?함수는 어디에 속하지 않은 함수. 메서드는 클래스에 속한 함수로 생각하자.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[]},{"title":"web 개론","slug":"cs/web/web1","date":"2021-07-30T06:02:27.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/07/30/cs/web/web1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/web/web1/","excerpt":"","text":"웹의 기본 3가지 요소 URI Uniform Resource Identifier. 리소스 식별자다양한 정보에 접근할 수 있는 정보 HTTP Hypertext Transfer Protocol어플리케이션 컨트롤GET, POST, PUT… HTMLHyper Text Markup LanguageXML 바탕으로 한 범용 문서 포맷.브라우저가 사용자가 볼 수 있는 형태로 표현. REST(자원의 상태 전달) - 네트워크 아키텍처 Client, Server : 클라이언트와 서버가 서로 독립적이고 분리 Stateless : 요청에 대해서 클라이언트의 상태를 서버에 저장하지 않음 Cache : 클라이언트는 서버 응답을 임시저장(cache로)할 수 있어야 함. 클라이언트가 캐시를 통해 응답 재사용이 가능해야 하고, 이를 통해 서버 부하를 낮춰야 함 계층화 : 서버와 클라이언트 사이에, 방화벽, 게이트웨이, 프록시 등 다양한 계층 형태로 구성되어야 함. 인터페이스 일관성 : 인터페이스가 일관성 있어야 하고, 아키텍처를 단순화시켜 작은 단위로 분리하여 클라이언트, 서버가 독립적으로 개선할 수 있어야 한다. Code on Demand(optional) : 특정한 기능을 서버로부터 클라이언트가 받아 코드를 실행할 수 있어야 한다. 인터페이스의 일관성을 잘 지켰느냐에 따라 REST를 준수했는지 판단 자원 식별리소스에 접근할 때 사용되는 URI에 자원을 식별하는 내용이 있어야 한다. 메시지를 통한 리소스 조작리소스를 조작할 때, 데이터 전체를 전달하지 않고, 메시지로 전달해야 한다. 자기 서술적 메시지요청하는 데이터가 어떻게 처리되야하는지 충분한 내용을 드러내야한다. 애플리케이션 상태에 대한 엔진으로써 하이퍼미디어REST API를 개발할 때 단순히 클라이언트 요청에 대한 데이터만 응답하는게 아닌, 관련된 리소스에 대한 링크 정보도 같이 포함해야 한다. URI URI vs URLIdentifier vs LocatorURI : 인터넷 특정 자원을 나타내는 주소 값. 해당 값은 유일(응답은 달라질 수 있음)URL : 인터넷 상에서의 자원, 특정 파일이 어디에 위치하는지 식별하는 주소URL은 URI의 하위 개념 URI 설계 원칙(RFC-3986) 슬래시 구분자(/)는 계층 관계를 나타날 때 사용 URI 마지막 문자로 슬래스를 포함하지 않음 하이픈(-)은 가독성을 위해 사용 밑줄(_)은 사용하지 않음. 세션 ID를 포함하지 않음 메소드 명을 이용하지 않음 단수형보다 복수형 사용 컨트롤러 이름으로는 동사를 사용 경로 부분 중 변하는 부분은 유일한 값을 대체 CRUD 기능을 나타내는 것은 URI에 사용하지 않는다. URI Query Parameter 디자인(컬렉션의 결과 필터링 등) 서브 도메인은 일관성 있게 사용 클라이언트 개발자 포탈 서브 도메인을 일관성 있게 만듬 HTTP Protocolweb에서 데이터를 주고 받는 프로토콜.하이퍼텍스트 전송용 프로토콜로 정의되어 있지만 실제로는 JSON, XML, Image 등 여러 가지를 전송!TCP 기반으로 한 REST 특징을 모두 구현한 web기반 프로토콜! HTTP는 요청을 주고 받는 (Request, Response) 형태의 통신 방법! HTTP 메소드&nbsp;의미CRUD멱등성(몇번을 요청해도 같은 응답)안정성Path VariableQuery ParameterDataBodyGET리소스 취득RooooxPOST리소스 생성, 취득Cxxo?oPUT리소스 갱신, 생성C / Uoxo?oDELETE리소스 삭제DoxooxHEAD해더 데이터 취득&nbsp;oo&nbsp;&nbsp;&nbsp;OPTIONS지원하는 메소드 취득&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;TRACE요청메시지 반환&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;CONNECT프록시 동작이 터널 접속으로 변경&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *멱등성(여러번 요청한 값이 한번 요청한 값과 같음), 안정성(요청할 때 리소스에 영향을 주지 않음)","categories":[],"tags":[]},{"title":"6. 스케쥴링 알고리즘의 기본","slug":"cs/os/os6","date":"2021-07-30T05:59:10.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/30/cs/os/os6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/os/os6/","excerpt":"","text":"프로세스란?메모리에 올려져 실행 중인 프로그램은 프로세스라고 한다.프로세스는 작업, task, job과 혼용되어 사용한다. 하지만 응용프로그램 != 프로세스다.왜냐면, 한 응용프로그램에 여러 개의 프로세스로 이뤄져있을 수 있기 때문! 스케쥴러스케줄러는 프로세스 실행을 관리하는 녀석. RTOS(RealTime OS) 응용 프로그램 실시간 성능 보장을 목표로 한 OS 정확하게 프로그램 시작, 완료 시간을 보장! 공장, 공정 같은 곳에서 사용. GPOS(General Purpose OS) 프로그램 실행시간에 민감하지 않음. 일반적인 목적으로 사용됨 스케쥴링 알고리즘어느 순서대로 프로세스를 실행시킬지 정하는 알고리즘 시분할 시스템 : 프로세스 응답 시간을 가능한 짧게 멀티 프로그래밍 : CPU 활용도를 최대한 높여서 프로세스를 빨리 실행 CPU를 처음부터 끝까지 사용을 가정. (저장매체를 읽는다던지, 프린팅한다던지 작업 없이) FIFO 스케쥴러 가장 간단한 스케쥴러(배치 처리 시스템) 먼저 들어온 프로세스를 먼저 실행 큐 자료구조를 활용해서 구현 최단 작업 우선(SJF) 알고리즘 Shortest Job First 프로세스 실행시간이 짧은 프로세스 먼저 실행시키는 알고리즘 우선순위 기반 스케쥴러(Priority-Based) 정적 우선순위(프로세스마다 우선순위를 미리 지정) 동적 우선순위(스케줄러가 상황에 따라 우선순위를 동적으로 변경) Round Robin 스케쥴러 시간 단위마다 각 프로세스마다 돌아가면서 프로세스를 실행시키는 방법(시분할 시스템 기반) 자기 차례 이후에도 작업이 더 필요한 프로세스는 RoundRobin queue에 들어가 다시 자기차례가 오기를 기다린다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"5. 배치 처리, 멀티 태스킹, 멀티 프로세싱, 멀티 프로그래밍","slug":"cs/os/os5","date":"2021-07-30T04:41:36.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/30/cs/os/os5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/os/os5/","excerpt":"","text":"프로세스 스케줄링배치 처리배치 처리는 어플리케이션을 순차적으로 처리하는 방식이다. 마치 큐처럼 FIFO방식을 준수한다. 단점어떤 프로그램은 실행이 너무 오래 걸려서, 다른 프로그램이 실행될 때까지 많이 기다려야 하는 경우가 존재.동시에 여러 작업이 불가능하다.(동시성)여러 사용자가 한 컴퓨터를 사용할 때 비효율적이다.(다중 사용자 지원) 이런 단점을 극복하고자 멀티 프로그래밍, 시분할 시스템이 등장하게 된다. 시분할 시스템시간을 작은 단위로 쪼개서 프로그램마다 돌아가면서 할당받는 시스템.여러 사용자들이 한 컴퓨터를 사용을 원할하게 하는 시스템. 멀티 태스킹단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템.굉장히 짧은 시간마다 여러 응용프로그램이 돌아가면서 실행되서 사용자는 이를 눈치채지 못한다. 멀티 프로세싱멀티 태스킹 : 단일 cpu, 멀티 프로세싱 : 여러 cpu에서 하나의 응용 프로그램을 병렬로 실행 멀티 프로그래밍최대한 cpu를 일정 시간 당 많이 활용하도록 하는 시스템 시간 대비 cpu 활용도 향상 응용 프로그램을 짧은 시간안에 완료 가능! 응용 프로그램은 온전히 cpu를 쓰기보다, 다른 작업을 중간에 필요로 하는 경우가 많다 파일을 읽을 때 프린팅 할 때 핵심 여러 응용 프로그램 실행을 가능토록 함 응용 프로그램이 동시에 실행되는 것처럼 보이게 함 cpu를 쉬지 않고 응용 프로그램을 실행하게 함(짧은 시간에 실행 완료시킴) 컴퓨터 응답 시간도 짧게 해줘서 다중 사용자 지원함","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"스트림으로 데이터 수집","slug":"java/modern-java-in-action/modern6","date":"2021-07-30T00:49:07.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern6/","excerpt":"","text":"컬렉터란 무엇인가?일단 예시를 하나 보자. 123456789101112131415//통화별로 트랜잭션을 그룹화한 코드(명령형 버전)Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = new HashMap&lt;&gt;();for (Transaction transaction : transactions)&#123; Currency currency = transaction.getCurrency(); List&lt;Transaction&gt; transactionsForCurrency = transactionsByCurrencies.get(currency); if (transactionsForCurrency == null)&#123; transactionsForCurrency = new ArrayList&lt;&gt;(); transactionsByCurrencies.put(currency, transactionForCurrency); &#125; transactionsForCurrency.add(transaction);&#125;//함수형 버전Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream().collect(groupingby(Transaction::getCurrency)); 딱봐도 함수형 프로그래밍이 훨씬 쉽다.위 예제에서 collect 메서드로 Collector 인터페이스 구현을 전달했다.Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다. 컬렉터는 고급 리듀싱 기능을 수행한다. 스트림에 collect를 호출하면, 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행된다.collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다. 미리 정의된 컬렉터Collectors 클래스에서 미리 정의된 팩터리 메서드의 기능은 크게 세가지로 분류된다. 스트림 요소를 하나의 값으로 리듀스하고 요약. 요소 그룹화 요소 분할 이 세가지에 대해 더 알아보자. 리듀싱과 요약컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있었다.하나의 결과란 복잡한 다수준 그룹화 맵 일 수도, 그냥 평범한 정수 형태 일 수도 있다. counting()이란 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산해보자 123long howManyDishes = menu.stream().collect(Collectors.counting());//불필요한 과정을 제외하면,long howManyDishes = menu.stream().count() 요약 연산스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산을 요약 연산이라 부른다.물론 요약 연산에도 리듀싱 기능이 자주 사용된다. Collectors 클래스는 Collectors.summingInt라는 요약 팩토리 메서드를 제공한다.summingInt 인수로 전달된 함수는 객체를 int로 매핑하는 함수를 인수로 받는다.int로 매핑한 컬렉터를 collet 메서드에 전달되면, 요약 작업을 수행한다. 1int totalCalories = menu.stream().collect(summingInt(Dish::getCalories)); 이런 역할은 summingInt 뿐만 아니라,summingLong, summingDouble 등이 있다.합계를 구하는 과정 말고, 평균을 구하는 averagingInt도 가능하다 두 개 이상의 연산을 해야 되면..? summarizingInt가 반환하는 내용을 사용하면 된다!하나의 요약 연산으로 여러가지 연산값을 얻을 수 있다! 123IntSummaryStatics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));//출력 시.IntSummaryStatics&#123;count =9, sum = 4300, min=120, average=477.777778, max=800&#125; 문자열 연결컬렉터에 joining 팩터리 메서드를 사용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 만든다.joining 메서는 내부적으로 StringBuilder를 이용해 문자열을 하나로 만든다. 12345String shortMenu = menu.stream().map(Dish::getName).collect(joining());//만약 스트림 객체가 toString이 요구 대로 정의되어 있다면?String shortMenu = menu.stream().collect(joining());//문자열 사이에 쉼표를 넣어줄 수도 있다.String shortMenu = menu.stream().collect(joining(&quot;, &quot;)); collect와 reduce의 차이? 둘 다 비슷한 결과를 만들 수 있어서 어떤 것을 사용해야하는지 헷갈린다.collect 메서드는 결과를 누적하는 컨테이너로 바꾸도록 설계된 메서드이고,reduce는 두 값을 하나로 도출하는 불변형 연산이다! 그룹화분류 함수인 groupingBy 메서드를 활용해보자. 12Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType)); Dish 클래스의 Type을 키로 키에 맞는 스트림 요소들을 map에 담아 반환했다. 하지만 여러 가지 기준으로 그룹화하려면 어떨까..? 그룹화된 요소 조작고기, 생선, 그 외 음식들로 분류하고, 500칼로리가 넘는 음식을 얻으려면 어떻게 해야 할까? 123Map&lt;Dish, Type, List&lt;Dish&gt;&gt; caloricDishesByType = menu.stream().filter(dish-&gt;dish.getCalories() &gt; 500) .collect(groupingBy(Dish::getType)); 이 방식에는 치명적인 문제가 있다. 만약 생선류에 500칼로리가 넘는 음식이 없으면 아예 그 키를 없앤다는거다.출력하면 {OTHER=[french fries, pizza], MEAT=[pork, beef]}가 출력된다. groupingBy는 두번째 인수로 Collector를 가질 수 있도록 만들어 이를 해결한다.두번째 Collector 안에 필터 프레디케이트를 넣으면 된다.Collectors의 정적 팩토리 메서드 filtering메소드는 프레디케이트를 인수로 받아 리스트로 만든다. 1234Map&lt;Dish.Type, List&lt;Dish&gt;&gt; caloricDishesByType = menu.stream() .collect(groupingBy(Dish::getType, filtering(dish-&gt;dish.getCalories()&gt;500, toList()))); mapping메소드 사용 예시도 보자 123Map&lt;Dish.Type, List&lt;String&gt;&gt; dishNameByType = menu.stream() .collect(groupBy(Dish::getType, mapping(Dish::getName, toList()))); 이러면 이름을 기반으로 한 맵이 반환될 것이다. flatmapping메소드 사용 예시도 보자dishTags가 음식이름, 관련 문자열 리스트로 매핑된 맵이라고 했을 때, 1234Map&lt;Dish.Type, Set&lt;String&gt;&gt; dishNamesByType = menu.stream() .collect(groupingBy(Dish::getType, flatMapping(dish -&gt; dishTags.get(dish.getName().stream(),toSet())))); groupingBy 여러개를 연결해서 다수준 그룹화 123456789101112Map&lt;Dish.Type, Map&lt;Caloriclevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish-&gt;&#123; if (dish.getCalories()&lt;=400)s return CaloricLevel.DIET; else if(dish.getCalories()&lt;=700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;) )); 종류로 그룹화 칼로리로 DIET, NORMAL, FAT으로 그룹화이 과정을 버킷 개념으로 생각하면 편한다. 첫 그룹화로 한 버킷에 육류 음식들이 담기고, 그 버킷을 또 칼로리별로 여러 버킷으로 나눠 담았다! 분할분할은 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능.이런 분류 함수는 분할 함수라고 하는데, 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean이다.즉 분할 그룹화는 최대 두 개 그룹으로 나뉜다. 123Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(true); 분할은 참 거짓 두가지 요소 스트림 리스트를 모두 유지한다는 장점이 있다. 1234Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = menu.stream().collect( partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"다양한 형태의 스트림 만들기","slug":"java/modern-java-in-action/modern5","date":"2021-07-30T00:39:50.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern5/","excerpt":"","text":"숫자형 스트림reduce 메서드로 스트림 요소의 합을 구하는 사례를 보자 123int calories = menu.stream() .map(Dish::getCalories) .reduce(0, Integer::sum); 이런 경우, reduce에 박싱비용이 포함되어 있다. 합계를 계산하기 전에 Integer를 기본형으로 언박싱해야한다. 기본형 특화 스트림자바에서는 이런 박싱 비용을 피할 수 있도록 세 가지 기본형 특화 스트림을 제공한다. int 특화 IntStream double 특화 DoubleStream long 특화 LongStream 이런 특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련 있으며, 스트림에 추가 기능을 제공하지는 않는다. 숫자 스트림으로 매핑스트림을 특화 스트림으로 변환할 때는 mapToInt, mapToDouble, mapToLong 세가지 메서드를 주로 사용한다.이 메서드들은 기존의 map과 동일한 기능이지만, Stream 대신 특화된 스트림을 반환한다. 123int calories = menu.stream() .mapToInt(Dish::getCalories) .sum(); mapToInt 메서드가 각 요리에서 모든 칼로리를 추출하고(Integer), IntStream을 반환한다.따라서 IntStream이 제공하는 sum메소드를 활용할 수 있다. 숫자 스트림을 객체 스트림으로 복원하기숫자 스트림은 기본형의 값만 만들 수 있다. 만약 다른 값을 반환하려면 어떻게 해야 할까?boxed 메서드를 활용하면 특화 스트림을 일반 스트림으로 변환할 수 있다. 12IntStream intStream = menu.stream().mapToInt(Dish::getCalories);Stream&lt;Integer&gt; stream = intStream.boxed(); 기본값 : OptionalInt숫자 스트림에서 해당 조건에 만족하는 요소가 없는 경우와, 해당 조건에 맞는 요소가 0인 경우, 둘 다 0을 반환해서 혼동이 올 수 있다.그렇다면 이 두 가지 경우를 어떻게 해야 구분할 수 있을까? 바로 OptionalInt, OptionalDouble, OptionalLong으로 가능하다. 123OptionalInt maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max(); 이제 조건에 맞는 값이 없는 경우와 0이 반환되는 요소가 서로 구별 가능하므로 다음과 같은 기본값도 명시할 수 있다. 1int max = maxCalories.orElse(1); 숫자 범위 정하기 스트림에서 특정 범위의 숫자를 사용해야 되는 상황에서는 어떻게 해야 할까? IntStream과 LongStream에서는 range와 rangeClosed 두가지 정적 메서드를 제공한다.두 메서드 모두 첫 인수는 시작값, 두번째 인수는 종료값을 갖는다.range는 시작값과 종료값이 범위에 포함되지 않고,rangeClosed는 시작값과 종료값이 범위에 포함된다. 123IntStream evenNumbers = IntStream.rangeClosed(1, 100) .filter(n-&gt;n%2==0);System.out.println(evenNumbers.count()); 이 예시는 1~100까지 한정한 상황에서 필터로 짝수만 찾아 출력한 코드이다. 스트림 만들기컬렉션이나 숫자 뿐만 아니라 다양한 방식으로 스트림을 만들 수 있다.배열, 파일, 함수를 이용한 스트림을 알아보자 값으로 스트림 만들기 임의의 수들을 인수로 받는 정적 메서드 Stream.of를 이용해 스트림을 만들수 있다. 12Stream&lt;String&gt; stream = Stream.of(&quot;Modern&quot;, &quot;Java&quot;, &quot;Action&quot;);stream.map(String::toUpperCase).forEach(System.out::println); 또한 empty 메서드로 스트림을 비우거나 빈 스트림을 만들 수 있다. 1Stream&lt;String&gt; emptyStream = Stream.empty(); null이 될 수 있는 객체로 스트림 만들기 null을 가질 수 있는 객체는 null일 경우를 검사해서 빈 스트림을 반환해야 한다. 기존의 방식으로 null을 검사하면 다음과 같다 12String homeValue = System.getProperty(&quot;home&quot;);Stream&lt;String&gt; homeValueStream = homeValue == null ? Stream.empty() : Stream.of(value); 하지만 자바 9에서 지원하는 Stream.ofNullable을 이용해 다음과 같이 구현할 수 있다! 1Stream&lt;String&gt; homeValueStream = Stream.ofNullable(System.getProperty(&quot;home&quot;); flatMap과 사용하면 다음과 같은 코드도 가능하다! 12Stream.of(&quot;config&quot;, &quot;home&quot;, &quot;user&quot;) .flatMap(key-&gt;Stream.ofNullable(System.getProperty(key))); 배열로 스트림 만들기 정적 메서드 Arrays.stream를 통해 숫자 스트림이나 일반 스트림을 만들어낼 수 있다. 12int[] numbers = &#123;2,3,4,5,6&#125;;int sum = Arrays.stream(numbers).sum(); 파일로 스트림 만들기 java.nio.file.Files 의 많은 정적 메서드가 스트림을 반환한다. 123456789long uniqueWords = 0; try(Stream lines = Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset()))&#123; uniqueWords = lines.flatMap(line-&gt;Arrays.stream(line.split(&quot; &quot;))) .distinct() .count();&#125;catch(IOException e)&#123; //예외처리&#125; 위 예시에서 File.lines로 파일의 각 행 요소를 반환하는 스트림을 얻는다.스트림 소스가 I/O 자원이므로, try-catch 블록으로 감싸고 finally 블록으로 자원을 닫아줘야 하지만.스트림 인터페이스는 AutoCloseable 인터페이스를 구현하므로 try 블록 자원을 자동으로 관리한다.각 행 요소를 split메서드를 통해 단어별 요소로 만들고,이 단어들을 distinct와 count를 연결해 고유 단어들의 갯수를 계산했다. 함수로 무한 스트림(언바운드 스트림) 만들기 크기가 고정되지 않은 스트림은 두 정적 메서드 Stream.iterate, Stream.generate로 구현한다. iterate와 generate에서 만든 스트림은 요청때마다 주어진 함수로 값을 만든다.보통 무한한 스트림을 제한하기 위해 limit을 연결해 사용한다. iterate 메서드123Stream.iterate(0, n-&gt;n+2) .limit(10) .forEach(System.out::println); iterate메소드는 초기값과 람다를 인수로 받아 무한히 실행한다.예제에서는 n-&gt;n+2이므로, 0, 2, 4, 6 …. 이런식으로 요소들을 만들어 낸다.limit으로 10개의 요소만 생성하고, 각 요소를 출력하며 스트림을 끝낸다. 자바 9의 iterate 메소드는 프레디케이트를 지원한다. 12IntStream.iterate(0, n-&gt;n&lt;100, n-&gt;n+4) .forEach(System.out::println); 그런데 여기서 이런 의문이 생긴다.다음과 같은 코드는 작동할까? 123IntStream.itrerate(0, n-&gt;n+4) .filter(n-&gt;n&lt;100) .forEach(System.out::println); 언뜻 보면 잘 작동할 것 같지만, 위 코드는 무한히 계산하여 종료되지 않는다!!!!! 엥 왜?filter는 이 작업이 언제 끝내야되는지 모르기 때문이다.filter는 100이 넘어가도 계속 자신의 해야할 계산을 한다. 우리의 의도를 달성하려면 _스트림 쇼트서킷_을 지원하는 takeWhile을 사용해야 한다. 123IntStream.iterate(0, n-&gt;n+4) .takeWhile(n-&gt;n&lt;100) .forEach(System.out::println); generate 메서드generate는 iterate와 다르게, 생산된 각 값을 연속적으로 계산하지 않는다. generate는 Supplier를 인수로 받아 새로운 값을 생산한다. 123Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 이 코드는 0과 1 사이의 임의 더블 수 다섯개를 만든다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"스트림 더 알아보기","slug":"java/modern-java-in-action/modern4","date":"2021-07-30T00:37:30.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern4/","excerpt":"","text":"a. 필터링스트림 요소를 선택하는 방법을 필터링이라고 한다.프레디케이트 필터링과 고유 요소만 필터링하는 방법에 대해 알아보자! 프레디케이트로 필터링하기프레디케이트를 인수로 받아 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환하는 방식을 말한다.대표적으로 filter method가 있다. 예시로 보자! 123List&lt;Dish&gt; vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(toList()); 고유 요소 필터링고유 요소로 이뤄진 스트림을 반환하는 distinct method를 지원한다.여기서 고유 요소라는 말은 중복된 요소가 없는 요소를 의미한다.중복된 요소를 검증은 hashCode, equals로 결정된다. 12345List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,3,2,4);numbers.stream() .flter(i -&gt; i%2 ==0) .distinct() .forEach(System.out::println);//2,4 b. 스트림 슬라이싱스트림 요소를 선택하거나 스킵하는 여러 방법에 대해 알아보자.프레디케이트 이용하기, 스트림 초기 몇 요소 무시하기, 특정 크기로 스트림 줄이기 등 다양한 방법이 있다. b-1. 프레디케이트 :takeWhile 활용스트림의 요소(음식)들이 이미 칼로리로 정렬되어 있을 때, 특정 칼로리보다 높은 칼로리를 갖는 음식들만 보고 싶으면 어떻게 해야 될까?이전에 배웠던 filter로 모든 요소를 확인해볼수 있지만, 요소들은 이미 칼로리로 정렬되어 있다.즉 특정 칼로리와 비교 연산의 결과가 달라지는 순간부터는 굳이 다음 요소를 검증하지 않아도 된다는 의미다.takeWhile은 처음 거짓이 나올 때까지 요소들을 모은다. 즉 거짓이 나오면 요소를 그만 모은다.이를 takeWhile연산으로 구현할 수 있다. 123List&lt;Dish&gt; sliceMenu1 = specialMenu.stream() .takeWhile(dish-&gt;dish.getCalories() &lt; 320) .collect(toList()); b-2. 프레디케이트 :dropWhile 활용takeWhile과는 달리 dropWhile은 정반대이다. 조건에 거짓이 되는 요소가 나오게 되면 그 지점에서 작업을 중단하고, 남은 모든 요소를 반환한다.dropWhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다. 1234List&lt;Dish&gt; sliceMenu1 = specialMenu.stream() .takeWhile(dish-&gt;dish.getCalories()&lt;320) .collect(toList()); b-3. 스트림 축소: limit주어진 값 이하의 요소를 갖는 스트림을 반환하는 limit(n)을 활용하면 스트림을 줄일 수 있다. 1234List&lt;Dish&gt; dishes = specialMenu.stream() .filter(dish-&gt;dish.getCalories() &gt; 300) .limit(3) .collect(toList()); 처음 일치하는 n개의 요소만 반환한다. b-4. 요소 건너뛰기: skip스트림으로 들어온 요소 n개를 제외한 스트림을 반환하는 skip(n) 메서드를 활용할 수 있다. 1234List&lt;Dish&gt; dishes = menu.stream() .filter(d -&gt; d.getCalories() &gt; 300) .skip(2) .collect(toList()); c. 매핑특정 객체에서 특정 데이터를 선택하는 map과 flatMap으로 매핑을 구현한다 c-1. 스트림의 각 요소에 함수 적용하기: mapmap은 함수를 인수로 받아 각 요소에 적용한 결과가 새로운 요소로 매핑된다. 123List&lt;String&gt; dishNames = menu.stream() .map(Dish::getName) .collect(toList()); c-2. 스트림 평면화: flatMap자 flatMap을 배우기 전에, 이게 왜 필요한지 알아보자.hello와 world라는 문자열 두개를 배열에 저장한 다음, 각 문자열의 고유문자만 모아 리스트에 넣어 반환하고 싶다고 하자.우리가 원하는 결과물은 h,e,l,o,w,r,d를 가진 리스트다. flatMap을 활용하지 않고 하면 시도를 하면 이렇게 된다 1234words.stream() .map(word-&gt;word.split(&quot;&quot;)) .distinct() .collect(toList()); 근데 이렇게 하면 map에서 해당 함수를 적용해도 문자배열을 가진 두 객체가 요소가 되는거지, 하나하나의 문자가 스트림요소가 되는게 아니다!즉 {h,e,l,l,o}, {w,o,r,l,d} 이렇게 두 요소가 반환되는거지, h,e,l,l,o,w,o,r,l,d 이런 식으로 문자들이 다 요소가 되는 게 아니다.결국 이렇게 하면 distinct 메소드는 두 요소를 비교하게 되는데, 두 요소는 엄연히 다른 요소이므로, 두 문자열 둘다 살아남게 된다.이제 collect를 통해 문자열 두개를 포함한 리스트가 반환된다. 자 그러면 이제 flatMap을 활용해보자.일단 우리가 원하는 목표를 달성하기 위해서는 배열 스트림이 아닌 문자열 스트림이 필요하다.문자열을 받아 문자열 스트림으로 활용하려면, Arrays.stream() 메서드를 활용하면 된다. 12String[] arrayOfWords = &#123;&quot;hello&quot;, &quot;world&quot;&#125;;Stream&lt;String&gt; streamOfWords = Arrays.stream(arrayOfWords); 이런 파이프라인으로 하면 문자열 스트림이 생성된다.이 파이프라인으로 우리가 원래 하려던 것을 해보자 12345words.stream() .map(word -&gt;word.split(&quot;&quot;)) .map(Arrays::stream) //각 배열을 별도의 스트림으로 생성 .distinct() .collect(toList()); 하지만 아직 문제가 있다. .map(Arrays::stream)을 하면, 각 문자열 배열들이 개별의 스트림이 되어toList() 반환값이 List이 되어버린다. 즉 스트림을 가진 리스트가 되어버린다. 우리가 원하는건 문자열은 가진 리스트다. 이를 위해 flatMap을 도입하자. flatMap 각 배열을 스트림이 아닌 한 스트림의 컨텐츠로 매핑한다. 123456List&lt;String&gt; uniqueCharacters = words.stream() .map(word-&gt;word.split(&quot;&quot;)) .flatMap(Arrays::stream) .distinct() .collect(toList()); d. 검색과 매칭d-1. anyMatch 프레디케이트가 적어도 한 요소와 일치하는지 확인123if(menu.stream().anyMatch(Dish::isVegetarian))&#123; System.out.println(&quot;the menu is vegetarian friendly!&quot;);&#125; d-2. allMatch 프레디케이트가 모든 요소와 일치하는지 검사12boolean isHealthy = menu.stream() .allMatch(dish -&gt; dish.getCalories()&lt;1000); d-3. noneMatch 프레디케이트와 일치하는 요소가 없는지 검사allMatch와 반대 되는 메서드라고 생각하자. 1boolean isHealthy = menu.stream().noneMatch(d-&gt;d.getCalories() &gt;= 1000); 이렇게 anyMatch, allMatch, noneMatch, findAny는 논리연산자 &amp;&amp;,||와 비슷하게 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다. 이를 쇼트 서킷이라 부른다!(특히 무한한 요소를 가진 스트림을 유한 요소 스트림으로 줄일 때 유용하다!)(limit도 포함!)d-4. findAny 요소 검색해서 해당 요소 반환123Optional&lt;Dish&gt; dish = menu.stream() .filter(Dish::isVegetarian) .findAny(); 여기서 optional은 추후에 더 공부할 것이니 넘어가고, 지금은 조건에 맞는 요소들을 찾아 반환해준다는 사실만 확인하고 넘어가자. d-5. findFirst 논리적인 순서를 가진 스트림에서 첫번째 요소 찾기12345List&lt;Integer&gt; someNumbers = Arrays.asList(1,2,3,4,5);Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream() .map(n-&gt;n*n) .filter(n-&gt;n%3 ==0) .findFirst(); //9 findFirst와 findAny는 언제 사용하나? 병렬 실행에서는 첫번째 요소를 찾기가 어렵다! 그럴 때 findFirst를 사용하고 그렇지 않으면, findAny를 사용한다!! e. 리듀싱리듀스 연산은 모든 스트림 요소를 처리해서 값으로 도출하는 연산이다.함수형 프로그래밍 언어로는 폴드라고 부른다. d-1. reduce 요소의 합요소의 합을 구하는 reduce에는 일반적으로 두 개의 파라미터가 필요하다.하나는 누적값의 초기값, 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator (보통 람다로 표현). 1int product = numbers.stream().reduce(1, (a,b)-&gt;a*b); 위 코드는 1부터 시작해서, 1+첫요소가 다시 누적값이 되고 (1+첫요소)+두번째요소가 되는 식이다.(물론 얘도 다음 요소와 연산될 때는 누적값이 된다.) 초기값을 받지 않는 reduce도 있다. Optional을 반환한다. 1Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a+b)); d-2. reduce로 최댓값 최솟값 찾기최대 최소를 구할 때는 reduce의 초기값(누적)이 필요가 없다. 그저 요소를 순서대로 받아 max연산을 하면 된다. 12Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min); reduce 메서드의 장점과 병렬화 반복으로 합계를 구하는 것과 reduce의 차이는 뭘까?reduce는 스트림이므로, 내부 구현으로 병렬로 실행할 수 있다. 스트림 연산 : 상태 없음과 상태 있음map, filter는 각 요소를 하나씩 받아 결과를 출력 스트림으로 보내는 내부 상태를 갖지 않는 연산이다.한편 reduce, sum, max 같은 연산은 결과를 누적할 내부 상태가 필요하다. 스트림의 요소 수와 관계없이 내부 상태의 크기는 한정적이다.하지만 sorted, distinct는 요소를 하나하나 받아 결과를 출력 스트림으로 보내는 연산이 아니라, 모든 요소를 버퍼에 추가하여 결과를 출력 스트림으로 보내는 연산이다.이런 연산들은 무한 스트림을 입력받으면 안된다. 예를 들어 모든 소수를 담은 무한 스트림을 sorted 할 수 있을까? 세상에서 가장 큰 소수가 맨 앞으로 와야되는데, 그런 연산은 불가능하다!. 이런 연산들을 우리는 내부 상태를 갖는 연산이라고 한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"스트림에 대해 간략하게 알아보자","slug":"java/modern-java-in-action/modern3","date":"2021-07-30T00:36:18.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern3/","excerpt":"","text":"a. 스트림이 뭘까?스트림은 자바 8 API에 새로 추가된 기능이다. 스트림을 이용하면 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현이 가능)으로 컬렉션 데이터를 처리할 수 있다. 쉽게 말하면, 스트림은 데이터 컬렉션 반복을 멋지게 처리하는 기능이라고 생각하자. 또한 스트림을 사용하면 멀티스레드 코드를 쓰지 않고도 투명하게 데이터를 병럴로 처리할 수 있다.(추후 알아보자) 일단 코드로 이해해보자 먼저 요리 중 저칼로리 요리명을 반환하고, 칼로리 기준으로 요리를 정렬하는 자바 7 코드를 보자. 123456789101112131415161718//요소 필터링List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();for (Dish dish : menu) &#123; if(dish.getCalories() &lt; 400) &#123; lowCaloricDishes.add(dish); &#125;&#125;//요소 정렬Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() &#123; //익명 클래스 public int compare(Dish dish1, Dish dish2) &#123; return Integer.compare(dish1.getCalories(), dish2.getCalories()); &#125;&#125;//요소 이름을 저장List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();for(Dish dish : lowCaloricDishes) &#123; lowCaloricDishesName.add(dish.getName());&#125; 이 코드를 보면 요소 정렬하면서 lowCaloricDishes라는 가비지 변수를 사용했다. lowCaloricDishes는 그저 정렬된 요소를 임시로 저장했다가 새로운 리스트인 lowCaloricDishesName에 전달해주는 역할을 한다. 자바 8에서는 이런 컨테이너 역할을 하는 중간 변수 구현을 라이브러리 내에서 모두 처리한다. 1234567import static java.util.Comparator.comparing;import static java.util.stream.Collections.toList;List&lt;String&gt; lowCaloricDishesName = menu.stream() .filtered(d -&gt; d.getCalories() &lt; 400) .sorted(Comparing(Dish::getCalories)) .map(Dish::getName) .collect(toList()); stream()을 parallelStream()으로 바꾸면, 멀티코어 아키텍처에서 병렬로 실행할 수 있다.(추후 게시물로 공부하자) 그렇다면 스트림을 사용하면 어떤게 좋을까? 선언형으로 코드를 구현할 수 있다. 즉, 반복문이나 조건문같은 제어블록을 사용해서 상황에 따라 어떻게 행동할 지 구현할 필요없이, 동작의 수행을 지정할 수 있다. 선언형 코드와 동작 파라미터화를 활용하면 요구사항에 쉽게 대응할 수 있다.(람다만 적절하게 바꿔주면 된다!) 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다. 위 예시에서처럼 filtered, sorted, map, collect등 연결해 더 복잡한 파이프라인을 만들 수 있다. 고수준 빌딩 블록(filter, sorted, map, collect 등..)은 특정 스레딩 모델에 제한되지 않고 사용가능 하다. 이 블록들은 멀티코어 아키텍처를 최대한 투명하게 활용할 수 있게 구현되어 있다. 덕분에 데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정할 필요가 없다. 마지막으로 스트림의 특징을 요약하면서 다음 챕터로 넘어가자! 선언형 : 더 간결, 가독성 상승 조립 가능 : 유연성 병렬화 : 성능 향상 b. 스트림 시작하기스트림에 대해 공부하기 앞서, 스트림이 정확하게 어떤 것을 의미하는 지 살펴보고 가자. 스트림이란 ‘데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소’를 의미한다. 무슨 말인지 아직도 모르겠다… 정의에 나온 단어 하나하나 파악해보자 연속된 요소? 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이뤄진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션은 요소 저장 및 접근 연산이 주를 이루지만, 스트림은 요소들의 표현이나 계산식이 주를 이룬다. 소스? 스트림은 컬렉션, 배열, 입출력 자원 등 데이터 제공 소스로부터 데이터를 소비한다. 컬렉션에서 요소들을 스트림에 연결하면, 컬렉션에 저장된 순서대로 스트림 요소가 소비된다는 의미! 데이터 처리 연산? 스트림은 함수형 프로그래밍 언어나 데이터베이스와 비슷한 연산을 지원한다.(filter, map, reduce, find, match, sort…) 스트림의 정의는 이렇게 이해할 수 있게 됐다. 한편 스트림의 두 가지 중요한 특징도 짚고 넘어가자! 파이프라이닝 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록, 스트림 자신을 반환한다! 내부 반복 반복자를 이용해서 명시적으로 반복하는 컬렉션과는 달리 스트림은 내부 반복을 지원한다. 지금까지 배운 내용을 코드로 이해해 보자 12345678import static java.util.stream.Collectors.toList;List&lt;String&gt; threeHighCaloricDishNames = menu.stream() //List&lt;Dish&gt; menu에서 스트림얻음 .filter(dish -&gt; dish.getCalories() &gt; 300) //고칼로리 필터링 .map(Dish::getName) //필터링 된 요리를 이름을 추출 .limit(3) //선착순 세개만 저장 .collect(toList()); //결과를 다른 리스트로 저장System.out.println(threeHighCaloricDishNames); 이 코드를 도표로 나타내면 다음과 같다 [##Image|kage@bhCDUs/btq9TEvcCqe/zfB1YOZVyffzyU46TnHLVK/img.png|alignCenter|data-origin-width=”715” data-origin-height=”506” width=”666” height=”471” data-ke-mobilestyle=”widthOrigin”|||##] c. 스트림과 컬렉션자 이제, 스트림과 컬렉션을 비교해보자. 앞서 살펴본 것처럼 스트림과 컬렉션은 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. 연속된 이란 의미는 아무렇게나 값에 접근할 수 있는 것이 아닌 순차적으로 값에 접근한다는 의미다. 스트림과 컬렉션을 DVD와 비디오스트리밍의 관계로 이해할 수 있다. DVD(컬렉션)비디오스트리밍(스트림)전체 자료구조가 저장되어 있음전체가 저장되어 있지않고 사용할 일부만 받아와 사용 c-1. 데이터를 언제 계산하는가컬렉션과 스트림의 가장 큰 차이를 보이는 게 바로 데이터를 언제 계산하는 지이다. 컬렉션은 모든 데이터를 메모리에 저장하는 자료구조다.즉 컬렉션에 어떤 값을 추가하거나, 삭제하려 할 때마다 컬렉션의 모든 값이 메모리에 저장되어야하고, 추가하려는 값은 미리 계산되어야 한다. 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다. 고정됐다는 의미는 요소를 삭제하거나 제거할 수 없다는 의미다. 사용자가 요청하는 값만 스트림에서 추출하는 것이 핵심이다. 구글검색을 한다고 가정했을 때 모든 검색 결과를 가져올 때까지 기다리는 방식이 컬렉션이고, 가장 연관있는 10개를 먼저 보여주고 그 다음 페이지로 넘어가면 그 때 다음 10개를 가져오는 방식이 스트림이라고 이해하자! c-2. 딱 한 번만 탐색할 수 있다.반복자(iterator)와 마찬가지로 스트림도 단 한번만 탐색할 수 있다. 어떤 요소가 한 스트림에서 이미 탐색됐을 때, 그 요소에 다시 접근하려면 새로운 스트림으로 접근해야 한다는 의미다. (물론 데이터 소스도 반복 접근이 가능해야 한다. 입출력 소스 처럼 반복 사용할 수 없는 경우 스트림을 새로 만들어도 접근 불가능이다.) c-3. 외부 반복, 내부 반복컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.(반복문을 써서) 이를 외부 반복이라고 한다. 하지만 스트림은 내부 반복을 사용한다. 내부 반복은 반복을 알아서 처리하고, 결과 스트림 값을 어딘가에 저장하는 방식이다. 함수에 동작만 결정하면 반복과 저장은 알아서 해준다는 의미다. 12345678List&lt;String&gt; names = new ArrayList&lt;&gt;();for(Dish dish: menu) &#123; names.add(dish.getName());&#125;List&lt;String&gt; names = menu.stream() .map(Dish::getName) .collect(toList()); 내부 반복이 외부 반복보다 편리한 이유는 무엇일까?방에 쓰레기를 주우라고 명령할 때 외부 반복은 마치 쓰레기가 있니? - 왼쪽에 쓰레기가 있네요- 주우렴 - 다시 쓰레기가 아직도 있니 - 오른쪽에도 쓰레기가 있네요 - 주우렴- …. 이런식인데, 내부 반복은 방에 있는 쓰레기를 모두 주우렴 - 주웠어요. 이렇게 실행된다. 또한 내부 반복은 쓰레기를 두 손으로 동시에 주울 수도 있고(투명한 병렬 처리), 쓰레기통을 가끼이 두고 빨리 처리 할 수 있다.(최적화) 내부반복과 외부반복은 라이브러리가 반복을 자기 안에서 해결하느냐 마느냐로 구분한다고 이해하자. 하지만 스트림의 내부 반복은 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다.(filter, map..) d. 스트림 연산스트림 연산은 크게 중간 연산, 최종 연산 두 가지로 나누어진다. d-1. 중간 연산중간 연산은 다른 스트림을 반환하는 연산이다. (filter, map…) 중간 연산의 가장 중요한 특징은 최종 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것이다. 중간 연산이 연결되어 합쳐지고, 이 것을 최종 연상으로 한번에 처리한다. 연산형식반환 형식연산의 인수함수 디스크립터filter중간Stream&lt;T&gt;Predicate&lt;T&gt;T -&gt; booleanmap중간Stream&lt;R&gt;Function&lt;T, R&gt;T -&gt; Rlimit중간Stream&lt;T&gt;&nbsp;&nbsp;sorted중간Stream&lt;T&gt;Comparator&lt;T&gt;(T, T) -&gt; intdistinct중간Stream&lt;T&gt;&nbsp;&nbsp; d-2. 최종 연산최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에서는 스트림이 아닌 List, Integer, void 등 도출된다. 연산형식반환 형식목적forEach최종void스트림 각 요소를 람다를 적용하면서 소비count최종long스트림 요소 갯수 반환collect최종collection스트림을 리스트, 맵, 정수 형식 컬렉션으로 만든다 스트림 이용 과정은 다음 세가지로 요약 가능하다. 질의를 수행할 데이터 소스(컬렉션, 배열, 입출력 소스) 스트림 파이프라인을 구성할 중간 연산 연결 스트림 파이프라인을 실행하고 결과를 만들 최종 연산","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"람다표현식","slug":"java/modern-java-in-action/modern2","date":"2021-07-30T00:25:25.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern2/","excerpt":"","text":"a. 람다란 무엇인가?람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다! 익명 : 람다 표현식에는 이름이 없다. 함수 : 람다는 메서드와 달리 특정 클래스에 종속되지 않으므로 함수라 부른다. 전달 : 메서드 인수로 전달하거나 변수로 저장할 수 있다. 간결성 : 익명 클래스보다 간결하다. 커스텀 Comparator 객체 구현 예시로 람다의 힘을 느껴보지! 12345678Comparator&lt;Apple&gt; byWeight = new Comparator&lt;Apple&gt; &#123; public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;//RamdaComparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); 람다는 크게 세 부분으로 이뤄져있다. 파라미터 리스트 : (Apple a1, Apple a2) 화살표(-&gt;) : 람다의 파라미터 리스트와 바디를 구분 람다 바디 : a1.getWeight().compareTo(a2.getWeight()); 람다의 반환같이 해당하는 표현식. 람다는 표현식 스타일과 블록 스타일로 나타낼 수 있다. 표현식 스타일 (parameters) -&gt; expression 블록 스타일 (parameters)-&gt; { statements; } 구문(statements)와 표현식(expression)을 잘 구분해서 맞는 스타일대로 작성하기로 바란다! 아래 다양한 람다 사례를 보며 람다 표현식을 익혀보자! 12345678(List&lt;String&gt; list)-&gt; list.isEmpty()()-&gt;new Apple(10)(Apple a)-&gt; &#123; System.out.println(a.getWeight());&#125;(String s)-&gt; s.length()(int a, int b) -&gt; a*b(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) b. 어디에 어떻게 람다를 사용할까?b-1. 함수형 인터페이스함수형 인터페이슨느 정확히 하나의 추상 메서드를 지정하는 인터페이스다. 대표적으로 Predicate, Comparator, Runnable 등이 있다. (d 항목에서 더 자세히 다뤄본다.) 123456public interface Predicate&lt;T&gt; &#123; boolean test (T t);&#125;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; #인터페이스는 디폴트 메서드를 포함할 수 있다. 디폴트 메서드를 가지고 있더라도 추상메서드가 오직 하나면 함수형 인터페이스다. 함수형 인터페이스로 뭘 할 수 있을까? 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다. 즉 전체 표현식을 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급할 수 있다!! b-2. 함수 디스크립터먼저 함수 디스크립터에 대해 알아보기 전에 메서드 시그니처에 대해 알아보자. 시그니처란 메소드의 이름과 매개변수 이름을 제외한 나머지이다. 즉 int sum(int a, double b) , int sum2(int c, double d) 이 두 메소드는 서로 시그니처가 같다. 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다. (함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 부른다.) 123456public void process(Runnable r) &#123; r.run();&#125;process(()-&gt; System.out.println(&quot;This is awesome!!&quot;));//process(() -&gt; &#123; System.out.println(&quot;This is awesome!!&quot;);&#125;); Runnable 인터페이스의 유일한 추상 메소드인 run 메소드는 인수와 반환값이 없으므로, 람다 표현식의 함수 디스크립터도 해당 시그니처에 맞춰 작성됐다. #이때 왜 람다 표현식에 중괄호를 사용하지 않았는지 궁금할텐데, 이는 하나의 void 메소드 호출은 중괄호를 생략한다. @FunctioalInerface는 무엇일까? 다음에 나오는 인터페이스가 함수형 인터페이스임을 알리는 어노테이션. 함수형 인터페이스가 아닐경우 에러 발생. c. 람다 활용 : 실행 어라운드 패턴데이터베이스의 파일 처리를 구현한다고 상상해보자 자원을 열고(설정), 처리한 다음에, 자원을 닫는(정리) 순으로 구현할 것이다. 이런 순환 패턴의 코드를 실행 어라운드 패턴이라 부른다. (다음 예시는 try with resources 구문을 사용했다. 자원을 명시적으로 닫지 않아도 된다.) 12345public String processFile() throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123; return br.readLine(); &#125;&#125; 이 예시를 람다로 간결하게 구현하는 과정을 한번 경험해보자! c-1. 1단계, 동작 파라미터화를 기억하라현재 코드는 파일에서 한번에 한 줄만 읽을 수 있다. 만약 요구사항이 한번에 두 줄을 읽거나 자주 사용되는 단어를 반환하라는 등으로 바뀌면 어떻게 해야하나? 그렇다! 설정과 정리 과정은 재사용하고, processFile 메소드만 다른 동작으로 작동할 수 있으면 된다! 즉 processFile의 동작을 파라미터화 하는 것이다!!!!! 자 이제 다음 단계부터 차근차근 동작 파라미터화를 구현해보자! c-2. 2단계, 함수형 인터페이스를 이용해서 동작 전달람다로 활용하려면 함수형 인터페이스를 이용해야 한다. processFile 의 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다. BufferedReaderProcessor라고 정의해 인터페이스를 구현하고, processFile 메서드의 인수로 전달해보자! 12345678@FunctionalInterfacepublic interface BufferReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125;public String processFile(BufferedReaderProcessor p) throws IOException &#123;//...&#125; c-3. 3단계, 동작 실행자 이제 BufferedReaderProcessor에 process 메서드의 시그니처와 일치하는 람다를 전달할 수 있다. 이렇게 하면 함수형 인터페이스의 추상 메소드를 람다가 구체화해서 precessFile에서 실행할 수 있게 된다. 즉 람다로 구현된 다양한 요구조건들을 받는 그릇이 준비된 셈이다. 12345public String processFile(BufferedReaderProcessor p) throws IOEXception &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123; return p.process(br); &#125;&#125; c-4. 4단계, 람다 전달이제 람다를 이용해서 다양한 동작을 processFile 메서드로 전달할 수 있다. 123String oneLine = processFile(BufferedReader br) -&gt; br.readLine());String twoLine = processFile(BufferedReader br) -&gt; br.readLine()+br.readLine(); d. 함수형 인터페이스 사용다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다! 자바 8에는 java.util.function 패키지로 여러가지 함수형 인터페이스를 제공한다. d-1. Predicatejava.util.function.Predicate 인터페이스는 test라는 추상 메소드를 정의한다! test는 T 객체를 인수로 받아 불리언을 반환한다! 123456789101112131415@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; results = new ArrayList&lt;&gt;(); for(T t: list) &#123; if(p.test(t)) &#123; results.add(t); &#125; &#125; return results;&#125;Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();List&lt;String&gt; nonEmpty = filter(listOfStrings, nonEmptyStringPredicate); d-2. Consumerjava.util.function.Consumer 인터페이스는 accept라는 추상 메소드를 정의한다! accept는 T 객체를 인수로 받아 어떤 동작을 수행하고 반환값은 없다. for each를 Consumer로 구현한 사례를 보자 1234567891011@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;public &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c) &#123; for(T t: list) &#123; c.accept(t); &#125;&#125;forEach(Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.println(i)); d-3. Functionjava.util.function.Function&lt;T, R&gt; 인터페이스는 추상 메서드 apply를 정의한다 apply는 T를 인수로 받아 R 객체로 반환한다. 입력을 출력으로 매핑하는 람다를 정의할 때 사용할 수 있다. String 리스트를 인수로 받아, 각 String 길이를 포함하는 Integer 리스트로 변환하는 map메서드 구현 사례를 보자! 123456789101112131415@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;public &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t: list) &#123; result.add(f.apply(t)); &#125; return result;&#125;List&lt;Integer&gt; l = map(Arrays.asList(&quot;lambdas&quot;, &quot;in&quot;, &quot;action&quot;), (String s) -&gt; s.length());//[7,2,6] d-4. 기본형 특화이 글을 보고 있는 사람들은 아시다시피, 제네릭에는 래퍼클래스(책에서는 참조형이라고 한다) 인스턴스만 사용가능하다. 이런 불편을 박싱과 언박싱으로 해소할 수 있지만, 그럴 경우 불필요한 메모리 소모가 생긴다. 자바 8에서는 기본형으로 입출력할 때 오토박싱을 피하기 위해 특별한 함수형 인터페이스를 제공한다. 아래는 IntPredicate를 활용한 예시이다. 123456789public interface IntPredicate &#123; boolean test(int i);&#125;IntPredicate evenNumbers = (int i) -&gt; i%2==0;evenNumbers.test(1000); //참이고 박싱이 진행되지 않음Predicate&lt;Integer&gt; evenNumbers2 = (int i) -&gt; i%2==0;evenNumbers2.test(1000); //참이고 박싱이 진행됨 Predicate와 IntPredicate의 차이를 알아차리기 바란다! d-5. 람다와 함수형 인터페이스 예제를 표로 정리사용 사례람다 예제대응하는 함수형 인터페이스불리언 표현(List&lt;String&gt; list) -&gt; list.isEmpty()리스트가 비었는지 확인Predicate&lt;List(String)&gt;객체 생성() -&gt; new Apple(10)Supplier&lt;Apple&gt;객체 소비(Apple a) -&gt; System.out.println(a.getWeight())Consumer&lt;Apple&gt;객체에서 선택/추출(String s) -&gt; s.length()Function&lt;String, Integer&gt;ToIntFunction&lt;String&gt;두 값 조합(int a, int b) -&gt; a*bIntBinaryOperator두 객체 비교(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())Comparator&lt;Apple&gt; 또는BiFunction&lt;Apple, Apple, Integer&gt;,ToIntBiFunction&lt;Apple, Apple&gt; 복잡하긴 하다. d-6. 예외, 람다, 함수형 인터페이스의 관계함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다. 즉 예외를 던지는 람다 표현식을 만들려면, 함수형 인터페이스에서 예외를 선언하도록 직접 정의하거나, 람다를 try catch문으로 감싸야 한다. 예외를 처리하는 함수형 인터페이스를 선언하는 예시를 보자. 12345@FunctionalInterfacepublic interface BufferedReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125;BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine(); 하지만 이미 자바 API에 정의된 함수형 인터페이스를 사용하려 하는데예외 때문에 다시 직접 만들어 쓰기는 쉽지 않다… 이럴 때는 람다를 try catch로 감싸는 방법을 사용해보자!! 1234567Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; &#123; try &#123; return b.readLine(); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125;&#125;; e. 형식 검사, 형식 추론, 제약람다로 함수형 인터페이스의 인스턴스를 만들 수 있는데, 정작 람다 표현식 자체에는 어떤 함수형 인터페이스를 구현하는지의 정보가 없다.. 어떻게 알고 인스턴스를 만드는걸까? e-1. 형식 검사람다가 사용되는 콘텍스트(람다가 전달될 메서드 파라미터, 람다가 할당되는 변수 등..)을 통해람다의 형식을 추론할 수 있다! 예시로 이해해보자. 1234567public &lt;T&gt; void filter(inventory, Predicate&lt;T&gt; p)&#123; if(p.test())&#123; inventory.add(p); &#125;&#125;List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); 위 코드의 형식 확인 과정은 다음과 같다. 람다가 사용된 콘텍스트는 뭐냐? filter 메서드에서 사용됐으니, filter메서드의 정의를 확인하자! 대상 형식은 뭐냐? #대상 형식이란, 컨텍스트에서 기대되는 람다의 형식. filter 메서드를 보니, 람다에 해당하는 대상형식은 Predicate이다! Predicate 인터페이스의 추상 메서드는 뭐냐? boolean test(Apple apple)이다! #d-1참고. 아하! 그러면 해당 람다는 Apple을 받아 boolean을 반환하면 되겠군! e-2. 같은 람다, 다른 함수형 인터페이스앞서 다룬 대상 형식(타겟타입)이란 개념 때문에 같은 람다 표현식도 여러 함수형 인터페이스에 사용할 수 있다! 물론 이렇게 활용되기 위해서는 해당 추상 메서드에 호환이 되어야 한다.(시그니처가 호환되어야 할 것이다.) 12Callable&lt;Integer&gt; c = () -&gt; 43;PrivilegedAction&lt;Integer&lt; p = () -&gt; 43; 위 두 코드에는 같은 람다식이 서로 다른 함수형 인터페이스에 할당 되었다. Callable과 PrivilegedAction 모두, 인수를 받지 않고 제네릭 형식 T를 반환하는 추상 메소드가 있어서 가능하다. #특별한 void 호환 규칙 람다의 바디에 일반 표현식이 있으면 void를 반환하는 함수 디스크립터(시그니처)와 호환된다. List의 add는 T를 받아 boolean을 반환하지만 T를 받는 void 형식에도 사용 가능하다. 12// Consumer는 void 반환값을 가지면, 일반 표현식이 와도 괜찮다!Consumer&lt;String&gt; b = s -&gt; list.add(s); e-3. 형식 추론람다 표현식의 파라미터 형식을 생략해도 컴파일러가 추론할 수 있다. 1List&lt;Apple&gt; greenApple = filter(inventory, apple -&gt; GREEN.equals(apple.getColor())); apple이 어떤 형식인지 말 안해줘도, filter 메소드을 통해 추론 할 수 있게된다. 형식을 써주는게 좋을 때도 있고, 생략해야 좋을 때도 있으니, 개발자가 가독성이 좋은 방향으로 선택하길 바란다! e-4. 지역 변수 사용(람다 캡처링)람다 표현식에 자유 변수(파라미터로 넘겨진 변수가 아닌 외부에 정의된 변수)를 활용할 수도 있다! 12int portNumber =1337;Runnable r = () -&gt; System.out.println(portNumber); 람다는 인스턴스 변수, 정적 변수 모두 사용 가능하지만 제약이 있다. 명시적으로 final 선언되어 있거나, 실질적으로 final 선언된 변수여야만 한다. 즉 람다는 한번만 할당할 수 있는 지역 변수를 사용할 수 있다. 다음 예시는 컴파일 에러를 일으킨다. 123int portNum = 1337;Runnable r = () -&gt; System.out.println(portNum);portNum=31338; //error 그렇다면 왜 제약이 있는 건가? 인스턴스 변수와 지역 변수의 태생적 차이 때문! 인스턴스 변수는 힙에 저장, 지역 변수는 스택에 저장된다. 람다가 지역 변수에 접근할 수 있는 상황에서 람다가 스레드에서 실행되면,변수를 할당한 스레드가 사라져 변수 할당이 해제되지만, 람다에서 해당 변수를 사용해야 된다. 즉 자바에서는 원래 변수에 접근하는 개념이 아니라, 원래 변수를 복사본을 제공하는 개념으로 구현한다. 따라서 복사본의 값이 바뀌면 않아야 되므로, 할당을 한번만 허용하는 것이다. f. 메서드 참조메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있다. 때로는 람다보다 메서드 참조가 더 가독성이 좋을 수 있다. 12345//람다 표현식inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));//메서드 참조inventory.sort(comparing(Apple::getWeight)); f-1. 메서드 참조 요약메서드 참조는 람다 표현식을 축약한 것이다. 위 코드에서 (Apple a1, Apple a2) -&gt; …. 을 Apple::getWeight로 줄인 것이다. 그렇다면 이 코드는 어떤 효과를 가질까? 람다로 이미 존재하는 메서드를 호출하려고 하면,굳이 그 내용을 설명할 것이 아니라, 해당 메소드명을 직접 참조하는 것이 편리하고 가독성이 좋다. (위 코드로 예시를 들면 getWeight메소드이 구현되어 있으면, 굳이 람다로 그 내용을 쓰지말고 메소드 명만 쓰는 메소드 참조를 하자는 것이다.) 이때 실제 메소드를 호출하는 것은 아니므로 괄호가 없다. 람다를 축약한 것임을 기억하자. 단축 표현 예시를 보자 람다메서드 참조 단축 표현(Apple apple) -&gt; apple.getWeight()Apple::getWeight() -&gt; Thread.currentThread().dumpStack()Thread.currentThread()::dumpStack(str, i) -&gt; str.substring(i)String::substring(String s) -&gt; System.out.println(s)(String s) -&gt; this.isValidName(s)System.out::printlnthis::isValidName 당장은 이해가 안되도 차근차근 공부해보자. f-2. 메서드 참조를 만드는 방법일단 메소드 참조에는 세가지 유형이 있다 정적 메서드 참조 Integer의 parseInt는 Integer::parseInt로 표현 가능하다 다양한 형식의 인스턴스 메소드 참조 String의 toUpperCase는 String::toUpperCase로 표현 가능하다 즉 (String s) -&gt; s.toUpperCase()를 String::toUpperCase로 축약 가능하다. 기존 객체의 인스턴스 메서드 참조 Transaction이라는 객체를 할당받은 expensiveTransaction 지역 변수가 있고, Transaction 객체에는 getValue메서드가 있다고 할 때, expensiveTransaction::getValue라고 표현 가능하다. 즉 () -&gt; expensiveTransaction.getValue()를 expensiveTransaction::getValue라고 축약 가능하다. 람다 표현식을 메서드 참조로 표현하는 단축 규칙을 보여주는 도표이다. [##Image|kage@dUB92e/btq9EO4XvW0/KuP3ujmb0mkTZiKm9VA580/img.jpg|alignCenter|data-origin-width=”825” data-origin-height=”659” data-ke-mobilestyle=”widthOrigin”|||##] f-3. 생성자 참조ClassName::new처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다. 이는 정적 메서드의 참조를 만드는 방법과 비슷하다. 다음 예시들은 다양한 시그니처에 따른 생성자 참조를 보여준다. 12345678910111213141516171819//람다 스타일, new Apple() 이라는 생성자가 있을 경우Supplier&lt;Apple&gt; c1 = () -&gt; new Apple();Apple a1 = c1.get();//생성자 참조Supplier&lt;Apple&gt; c1 = Apple::new;Apple a1 = c1.get();//람다 스타일, new Apple(Integer)Funtion&lt;Integer, Apple&gt; c2 = (weight) -&gt; new Apple(weight);Apple a2 = c2.apply(110)//생성자 참조Function&lt;Integer, Apple&gt; c2 = Apple::new;Apple a2 = c2.apply(110)//람다 스타일, new Apple(String color, Integer)BiFUnction&lt;String, Integer, Apple&gt; c3 = (color, weight) -&gt; new Apple(color, weight);Apple a3 = c3.apply(GREEN, 110);//생성자 참조BiFunction&lt;Color, Integer, Apple&gt; c3 = Apple::new 이렇게 인스턴스화하지 않고도 생성자에 접근할 수 있는 기능을 다양한 상황에서 응용해보자. 12345678910//사과의 무게 정보와 함께 Apple 생성자 호출List&lt;Integer&gt; weights = Arrays.asList(7, 3, 4, 10);List&lt;Apple&gt; apples = map(weights, Apple::new);public List&lt;Apple&gt; map(List&lt;Integer&gt; list, Function&lt;Integer, Apple&gt; f) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for( Integer i : list) &#123; result.add(f.apply(i)); &#125; return result;&#125; 지금까지는 이미 존재하는 함수형 인터페이스를 활용해 생성자 참조를 했다. 만약 인수가 세개 이상을 필요로 하는 생성자의 생성자 참조는 어떻게 해야 할지 알아보자! 12345public interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125;TriFunction&lt;Integer, Integer, Integer, Color&gt; colorFactory = Color::new g. 람다, 메서드 참조 활용하기자 처음에 다룬 사과리스트를 다양한 요구조건에 맞춰 정렬하는 문제를 지금까지 배운 람다와 메서드 참조로 해결해보자! 우리가 얻을 최종 결과물은 다음과 같다. 1inventory.sort(comparing(Apple::getWeight)); g-1. 1단계, 코드 전달우리는 자바 8에 도입된 List API에서 sort 메소드를 활용해 정렬을 해결하기로 했다. 그런데 sort 메소드에 정렬 전략을 어떻게 도입할 수 있을까? 일단 sort 메소드의 시그니처를 알아보자 1void sort(Comparator&lt;? super E&gt; c) 위 코드는 Comparator 객체를 인수로 받아 두 사과를 비교한다. 즉 Comparator 객체에 다양한 동작을 포함시켜서 전략을 도입시킬 수 있을 것이다. 이제 ‘sort의 동작은 파라미터화 되었다.’ 말할 수 있다. 즉 sort에 전달된 정렬 전략에 따라 sort의 동작이 달라질 것이다. 그렇다면 우리는 맨 처음 코드를 다음과 같이 바꿀 수 있다. 123456public class AppleComparator implements Comparator&lt;Apple&gt; &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;inventory.sort(new AppleComparator()); 자 이제 AppleComparator 클래스의 동작을 바꿔주면 요구조건에 유연하게 대응할 수 있다! g-2. 2단계, 익명 클래스 사용하지만 한번만 사용할 Comparator를 1단계에서 처럼 구현하는 거 보다는 익명 클래스를 이용하는게 나아 보인다. 12345inventory.sort(new Comparator&lt;Apple&gt;() &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); g-3. 3단계, 람다 표현식 사용하지만 여전히 코드가 장황하다! 자바 8에서는 함수형 인터페이스(오직 하나의 추상 메서드를 정의하는 인터페이스)를 기대하는 곳 어디에서나 람다표현식을 사용할 수 있다! Comparator의 함수 디스크립터(추상 메서드의 시그니처)는 (T, T) -&gt; int다. 우리의 경우는 사과를 사용하므로, (Apple, Apple) -&gt; int로 표현할 수 있다. 123inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); 이렇게 코드를 작성할 수 있는데, 첫 줄은 자바 컴파일러가 inventory의 제네릭 타입에 따라 람다의 파라미터 형식을 추론한다! 이 코드의 가독성을 더 높여보자!! Comparator는 Comparable 키를 추출해서 Comparator 객체로 만드는 Function 함수를 인자로 받는 정적 매서드 comparing을 포함한다!!! 이 comparing 메소드를 활용해서 더 간단하게 작성할 수 있다. 12import static java.util.Comparator.comparing;inventory.sort(comparing(apple -&gt; apple.getWeight())); 람다표현식은 사과를 비교하는 데 사용할 키를 어떻게 추출할 것인지 지정하는 한 개의 인수만 포함한다. g-4. 4단계, 메서드 참조 사용이제 람다 표현식을 메서드 참조를 활용해 더 간단히 만들어보자 (앞서 본 거 처럼, java.util.Comparator.comparing은 정적으로 임포트했다고 가정하자) 1inventory.sort(comparing(Apple::getWeight)); h. 람다 표현식을 조합할 수 있는 유용한 메서드람다 8에서는 몇몇 함수형 인터페이스는 다양한 유틸리티 메서드를 포함한다. 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 의미다!!! 근데 함수형 인터페이스가 추가로 메서드를 제공하는 것에 의문이 생길 수 있다… 이 때 등장하는 개념이 바로 디폴트 메소드다.(추후에 관련 게시물로 추가 등록) h-1. Comparator 조합이전에 g-3에서 알아봤듯이, 정적메서드 Comparator.comparing을 이용해서 비교에 사용될 키를 추출하는 Function 기반의 추출하는 Function 기반의 Comparator를 반환할 수 있다. 1Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight); h-1-1. 역정렬내림차 정렬은 다른 Comparator 인스턴스를 만들 필요가 없다! reverse 디폴트 메소드에 제공되어 있으니 써먹으면 된다. (reverse 메소드는 비교자의 순서를 뒤바꾸는 역할을 한다.) 1inventory.sort(comparing(Apple::getWeight).reversed()); h-1-2. Comperator 연결만약 무게가 같은 두 사과가 존재하면, 어떻게 정렬해야 하는가? 이런 상황에 대비해, 비교 결과를 더 다듬을 수 있는 두번째 Comparator를 만들어 연결할 수 있다. 이때 사용되는 thenComparing 메소드를 활용해 두번째 비교자를 받아 사용할 수 있다. 다음 예시는 무게로 내림차순 정렬을 하고, 만약 같은 무게를 가진 경우, 생산 국가로 다시 정렬하는 예시이다. 1inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry)); h-2. Predicate 조합Predicate 인터페이스의 경우, 보다 복잡한 프레디케이트를 만들 수 있도록, negate, and, or 세가지 메서드를 제공한다. (당연히 얘네는 디폴트 메서드일 것이다.) h-2-1. negatenegate는 부정한다는 의미다. negate를 붙이면 앞서 진행됐던 프레디케이트를 반전시킬 수 있다. 쉽게 말해 여집합을 생각하면 편할 것이다. 1Predicate&lt;Apple&gt; notRedApple = redApple.negate(); 빨간 사과를 구분하는 Predicate 인터페이스 redApple 뒤에 negate메소드를 더해주면, 빨갛지 않은 사과만 뽑아낼 수 있다! h-2-2. andand는 두 람다를 조합할 수 있다. 1Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; 150); 빨간 사과를 구분하는 Predicate 인터페이스 redApple 뒤에 람다를 포함한 and메소드를 연결하면, 빨갛고 무거운 사과를 뽑아낼 수 있다. h-2-3. oror는 다양한 조건을 만들어 낼 수 있다. 예시로 보면 이해가 빠를 것이다. 12Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(apple -&gt; apple.getWeight() &gt; 150).or(apple -&gt; GREEN.equals(a.getColor())); h-3. Function 조합Function 인터페이스는 andThen과 compose 두가지 메소드를 제공한다! h-3-1. andThenandThen 메소드는 두 개의 Function 인터페이스를 받아, 하나의 인터페이스의 결과물을 다른 인터페이스의 입력값으로 전달하는 역할을 한다. 1234Function&lt;Integer, Integer&gt; f = x -&gt; x+1;Function&lt;Integer, Integer&gt; g = x -&gt; x*2;Function&lt;Integer, Integer&gt; h = f.andThen(g);int result = h.apply(1); //return 4 h-3-2. composecompose 메소드는 인수로 주어진 함수를 먼저 하고, 그 결과를 외부 함수의 인수로 제공한다. 이 말이 어렵게 느껴지겠지만 예시로 살펴보자. 1234Function&lt;Integer, Integer&gt; f = x -&gt; x+1;Function&lt;Integer, Integer&gt; g = x -&gt; x*2;Function&lt;Integer, Integer&gt; h = f.compose(g);int result = h.apply(1); //return 3 andThen의 예시에서는 4가 반환됐는데, compose는 3이 반환 됐다. 이 차이를 살펴보자. andThen은 말그대로 f를 하고 g를 해라 라는 의미다. 매우 직관적이다. compose는 g를 하고 f를 하라는 거다. 아까 설명을 함수 스타일로 표현하면 f(g(1))이 되어 (1*2)+1이 되므로 3이 반환된 거다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"동적 파라미터화 코드 전달하기","slug":"java/modern-java-in-action/modern1","date":"2021-07-30T00:19:44.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/modern-java-in-action/modern1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/modern-java-in-action/modern1/","excerpt":"","text":"‘녹색 사과를 모두 찾고 싶어요… 아니다! 150그람 이상인 사과를 모두 찾고 싶어요…. 생각해보니 150그람 이상이면서 녹색인 사과를 모두 찾아야 될 것 같네요..’ 이렇게 시시각각 변화는 사용자의 요구 사항을 최소 비용으로 대응하기 위해서는 어떻게 해야할까? a. 동적 파라미터화란…동적 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 말한다. 나중에 실행될 메서드의 인수로 코드 블록을 전달할 수 있다. b. 변화하는 요구사항에 대응하기맨 처음 사과 요구사항을 자꾸 바꿔서 요청하는 예시를 해결해보자! b-1. 첫번째 시도. 녹색 사과 필터링1234567891011enum Color&#123;RED, GREEN&#125;public static List&lt;Apple&gt; filterGreenApple(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple:inventory)&#123; if(GREEN.equals(apple.getColor())&#123; result.add(apple); &#125; &#125; return result;&#125; 이 코드에서 만약 요구사항이 녹색 사과에서 빨간 사과를 수집하도록 바뀐다면 어떨까? 이럴 땐 이 규칙을 기억해야 한다. 거의 비슷한 코드가 반복 존재한다면 그 코드를 추상화한다. b-2. 두번째 시도, 색을 파라미터화123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, Color color)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory)&#123; if(apple.getColor().equals(color))&#123; result.add(apple); &#125; &#125; return result;&#125; 이런 식으로 코드를 짜면, 코드를 반복하여야지 않고 다양한 색에 대한 요구사항을 효율적으로 대응할 수 있을 것이다. 12List&lt;Apple&gt; greenApples = filterApplesByColor(inventory, GREEN);List&lt;Apple&gt; redApples = filterApplesByColor(inventory, RED); 하지만 사용자가 이번엔 색깔이 아닌 다른 요소(무게나 모양 등)로 요구사항을 제시한다면 어떻게 될까? 123456789public static List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple: inventory)&#123; if(apple.getWeight()&gt; weight)&#123; result.add(apple); &#125; &#125; return result;&#125; 이런 식으로 무게에 대한 새로운 메소드를 만들 수 있지만, 결국 색 필터링 코드와 대부분 중복된다.. 이런 중복된 코드는 성능 개선하려 할 때 메서드 전체 구현을 고쳐야 하는 대참사가 발생할 수 있다.. b-3. 세번째 시도, 가능한 모든 속성으로 필터링정말 해서는 안되는 방법이지만 이런 방법도 있긴하다. 123456789101112public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, Color color, int weight, boolean flag)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory)&#123; if((flag &amp;&amp; apple.getColor().equals(color)) ||(!flag&amp;&amp;apple.getWeight()&gt;weight))&#123; result.add(apple); &#125; &#125; return result;&#125;List&lt;Apple&gt; greenApples = filterApples(inventory, GREEN, 0, true);List&lt;Apple&gt; heaveyApples = filterApples(inventory, null, 150, false); 정말 형편없는 코드다.. 도대체 true와 false가 어떤 것을 의미하는 건가? 새로운 조건이 필요하면 어떻게 할 것인가? c. 동적 파라미터화요구 조건들을 어떤 속성에 기초해서 불리언값을 반환하는 형태로 구현할 수 있다. 참 거짓을 반환하는 함수를 프레디케이트 라고 한다. 123456789101112131415public interface ApplePredicate &#123; boolean test (Apple apple);&#125;public class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight()&gt;150; &#125;&#125;public class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return GREEN.equals(apple.getColor()); &#125;&#125; 이와 같은 방식을 전략 디자인 패턴이라고 부르는데, 각 알고리즘(전략이라고 부른다)을 캡슐화하는 알고리즘 패밀리를 정의해둔 다음에, 런타임이 알고리즘을 선택하는 기법이다. 즉 메서드가 다양한 동작(또는 전략)을 받아서 내부적으로 다양한 동작을 수행 할 수 있다. c-1. 네번째 시도, 추상적 조건으로 필터링ApplePredicate 인터페이스를 사용하면 이런 식으로 구현할 수 있다. 123456789public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory) &#123; if(p.test(apple)) &#123; result.add(apple); &#125; &#125; return result;&#125; 훨씬 좋아졌다!! 이를 바탕으로 무게가 150 이상이고 빨간 사과를 모아 달라는 요구조건을 해결해보자! 1234567public class AppleRedAndHeavyPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return RED.equals(apple.getColor())&amp;&amp; apple.getWeight()&gt;150; &#125;&#125;List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 우리가 전달한 ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정된다!!!! 안타깝게도 메서드는 객체만 인수로 받으므로 test메서드를 ApplePredicate 객체로 감싸서 전달해야 했다. d. 복잡한 과정 간소화위에서 구현한 방식, 즉 프레디케이트로 필터링 할 경우, 조건 마다 여러 클래스를 정의한 다음, 인스턴트화 해야 하므로 번거롭다. 이를 익명 클래스의 람다 표현식으로 해결해보자 d-1. 다섯번째 시도, 익명 클래스 사용익명 클래스는 자바의 지역 클래스와 비슷한 개념이다. 익명 클래스는 클래스 선언과 인스턴스화를 동시에 한다. 익명 클래스를 활용한 ApplePredicate 객체를 생성하는 방식으로 필터링해보자 12345List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123; public boolean test(Apple apple)&#123; return RED.equals(apple.getColor()); &#125;&#125;); filterApples 메서드의 동작을 익명클래스로 직접 파라미터화 했다. 하지만 익명 클래스는 여전히 문제가 많다. 일단 람다에 비해 차지하는 공간이 많고, 이해하기도 어렵다. d-2. 여섯번째 시도, 람다 표현식 사용람다 표현식을 사용하면 굉장히 간단하게 구현할 수 있다. 1List&lt;Apple&gt; result = filterApples(inventory, (Apple apple)-&gt; RED.equals(apple.getColor())); d-3. 일곱번째 시도, 리스트 형식으로 추상화이제 사과 말고 다양한 개체들이 필터링 될 수 있도록 활용해보자 12345678910111213141516public interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T e: list) &#123; if(p.test(e)) &#123; result.add(e); &#125; &#125; return result;&#125;List&lt;Apple&gt; redApples = filter(inventory, (Apple apple)-&gt;RED.equals(apples.getColor());List&lt;Integer&gt; evenNumbers = filter(numbers, (Integer I)-&gt;i%2==0); 람다 표현식으로 인터페이스를 보다 용이하게 구현했다!!!! **e. 실전 예제 **e-1 Comparator로 정렬하기List.sort나 Collections.sort에 java.util.Comparator 객체를 이용해서 sort의 동작을 파라미터화 해보자 123456789101112// java.util.Comparatorpublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;inventory.sort(new Comparator&lt;Apple&gt;() [ public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;);inventory.sort((Apple a1, Apple a2)-&gt;a1.getWeight().compareTO(a2.getWeight()));","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]},{"title":"4. 운영체제 구조 - 시스템콜, 커널 모드","slug":"cs/os/os4","date":"2021-07-29T06:22:24.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os4/","excerpt":"","text":"응용 프로그램, 운영체제, 컴퓨터 하드웨어 관계 운영체제는 프로그램이 요청하는 메모리를 허가, 분배 운영체제는 프로그램이 요청하는 CPU시간 제공 운영체제는 프로그램이 요청하는 IO device 사용을 허가 제어 사용자 - 응용 프로그램 - 운영체제 - 하드웨어 이런 식으로 연결된다고 보자! 운영체제는 사용자 인터페이스를 제공한다. 쉘(Shell) 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램. 쉘은 GUI환경과 CLI환경으로 나뉜다. 운영체제는 응용 프로그램을 위해서도 인터페이스를 제공한다 API(aplication programming interface) 프로그램이 운영체제에 뭔가를 요청할 수 있게 프로그램 안에 작성된 인터페이스 일종의 요청서로 이해하자. 함수로 제공된다. 각 언어별 운영체제 기능 호출 인터페이스 함수 시스템 콜 시스템 콜 또는 시스템 호출 인터페이스 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공 API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분. 운영체제 기능 호출 함수 운영체제를 만든다면? 운영체제를 개발한다.(kernel) 시스템 콜을 개발 C API(library) 개발 - 다른언어로도 개발 Shell 프로그램 개발 응용 프로그램 개발 운영체제와 시스템콜시스템 콜의 예시(POSIX API, 윈도우 API) CPU Protection Ringscpu도 권한 모드라는 것을 가지고 있다. 사용자 모드 커널 모드 : 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케하는 모드.이 사진에서 ring 3이 사용자 모드다. 가운데에 있는게 커널이다. 개발자가 만든 프로그램은 맨위에서 작동한다! 시스템콜은 커널 모드로 실행 커널 모드에서만 가능한 기능이 존재 커널 모드로 실행하려면, 반드시 시스템콜 거쳐야함 시스템콜은 운영체제 제공 왜 이렇게 나눴을까 함부로 응용 프로그램이 전체 컴퓨터 시스템을 해치지 못하게 하기 위함. 코드로 이해하기 정리 운영체제는 시스템 콜 제공 프로그래밍 언어 별 운영체제 기능을 활용하기 위한 시스템 콜 기반 API제공 응용 프로그램은 운영체제 기능 필요시 해당 API를 사용해 프로그램 작성 응용 프로그램 실행되서 운영체제 기능이 필요한 API를 호출하면, 시스템콜이 호출되서, 커널모드로 변경후, OS 내부에서 실행","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"3. 시대별로 이해하는 운영체제 핵심 개념","slug":"cs/os/os3","date":"2021-07-29T04:19:36.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os3/","excerpt":"","text":"1950년대ENIAC: 첫번째 컴퓨터.응용 프로그램 돌리기도 바빠 운영체제가 없었음. 응용 컴퓨터가 리소스를 관리. 1960년대 초반 프로그램 종류도 많아지고, 사용자도 늘기 시작. 배치 처리 시스템의 출현(batch processing system) 여러 응용 프로그램을 등록시켜놓으면, 순차적으로 실행시키는 시스템 두 프로그램의 순서를 일직선으로 실행.(하나에 한 프로그램만.) 프로그램을 어떤 순서로 등록하느냐에 따라 응용 프로그램의 실행 시간이 달라진다.(긴 프로그램하고 짧은 프로그램하기 vs 짧은 프로그램하고 긴 프로그램하기 였을 때 짧은 프로그램이 끝날때까지 얼마나 걸리나?) 단점 응답시간이 오래 걸릴 수 있다.(내 앞에 오래 걸리는 프로그램이 실행 될 경우) 실행시간도 오래 걸릴 수 있다.(CPU가 필요없는 상황에도 응용프로그램이 CPU를 점유 할 수 있음) 1960년대 후반 응용 프로그램이 CPU를 사용하는 시간을 쪼개서, 여러개의 응용 프로그램이 동시에 실행하는 기법 등장 시분할 시스템(Time Sharing System) : 다중 사용자 지원, 컴퓨터 응답 시간 최소화 멀티 태스킹(Multi Tasking) : 가능한 CPU를 많이 활용하도록 지원(시간 대비 CPU 사용률을 높이자.) 시분할 시스템컴퓨터 응답시간을 사용자가 요청하고 응답을 받을 때까지 걸린 시간이라고 한다.여러 사용자가 컴퓨터에 접속해 각 응용 프로그램을 실행하려고 할 때, 응답시간을 줄이는게 가장 중요하다.시분할 시스템은 시간을 특정 단위로 쪼개, 단위마다 각 프로그램들이 돌아가며 실행하는 방식이다. 멀티 태스킹단일 CPU에서 여러 응용 프로그램의 병렬 실행을 가능케하는 시스템.보통은 시분할 시스템과 비슷하게 통용되는 경우가 많음. 멀티 프로그래밍 : 최대한 CPU를 많이 활용하도록 하는 시스템어떤 프로그램이 CPU를 사용하는 시간 중 CPU가 아무 일도 안하는 시간은 다른 프로그램을 실행하도록 해주는 기능.(파일 입력을 기다리는 시간이 대표적) 1970년대 제대로 된 운영체제 등장 UNIX OS현대 운영체제의 기본 기술을 모두 포함한 최초의 운영체제 (멀티 태스킹, 시분할 시스템, 멀티 프로그래밍) 여기서 잠깐. 왜 C언어가 운영체제 개발에 필요한가?어셈블리 언어는 CPU와 메모리의 물리적인 주소로 직접 명령을 해서 개발한다. 이러면 각 컴퓨터마다 각각 다시 개발을 해줘야 된다..그런데 C언어는 컴파일러라는 녀석이 C언어를 해당 컴퓨터에 맞도록 어셈블리 언어로 변환해서 실행한다. 다른 컴퓨터에서 다시 작성할 필요가 없어진다. 1980년대 개인용 컴퓨터 시대 1980년대 이전에는 대형 컴퓨터에 여러 명이 접속해 사용(UNIX)1980년대 이후에는 PC시대가 시작. CLI에서 GUI로 전환 시작. CLI(command line interface) = 터미널 환경 = 키보드, 검은화면GUI(graphical user interface) = GUI 환경 = 마우스 1990년대 응용 프로그램 시대 (GUI 환경, PC 사용자 증가) 네트워크 기술 발전 - 월드와이드웹(WWW) 인터넷 대중화 오픈 소스 운동 활성화 2000년대 이후 오픈 소스 활성화(리눅스, 아파치, MySQL 등…) 가상 머신(가상으로 컴퓨터가 있는 것처럼 가상의 운영체제를 활용), 대용량 병렬 처리 활성화","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"2. 운영체제와 응용 프로그램의 관계","slug":"cs/os/os2","date":"2021-07-29T04:16:34.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os2/","excerpt":"","text":"응용 프로그램?응용 프로그램은 우리가 흔히 사용하는 엑셀이나 크롬같은 소프트웨어를 말한다.(그렇다고 모든 소프트웨어가 응용 프로그램인건 아니다. 우리가 공부하고 있는 운영체제도 소프트웨어 중 하나다.)즉 응용 프로그램은 소프트웨어 중 운영체제를 제외한 모든 소프트웨어를 의미한다. 운영체제와 응용 프로그램 간의 관계 운영체제는 응용 프로그램을 관리한다. 응용프로그램을 실행시킨다. 응용 프로그램간의 권한을 관리한다.(관리자 권한으로 실행) 응용 프로그램을 사용하는 사용자도 관리한다.(로그인 과정) 응용 프로그램의 잚못된 작동을 저지한다. 응용 프로그램이 잘못 동작해서, 프로그램을 정지시킨다. 모든 파일 삭제를 막는다.(권한/사용자 관리) 한 응용프로그램이 지나친 cpu소모를 막는다. 결국 이 둘의 관계는 응용 프로그램을 관리 시스템 자원을 관리 사용자 컴퓨터간의 커뮤니케이션 지원 운영체제는 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고 지원하는 소프트웨어!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"1. 운영체제의 역할은 무엇일까?","slug":"cs/os/os1","date":"2021-07-29T04:16:29.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os1/","excerpt":"","text":"운영체제 역할1: 시스템 자원(System Resource) 관리자 operating system 혹은 os라고 부름 시스템 자원 = 컴퓨터 하드웨어 cpu(중앙처리장치), 메모리(dram, ram) IO devices (monitor, mouse, keyboard, network…) 저장매체: SSD, HDD 컴퓨터의 하드웨어는 혼자서 뭘 혼자 하지 못한다. 운영체제가 이를 운영한다. 대표적인 운영체제 windows os, mac os, unix unix는 현대 os의 기술을 최초로 구현한 운영체제. 윈도우즈와 맥 운영체제도 영향을 받았음 unix 계열 os unix 사용법이나 os구조가 유사(리눅스가 대표적.) 운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원운영체제 역할3: 컴퓨터 하드웨어와 프로그램을 제어컴퓨터 하드웨어 뿐만 아니라, 프로그램을 관리한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[]},{"title":"7. 힙","slug":"cs/datastructure/ds7","date":"2021-07-28T13:02:01.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds7/","excerpt":"","text":"힙힙을 알기 위해서는 트리에 대한 기본적인 지식이 필요하다. 힙의 특성어떤 특정 값을 찾아내는 기능은 지원하지 않지만,값을 삽입하고, 최대값(최소값)을 찾거나 삭제하는데 큰 강점을 가진 자료구조.만약 최소값을 찾거나 삭제하고 싶으면 힙성질을 반대로 설정하면 된다. 간단한 용어 설명 트리 표현법 표현법 1: level 0 부터 해당 노드 자리에 노드가 있으면 노드이름을 쓰고, 없으면 None이라고 써서 가능한 모든 자리만큼 원소를 갖는 리스트로 표현. 표현법 2: 트리의 수직적 관계를 리스트 속 리스트를 활용해 표현하기. [부모노드, [부모노드의 왼쪽 서브트리], [부모노드의 오른쪽 서브트리]]. 이때 빈 노드나 서브트리는 빈 리스트 []로 표현한다. 표현법 3: 노드 클래스 활용 각 노드를 노드클래스로 구현해서 객체를 부여해 구현. 힙이란? 힙이란 1차원 배열 중 저장된 값이 힙 조건에 만족하는 배열을 의미. 힙조건힙 조건에는 크게 모양 조건과 값 조건이 있다. 모양 조건 : 리스트(배열)을 이진트리로 해석했을 경우. 마지막 레벨을 제외한 각 레벨엔 빠짐없이 노드가 존재한다. 마지막 레벨의 노드는 왼쪽부터 차례대로 빈틈없이 채워진다. 값 조건루트 노드를 제외한 모든 노드의 값은 부모 노드의 값보다 크지 않아야 한다!!(또는 각 노드의 값은 자신의 자손 노드들의 값보다 같거나 커야 한다.) 인덱스 값 구하기힙 조건을 만족하는 배열(리스트)A의 노드 A[k]가 있을 때, 왼쪽노드 : A[2k+1] 오른쪽노드 : A[2k+2] 부모노드 : A[(k-1)/2] 이렇게 왼쪽, 오른쪽, 부모 노드의 인덱스를 구할 때는 O(1)의 복잡도를 가진다. 힙 값 조건을 만족시키도록 만드는 연산힙이 될려면, A[k]가 자신의 자식 노드들과 같거나 커야한다. 이를 위해 A[k]를 자식노드와 비교 하면서 더 큰 자식을 찾으면 서로 swap해줘야 한다.(인덱스로 하면 된다.) 이 과정을 더이상 할 필요가 없을때까지 반복하면 힙의 값 조건을 만족하게 된다. 1234567891011121314151617def heapify_down(self, k, n): while 2*k+1&lt;n: L,R = 2*k+1 , 2*k+2 if L&lt;n and self.A[L] &gt; self.A[k]: m=L else: m = k if R&lt;n and self.A[R] &gt; self.A[m]: m = R if m != k: self.A[k], self.A[m] = self.A[m], self.A[k] k = m else : breakdef make_heap(self): n = len(self.A) for k in range(n-1, -1, -1): self.heapify_down(k, n) heapify_down 연산은 O(힙의 높이)이고, make_heap의 연산은 heapify_down연산을 n번 하는 것이므로 O(n*힙높이)이다. 힙의 높이와 힙 원소 갯수 사이의 관계 힙의 높이를 h라고 하고 원소 갯수 n개라고 했을 때, 레벨 0 :1개 / 레벨 1: 2개 / 레벨 3: 4개 …..레벨 h-1 : 2^(h-1) / 레벨 h : 최소 1개 이다. 즉 1+2+4+8+….2^(h-1)+1 &lt;=n 이 되고, (2^h -1) / (2-1) + 1 &lt;= n 2^h-1+1 &lt;= n 2^h&lt;=n h &lt;= logn 이라는 관계가 성립한다. 이 관계를 토대로 heapify_down 과 make_heap 연산을 보면, heapify_down은 O(log n), make_down은 O(nlog n) 엄밀히 말하면 O(n)이다. 이 된다. 힙 정렬힙 조건을 만족하는 배열을 정렬시키는 방법. 주어진 배열 A가 힙일 경우, 힙의 루트 노드에는 항상 전체의 최대값이 저장되어 있다 루트 노드의 값(현재 최대값) A[0]을 현재 리스트의 가장 마지막 값과 바꾼다. 새로 루트 노드에 온 값은 힙 성질을 만족하지 않을 수 있다. 루트 노드를 heapify_down 을 통해 힙의 위치를 찾아가도록 한다. 위 과정을 (n-1)번 반복하면 (n-1)개가 정렬되어 모든 n이 정렬된다. 123456def heap_sort(self): n = len(self.A) for k in range(len(self.A)-1, -1, -1): self.A[0], self.A[k] = self.A[k], self.A[0] n = n -1 self.heapify_down(0, n) heap_sort의 수행시간은 루트노드와 마지막 리프노드 자리바꾸고 heapify를 (n-1)번 하므로, (n-1)*O(log n) = O(nlog n) 힙 삽입일단 삽입할 값을 리프노드로 넣고, 힙 성질에 맞는 위치로 가도록 올려보내는 것. 일단 힙 성질에 맞는 위치로 가는 heapify_up 함수를 만들어 insert함수에 적용시키도록 해보자! 1234567def heapify_up(self, k): while k&gt;0 and self.A[(k-1)//2 ] &lt; self.A[k] : self.A[k], self.A[(k-1)//2] = self.A[(k-1)//2], self.A[k] k = (k-1)//2def insert(self, key): self.A,append(key) self.heapify_up(len(self.A)-1_ insert의 수행시간은 O(h=log n) 시간이 걸린다. 최대값을 찾고 삭제하기이전에도 여러번 말했듯이, 힙에서 최대값은 바로 루트노드다!최대값을 찾는다면 그냥 A[0]을 반환하면 된다! 참 쉽다! 근데 최대값을 삭제하는건 좀 까다롭다.최대값을 삭제하고 나서도 힙을 유지하려면 약간의 조정이 필요하기 때문이다. 최대값 삭제일단 최대값을 삭제하려면 루트 노드를 지우고, 맨 마지막 리프노드를 루트 노드 자리에 둔다.그러면 당연히 힙 조건을 벗어나게 되는데, heapify_down 연산을 통해 힙 성질을 만족시킨다! 1234567def delete_max(self): if len(self.A) == 0 : return None key = self.A[0] self.A[0], self.A[len(self.A)-1] = self.A[len(self.A)-1], self.A[0] self.A.pop() heapify_down(0, len(self.A)) return key 최대값 삭제의 경우, 루트노드와 마지막 노드 자리바꾸고 heapify_up하므로 O(h = log n) 시간이 걸린다. 수행시간 정리 heapfify_up, heapify_down : O(log n) make_heap : O(n log n) -&gt; O(n) insert : O(log n) delete_max : O(log n) heap_sort : O(n log n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"6. 이진트리","slug":"cs/datastructure/ds6","date":"2021-07-28T11:27:03.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds6/","excerpt":"","text":"이진트리? 자식노드가 최대 2개 뿐인 트리를 이진트리라 한다!! 1234567891011121314class Node: def __init__(self, key, parent=None, left=None, right=None): self.key = key self.parent = parent self.left = left self.right = right def __str__(self): return str(self.key) class Tree: def __init__(self): self.root = None self.size = 0 이진트리의 순회이진트리 노드 key값을 빠짐없이 출력하는 방법! preorder inorder postorder 헤더 노드를 M, 왼쪽 서브트리를 L, 오른쪽 서브트리를 R이라고 가정! 쉽게 생각하면 L, M, R이 삼각형 모양으로 있을 때 우선순위 노드가 있으면 해당 노드를 먼저 탐색하는 방식이다! preorderMLR 순으로 방문하는 방식FBADCEGIH 순으로 방문하게 된다! inorderLMR 순으로 방문하는 방식ABCDEFGHI postorderLRM 순으로 방문하는 방식ACEDBHIGF 코드로 구현하기1234567891011121314151617181920212223242526272829303132class Node: def __init__(self, key, parent=None, left=None, right=None): self.key = key self.parent = parent self.right = right self.left = left def __str__(self): return str(self.key) class Tree: def __init__(self): self.root = None self.size = 0 def preorder(self, v): if v: print(v.key, end=&#x27; - &#x27;) self.preorder(v.left) self.preorder(v.right) &#x27;&#x27;&#x27; inorder는? if v: self.inorder(v.left) print(v.key, end=&#x27; - &#x27;) self.inorder(v.right) postorder는? if v: self.postorder(v.left) self.postorder(v.right) print(v.key, end=&#x27; - &#x27;) 즉 재귀 알고리즘을 활용하여 print문의 위치를 바꿔가면서 구현하는거다!!!&#x27;&#x27;&#x27; 이진탐색트리 BST이진트리 중에 가장 많이 쓰이는 트리!이진트리의 노드를 search할 때 효율적으로 할 수 있게! 특징 각 노드의 왼쪽 서브트리의 key값은 노드의 key값보다 작거나 같아야 한다. 반면 오른쪽 서브트리의 key값은 노드의 key값보다 작거나 같아야 한다. 이런 특징이 탐색이 효율적으로 되게 한다!이진트리의 탐색 연산은 O(h=트리 높이)이므로, 만약 이진트리의 강점을 극대화하고 싶으면, 트리의 높이를 최소화 하는 방향으로 설계해야 한다! 코드로 구현 12345678class BST: def __iniit__(self): self.root = None self.size = 0 def __len__(self): return self.size def __iter__(self): return self.root.__iter__() 탐색 함수 search와 삽입 함수 insert탐색 함수와 삽입함수를 구현하기 전에, 해당 노드가 있다면, 해당 노드를 반환하고, 없다면 노드가 삽입될 위치의 부모노드를 반환하는 find_loc 함수를 먼저 구현해보자! 12345678910111213def find_loc(self, key): if self.size == 0: return None p = None v = self.root while v != None: if v.key == key : return v elif v.key &lt; key : p = v v = v.right else : p = v v = v.left return p 이제 find_loc함수를 활용해 search함수를 만들어보자! 123456def search(self, key): v = self.find_loc(key) if v and v.key==key: return v else : return None 노드를 삽입하는 insert함수도 만들 수 있다! 1234567891011def insert(self, key): v = Node(key) if self.size==0 : self.root = v else : p = self.find_loc(key) if p and p.key != key: if p.key &lt; key: p.right = v else : p.left = v v.parent = p self.size += 1 return v 여기서 잠깐 생각해보자. 만약 삽입 연산을 한다고 할 때, 삽입 순서에 따라 트리 모양도 달라질 수 있을까? find_loc, insert, search의 수행시간search, insert 모두 find_loc의 수행시간과 동일하다. (그 외 연산은 모두 상수시간에 이뤄지니까)find_loc은 최악의 경우 트리의 높이 만큼 수행시간이 걸리므로, O(h) 이다. 삭제 함수 delete이진 트리에서는 크게 두가지 방법이 있다. delete by merging delete by copying delete by merging어떤 노드를 지우게 되면 그 노드의 왼쪽 서브트리가 지운 노드의 자리에 오고 지운 노드의 오른쪽 서브트리는 왼쪽 서브트리의 자식 노드가 된다! 이때 삭제할 노드가 루트노드인 경우와 그렇지 않은 경우 두가지로 나뉜다. 삭제할 노드를 x, 왼쪽 자식노드 a, 오른쪽 자식노드 b, x의 왼쪽 서브트리중 가장 큰 노드 m이라 하고 x의 부모노드를 pt라고 하자. 만약 삭제할 노드가 루트노드일 경우 m이 존재 할 경우(if a!=None) : b가 m의 오른쪽 자식노드가 되도록 링크 수정, a가 루트노드가 되도록 변경 a == None이면 : b가 새로운 루트노드가 됨만약 삭제할 노드가 루트노드가 아닌 경우 m이 존재 할 경우(if a!=None) : b가 m의 오른쪽 자식노드가 되도록 링크 수정, a가 pt의 자식노드가 되도록 변경 a == None이면 : b가 pt의 자식노드가 되도록 변경 코드로 구현해보자 12345678910111213141516171819def deleteMerging(self, x) &#123; a, b, pt = x.left, x.right, x.parent if a == None: c = b else: c = m = a while m.right: m = m.right m.right = b if b: b.parent = m if self.root == x : #c가 새로운 루트노드가 된다. if c: c.parent = None self.root = c else : if pt.left == x : pt.left = c else: pt.right = c if c: c.parent = pt self.size -= 1&#125; delete by copying어떤 노드 x를 삭제하려 할 때, 왼쪽 서브 트리를 L, 오른쪽 서브 트리를 R이라고 하자. L에서 가장 큰 노드 y를 찾는다. y의 key 값을 x의 key값으로 카피한다. y의 왼쪽 서브트리가 존재하면, y의 자리로 옮긴다. 코드로 만들어보자 123456789101112131415161718def deleteByCopying(self, x)&#123; L, R = x.left, x.right if L == None : x.key = R.key if R.right: x.right = R.right R = None else : m = L while m.right: pt = m m = m.right x.key = m.key if m.left: pt.right = m.left m.left.parent = pt m = None&#125; delete by merging, delete by copying 의 수행 시간 두 연산 모두 지우려는 노드의 왼쪽 서브트리에서 가장 큰 노드 m을 찾는 연산이 중요. 두 경우 모두 최악의 경우 트리의 높이까지 m을 찾아야 하므로, O(h)이다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"5. 스택과큐","slug":"cs/datastructure/ds5","date":"2021-07-28T11:00:30.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds5/","excerpt":"","text":"a. 스택 Stack차례대로 삽입하고 최근에 저장된 값을 삭제(FILO) push스택에 값 추가pop가장 나중에 push된 값을 스택에서 제거하고 반환top가장 나중에 push된 값을 제거하지 않고 반환__len__스택의 저장된 요소 갯수를 반환isEmpty스택에 요소가 존재하는지 참거짓 1234567891011121314151617181920212223242526272829# stack_queue.py 에 저장class Stack: def __init__(self): self.items = [] # 데이터 저장을 위한 리스트 준비 def push(self, val): self.items.append(val) def pop(self): try: # pop할 아이템이 없으면 return self.items.pop() except IndexError: # indexError 발생 print(&quot;Stack is empty&quot;) def top(self): try: return self.items[-1] except IndexError: print(&quot;Stack is empty&quot;) def __len__(self): # len()로 호출하면 stack의 item 수 반환 return len(self.items) def isEmpty(self): return self.__len__() == 0# for testS = Stack()S.push(10)S.push(2)print(S.top())print(S.pop())print(len(S))print(S.isEmpty()) b. 스택 활용b-1. 괄호짝 맞추기입력 값 : 괄호로 이뤄져 있는 문자열 ex. ()()() 반환 값 : 괄호 짝이 맞는지 참 거짓 ex. True 12345678910111213141516171819202122232425262728293031323334353637383940class Stack: def __init__(self): self.item=[] def push(self, a): self.item.append(a) def pop(self): try: return self.item.pop() except IndexError: print(&#x27;Stack is empty.&#x27;) def top(self): try: return self.item[-1] except IndexError: print(&#x27;Stack is empty.&#x27;) def __len__(self): return len(self.item) def isEmpty(self): return len(self.item)==0 # pseudo codedef parChecker(parSeq): S=Stack() for i in parSeq: if i ==&#x27;(&#x27;: S.push(&#x27;(&#x27;) elif i ==&#x27;)&#x27;: if S.isEmpty(): print(False) return False else : S.pop() if S.isEmpty(): print(True) return True else : print(False) return FalseparSeq=list(input())parChecker(parSeq) b-2. infix 수식을 postfix로 바꾸기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Stack: def __init__(self): self.items = [] def push(self, val): self.items.append(val) def pop(self): try: return self.items.pop() except IndexError: print(&quot;Stack is empty&quot;) def top(self): try: return self.items[-1] except IndexError: print(&quot;Stack is empty&quot;) def __len__(self): return len(self.items) def isEmpty(self): return self.__len__() == 0def infix_to_postfix(infix): opstack = Stack() outstack = [] token_list = infix.split() # 연산자의 우선순위 설정 prec = &#123;&#125; prec[&#x27;(&#x27;] = 0 prec[&#x27;+&#x27;] = 1 prec[&#x27;-&#x27;] = 1 prec[&#x27;*&#x27;] = 2 prec[&#x27;/&#x27;] = 2 prec[&#x27;^&#x27;] = 3 for token in token_list: if token == &#x27;(&#x27;: opstack.push(token) elif token == &#x27;)&#x27;: while True: if opstack.top()==&#x27;(&#x27;: opstack.pop() break else : outstack.append(opstack.pop()) elif token in &#x27;+-/*^&#x27;: while True: if opstack.isEmpty(): opstack.push(token) break elif prec[opstack.top()]&gt;=prec[token]: outstack.append(opstack.pop()) else: opstack.push(token) break else: # operand일 때 outstack.append(token) # opstack 에 남은 모든 연산자를 pop 후 outstack에 append for i in range(opstack.__len__()): outstack.append(opstack.pop()) return &quot; &quot;.join(outstack)infix_expr = input()postfix_expr = infix_to_postfix(infix_expr)print(postfix_expr) b-3. Postfix 계산12345678910111213141516171819202122232425262728293031323334353637383940class Stack: def __init__(self): self.items=[] def push(self, val): return self.items.append(val) def pop(self): try: return self.items.pop() except IndexError: print(&#x27;stack is empty&#x27;) def top(self): try: return self.items[self.items.len()-1] except IndexError: print(&#x27;stack is empty&#x27;) def __len__(self): return self.items.len()def compute_postfix(postfix): opstack = Stack() token_list = postfix.split() for i in token_list: if i in &#x27;+-*/^&#x27;: a=opstack.pop() b=opstack.pop() if i ==&#x27;+&#x27;: opstack.push(a+b) elif i ==&#x27;-&#x27;: opstack.push(b-a) elif i ==&#x27;*&#x27;: opstack.push(a*b) elif i ==&#x27;/&#x27;: opstack.push(b/a) elif i ==&#x27;^&#x27;: opstack.push(b**a) else: opstack.push(int(i)) print(&#x27;%.4f&#x27;%opstack.pop())postfix=input()compute_postfix(postfix) c. 인터뷰 문제1. 스택을 하나 혹은 두개 사용해 push, pop, min 세 연산 모두 O(1) 시간에 수행되도록 하려면? 2. 스택 두 개를 써서 큐를 구현해라.(enqueue, dequeue를 구현하라) a. 큐 Queue가장 최근에 저장된 값 다음에 저장. 반환은 가장 먼저 저장된 값부터. FIFO(First in First out)원칙. enqueue큐의 오른쪽에 삽입(push와 같음)dequeue가장 왼쪽에 저장된 값을 삭제 후 리턴front가장 왼쪽에 저장된 값을 삭제하지 않고 리턴isEmpty큐가 비어져있는지 참거짓len큐의 요소 갯수 반환 12345678910111213141516171819202122class Queue: def __init__(self): self.items=[] self.front_index=0 #다음 dequeue될 값의 인덱스 def enqueue(self, val): self.items.append(val) def dequeue(self): if len(self.items)==0 or self.front_index==len(self.items): print(&quot;Queue is empty&quot;) else : x = self.items[self.front_index] self.front_index +=1 return x def front(self): if len(self.items) ==0 or self.front_index == len(self.items): print(&quot;queue is empty&quot;) else: return self.items[self.front_index] def __len__(self): return len(self.items)-self.front_index def isEmpty(self): return len(self) dequeue를 상수시간에 실행하기 위해선 dequeue가 될 값의 인덱스를 저장하고 관리해야 한다. -&gt; dequeue가 되면, 그 값을 실제로 지우는 것이 아닌 front_index값을 하나 늘려가며 다음 dequeue 될 예정 값의 인덱스를 가르키도록 관리한다. 실제로 dequeue될 때마다 값을 삭제시키면, 모든 값들을 한 칸씩 왼쪽으로 이동하는 시간이 소요되게 된다.O(n) a-1. 큐 활용 : Josephus game12345678910import Queue #큐 클래스 import. 이 부분은 달라질 수 있음def Josephus(n, k): Q=Queue() for v in range(1, n+1): Q.enqueue(v) while len(Q)&gt;1: for i in range(1, k): Q.enqueue(Q.dequeue()) Q.dequeue() #k번째 수 제거 return Q.dequeue() b. Dequeue왼쪽과 오른쪽에서 모두 삽입과 삭제가 가능한 큐 두 가지 버전의 pop과 push 연산을 구현 python collections 모듈에 deque 클래스로 구현되어 있음(덱으로 발음) 오른쪽 push : append / 왼쪽 push : appendleft 오른쪽 pop : pop / 왼쪽 pop : popleft","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"4. 해쉬테이블","slug":"cs/datastructure/ds4","date":"2021-07-28T11:00:17.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds4/","excerpt":"","text":"a. 해시테이블해시 테이블은 일종의 정보를 저장하는 서랍장. a는 2층에 b는 3층에 c는 1층에 넣어두는 방식…b를 보고 싶으면 어떤 서랍에 넣었는지 알아내서, 3층 서랍에 있는 내용 중에 b와 일치하는 것을 찾는 것. 해시테이블은 삽입, 삭제, 검색 연산을 빨리 처리할 수 있다. 만약 순서대로 정보를 서랍장에 넣었을 경우, 어떤 정보를 찾으려 할 때 일일히 순차적으로 찾아야 된다. 하지만 해시테이블은 그런 식으로 연산하지 않는다. 바로 해시 함수라는 것을 이용하기 때문에 보다 빠른 연산속도를 갖는다. 해시테이블 자료구조에서 가장 핵심은 각 정보들을 어떤 서랍에 넣을지를 결정하는 것!!! 정보를 어떤 서랍장(슬롯)에 넣을지를 결정하는 것이 바로 해시 함수!!!(f()로 표현) 예를 들어, 해시 테이블 H를 int H[10]으로 선언해 사용한다고 하자 해시 함수는 f(K) = K % 10로 정의했다고 하자. K = 28은 H[f(28)] 슬롯에 저장된다. 즉 H[8]에 저장된다. 근데 K = 18도 H[8]에 저장되어야 한다. 근데 이미 H[8]에는 28이 저장되어 있다. 이런 경우를 충돌이 발생했다고 한다. 충돌이 발생한 경우, 해당 슬롯에 18도 저장할 공간이 더 있으면 그냥 저장하면 되지만, 그렇지 않은 경우 18을 다른 곳에 저장해야한다. 이때 다른 곳을 정하는 방법을 충돌해결방법이라 한다. 결국 해시테이블에서 중요한 건 테이블을 어떤 방식으로 저장할 것인가? : 파이썬에서는 리스트로 저장 해시 함수를 어떻게 만들 것인가? 충돌 해결은 어떻게 할 것이가? 이렇게 세가지가 성능을 좌우한다. b. 해시 함수해시 함수에는 어떤 것들이 있는지 살펴보자. b-1. 완전 해시 함수 충돌없이 일대일 매핑하는 해시 함수 예를 들어 100개의 슬롯을 가지고 있는 H에 50개의 값을 저장한다고 할때, 100^50=10^100개의 함수가 만들어질 수 있는데, 완전 해시 함수는 100C50 = 10^94이므로, 임의의 함수고 완전 해시 함수일 확률은 10^-6으로 아주 작다… 비현실적이고, 구현하기도 까다롭다. b-2. c-universal 해시 함수서로 다른 두 key 값 x, y에 대해 prob(f(x)==f(y)) = c/size(H)이 성립하는 해시 함수 즉 f(x)와 f(y)가 같을 가능성이 c/size(H)인 해시 함수를 c-universal 해시 함수라고 한다. 여기서 c는 0보다 큰 실수 상수이다. 비교적 골고루 매핑하고 완전해시 함수보다 계산하기 쉬워 현실적이다. b-3. 현실에서 자주 쓰이는 해시 함수들 (key값이 수일 경우)m = 해시테이블의 크기 mod = 나머지를 구하는 연산 Division : f(k) = (k mod p) mod m (p = 소수) key 값들의 성질이 잘 알려져 있지 않은 경우에 유용 Folding : key 값이 digit를 나눠 연산하는 형식 k=1254-387-601 이라 할 때, shift folding : 두 digit씩 나눠 모두 더한 뒤 mod m -&gt;(12+54+38+76+01) mod m boundary folding : 여러 digit로 나눈 후 더하는데 짝수번 조각은 거꾸로해서 더함 -&gt;(12+45+38+67+01)mod m Mid-Square : key 값을 적당히 연산 후, 그 결과의 중간 부를 떼어나 주소로 이용 m = 1000, k = 3121 이면, 3121^2=9740641에서 중간에 3digit를 떼어낸 406이 주소가 됨 Extraction : key 값의 각 파트마다 임의의 digit을 떼어내 연결 k=1254-387-601 일 때 1254의 12, 601에서 1을 떼어내 121을 주소로 함 b-4. 현실에서 자주 쓰이는 해시 함수들 (key값이 문자열일 경우)key[i]는 ascii 코드 값 정도로 하자. Additive hash : key[i]의 단순 합 Rotating hash : &lt;&lt;, &gt;&gt;(비트 쉬프트) 연산과 ^(xor, exclusive or) 연산을 반복 Universal hash #좋은 해쉬 함수란? 충돌이 적어야 한다. 빠르게 계산할 수 있어야 한다. c. 충돌 해결 방법충돌 해결 방법에는 Open addressing과 Chasing 두 가지 방법이 있다. c-1. Open addressing : linear probing예시를 통해 이해해보자! H의 슬롯에는 값 하나만 저장할 수 있다고 가정 해시 함수에 의해 알파벳 다음 수가 저장될 슬롯이라고 가정하자 open addressing은 내가 들어갈 자리가 이미 차 있다면(충돌이 발생했다면) 아래쪽 슬롯으로 순차적으로 탐색하면서 가장 먼저 만난 빈 슬롯에 저장하는 것이다. 만약 마지막 자리까지 차있다면, 맨 처음 슬롯부터 다시 빈 자리를 찾는다. c-1-1. open addressing : linear probing 구현해시 테이블 H의 각 슬롯에는 하나의 아이템을 저장한다고 하자. 아이템은 (key, value) 쌍으로 정의되는데,key는 아이템을 구분하는데 쓰이므로 서로 달라야 하고, value는 해당 아이템의 정보를 의미한다. 123456789class HashOpenAddr: def __init__(self, size=10): self.size = size self.keys = [None]*self.size self.values = [None]*self.size def __iter__(self): for i in range(self.size): yield self.keys[i] c-1-2. 삽입 연산find_slot(key) :key값을 갖는 아이템을 찾아 슬롯 번호를 리턴 key값을 갖는 아이템을 못 찾으면, 해당 아이템이 저장되어야 할 슬롯 번호를 리턴 만약 슬롯이 존재하지도 않고 빈 슬롯도 없으면 FULL 리턴 1234567def find_slot(self, key): i = self.hash_function(key) start = i while self.keys[i] != None and self.keys[i] != key: i = (i+1) % self.size if i == start : return None return i set(key, value) : find_slot(key)를 요긴하게 사용한다!!key 값을 갖는 아이템이 테이블에 있으면 해당 아이템의 value를 매개변수 value로 수정하고 key 리턴 없다면 새 아이템 (key, value) 삽입하고 key 리턴 테이블에 빈 슬롯이 없어 삽입하지 못하고 key 값을 갖는 아이템도 못찾았으면 FULL 리턴 12345678910def set(self, key, value=None): i = self.find_slot(key) if i == None: return None if self.keys[i]!=None: self.values[i]=value else: self.keys[i]=key self.values[i] = value return key c-1-3. 삭제 연산remove(key): 어려우니 천천히 살펴보자 key값을 갖는 아이템을 find_slot(key)를 통해 찾고 i에 저장하자 H[i]에 해당 값이 없다면, 삭제할 아이템이 실제로 존재하지 않음을 의미. None 리턴 H[i]가 존재하면, 이 아이템이 삽입 될 때 다른 아이템이 아래쪽으로 밀렸을 가능성을 생각해야한다 아래쪽으로 밀린 아이템이 있다면, 해당 아이템들을 연쇄적으로 위로 올려야 한다. 일단 H[i]를 지우고, 아래 쪽 H[j]에 있는 아이템들을 H[i]로 이동할지 결정해야 한다. H[j]의 키 값을 해시함수 결과값을 k로 하자. (즉 원래 들어가야했을 자리를 k라고 하자) 이때 k가 i&lt;k&lt;=j 면 H[j]를 H[i]로 옮기면 안된다! 왜냐면, 원래 위치 k가 j에 있게 된 이유가 i 때문은 아니라는 것을 의미하기 때문이다. 즉 i에 밀려 j로 간 게 아니다.(다른 이유로 밀렸을 것이다.) 또한 해시 테이블은 원형이기 때문에, i &gt; j 일 가능성도 있다 그러면 j가 한바퀴를 돌아 j&lt;i&lt;k, k&lt;=j&lt;i 이 두 구간도 옮기면 안된다. (i때문에 k에 있어야 할 게 j로 간 것이 아니므로) 이 세가지 경우가 아니라면, H[j]를 H[i]로 옮긴다. (결국 옮기는 경우는 두가지다. k값이 i와 같거나(i 때문에 j로 밀림) k&lt;i&lt;j 이거나 (k에 이미 값이 있어서 내려왔는데 i에도 값이 있어 j로 간 경우)) 그러면 이제 H[j]가 빈 슬롯이 되니 다시 4번으로 돌아가 반복한다. 123456789101112131415161718def remove(self, key): i = self.find_slot(key) j = i if i == None : return None if self.keys[i] == None : return None while True: self.keys[i]=None self.values[i]=None while True: j = (j +1) % self.size if self.keys[j] == None: return key k = self.hash_function(self.keys[j]) if not (i&lt;k&lt;=j or j&lt;i&lt;k or k&lt;=j&lt;i): break self.keys[i] = self.keys[j] self.values[i] = self.values[j] i = j c-1-4. 탐색 연산search(key) :key 값을 갖는 아이템을 찾아 value(혹은 key)값을 리턴 없으면 None 리턴 123456def search(self, key): i = self.find_slot(key) if i != None: if self.keys[i] != None: return self.keys[i] return None c-2. Chaining슬롯에 값 하나만 저장하는게 아니라, 각 슬롯마다 연결리스트를 연결하여 슬롯 당 이론적으로 무한한 갯수 값을 저장하는 방법 1234567891011121314151617181920212223242526class HashChain: def __init__(self, m): self.size = m # 슬롯의 갯수 m self.H = [None] * self.size def hash_function(self, key): return f(key) # return hash value for key def find_slot(self, key): # chaining이므로 빈 슬롯을 찾을 필요없이 해시함수값을 리턴 return self.hash_function(key) def set(self, key, value): i = self.find_slot(key) v = self.H[i].search(key) if v == None: # key 값을 갖는 노드가 없다면 삽입연산 self.H[i].pushFront(key, value) # (key, value) 노드를 head 노드 위치에 삽입! else: # 기존의 key값을 갖는 노드가 있으므로 value값 수정 v.value = value def remove(self, key): i = self.find_slot(key) v = self.H[i].search(key) if v == None return NOTFOUND else: self.H[i].deleteNode(v)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"3. 양방향리스트","slug":"cs/datastructure/ds3","date":"2021-07-28T11:00:09.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds3/","excerpt":"","text":"a. 왜 양방향 연결 리스트가 필요한가?한방향 연결 리스트는 다음 노드를 연결하는 링크만 존재, 이전 노드를 알려면 head부터 다시 탐색을 해야된다… 이런 불필요한 연산을 줄이고자 이전 노드를 연결하는 링크가 있는 양방향 연결 리스트를 구현하고자 한다. 양방향 연결 리스트의 주요 개념은 다음과 같다. 이전 노드로의 링크(prev)를 포함해 이전 노드로 이동 가능 마지막 노드와 첫 노드가 서로 연결된 원형 리스트를 가정 첫 노드(head)는 항성 dummy 노드가 되어야 함 (dummy 노드는 리스트의 처음을 구분해주는 마커 기능을 하는 특별한 노드다.) b. 노드 클래스1234567class Node: def __init__(self, key=None): self.key = key self.next = self.prev = self #두개의 링크가 자기 자신에게 향함 def __str__(self): #print(node)했을 경우 출력할 문자열 return str(self.key) c. 양방향 연결 리스트 클래스12345678class DoublyLinkedList: def __init__(self): self.head = Node() self.size = 0 #아래 함수들은 한방향 리스트와 같다. def __iter__(self): def __str__(self): def __len__(self): c-1. splice(a,b,x) 연산 *중요*노드 a부터 노드 b까지를 떼어내 노드 x 뒤에 붙여 넣는 연산 이때, 두 가지 조건이 만족되어야 한다. 조건 1 : a와 b가 동일하거나 a 다음에 b가 나타나야 함 조건 2 : head 노드(dummy)와 x는 a와 b 사이에 포함되면 안됨. 1234567891011121314151617def splice(self, a, b, x): if a == None or b == None or x == None : return ap = a.prev bn = b.next #자르는 연산 ap.next = bn bn.prev = ap #x뒤에 a~b를 삽입 xn = x.next xn.prev = b b.next = xn a.prev = x x.next = a c-2. 탐색 및 기본 연산search(key) : key 값 가지는 노드 리턴, 없으면 None 리턴 isEmpty() : 빈 리스트면 True, 아니면 False first(), last() : 처음과 마지막 노드를 리턴, 빈 리스트면 None 리턴 12345678910111213141516171819202122232425262728def search(self, key): v = self.head while v.next !=self.head: if v.key==key: return v v=v.next return Nonedef isEmpty(self): v = self.head if v.next ==self.head: return True else: return False def first(self): v = self.head if v.next!=self.head: return v.next else: return None def last(self): v = self.head if v.prev != self.head: return v.prev else: return None c-3. 이동과 삽입 연산*splice 함수가 매우 빈번하게 사용된다!!!!* 1234567891011121314151617def moveAfter(self, a, x): #노드 a를 노드 x 뒤로 이동 self.splice(a, a, x) #a를 떼어내어 x뒤로 붙인 것과 같다def moveBefore(self, a, x): #노드 a를 노드 x 앞으로 이동 self.splice(a, a, x.prev)def insertAfter(self, x, key): #key값을 갖는 노드를 x뒤에 삽입 moveAfter(Node(key), x)def insertBefore(self, x, key): #key값을 갖는 노드를 x앞에 삽입 moveBefore(Node(key), x) def pushFront(self, key): # key값을 갖는 노드를 헤드 뒤에 삽입 insertAfter(self.head, key)def pushBack(self, key): # key값을 갖는 노드를 헤드 앞에 삽입 insertBefore(self.head, key) c-4. 삭제 연산remove(x) : 노드 x를 제거 만약 key값만 알고 노드 이름을 모르면 search(key)로 하여 노드 이름을 찾는다. popFront() : head 다음에 있는 노드의 데이터 값 리턴. 빈 리스트면 None popBack() : head 이전에 있는 노드의 데이터 값 리턴. 빈 리스트면 None 12345678910111213141516def remove(self, x): if x == None or x == self.head: return x.prev.next, x.next.prev = x.next, x.prev def popFront(self): if self.isEmpty(): return None key = self.head.next.key self.remove(self.head.next) return key def popBack(self): if self.isEmpty(): return None key = head.prev.key self.remove(head.prev) return key c-5. 연산의 시간 복잡도moveAfter / moveBeforeO(1)pushFront / pushBackO(1)insertAfter / insertBeforeO(1)popFront / popBackO(1)removeO(1)searchO(n) moveAfter(Before) , pushFront(Back), insertAfter(Before)는 splice의 시간복잡도와 같다. O(1)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"2. 배열과리스트","slug":"cs/datastructure/ds2","date":"2021-07-28T10:59:57.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds2/","excerpt":"","text":"a. 배열(array)데이터를 연속적인 메모리 공간에 저장 주소를 통해 매우 빠르게 접근 배열의 시작 주소, 저장된 값의 종류, 인덱스 세가지 정보로 원하는 값의 주소를 계산 가능. 읽기와 쓰기 연산에 O(1)시간이 걸림 고정된 길이를 가지며, 읽기와 쓰기만 지원하는 경우가 많다. b. 리스트 (파이썬)c의 배열에는 실제 데이터가 저장된 형식이지만, python의 리스트에는 데이터가 저장된 주소가 저장된다. 항상 객체의 주소만 저장하기 때문에 셀의 크기를 8바이트(혹은 4바이트)로 고정. 모든 셀의 크기가 같기 때문에 index에 의해 O(1)시간 접근이 가능 읽기/쓰기 외에 여러 연산들 지원 a.append(val)맨 뒤에 val 삽입a.pop(i)a[i]값을 지운 후 리턴pop()은 가장 오른쪽 값 지움a.insert(i, val)a[i]=value연산(원래 값들은 한 칸씩 이동)a.remove(val)val을 찾아 제거a.index(val)val이 처음 등장하는 index 리턴a.count(val)val이 몇 번 등장하는지 리턴a[i:j]a[i]...a[j-1]까지 복사해 새 리스트로 반환 리스트는 동적배열(파이썬)append나 insert로 메모리가 부족해지면, 더 큰 메모리를 할당받아 새로운 리스트에 이전 리스트의 값을 모두 이동한다. 반면 pop이나 remove로 메모리가 너무 널널해지면, 더 작은 메모리에 이전 리스트를 할당한다. 따라서 사용자가 배열의 크기를 신경쓰지 않아도 된다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]},{"title":"7.피보나치","slug":"cs/algorithm/theory/al7","date":"2021-07-28T10:43:13.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al7/","excerpt":"","text":"피보나치 수 피보나치 수열이란 F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)로 정의되는 수열! 구현 방법 피보나치수 정의를 그대로 재귀함수로 구현 간단하지만..O(g^n) 지수 시간이 걸림..(g는 황금비율 1.1618…) 이차원 배열을 재귀적으로 곱하기 (1 1)(F(n-1)) (1 0)(F(n-2)) 이렇게 이차원 배열을 곱하면 (F(n)) (F(n-1)) 을 구할 수 있다. 따라서 곱해준 이차원 배열을 여러번 곱해주면 피보나치 수열의 값을 알 수 있다! 이때 여러번 곱해주는 연산 power(a, n)로 구해주면, O(logn)이다! 123456789101112131415161718192021def fibo_rec(n): if n &lt;= 1: return n return fibo_rec(n-1)+fibo_rec(n-2)def fibo_array(n): F = [0, 1] for i in range(2, n+1): F.append(F[i-1] + F[i-2]) return F[n]def fibo_three(n): f1 = 0 f2 = 1 for i in range(2, n+1): f3 = f1 + f2 f1 = f2 f2 = f3 return f2n = int(input(&quot;n = &quot;))print(fibo_rec(n), fibo_array(n), fibo_three(n))","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"6.Median of Medians 알고리즘","slug":"cs/algorithm/theory/al6","date":"2021-07-28T10:42:57.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al6/","excerpt":"","text":"MoM(Median of Medians) 알고리즘퀵셀렉트는 세가지 영역으로 나누는데, 피벗보다 큰 쪽으로 너무 몰리면 수행시간이 길어졌었다. MoM 알고리즘은 피벗을 적절하게 고르는 알고리즘이다.피벗보다 작은 값의 집합 A, 피벗보다 큰 집합 B 둘 다 n/c보다 작도록 피벗을 설정하는 것이다!! 이런 과정으로 피벗을 고른다고 하면, 재귀 과정에서 집합의 크기가n-&gt;n/c-&gt;n/c^2-&gt;n/c^3….-&gt;n/c^k=1. 총 logcn 번 하게 된다. 하지만 이런 과정에는 피벗을 설정하는 연산이 필요하다.피벗 고르는데 필요햔 연산을 p라고 하고, 이 연산은 재귀를 거쳐도 동일하게 계산된다. 피벗과 다른 수들과 비교하는 횟수가 필요하게 된다.이 횟수는 재귀를 거치면서n-&gt;n/c-&gt;n/c^2….이렇게 된다. 결국 p+n + p+n/c + p+n/c^2 …..=logcn*(p+n)이다. 결국 O(nlogn)이다.MoM(L, k): 5개씩 그룹화 각 국릅의 중간값(median) 구하기. 5개에서 중간값 구하는 연산은 6번 비교해야하므로, n/5*6 비교해야 된다. 중간 값을 한 집합에 모아 medians라고 하자. m* = MoM(medians, len(medians)/2). 이때 T(n/5) 연산 소요 m*를 pivot으로 삼아 전체 집합을 A,pivot,B로 나눈다. 이때 n번 비교 pivot을 기준으로 내가 찾고자하는 값이 A에 있으면 MoM(A,k), B에 있으면 MoM(B,k) 아니면 return m*한다. 이때 재귀호출에 따라 T(A) or T(B)만큼 연산하는데, A와 B모두 원소 갯수가 n/c보다 작기 때문에 둘 다 최대 소요 시간은 T(n/c)이 된다. 결국 T(n) = 6/5*n + T(n/5) + n + T(n/c) 이때 c를 4/3이라고 하면(이 부분은 다소 난해) 점화식은 T(n) = T(3*n/4)+T(n/5)+11*n/5가 된다. (휴..)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"5.독특한탐색","slug":"cs/algorithm/theory/al5","date":"2021-07-28T10:42:28.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al5/","excerpt":"","text":"특수한 선택 문제다음과 같은 요구 조건을 가지느 문제들은 선택(Selection)문제라고 보면 된다. 입력 : n개의 값과 k(1&lt;=k&lt;=n) 값 출력 : k번째로 작은 입력 값 목표 : 비교 횟수 최소화 상한(upper bound) : 어떤 결과를 찾아내는데 항상 임의 횟수의 연산이면 무조건 찾아낼 수 있다.하한(lower bound) : 어떤 결과를 찾아내는데 임의 횟수의 연산이 반드시 필요한 경우가 존재한다.상한과 하한이 같은 경우가 해당 문제를 해결하는 적절한 알고리즘! k = n : 최대값 찾기현재 최대값을 따로 변수로 저장해놓으면서 하나씩 비교해보면 된다. -&gt;항상 n-1번 비교로 가능(상한 upperbound)혹은 이웃한 두쌍이 비교해서 큰 값이 토너먼트 방식으로 비교 -&gt; n-1번 비교로 가능최대값찾기는 무조건 n-1번 연산이 알맞은 알고리즘이다. k=1, k=n : 최대값, 최솟값 찾기먼저 토너먼트 식으로 최대값을 찾고(n-1번 비교)첫 비교에서 진 요소들(n/2개)끼리 다시 최소값 찾는 토너먼트를 실행(n/2-1번 비교)총 (3/2)n-2번 비교! k=1, k=2 :최솟값과 두번째로 작은 값찾기먼저 작은 값이 이기는 토너먼트로 최솟값 찾고(n-1번 비교)토너먼트에서 최대값에게 진 값들만 모아서 다시 비교! (라운드 수-1 번=logn올림 -1번)(매 라운드마다 패배자가 발생하므로…)총 n-2-log2올림번 비교!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"4.일반적인 탐색","slug":"cs/algorithm/theory/al4","date":"2021-07-28T10:42:14.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al4/","excerpt":"","text":"일반적인 선택 문제n개의 값중 k 번째 작은 수 찾기 - QuickSelction 배열 중 임의의 수 p를 고른다.(이 p는 pivot) p보다 작은 값을 A에 따로 모으고, p보다 큰 값을 B에 따로 모으고, p와 같은 값을 M에 따로 모은다. 만약 A의 원소가 k보다 작으면 A의 k번째 작은 값이 전체 데이터의 k번째 작은 값이다. 이제 A에서 k보다 작은값 찾기는 재귀적으로 해결 가능하다. 만약 A와 M의 원소 갯수 합이 k보다 작을 때는 B에서 (k-A-M)번째 작은 값을 구하면 된다. 나머지 경우는 그냥 p를 반환하면 된다. 12345678910111213def quickSelet(L,k): #1. p=L[0] A,B,M=[],[],[] #2. for x in L: if p&gt;x:A.append(x) elif p&lt;x:B.append(x) else: M.append(x) #3-6. if len(A)&gt;k : return quickSelect(A,k) elif len(A)+len(M)&lt;k: return quickSelect(B,k) else: return p Worst case? p를 첫 원소로 했는데 가장 큰 원소가 맨 끝 원소일 때.T(n) = T(n-1)+n = 1+2+3+…+n = n(n+1) / 2 -&gt; O(n^2) 평균적인 경우는 O(n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"3.재귀 알고리즘","slug":"cs/algorithm/theory/al3","date":"2021-07-28T10:38:20.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al3/","excerpt":"","text":"재귀 알고리즘재귀 알고리즘 = 알고리즘 내부에서 한번 이상 자신의 함수를 호출sum(n) = 1+2+..+nsum(n) = sum(n-1)+n 123def sum(n): if n==1 : return 1 return sum(n-1) + n 수행시간T(n) = sum(n)의 수행시간이라 할 때T(n) = T(n-1)+ c (상수 번의 기본 연산) =&gt; 점화식! = (T(n-2)+c)+c = T(n-1)+2c … =T(1)+(n-1)c (바닥조건) =c*n 따라서 BigO -&gt; O(n)점화식을 구해 바닥조건까지 전개해가자!! 좀 더 복잡한 예제sum(a,b) = a + (a+1) + …. + (b-1) + bsum(3,8) = 3+4+5+6+7+8 = sum(3,5) + sum(6,8) … 12345def sum(a, b): if a == b : return a if a&gt;b : return 0 m = (a+b)//2 return sum(a,m)+sum(m+1, b) n=2^k라고 가정T(n) = 2T(n/2)+c …. =2^k * T(n/2^k) + c(1+2+2^2+2^3….+2^(k-1)) T(1)=c이고 등비수열 정리하면 =2^kc + c(2^k-1) =c*2^k + c * 2^r - c = 2cn - c = O(n) reverse 함수 예제reverse(A) = reverse(A[1:])+A[:1]즉 T(n) = T(n-1) + c =&gt; O(n) reverse(A, start, stop)= A[strat]와 A[stop-1] 바꾸고, reverse(A, start-1, stop-1)즉 T(n) = T(n-2) + c = T(1)+(n/2)*c =&gt;O(n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"2.분할정복법","slug":"cs/algorithm/theory/al2","date":"2021-07-28T10:05:36.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al2/","excerpt":"","text":"분할정복법큰 문제를 작은 문제로 분할해 재귀적으로 해결 a와 n 입력받아 a^n 값 구하는 power1(a,n)을 분할 정복법으로 해보자. power1(a, n) = power1(a, n-1)*a 이다. 123def power1(a, n): if n==1: return a return a*power1(a, n-1) power1의 걸리는 시간 T(n)은T(n) = T(n-1)+c = O(n) 다른 방법은 없을까? power2를 보자 123456def power2(a, n): if n==1 : return a if n==0 : return 1 if n%2==0: power2(a, n//2)*power2(a, n//2) else : return power2(a, n//2) * power2(a, n//2)*a power2의 걸리는 시간 T(n)은T(n) = 2T(n/2)+c=O(n) 자세히 보면 power2에는 중복 사용되는 메소드가 있다.이걸 좀 더 개선해보자 12345def power3(a, n): if n==0: return 1 x = power3(a, n//2) if n%2==0: return x*x else return x*x*a T(n) = T(n/2)+c = O(logn)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"1.이진탐색","slug":"cs/algorithm/theory/al1","date":"2021-07-28T10:04:00.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al1/","excerpt":"","text":"이진탐색오름차순으로 정렬된 n개의 숫자가 저장된 배열 A에서 어떤 값 x가 배열에 있는지 없는지 O(log n) 비교에 알 수 있는 탐색법. 현재 탐색 범위가 A[i]…A[j]라면 가운데값(A[(i+j)/2]) 비교에 알 수 있는 탐색법. 한 번의 비교로 탐색 범위가 반씩 줄어들어 (log n +1)번 이하의 비교로 x 존재 여부 판별. 주어진 배열을 반으로 나눠서 재귀적으로 해결하는 분할정복 알고리즘 12345678910111213141516def binary_search(A, i, j, x): if i&gt;j: return -1 m = (i+j)//2 if x == A[m]: return m elif x&lt; A[m]: return binary_search(A, i, m-1, x) elif x&gt; A[m]: return binary_search(A, m+1, j, x)A = [2*i for i in range(11)]print(A)x = int(input(&quot;x = &quot;))index = binary_search(A,0,len(A)-1, x)if index == -1: print(&#x27;cannot find&#x27;)else : print(index)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[]},{"title":"1. 연결리스트","slug":"cs/datastructure/ds1","date":"2021-07-28T06:54:58.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds1/","excerpt":"","text":"a. 연결리스트 기본 개념연결리스트는 노드가 링크에 의해 기차처럼 연결된 순차 자료구조. 노드는 실제 값을 가지고 있는 data 정보와 인접 노드로 향하는 link 정보로 구성된 클래스로 구현한다. 다른 값에 접근하려면 링크에 따라 원하는 노드의 데이터에 접근한다. 다만, 배열처럼 index로 접근할 수 없다. 어떤 값을 찾으려면 처음부터 순차적으로 찾아야한다. 배열과 연결리스트의 차이를 그림으로 파악해보자! b. 한방향 연결리스트노드들이 한 방향으로 연결된 리스트 가장 앞에 있는 노드를 head 노드라고 부르자. 가장 마지막 노드는 다음 노드가 없으므로 마지막 노드의 next 링크는 None이다. b-1. 노드 클래스 구현하기123456789class Node: def __init__(self, key=None, value=None): #노드를 구분하는 key, 필요할 경우 추가 데이터 value self.key = key self.value = value self.next = None def __str__(self): #print(node)인 경우 출력할 문자열 return str(self.key) b-2. 한방향 연결 리스트 클래스 구현하기12345678910111213class SinglyLinkedList: def __init__(self): self.head = None self.size = 0 def __iter__(self): #반복하게 만드는 반복자. yield가 있는 generator v = self.head while v != None: yield v #return과 비슷 v = v.next def __str__(self): return &quot;-&gt;&quot;.join(str(v) for v in self) def __len__(self): return self.size #len(a) = a의 노드 개수 리턴 c. 지원하는 연산 (삽입, 삭제, 탐색 등…)pushFront(key)key값을 갖는 새 노드를 만들어 head 앞에 삽입pushBack(key)key값을 갖는 새 노드를 마지막 노드 뒤에 삽입popFront()첫 노드(head)를 삭제 후 key값을 리턴popBack()마지막 노드를 삭제 후 key값을 리턴search(key)key값을 갖는 노드를 찾아 리턴remove(v)노드 v를 제거 c-1. pushFront vs pushBackpushFront는 현재 head 앞에 새 노드를 생성해 앞에 삽입한다. 12345def pushFront(self, key, value=None): new_node = Node(key, value) new_node.next = self.head self.head = new_node self.size += 1 pushBack은 마지막 노드의 next 링크가 새로운 노드로 연결되도록 해야한다. 만약 마지막 노드가 없다면(즉 리스트가 비었다면) 새 노드가 리스트의 head가 되어야 한다. 12345678910def pushBack(self, key, value=None): new_node = Node(key, value) if self.size == 0: self.head = new_node else : tail = self.head while tail.next != None: #마지막 노드 찾기 tail = tail.next tail.next = new_node self.size += 1 c-2. popFront vs. popBackpopFront는 빈 리스트라서 head를 지울 수 없는 경우와 그렇지 않은 경우로 나눠 구현한다. 12345678910def popFront(self): if self.size == 0 return None else : x = self.head key = x.key self.head=x.next self.size=self.size-1 del x #메모리 상에서 x를 제거 return key popBack은 마지막 노드를 찾고 지우고 그 전 노드의 링크를 수정해야 하므로, 마지막 전 노드를 알아야 한다. (다시 말하면 마지막 노드는 next링크가 None인 노드이다. 마지막 전 노드를 마지막 노드로 하고 싶으면 해당 노드의 next링크를 None으로 해줘야 된다는 의미다.) 연결리스트는 인덱스로 접근이 안되니, 일일히 처음부터 마지막 전 노드까지 찾아가야 한다.(O(n)) 총 세가지로 나눠 구현해야 한다. 빈 리스인 경우 리스트에 노드가 하나만 있는 경우 리스트에 두 개 이상의 노드가 있는 경우 12345678910111213141516def popBack(self): if self.size ==0 return None else : prev, tail = None, self.head while tail.next != None: prev = tail tail = tail.next if prev == None: self.head = None else : prev.next = tail.next key = tail.key del tail self.size -= 1 return key c-3. search(key)key 값을 저장한 노드를 찾아 리턴하거나 없으면 None을 반환하는데, 두가지 방법이 있다. head부터 next 링크를 따라가면서 찾기 1234567def search(self, key): v = self.head while v != None: if v.key == key: return v v = v.next return v​ for 루프를 이용하는 방법(__iter__(self)에 의해 가능) 12345def search(self, key): for v in self: if v.key == key: return v return None​ c-4. remove(v)노드 v를 리스트에서 제거하는 함수. 세가지 경우를 고려해 구현한다. 리스트가 비어있거나, 노드 v가 None인 경우 -&gt; do nothing 노드 v가 head인 경우 -&gt; popFront 호출 그 외의 경우 -&gt; v의 전 노드 w를 찾은 후 w.next = v.next로 w의 링크 수정 1234567891011121314151617def remove(self, x): # 노드 x를 제거한 후 True리턴. 제거 실패면 False 리턴 pre=None now=self.head if self.size==0: return False elif v==self.head: popFront() return True else : while now!=x: pre=now now=now.next pre.next=now.next del now self.size-=1 return True","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[]}],"categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"},{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"JPA","slug":"spring/jpa","permalink":"https://yangdongjue5510.github.io/categories/spring/jpa/"},{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"},{"name":"Clean Code","slug":"clean-code","permalink":"https://yangdongjue5510.github.io/tags/clean-code/"},{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"},{"name":"sable project","slug":"sable-project","permalink":"https://yangdongjue5510.github.io/tags/sable-project/"},{"name":"git","slug":"git","permalink":"https://yangdongjue5510.github.io/tags/git/"},{"name":"reshapi project","slug":"reshapi-project","permalink":"https://yangdongjue5510.github.io/tags/reshapi-project/"},{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"},{"name":"greedy","slug":"greedy","permalink":"https://yangdongjue5510.github.io/tags/greedy/"},{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}]}