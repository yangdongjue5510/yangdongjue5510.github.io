{"meta":{"title":"mudura | 그거 뭐더라","subtitle":"mudura powered by yangdongjue5510","description":"This is yangdongjue5510 dev blog.","author":"yangdongjue5510","url":"https://yangdongjue5510.github.io"},"pages":[{"title":"소프트웨어 엔지니어링","date":"2021-09-09T12:06:57.000Z","updated":"2022-01-22T16:20:00.072Z","comments":true,"path":"img/engineer1.html","permalink":"https://yangdongjue5510.github.io/img/engineer1.html","excerpt":"","text":"Software Engineering?개발 운용 유지보수 등 생명 주기 전반을 체계적, 서술적, 정량적으로 다루는 학문 SLDC요구사항 분석 -&gt; 설계 -&gt; 구현 -&gt; 테스트 -&gt; 유지보수 하는 과정 요구사항 분석요구사항 유도 : 대화를 통해 요구사항을 결정 -&gt; 애매하면 구체적이 되도록 유도! 비즈니스 요구사항 : 왜 이걸 하는지, 고객은 어떤 이득을 보는지 사용자 요구사항 : 사용자가 이걸 통해 어떤걸 할 수 있는지(유스케이스 다이어그램과 유저스토리를 작성) 기능적 요구사항 : 개발자가 이 제품의 무엇을 개발할 것인지 “해야한다” &#x2F; “하면 안된다”로 모든 요구사항을 서술해야 한다. 비즈니스 룰 : 비즈니스적 제약사항 유저 로그인을 위해서는 페이스북 계정이 있어야한다. 등.. 품질 명세 : 100명의 사용자가 1.5초 안에는 처리해야..등.. Software Development Lifecycle Process ModelBuild-fix Model설계없이 일단 개발! 만족할 때까지 수정!개발 문서도 없고 파악도 힘들고… Waterfall Model순차적으로 개발, 가장 많이 사용.체계적인 문서화, 정형화된 접근 가능!하지만 한 단계에서 오래 걸리면 다음 단계로 넘어가는데 오래걸림한 단계가 완료되야 다음 단계로 넘어감 Prototype Model요구 사항을 프로토타입으로 구현하고, 피드백받고 다시 수정하고다시 수정하는 방식.대규모 프로젝트에 적용하긴 힘듬. Agile프로젝트 생명 주기 동안 반복적인 개발 촉진.지나친 계획과 부족한 계획의 절충안.문서 작성보다는 코드를 활용한 방법 eXtream Programming요구조건을 확인 할 수 있는 테스트 코드를 먼저 작성하고,그 코드를 만족할 수 있도록 프로그래밍(TDD)2주 주기로 계획 설립, 프로토타입으로 개발 방향 점검(Planning)Pair Programming(한명이 개발, 한명이 검사) Scrum 만들어야 될 기능&#x2F;개선점에 우선순위를 부여 일정 기간안에 실제 작동하는 제품을 제작. 스프린트 : 반복적인 개발 주기(계획 회의 ~ 제품 리뷰 단위) 스프린트 계획 회의 : 스프린트 목표와 백로그 계획 스프린트 백로그 : 필요한 작업 목록 일일 회의 : 어제 한일, 오늘 할 일, 장애 현상 공유 정리 개발 이전 요구사항 분석 고객 측면 기능 측면 외부 인터페이스 디자인 프로토타입 유스케이스 스토리 보드 데이터 플로우, ERD 작성 API 기획회의 API 디자인"}],"posts":[{"title":"girigiri-rent-refactor","slug":"girigiri-rent-refactor","date":"2023-07-31T13:35:47.000Z","updated":"2023-07-31T13:35:47.182Z","comments":true,"path":"2023/07/31/girigiri-rent-refactor/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/31/girigiri-rent-refactor/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"girigiri-time-instant","slug":"girigiri-time-instant","date":"2023-07-31T13:22:37.000Z","updated":"2023-07-31T13:22:37.414Z","comments":true,"path":"2023/07/31/girigiri-time-instant/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/31/girigiri-time-instant/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"girigiri-member-check","slug":"girigiri-member-check","date":"2023-07-31T13:22:21.000Z","updated":"2023-07-31T13:22:21.177Z","comments":true,"path":"2023/07/31/girigiri-member-check/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/31/girigiri-member-check/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"페이징 방식에 의존하지 않는 페이지 API 설계하기","slug":"girigiri-page-api","date":"2023-07-31T13:16:14.000Z","updated":"2023-08-01T00:50:26.998Z","comments":true,"path":"2023/07/31/girigiri-page-api/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/31/girigiri-page-api/","excerpt":"","text":"요약Rest API의 HATEOAS 원칙을 적용하면 페이징 방식에 의존하지 않는 API를 구현할 수 있다. 첫 페이지에 접근할 수 있는 API만 프론트엔드에게 알려주고 다른 페이지에 접근하는 API는 첫 페이지에 접근하는 API의 응답 데이터에 동적으로 담겨있게 하자. 그러면 페이징 방식 변경에 따른 프론트엔드 변경이 생기지 않는다. 문제 상황기리기리 서비스는 페이지 API를 제공해야 한다. 페이지 API는 일반적으로 쿼리 파라미터를 통해 다음과 같은 보고 싶은 페이지에 필요한 정보를 함께 전달한다. 페이지 번호 페이지 당 데이터 갯수 정렬 기준 등… 문제는 페이지네이션의 구현 방법에 따라 쿼리 파라미터로 받아야 하는 정보가 달라지게 된다. 대표적으로 오프셋 기반 페이지네이션을 커서 기반 페이지네이션으로 바뀌게 되면 쿼리 파라미터로 현재 어디까지 읽었는 지를 전달해줘야 한다. (https://velog.io/@minsangk/%EC%BB%A4%EC%84%9C-%EA%B8%B0%EB%B0%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-Cursor-based-Pagination-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0) 즉 백엔드에서 구현을 바꾸면 쿼리 파라미터가 변경되면서 API에 변경이 생긴다. 현재 프로젝트에서는 프론트엔드와 백엔드가 함께 일하는 구조라 괜찮지만 만약 프로젝트가 끝나서 프론트엔드에게 변경을 요청하기 힘든 경우에는 어떨까? 만약 우리의 API를 수만명이 사용하고 있다면? API 변경을 통보하기 쉽지않을 것이다. 개선 방법일단 페이지 API를 어떻게 사용하는 지 이해해보자. 기리기리 서비스에서는 누구나 첫 페이지부터 조회해서 다른 페이지로 이동할 때 페이지 번호를 클릭하거나 아니면 화살표를 클릭해서 이동할 것이다. 즉 첫 페이지를 조회하는 API는 반드시 노출된다. 첫 페이지를 조회하는 API는 다음과 같다.equipments?size=16&amp;page=0여기서 판단하기를 첫 페이지 조회의 API는 페이지네이션 구현방법에 의존하지 않는다. 해당 API에 페이지네이션 구현 방법에 의존하는 데이터는 드러나지 않는다. 문제는 다음 페이지로 이동하는 경우에 문제가 될 수 있다. 오프셋 기반 페이지네이션으로 두번째 페이지를 조회하는 API는 다음과 같다.equipments?size=16&amp;page=1커서 기반 페이지네이션으로 두번째 페이지를 조회하는 API는 다음과 같다.equipments?size=16&amp;cursor=&#123;마지막으로 읽은 위치&#125;즉 페이지네이션 구현에 의존하는 API가 됐다. 그렇다면 첫 페이지 조회 API만 공개하고 다른 페이지 조회는 공개하지 않는다면?우리 서비스가 반드시 첫 페이지에 접근해서 다른 페이지로 이동하는 방식이므로 첫 페이지 조회 API만 공개하고 다른 페이지 접근하는 API는 첫 페이지 조회 API의 바디값에 동적으로 담아서 전달하면 된다. 즉 다음과 같이 응답해주면 된다. 123456789101112131415161718192021&#123; &quot;endPoints&quot;: [ &quot;/api/equipments?size=16&amp;page=0&amp;sort=id,DESC&quot;, &quot;/api/equipments?size=16&amp;page=1&amp;sort=id,DESC&quot; ], &quot;page&quot;: 0, &quot;items&quot;: [ &#123; &quot;id&quot;: 53, &quot;category&quot;: &quot;VR&quot;, &quot;maker&quot;: &quot;Meta&quot;, &quot;modelName&quot;: &quot;Oculus Quest2&quot;, &quot;rentalQuantity&quot;: &#123; &quot;totalQuantity&quot;: 6, &quot;remainingQuantity&quot;: 6 &#125;, &quot;imgUrl&quot;: &quot;https://images.stockx.com/images/Oculus-Quest-2-128GB-VR-Headset-AU-Plug-899-00186-02.jpg?fit=fill&amp;bg=FFFFFF&amp;w=480&amp;h=320&amp;fm=webp&amp;auto=compress&amp;dpr=2&amp;trim=color&amp;updated_at=1675800692&amp;q=75&quot; &#125;, // 생략... ]&#125; 우리 서비스는 endPoints에 접근 가능한 다른 페이지의 API를 같이 응답해준다. 그러면 프론트엔드는 해당 API를 그대로 요청하면 해당 페이지를 조회할 수 있게 된다. 그리고 백엔드가 페이지네이션 구현 방법을 변경해도 프론트엔드는 변경 없이 endPoints을 통해 다른 페이지를 조회하면 된다. 결과API 사용 형태를 분석하여 페이지네이션 구현에 의존하지 않는 첫 페이지 조회 API만 공개하고 다른 페이지 조회 API는 바디값에 넣어서 해당 API를 사용하도록 하여 프론트엔드에서는 페이지네이션 구현 방법에 대한 의존을 없앨 수 있었다.","categories":[],"tags":[],"keywords":[]},{"title":"girigiri-db","slug":"girigiri-db","date":"2023-07-31T13:13:13.000Z","updated":"2023-07-31T13:13:13.513Z","comments":true,"path":"2023/07/31/girigiri-db/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/31/girigiri-db/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"실전 자바 소프트웨어 개발을 읽고 재밌었던 부분 모음","slug":"realWorldJava","date":"2023-07-16T09:25:31.000Z","updated":"2023-07-16T09:26:36.112Z","comments":true,"path":"2023/07/16/realWorldJava/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/16/realWorldJava/","excerpt":"","text":"실전 자바 소프트웨어 개발을 읽고 몇가지 재밌는 포인트를 적어본다. Q. 유지보수에 유리한 코드는 어떤 코드인가?특정 기능을 담당하는 코드를 빠르게 찾을 수 있어야 한다. 코드가 어떤 일을 수행하는 지 쉽게 파악할 수 있어야 한다. 새로운 기능을 추가하기 쉽고 기존의 기능을 제거하기 쉬워야 한다. 캡슐화가 잘 되어 있어야 한다. 사용자가 내부 구현을 몰라도 쉽게 이해할 수 있어야 하고 쉽게 다른 기능으로 바꿀 수 있어야 한다. Q. 코드 중복은 왜 안좋은가?코드 중복은 해당 기능 변경이 일어나면 변경 작업을 여러 곳에서 해야 한다. 이 과정에서 빼먹는 곳이 있다면 버그가 발생한다. Q. 응집도가 무엇인가? 왜 중요한가?응집도는 메서드나 클래스 혹은 모듈 속에 있는 구성 요소들이 얼마나 연관있는지를 가르킨다. 코드를 쉽게 찾고 이해하고 사용할 수 있게한다. Q. 클래스 수준 응집도를 어떤 기준으로 높일 수 있나?기능, 정보, 유틸리티, 논리, 순차, 시간 등 기준으로 클래스를 분리할 수 있다. 기능이 비슷한 메서드를 모아서 할 수 있다. 함께 사용하는 메서드가 같은 클래스에 모여 있어서 찾기 쉽고 이해하기 쉽다. 하지만 기능이 세세하게 나눠질 경우 클래스파일이 매우 많아져 더 이해하기 어려워질 수 있다. 정보를 기준으로 메서드를 모을 수 있다. 특정 객체를 처리하는 메서드를 모으는 방식이다. 하지만 이 경우 여러 기능이 한 클래스에 모이게 되고 일부 기능만 사용하고 싶어도 해당 클래스에 의존하게 된다. 유틸리티는 어디에 포함시키기 어려운 메서드를 모으는 방식이다. 이렇게 모인 메서드들은 서로 연관성이 낮기 때문에 주의해야 한다. 논리는 비슷해보이는 메서드를 모은다. 책에서 나온 예시는 문자열을 입력받아 특정 객체로 파싱하는 로직이 있는데, 문자열의 형식이 CSV, JSON 등 다양하므로 이에 따른 다양한 파싱 로직을 한 클래스에 모은 방식이다. 이렇게하면 다양한 로직이 모이게 되는 것이므로 SRP에 위반하게 된다. 하나의 비즈니스 로직의 순차적인 진행을 묶을 수 있다. 로직의 진행을 이해하기 쉬울 수는 있으나 다양한 기능이 하나의 단위로 묶이게 되므로 SRP를 위배하게 된다. 마지막으로 시간 응집 클래스는 특정 시점에 실행되어야 하는 기능을 모은 클래스다. 책에서는 특정 작업 이전과 이후에 해야할 작업들을 모으는 예시를 들고 있다. Q. 개방 폐쇄 원칙이 무엇이고 구체적으로 어떤 예시를 들 수 있나?개방 폐쇄 원칙은 기존의 기능을 확장할 때 다른 코드를 변경하지도 않고 가능해야 한다는 의미다. 책에서는 은행 거래 내역 찾기를 예시로 들었다. 다음은 특정 금액 이상의 거래 내역 찾기이다. 123456789public List&lt;BankTransaction&gt; findGreaterThanEqual(final int amount) &#123; final List&lt;BankTransaction&gt; result = new ArrayList&lt;&gt;(); for (final BankTransaction bankTransaction : bankTransactions) &#123; if (bankTransaction.getAmount() &gt;= amount) &#123; result.add(bankTransaction); &#125; &#125; return result;&#125; 비슷한 로직을 가진 특정 월에 거래된 거래 내역 찾기이다. 123456789public List&lt;BankTransaction&gt; findInMonth(final Month month) &#123; final List&lt;BankTransaction&gt; result = new ArrayList&lt;&gt;(); for (final BankTransaction bankTransaction : bankTransactions) &#123; if (bankTransaction.getDate().getMonth() == month) &#123; result.add(bankTransaction); &#125; &#125; return result;&#125; 여기에 특정 월에 거래되었고, 특정 금액 이상의 거래 내역을 찾으려고 한다면 비슷한 메서드를 또 추가해줘야 할 것이다. 이 예시의 거래 내역 찾기 기능은 확장에 열려있지 않다. 그리고 위 예시는 비슷한 로직을 가진 여러 개의 메서드가 생기는, 즉 중복 코드를 가지기 때문에 중복된 부분에 변경이 생길 경우 여러 곳을 변경해야 한다. 즉 변경에 닫혀있지 않다. 이를 위해서 메서드들마다 중복되는 코드와 그렇지 않은 코드를 분리하자. 위 예시에서는 거래 내역을 순회하는 로직이 있고, 거래 내역이 조건에 맞는 지 확인하는 로직이 있다. 거래 내역 순회 로직은 각 메서드마다 중복되고, 거래 내역 조건 확인하는 로직은 각 메서드마다 달라진다. 문제는 이 두 로직이 결합되어 있어서 순회 로직이 거래 내역 조건 확인 로직이 추가될 때마다 중복되어 작성된다는 점이다. 이를 위해서는 두 로직의 결합을 제거하기로 한다. 우리는 인터페이스로 로직을 분리한다. 1234@FunctionalInterfacepublic interface BankTransactionFilter &#123; boolean test(BankTransaction bankTransaction);&#125; 이제 조건 맞는지 확인하는 로직을 해당 인터페이스로 추상화할 수 있다. 인터페이스로 순회로직이 검증 로직들과 분리되었다. 매개변수로 함수형 인터페이스의 구현체 객체를 전달하거나 람다를 전달하면 된다. 1234567public List&lt;BankTransaction&gt; findTransactions(final BankTransactionFilter filter) &#123; final List&lt;BankTransaction&gt; result = new ArrayList&lt;&gt;(); for (final BankTransaction bankTransaction : bankTransactions) &#123; if (filter.test(bankTransaction) &#123; result.add(bankTransaction); &#125; &#125; Q. 인터페이스를 잘게 분리하는 게 좋나? 큰 인터페이스는 어떤 문제가 있나?한 인터페이스가 많은 연산을 제공하면 그 만큼 인터페이스가 변경될 여지가 많아진다. 인터페이스가 변경될 때마다 모든 구현체를 변경해줘야 한다. 변경이 많아지면 문제가 생길 여지가 많아진다. 그리고 인터페이스에 특정 도메인 내부 구현이 드러나면 안된다. 구현이 변경되면 인터페이스에도 변경이 생기고 결과적으로 모든 구현체에 변경해야 할 일이 생긴다. 하지만 인터페이스를 극단적으로 잘게 나누면 기능이 여러 인터페이스로 분산되서 필요한 기능을 찾기 어려워지는 문제가 생길 수 있다. Q. 명시적 API VS 암묵적 API개방 폐쇄 원칙으로 하나의 메서드로 기능을 쉽게 확장할 수 있게 했던 findTransactions() 메서드와 같이 유연하지만 처음에 사용하기 어려운 암묵적 API와 구체적으로 어떤 작동을 하는 지 드러나는 findTransactionsGreaterThanEqual() 같은 메서드를 명시적 API라고 한다. 흔하게 사용하는 경우는 명시적 API를 추가해놓는 게 편할 수 있다. Q. CheckedException과 UncheckedException 의 차이는 뭘까?CheckedException은 API 사용자가 회복해야 할 예외다. 시그니처에 드러내거나 Try catch로 처리해줘야 한다. 반면 UncheckedException은 프로그램 실행 중 언제든지 발생할 수 있는 예외다. 이 두가지를 선택하는 기준은 응용 프로그램을 회복시켜야 하는가(혹은 회복 시킬 수 있는가?)이다. 일시적으로 문제가 발생한 경우는 API 사용자가 회복을 하려고 하는 것보다 잠시 뒤에 다시 재요청하는 게 나을 것이다. 그리고 비즈니스 로직 검증 시 발생한 문제는 불필요한 Try catch나 시그니처에 노출하지 않도록 하기 위해서 unchecked로 하는 게 좋다. 마지막으로 시스템 예외가 발생한 경우 API 사용자가 회복 시킬 수 있는 상황이 아닌 경우도 있다. 이럴 때도 unchecked로 처리하는 것이 좋다. 결론은 대부분의 unchecked 예외로 처리해서 불필요한 try catch나 메서드 시그니처에 노출하지 않도록 하는 게 좋다. Q. 검증 코드는 어디에 두는 것이 좋을까? 객체 생성 시 VS 검증자책에서는 검증자를 추천한다. 검증 로직을 재사용할 수 있고 로직을 독립적으로 테스트할 수 잇고 SRP를 지키기 때문이다. Q. 예외로 흐름을 제어하면 안되는 이유가 무엇인가?예외를 처리하는 불필요한 try catch가 코드 가독성을 떨어트린다. try catch는 흐름 제어가 아닌 예외나 오류 처리를 위한 코드라서 흐름 제어에 사용하면 코드 이해하기가 어려워진다. 마지막으로 예외를 생성했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생긴다. Q. 예외 대신에 사용할 수 있는 기능은 무엇인가?Null을 반환하도록 할 수 있다. 다만 어느 시점에서 Null이 반환됐는 지 추적하기가 어렵다. 그리고 API 호출마다 null 체크를 해야 하는 번거로움이 생기고 Null 만으로는 그 어떤 정보도 얻을 수 없어서 추천하지 않는다. Null 오브젝트 패턴을 사용할 수 있다. 반환되어야할 인터페이스를 구현하되 바디가 비어있는 형식을 가진 게 Null 오브젝트의 특징이다. 사용자에게 제공하고 싶은 내용을 담을 수 있고 NPE나 null 체크를 하지 않아도 된다. 다만 null 오브젝트는 발생 시 아무 단서를 주지 않기 때문에 문제를 파악하기가 어렵다. 그 외에 자바 8의 Optional을 사용할 수 있다. Q. 빌드 도구를 왜 사용하는가?프로젝트를 실행하기 위해서는 컴파일해야 한다. 이때 여러 파일을 컴파일하는 명령어를 기억하기 힘들다. 여러 패키지를 컴파일하려면 어떤 명령어를 사용해야 할까? 다른 라이브러리 의존성은 어떻게 관리할 것인가? JAR와 같이 특정한 형식으로 어떻게 패키징할까 등 다양한 문제가 있다. 프로그램을 실행할 때마다 이런 문제를 고민하기 보다는 스크립트를 통해 모든 명령어를 자동화하면 훨씬 편한다. 다음은 빌드 도구 장점을 정리한 내용이다. 응용 프로그램 빌드하고 실행하는 표준적인 작업 설정 저수준 설정과 초기화에 들이는 시간을 절약해서 개발에 집중 가능 설정과 빌드 과정에서의 오류 범위를 줄임 Q. 리스코프 치환 원칙에 대해 설명해보라리스코프 치환 원칙은 크게 네가지 원칙으로 쉽게 설명할 수 있다. 하위형식에서 선행조건을 더할 수 없다.자식이 부모보다 더 많은 선행조건을 요구할 수 없다. 하위형식에서 후행조건을 약화시킬 수 없다.후행조건은 코드를 실행한 다음에 만족해야 하는 규칙이다. 자식은 부모의 후행조건을 반드시 만족해야 한다. 슈퍼형식의 불변자는 하위형식에서 보존 히스토리 규칙부모가 허용하지 않은 상태 변화를 허용해서는 안된다. (부모가 불변 객체면 자식도 이를 준수) Q. 클라이언트 서버 모델에서 서버가 먼저 데이터를 전달하고 싶으면 어떻게 하는가?푸시 기반 통신을 사용한다. 리액티브 혹은 이벤트 주도 통신이라고도 한다. 푸시 기반 통신에서는 작성자(publisher)가 이벤트 스트림을 구독하는 상대들에게 데이터를 전달한다. 푸시 기반 통신은 일대다 통신을 지원하고 복잡한 컴포넌트들과 통신해야 할 때 유리하다. 풀 기반 통신은 푸시 기반 통신의 반대다. 클라이언트가 원하는 데이터를 먼저 서버에게 요청하고 응답받는 방식이다. Q. 저장소 패턴이란 무엇인가? 레포지토리의 책임은 무엇인가?저장소 패턴은 비즈니스 로직과 저장소 백엔드 간의 인터페이스를 정의한다. 저장소 패턴은 저장소 백엔드를 추상화해서 저장소를 다른 방식으로 구현해도 비즈니스 로직에는 영향이 가지 않도록 한다. 저장소 패턴을 사용하면 도메인 모델 데이터로 매핑하는 로직을 중앙화 할 수 있다.","categories":[],"tags":[],"keywords":[]},{"title":"가상 면접 사례로 배우는 대규모 시스템 설계 - part 1","slug":"systemDesign-1","date":"2023-07-02T10:02:46.000Z","updated":"2023-07-03T04:03:52.646Z","comments":true,"path":"2023/07/02/systemDesign-1/","link":"","permalink":"https://yangdongjue5510.github.io/2023/07/02/systemDesign-1/","excerpt":"","text":"사용자 수에 따른 규모 확장성단일 서버 클라이언트가 도메인 이름으로 요청을 날릴 때 DNS를 통해 도메인 주소를 통해 웹 서버의 IP 주소를 얻을 수 있다. 클라이언트는 IP 주소로 HTTP 요청을 날린다. 웹 서버는 요청을 처리할 때 필요한 경우 데이터베이스에게 쿼리를 실행하도록 한다. 요청의 결과를 클라이언트에게 응답한다. 어떤 데이터베이스를 사용하나?RDB(관계형 DB)와 NoSQL(비관계형 DB)로 나뉜다. RDB는 테이블 단위로 데이터를 관리하고, 조인을 활용해서 다른 테이블의 자료를 같이 조회해올 수 있다. NoSQL은 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나뉘는데 조인 연산을 지원하지 않는다. 수직적 규모 확장 VS 수평적 규모 확장스케일업은 서버를 더 고사양으로 되도록 램이나 더 좋은 CPU를 교체하는 행위이다. 반면 스케일아웃은 서버를 더많이 추가하여 서비스의 수행력을 높이는 행위다. 하지만 각 방법의 장단점이 있다. 수직적 확장은 한계가 있다. 아무리 돈을 많이 써도 하나의 서버의 성능을 무한대로 높일 수 있다. 수직적 확장은 적은 서버를 운영하게 된다. 장애에 대한 자동복구(Fail over)나 다중화가 되지않아 불리하다. 다중 서버 이번엔 웹 서버를 스케일아웃한 예시이다. DNS를 통해 로드밸런서의 IP 주소를 얻어낸다. 로드밸런서는 요청을 웹서버들에게 나눠줘서 처리하도록 한다. 다만 웹 서버의 IP는 private IP로 같은 네트워크에 속한 서버 사이 통신에만 사용된다. private IP는 외부 인터넷에서 접속할 수 없다. 이제 웹 서버 하나가 운영할 수 없게 되더라도 다른 웹 서버가 트래픽을 처리할 수 있다. 데이터베이스 다중화데이터베이스 다중화는 주-부 관계(master-slave)를 통해 이뤄진다. 주 데이터베이스에는 원본을 저장하고 부 데이터베이스에는 사본을 저장한다. 쓰기 연산은 주 데이터베이스에서만 한다. 부 데이터베이스에서는 주 데이터베이스의 사본만 전달받으며, 읽기 연산만 한다. 데이터베이스 다중화는 다음과 같은 장점이 있다. 성능 향상 : 읽기 연산을 여러 데이터베이스에서 나눠서 진행해서 성능이 더 올라갈 수 있다. 안정성 : 데이터베이스 하나가 작동하지 않아도 다른 데이터베이스의 존재 때문에 데이터가 보존된다. 가용성 : 데이터베이스 하나가 작동하지 않아도 다른 데이터베이스가 트래픽을 소화할 수 있게 된다. 데이터베이스 다중화 환경의 가용성 시나리오 부 데이터베이스가 하나 뿐인데 다운된 경우 : 읽기 연산을 주 데이터베이스가 한시적으로 처리한다. 그 동안 새로운 부 데이터베이스가 생성되어 대체한다. 주 데이터베이스가 다운된 경우 : 부 데이터베이스 중 하나가 주 데이터베이스가 되고 부 데이터베이스를 새로 추가한다. 다만 주 데이터베이스 역할을 하게 될 부 데이터베이스의 데이터 상태가 최신 상태가 아닌 경우가 있을 수 있다. 이 경우 복구 스크립트를 돌려서 최신 상태로 만들거나, 다중 마스터(Multi-masters)나 원형 다중화 방식을 도입하면 이런 상황을 대처할 수 있다. 응답 시간(latency) 개선캐시비싼 연산 결과나 자주 참조되는 데이터를 메모리에 두고 뒤이은 요청에 빠르게 처리하는 저장소. 읽기 주도형 캐시 전략요청을 받으면 일단 해당 데이터를 찾아 보고 있으면 반환한다. 없으면 데이터베이스에서 조회해와서 캐시에 저장하고 반환한다. 캐시 사용 시 유의할 점 데이터 갱신이 자주 일어나지 않지만 참조가 빈번하게 일어나는 경우 유리하다. 영속적으로 보관할 데이터를 캐시에 두지 말고 중요 데이터는 지속적 저장소(persistent data store)에 저장한다. 만료 정책을 정해둬야 한다. 너무 짧으면 데이터베이스 조회가 자주 일어난다. 너무 길면 캐시 데이터가 원본과 달라질 수 있다. 데이터 저장소 원본 갱신 연산과 캐시 갱신하는 연산이 단일 트랜잭션으로 처리 되지 않는 경우 일관성이 무너진다. 캐시 서버 한 대만 두면 SPOF가 된다. 캐시 서버는 여러개가 되어야 한다. 캐시 메모리 크기. 캐시 메모리가 너무 작으면 액세스 패턴에 따라 데이터가 캐시에서 밀려날 수 있다. 캐시 메모리를 과할당하면 데이터가 갑자기 늘어났을 때 메모리에서 밀려나는 상황을 막을 수 있다. 데이터 방출 정책. 캐시가 꽉 찬 경우 어떤 데이터를 내보내야 하는 지 정하는 방법이다. LRU(가장 마지막에 쓰인 데이터 빼기), LFU(가장 덜 빈번하게 쓰인 데이터 빼기), FIFO(가장 먼저 들어온 캐시 데이터를 내보내기) 콘텐츠 전송 네트워크 (CDN)정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크. 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등 정보에 기반해서 정적 콘텐츠를 캐싱한다. 비용 : CDN을 통해 데이터가 들어나고 나가는 양에 따라 요금을 내게 된다. 적절한 만료 시한 설정 : 시의성 중요한 컨텐츠의 경우 만료 시점을 잘 정해야 한다. CDN 장애에 대한 대처 : CDN 자체가 죽었을 경우 대응을 해야 한다. 만약 클라이언트에서 CDN으로 접근이 불가능한 경우 원본 서버로 바로 접근하도록 구현할 수 있다. 무상태 웹 계층웹 계층을 수평적으로 확장하기 위해서는 무상태로 유지해야 한다. 무상태는 서버에서 상태 정보를 저장하지 않는 모습을 의미한다. 상태 정보 의존적인 아키텍처 각 서버가 클라이언트의 세션 정보를 저장하는 경우는 상태 정보에 의존적인 아키텍처이다. 이 경우 클라이언트가 기존에 요청하던 서버가 아닌 다른 서버로 요청할 경우 해당 서버에는 클라이언트의 세션 정보가 없어서 요청 처리에 문제가 생길 수 있다. 상태 정보 의존적인 아키텍처는 클라이언트가 통신하던 서버와만 계속 통신해야 하는 문제가 있다. 이 문제를 로드밸런서가 원래 소통하던 서버로 요청을 중개하는 sticky session 기능을 해줄 수 있으나 로드밸런서에 부담을 주게 된다. 무상태 아키텍처 웹서버들이 공유해야 하는 세션 정보와 같은 내용을 공유 저장소로 모아두고 해당 데이터가 필요할 때마다 공유 저장서에서 데이터를 가져오도록 한다. 이렇게 각 서버들이 공유해야 할 정보를 공유 저장소로 모으면 서버들은 상태 데이터를 관리하지 않아도 되고, 클라이언트들도 어떤 서버에 요청하던지 상관 없게 된다. 데이터 센터 아키텍처데이터 센터를 여러 지역마다 운영해서 사용자와 지리적으로 가까운 데이터 센터에 라우팅하는 방식의 아키텍처이다. 이 절차를 지리적 라우팅 (geoDNS-routing, geo-routing)이라고 한다. 이렇게 여러 데이터센터를 운영하면 다른 데이터 센터에 장애가 생겨도 다른 데이터 센터로 트래픽을 옮기면 장애에 대응할 수 있다. 다만 다중 트래픽센터 아키텍처는 다음과 같은 어려움이 있다. 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 효과적 방법을 찾아야 한다. GeoDNS는 사용자와 가장 가까운 데이터 센터로 트래픽을 보내도록 한다. 데이터 동기화 : 데이터 센터마다 별도의 데이터베이스를 사용하는 상황이면 다른 데이터센터의 데이터베이스에 기존의 데이터 센터의 데이터가 없을 수 있다. 데이터를 여러 데이터센터에 걸쳐 다중화하는 전략을 사용할 수 있다. (넷플릭스의 다중화 :https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b) 테스트와 배포 : 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 여러 위치에서 테스트를 해야 한다. 메시지 큐시스템이 대규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여 독립적으로 확장해야 한다. 분리된 컴포넌트들의 통신을 지원한다. 메시지 큐는 메시지의 무손실(큐에 넣어두면 꺼내기 전까지 안전하게 보관된다.)을 보장하고 비동기적 통신을 지원하는 컴포넌트다. 메시지 큐 기본 아키텍처는 간단하다. 생산자(발행자, producer, publisher) 역할하는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다. 큐에는 소비자(구독자, consumer, subscriber)라 불리는 서비스가 연결되어 있다. 큐에 연결된 소비자가 메시지를 받아 그에 맞는 동작을 수행한다. 메시지 큐를 사용하면 서비스 또는 서버 간 결합이 느슨해져서 규모 확장성을 안정적으로 확보할 수 있다. 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다. 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다. 즉 일반적인 HTTP 통신으로 서비스 간 통신을 한다면, 클라이언트와 서버 중 한 쪽이라도 가용하지 않다면 해당 통신 내용은 실패하고 사라지게 된다. 메시지 큐는 한 쪽이 가용하지 않더라도 메시지가 사라지지 않는다. 로그, 메트릭, 자동화 로그 : 여러 서버에서 로그를 만들 때 이를 단일 서비스로 모아주면 편리하게 관리할 수 있다. 메트릭 : 메트릭은 시스템의 현재 상태를 나타내는 몇가지 지표를 의미한다.호스트 단위 메트릭 : CPU, 메모리, 디스크 IO종합 메트릭 : 데이터베이스 계층 성능, 캐시 계층 성능핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문 자동화 : 생산성을 높이기 위한 자동화 도구를 활용할 수 있다. 지속적 통합을 자동화하면 코드를 검증을 자동화할 수 있다. 데이터베이스 규모 확장데이터 양이 많아지면 데이터베이스 부하도 증가한다. 데이터베이스를 증설할 방법에 대해 알아본다. 데이터베이스도 웹 서버 규모 확장과 동일하게, 수직적 확장(스케일 업)과 수평적 확장(스케일 아웃) 전략이 있다. 샤딩샤딩은 데이터베이스를 작은 단위(샤드)로 분할하는 기술이다. 각 샤드는 같은 스키마를 쓰지만 보관되는 데이터 사이에 중복이 없다. 예를 들어 유저 테이블을 4개로 확장한다면, 유저 아이디를 4로 나눈 나머지 값에 따라 테이블에 나눠서 저장하면 중복 없이 샤딩할 수 있다. 다만 다음과 같은 부분을 고려해야 한다. 재샤딩(resharding) : 데이터가 기존 샤드로 버틸 수 없을 때, 일부 샤드에 데이터가 지나치게 몰려서 가득 찰 때 샤드 키 계산하는 함수를 수정하여 데이터를 재배치시킬 수 있다. (안정 해시 기법을 활용하면 문제를 해결할 수 있다.) 유명인사 문제(핫스팟 키) : 특정 샤드에 질의가 집중되어 과부하가 걸리는 문제. 이 경우에는 자주 질의되는 데이터들을 한 샤드에 몰리지 않도록 하거나 샤드를 더 잘게 나눠야 한다. 조인과 비정규화 : 샤딩된 테이블들과 조인하기가 힘들다. 비정규화를 통해 하나의 테이블에서 질의할 수 있도록 하는 방법을 고민해야 한다. 요약 웹 계층은 무상태 계층 모든 계층 다중화 가능한 많은 데이터 캐시 여러 데이터 센터 지원 정적 컨텐츠는 CDN을 통해 서비스 데이터 계층은 샤딩을 통해 규모 확장 각 계층은 독립적 서비스로 분할 시스템을 지속적으로 모니터링, 자동화 도구 활용","categories":[],"tags":[],"keywords":[]},{"title":"AWS Elastic Beanstalk에서 HTTPS 적용하기","slug":"ebsHttps","date":"2023-06-18T05:20:06.000Z","updated":"2023-06-18T06:54:51.577Z","comments":true,"path":"2023/06/18/ebsHttps/","link":"","permalink":"https://yangdongjue5510.github.io/2023/06/18/ebsHttps/","excerpt":"","text":"문제 상황광운대학교 미디어 기자재 대여 웹 서비스 프로젝트에서 AWS Elastic Beanstalk(이하 EBS)를 활용해 CICD를 구현했다. 문제는 EBS를 활용한 인프라에서 HTTPS 프로토콜을 적용해야 하는 상황에서 발생했다. 우리 서비스의 EBS는 새 버전을 배포할 때 새로운 EC2를 생성해서 빌드된 파일을 배포하도록 했다. 보통 HTTPS 프로토콜은 서버 측에 인증서가 저장되어 있어야 한다. 매번 새로운 EC2를 생성하는 현 방식에서는 어떻게 매번 새롭게 서버(EC2)에 인증서를 설치해야 하는 걸까? 그리고 꼭 그래야 할까? 다른 방법은 없는 걸까? 요구 사항프론트에서 HTTPS로 백엔드와 통신해야 한다. 왜냐면 쿠키로 JSESSIONID를 주고 받아야 하는데 다른 오리진에서 설정한 쿠키가 요청에 포함되어 전달되려면 SAME-SITE=NONE, SECURE=TRUE이 설정되어야 한다. 이때 SECURE=TRUE로 설정하기 위해서는 HTTPS가 적용되어야 한다. 즉 백엔드에서 설정한 쿠키를 활용하기 위해서 프론트와 백엔드는 HTTPS로 통신해야 한다. 쿠키의 SameSite 속성쿠키가 어떤 상황에서만 전송될 수 있는지를 지정한다. CSRF와 쿠키를 통한 정보 유출을 막기 위해 도입됐다. 다음 값으로 SameSite를 설정한 쿠키는 특정 조건에 만족해야만 함께 전송된다. Strict : 현재 사이트와 동일한 출처(오리진)로 요청할 때만 쿠키가 전송된다. Lax(기본값) : 현재 사이트에서 다른 오리진의 이미지를 로드하는 요청과 같은 경우에는 쿠키를 포함하지 않되, 현재 사이트에서 다른 링크로 이어지는 경우에는 요청에 포함된다. None : 동일한 출처가 아니더라도 쿠키가 함께 전송된다. 이 경우에는 Secure가 포함되어야 한다.(즉, HTTPS가 적용되어야 한다.) 문제 해결일단 AWS 공식문서에 내가 하고 있는 고민에 대해 설명하고 있다. Configuring HTTPS for your Elastic Beanstalk environment 위 문서에 따르면 EBS 환경에 가장 쉽게 HTTPS를 사용하는 방법은 로드밸런서에 서버 인증서를 할당하는 것이라 한다. EBS는 로드밸런서가 일종의 프록시처럼 백엔드의 서버 인스턴스들을 프론트엔드에 노출시키지 않고 소통한다. 즉 프론트엔드와 백엔드가 HTTPS 통신하려면 로드밸런서에 서버 인증서를 할당하여 프론트엔드와 HTTPS 통신하도록 하고, 로드밸런서 뒷편의 EC2들은 HTTP로 통신함으로써 서버 인스턴스에 추가적인 설정을 하지 않아도 요구사항을 충족할 수 있게 된다. 로드밸런서에 서버 인증서를 할당할 때는 AWS Certificate Manager를 활용하는 것이 쉽다. ACM은 AWS 서비스 및 연결된 리소스에 SSL&#x2F;TLS 인증서를 관리해주는 서비스다. AWS의 리소스를 사용하고 있다면 별도의 비용을 지불하지 않고도 쉽게 인증서를 발급받아 사용할 수 있다. 실습도메인 레코드 설정하기나는 kwmedialab.com을 가비아를 통해 구입해놨었다. 이제 프론트가 백엔드와 통신할 도메인을 도메인 레코드를 통해 추가해본다. 여기서 CNAME 타입으로 백엔드 도메인을 서브 도메인으로 추가했다. 값/위치에 실제 연결되는 주소를 적어주면 된다. 우리의 경우는 EBS 환경의 주소를 넣어주면 된다. (참고로 EBS 환경의 주소는 로드밸런서 주소의 도메인 주소이다.) ACM을 통해 인증서 발급하기ACM을 들어가면 다음과 같이 인증서 요청 버튼이 있다. 눌러준다. 인증서 유형은 퍼블릭 인증서를 요청한다. 완전히 정규화된 도메인 이름(즉 우리의 경우에는 back-dev.kwmedialab.com)을 입력해주고 아래는 사진과 동일하게 한다.검증이 이뤄지고 나면 인증서 발급된다. 로드밸런서에 인증서 할당하고 포트 포워딩 설정이제 ACM에서 만든 인증서를 로드밸런서에 설정하고 포트 포워딩하도록 하자.EBS의 환경에서 구성 -&gt; 인스턴스 트래픽 및 크기 조정 구성 -&gt; 리스너 로 가서 리스너를 추가하면 된다. HTTPS의 443포트로 HTTPS 프로토콜로 설정하고 SSL 인증서를 우리가 ACM에서 만든 인증서를 할당하면 된다. 이렇게 설정하고 https://&#123;완전히 정규화된 도메인 주소&#125;로 요청을 보내서 정상 작동을 확인하면 끝난다! 더 나아가기현재의 방식은 주어진 요구 사항을 해결하기 위한 솔루션이다. 프론트엔드에서 백엔드의 로드밸런서까지만 HTTPS 통신할 수 있고 로드밸런서부터 서버 인스턴스까지는 HTTP 통신을 한다. 만약 서버 인스턴스까지 HTTP 통신을 하려면 인증서를 로드 밸런서가 아닌 EC2 서버에 할당해야 한다. 이 경우에는 EBS에서 procfile을 통해 매번 EC2가 새롭게 실행될 때마다 터미널에 실행할 명령어를 적어줄 수 있다. procfile을 통해 새 EC2에 인증서를 설치할 수 있다. 다만 이 솔루션은 배포 과정에서 인증서 설치 과정이 포함된다. 그래서 배포 시간이 더 길어질 수 있다.","categories":[],"tags":[],"keywords":[]},{"title":"클라우드 서비스의 인증과 보안 (HTTPS)","slug":"cs/infra/infrasecurity","date":"2023-05-07T09:26:38.000Z","updated":"2023-05-11T06:03:32.700Z","comments":true,"path":"2023/05/07/cs/infra/infrasecurity/","link":"","permalink":"https://yangdongjue5510.github.io/2023/05/07/cs/infra/infrasecurity/","excerpt":"","text":"HTTPSAPI와 통신할 때 사용하는 프로토콜인 HTTP는 통신 내용을 평문으로 전달된다. 그래서 도청하면 내용을 그대로 알 수 있게 된다.HTTPS는 통신 내용에 보안이 중요한 내용을 다룰 때 사용되는 기술이다. HTTP over SSL&#x2F;TLS이라는 의미다. HTTPS는 포트번호로 443을 사용한다.SSL&#x2F;TLS는 OSI 참조모델에서 L4인 전송 계층에서 적용된다. SSL과 TLS둘다 인터넷 상의 안전한 통신을 위한 프로토콜. SSL은 1990년대에 개발되었지만 3.0까지만 지원하고 보안 취약점이 많다. 그래서 SSL의 후속버전인 TLS이 1999년에 개발됐다. 현재는 TLS가 SSL의 대체제로 널리 사용된다. 인증서와 암호화 방식HTTPS에는 인증서가 사용된다. 인증서는 크게 서버 인증서와 클라이언트 인증서로 분류된다. 기본적으로 HTTPS에서는 서버 인증서로 서버의 신원을 검증한다.필요한 경우에는 클라이언트 신원을 검증하는 클라이언트 인증서를 사용해서 보안 수준을 높일 수 있으나, 서버 인증서만 적용하는 게 일반적이다.클라이언트 검증은 HTTP 헤더의 User-Agent 정보를 활용해서 알아내는 등 다양한 다른 방법으로 검증할 수 있다. 이런 인증서는 인증기관에서 발급한다. 키통신 내용을 암복호화 하려면 키가 필요하다. 키를 활용하는 방식은 공유 키 암호화 방식과 공개 키 암호화 방식이 있다. **공유 키 암호화 방식(대칭키 암호화 방식)**은 하나의 키로 암호화와 복호화에 모두 사용하는 방식이다.암호화와 복호화에 같은 키를 사용해서 속도가 빠르고 구조가 간단하다. 반면 하나의 키를 안전하게 보관해야 하는 부담이 있다. **공개 키 암호화 방식(비대칭 암호화 방식)**은 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 방식이다.공개 키는 누구나 알 수 있다. 하지만 비밀 키는 자신만 알 수 있게 한다.공개 키로 암호화하면 비밀 키로 복호화 할 수 있다. 비밀 키로 암호화하면 공개 키로 복호화 할 수 있다.공개 키 암호화 방식은 더 안전한 대신 공유 키 암호화 방식에 비해 느리다. HTTPS 암호화 방식HTTPS는 공유 키 암호화 방식과 공개 키 암호화 방식을 혼합해서 사용한다.처음에 공유 키를 공개 키 암호화 방식으로 안전하게 전달하고, 전달된 공유 키로 빠르게 암호화 통신을 하게 된다.구체적인 동작 과정에 대해 알아보자. 1. 일단 웹 브라우저는 인증 기관들과 각 인증 기관들의 공개 키를 알고 있다. 웹 브라우저는 인증 기관들과 각 인증 기관들의 공개 키를 알고 있다.즉 웹 브라우저는 인증 기관들이 비밀 키로 암호화 한 내용을 복호화할 수 있고, 웹 브라우저가 암호화한 내용을 인증 기관이 복호화할 수 있다.웹 브라우저들이 가지고 있는 인증 기관들의 공개 키는 인증 기관이 발급한 인증서를 복호화할 때 사용된다. 2. 웹 서버는 인증기관으로부터 인증서를 발급받는다. 웹 서버는 사이트 정보와 자신의 공개키를 인증기관에 전달하여 인증서를 발급받는다.인증 기관은 사이트 정보와 사이트 공개키를 인증 기관의 개인 키로 암호화하여 인증서를 발급한다. 인증 기관 (CA, Certificate Authority)인증 기관은 공개키와 공개 DNS명의 연결을 보장한다. 웹 서버가 인증 기관으로 부터 서버 인증서를 발급받으려 할 때 사이트 정보와 자신의 개인키를 전달한다.인증 기관은 자신의 개인 키로 웹사이트의 공개키를 암호학적으로 사인한 인증서를 만들어서 웹 서버에게 전달한다.이제 인증 기관이 발급한 인증서는 웹 브라우저가 가진 인증 기관의 공개키로 복호화 할 수 있고, 인증서를 복호화하면 웹 서버의 개인키를 얻을 수 있게 된다. 3. 클라이언트와 웹서버에 접근하여 인증서를 검증하고 대칭키를 발급한다. 클라이언트가 웹 서버에 통신하려고 할 때 SSL 핸드쉐이크를 진행한다.이 과정에서 서로 암호화 알고리즘을 정하거나 인증 방시을 정한다.또한 서버의 인증서를 전달받아서 브라우저가 인증 기관의 개인키로 복호화한다. 이를 통해 서버가 인증 기관이 검증한 서버임을 알 수 있고, 서버의 개인키를 얻을 수 있다. 그리고 클라이언트 측에서 데이터 암호화 복호화에 쓰일 대칭키를 정하고 서버의 개인키로 암호화해서 서버에게 알린다.이제 대칭키로 클라이언트와 서버는 데이터를 암호화 복호화해서 주고 받게 된다.세션이 종료되고 나면 대칭키를 폐기한다. 사용자, 그룹, 롤, 정책클라우드에서 인증하는 단위와 권한 제어 방식에 대해 살펴보자. 테넌트태넌트는 클라우드 서비스애서 최상위 개념이다. AWS에서는 어카운트가 테넌트 개념에 해당한다.원착적으로 태넌트는 여러 태넌트애 걸쳐서 작업을 하지 못한다. 클라우드는 인증도 리소스의 일종이라 적어도 하나의 태넌트애 속한다.하지만 예외적으로 여러 테넌트애 걸쳐서 인증하는 방법도 있다. 사용자클라우드에서는 API를 실행하게 하는 액터가 존재한다. 액터는 즉 사용자를 의미한다.클라우드에서는 사용자도 리소스의 종류로 취급한다.처음 클라우드를 구성할 때는 리소스가 존재하지 않으므로 사용자도 없다. 대신 클라우드에는 테넌트에 연결된 특별한 관리자 계정이 있다.이 관리자 계정을 사용자처럼 사용해서 리소스를 생성한다. 관리자 계정은 막강한 권한이 있어서 운영 시에는 일반적으로 사용하지 않는다. 관리자 계정으로 사용자를 만들고 권한을 할당해서 사용하도록 한다. 권한을 할당하려면 정책을 생성하고 사용자에게 할당해야 한다. 그룹과 정책클라우드에는 사용자를 그룹으로 묶을 수 있다. 그룹 단위로 정책을 할당하여 많은 사용자를 쉽게 관리할 수 있다.정책은 권한을 제어할 때 사용하는 기능이다. 클라우드 리소스 중 통제가 필요한 대상에 정책으로 접근이나 실행을 제한할 수 있다.정책은 액션과 리소스의 집합체에 대해 이펙트를 허가하거나 거부하는 방식으로 JSON 형식으로 나열한다. AWS IAM 정책의 기본 요소 이펙트 : 허가하면 ‘Allow’, 거부는 ‘Deny’로 표현 액션 : 허가 혹은 거부할 액션 API를 기재 리소스 : 허가하거나 거부할 리소스를 ARN 형식으로 기재. (ARN은 아마존 리소스 이름 형식.) 정책에 정해지지 않은 것은 묵시적인 거부로 판단한다. 만약 하나의 액션이나 리소스에 여러 이펙트가 정의되면 다음 우선순위로 적용한다.명시적인 Deny &gt; 명시적인 Allow &gt; 묵시적인 Deny 그 외 정책 규칙은 다음 문서를 참고하자. (https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/reference_policies_grammar.html)JSON으로 일일히 작성하기 까다로우니 Policy Generator를 사용하고, 실제로 잘 작동하는지 확인할 때 Policy Simulator를 사용할 수 있다. 인증 키와 토큰인증 키사용자가 인증하려면 ID와 패스워드에 해당하는 인증 키가 필요하다. AWS는 콘솔, API, CLI, SDK에 따라 인증 방식이 약간 다르다. 콘솔에서는 패스워드로 인증하고, 그외는 ID에 상응하는 액세스 키와 시크릿 액세스 키를 사용한다. 토큰설정 파일에 패스워드를 미리 넣어두거나, 헤더나 쿼리 파라미터로 패스워드를 전달하는 방식은 매우 위험하다. 그래서 유효 기간이 정해진 임시 비밀번호를 발급해서 사용하는 방식을 선택한다. 임시 비밀번호를 토큰이라고 한다.일반적으로 사용자의 ID와 패스워드로 토큰을 발급받고 API호출할 때 사용한다. AWS는 STS라는 서비스가 임시 자격 증명 토큰 발급을 해준다. AWS는 토큰과 액세스 키(아이디)를 조합해서 API를 호출한다.토큰은 임시 비밀번호 역할 뿐만 아니라 IAM 롤과 페더레이션에도 사용된다. 서명클라이언트의 요청을 처리하기전에 클라이언트가 실존하는지, 전송된 데이터가 위변조되지는 않았는지 확인해야 한다. 이때 필요한 게 전자 서명이다.CLI나 SDK는 내부적으로 이런 과정을 거치지만 API는 전자 서명에 의존할 수 밖에 없다. 전자 서명을 위해서는 요청 정보의 해시 값과 요청 값, 시크릿 액세스 키를 조합하여 만든다. 이때 사용되는 알고리즘은 SHA이고, 해시 값에따라 버전이 달라진다.시크릿 액세스 키로부터 서명 키를 얻어내고, 본문 페이로드로부터 해시(서명 문자열)을 얻어낸다. 서명 키를 해시 키로 서명 문자열을 해시 처리하면 서명 값이 나온다.서명 값을 HTTP 헤더의 Authorization에 설정되면 전자서명이 이뤄진다. IAM 롤과 리소스 기반 정책정책인 기본적으로 사용자와 그룹에게 적용된다. 하지만 리소스 지향적인 관점으로 리소스에 정책을 할당할 수 있어야 한다.이를 위해 AWS에서는 IAM롤과 리소스 기반 정책을 사용한다. IAM 롤은 리소스에게 정책을 부과한다. IAM 롤은 내부적으로 STS를 통해 토큰을 발행받아서 API를 실행할 때 다른 인증 키가 필요없다.IAM 롤은 어떤 리스소가 특정 리소스에 대한 접근을 다루는 정책을 관리한다. 즉 API 호출하는 주체가 중점이 된다. 그래서 IAM 롤은 API 호출 주체에게 할당한다.반면 리소스 기반 롤 정책은 관점이 다르다. 접근이 되는 대상이 중점이 된다. 즉 API 호출 대상이 중점이 된다. 이때 호출 대상을 호출하는 주체를 Principal이라는 이름으로 관리한다. 리소스 기반 롤 정책은 호출 대상 리소스에 할당한다. 복수 테넌트에 대한 제어 권한일반적으로 테넌트는 다른 테넌트와 분리되어 있다. AWS에서는 인증도 테넌트의 리소스에 속하므로 테넌트를 넘나드는 작업은 기본적으로 불가능하다.하지만 정책을 통해 권한을 부여하면 테넌트를 넘나드는 작업이 가능하다. 일단 오픈스택에서는 여러 테넌트에 접근할 수 있는 사용자를 만들 수 있다. 다만 각 테넌트의 토큰이 서로에게 호환되지 않기 때문에 다른 테넌트의 리소스를 다룰때는 해당 테넌트의 토큰을 발급받아 사용해야 한다.한편 AWS에서는 한 테넌트의 관리자 계정이 다른 테넌트의 리소스를 접근하지 못하는 게 일반적이다. 하지만 IAM 롤을 잘 활용하면 된다.먼저 접근을 허용할 테넌트의 IAM 롤에 AssumeRole API에 대해 Principal에 접근할 테넌트의 어카운트 번호를 입력한다. 이러면 해당 테넌트가 일부 리소스에 대해 접근할 수 있게 된다.하지만 당연히 제 3자의 접근을 막기 위해 Principal에서 접근을 허용할 테넌트의 정보만 적어줘야 한다. 페더레이션인증이 필요한 API를 사용할 때 인증을 다른 서비스의 계정에 권한을 위임하는 것을 페더레이션이라고 한다.대표적으로 다른 SNS 계정으로 로그인 가능한 사이트들이 페더레이션을 사용한 예시다. 인증 권한을 위임받아서 처리하는 서비스를 ID 프로바이더라고 하고 또다른 ID를 사용하는 시스템과 상호 신뢰 관계를 맺어 통합 인증을 구현한다. 대표적인 방법들통합 인증 방식은 SAML, OIDC, WebID로 구현할 수 있다.SAML은 인증 인가에 필요한 정보등르 기술하는 마크업 언어다. SAML을 HTTP(HTTPS)로 주고받으면 통합 인증이 되는 방식이다. SAML의 메타 데이터는 클라우드 측에서 제공한다.OIDC는 OAuth 2.0을 채용하여 웹 API를 통한 접근 제어하는 방법이다. AWS에서는 ID 인증과 페더레이션 처리가 되어 인증 어썰션을 취득한다.인증 어썰션을 기반으로 STS에서 토큰을 발급받아서 API를 실행할 수 있게 된다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"오케스트레이션","slug":"cs/infra/orchestration","date":"2023-04-05T11:35:00.000Z","updated":"2023-04-19T13:38:46.234Z","comments":true,"path":"2023/04/05/cs/infra/orchestration/","link":"","permalink":"https://yangdongjue5510.github.io/2023/04/05/cs/infra/orchestration/","excerpt":"","text":"오케스트레이션과 오토메이션데브옵스 관점에서 오케스트레이션은 소프트웨어 개발의 자동화를 위해 태스크를 만드는 작업이다.데브옵스 관점에서 오토메이션은 CI 툴을 사용해서 빌드나 소스 코드 정적 검사를 자동화하는 작업이다. 일반적으로 오케스트레이션 및 오토메이션의 접근 방법은 두가지로 나뉜다. 프로그래밍 언어처럼 애플리케이션 설치나 설정 순서를 열거하고 절차형 툴을 통해 자동화 애플리케이션에 최적화된 인프라 상태를 템플릿 형태로 정의하고 이를 관리하는 선언형 기능 사용 절차형 툴은 앤서블 등이 대표적이다. 절차형 툴은 구성 정보나 설정 정보를 관리하는 서버와 설정을 적용하는 클라이언트로 나뉜다. 서버가 클라이언트의 상태를 모니터링하면서 원하는 상태로 유지되도록 관리한다.선언형 툴은 AWS CloudFormation이 있다. 시스템 리소스들을 하나의 템플릿으로 정의하고 이 템플릿으로 인프라의 프로비저닝을 한다. 절차형 툴과 선언형 툴의 작용 범위절차형 툴과 선연형 툴의 작용 범위가 다르다.선언형 툴은 네트워크 및 블록 스토리지를 준비하고 이미지를 사용한 서버를 기동하는 등 인프라 리소스를 구성할 때 주로 사용된다.절차형 툴은 선언형 툴이 구성한 클라우드 리소스 위에 OS를 설치하고 어플리케이션을 설치할 때 주로 사용된다.이 차이를 잘 알고 충돌하지 않도록 툴을 사용해야 한다. 오케스트레이션과 리소스 집합체의 기본 사상클라우드 리소스를 관리할 때 REST API를 활용해서 제어해도 된다. 문제는 관리할 리소스가 매우 많아지거나 의존성 때문에 API 호출 순서가 복잡해지면 리소스 관리가 어려워진다. 그래서 리소스를 그룹으로 묶어서 관리하는 상황에 이르게 된다.오케스트레이션은 궁극적으로 리소스의 집합체를 정의하는 기술이다. 오케스트레이션은 액션에 해당하는 API로 처리하는 방식에서 리소스 그룹으로 처리하는 방식으로 전환함을 의미한다. 리소스의 집합체를 스택으로 지칭하며 스택을 활용하면 개별 리소스마다 액션에 해당하는 API 호출보다 훨씬 적은 API 호출로 다수의 리소스를 관리할 수 있다. 오케스트레이션의 근간인 템플릿템플릿은 리소스를 정의하는 역할을 한다. 템플릿은 클라우드 서비스마다 상이하다. 다만 몇 가지는 공통된다. 리소스, 파라미터, 아웃풋이 공통된다. 리소스템플릿이 오케스트레이션의 근간이면, 리소스는 템플릿의 근간이다. 템플릿에는 다수의 리소스를 정의할 수 있다. 리소스의 이름, 타입, 프로퍼티를 통해 리소스에 대한 정보를 정할 수 있고, 필요하면 다른 리소스와 의존관계를 표현해서 리소스 간 순서를 제어할 수도 있다.(AWS CloudFormation에서 DependsOn) 다른 리소스의 속성 정보를 참조하는 Ref도 활용할 수 있다. 다음은 시큐리티 그룹에 속한 EC2 인스턴스를 정의하는 AWS CloudFormation의 리소스 부분이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&quot;Resources&quot;: &#123; &quot;EC2Instance&quot;: &#123; &quot;Type&quot;: &quot;AWS::EC2::Instance&quot;, &quot;Properties&quot;: &#123; &quot;InstanceType&quot;: &#123; &quot;Ref&quot;: &quot;InstanceType&quot; &#125;, &quot;SecurityGroups&quot;: [ &#123; &quot;Ref&quot;: &quot;InstanceSecurityGroup&quot; &#125; ], &quot;KeyName&quot;: &#123; &quot;Ref&quot;: &quot;KeyName&quot; &#125;, &quot;ImageId&quot;: &#123; &quot;Fn::FindInMap&quot;: [ &quot;AWSRegionArch2AMI&quot;, &#123; &quot;Ref&quot;: &quot;AWS::Region&quot; &#125;, &#123; &quot;Fn::FindInMap&quot;: [ &quot;AWSInstanceType2Arch&quot;, &#123; &quot;Ref&quot;: &quot;InstanceType&quot; &#125;, &quot;Arch&quot; ] &#125; ] &#125; &#125; &#125; &quot;InstanceSecurityGroup&quot;: &#123; &quot;Type&quot;: &quot;AWS::EC2::SecurityGroup&quot;, &quot;Properties&quot;: &#123; &quot;GroupDescription&quot;: &quot;Enable SSH access via port 22&quot;, &quot;SecurityGroupIngress&quot;: [ &#123; &quot;IpProtocol&quot;: &quot;tcp&quot;, &quot;FromPort&quot;: &quot;22&quot;, &quot;ToPort&quot;: &quot;22&quot;, &quot;CidrIp&quot;: &#123; &quot;Ref&quot;: &quot;SSHLocation&quot; &#125; &#125; ] &#125; &#125;&#125;, 파라미터템플릿의 리소스와 프로퍼티 값이 고정되어 있으면 템플릿을 특정 설정에만 사용할 수 있게 된다. 즉 재사용이 안된다. 이를 대응하는 부분이 파라미터다. 파라미터는 템플릿의 가변적인 정보를 입력할 수 있는 부분이다. 파라미터를 통해 템플릿 재사용성을 높일 수 있다. 파라미터로 입력된 값을 사용하려면 앞서 리소스에서 언급한 Ref로 파라미터의 이름을 입력하면 된다. 다음은 시큐리티 그룹에 속하는 EC2 인스턴스를 만드는 AWS CloudFormation의 템플릿 중 파라미터 부분이다. 123456789101112131415161718192021222324252627&quot;Parameters&quot;: &#123; &quot;KeyName&quot;: &#123; &quot;Description&quot;: &quot;Name of an existing EC2 KeyPair to enable SSH access to the instance&quot;, &quot;Type&quot;: &quot;AWS::EC2::KeyPair::KeyName&quot;, &quot;ConstraintDescription&quot;: &quot;must be the name of an existing EC2 KeyPair.&quot; &#125;, &quot;InstanceType&quot;: &#123; &quot;Description&quot;: &quot;WebServer EC2 instance type&quot;, &quot;Type&quot;: &quot;String&quot;, &quot;Default&quot;: &quot;t2.small&quot;, &quot;AllowedValues&quot;: [ &quot;t1.micro&quot;, //...생략 &quot;cg1.4xlarge&quot; ], &quot;ConstraintDescription&quot;: &quot;must be a valid EC2 instance type.&quot; &#125;, &quot;SSHLocation&quot;: &#123; &quot;Description&quot;: &quot;The IP address range that can be used to SSH to the EC2 instances&quot;, &quot;Type&quot;: &quot;String&quot;, &quot;MinLength&quot;: &quot;9&quot;, &quot;MaxLength&quot;: &quot;18&quot;, &quot;Default&quot;: &quot;0.0.0.0/0&quot;, &quot;AllowedPattern&quot;: &quot;(\\\\d&#123;1,3&#125;)\\\\.(\\\\d&#123;1,3&#125;)\\\\.(\\\\d&#123;1,3&#125;)\\\\.(\\\\d&#123;1,3&#125;)/(\\\\d&#123;1,2&#125;)&quot;, &quot;ConstraintDescription&quot;: &quot;must be a valid IP CIDR range of the form x.x.x.x/x.&quot; &#125;&#125; 아웃풋템플릿 처리 과정에서 출력하는 내용을 다룬다. Fn::GetAtt로 리소스의 프로퍼티 정보를 직접 인용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435&quot;Outputs&quot;: &#123; &quot;InstanceId&quot;: &#123; &quot;Description&quot;: &quot;InstanceId of the newly created EC2 instance&quot;, &quot;Value&quot;: &#123; &quot;Ref&quot;: &quot;EC2Instance&quot; &#125; &#125;, &quot;AZ&quot;: &#123; &quot;Description&quot;: &quot;Availability Zone of the newly created EC2 instance&quot;, &quot;Value&quot;: &#123; &quot;Fn::GetAtt&quot;: [ &quot;EC2Instance&quot;, &quot;AvailabilityZone&quot; ] &#125; &#125;, &quot;PublicDNS&quot;: &#123; &quot;Description&quot;: &quot;Public DNSName of the newly created EC2 instance&quot;, &quot;Value&quot;: &#123; &quot;Fn::GetAtt&quot;: [ &quot;EC2Instance&quot;, &quot;PublicDnsName&quot; ] &#125; &#125;, &quot;PublicIP&quot;: &#123; &quot;Description&quot;: &quot;Public IP address of the newly created EC2 instance&quot;, &quot;Value&quot;: &#123; &quot;Fn::GetAtt&quot;: [ &quot;EC2Instance&quot;, &quot;PublicIp&quot; ] &#125; &#125;&#125; 템플릿을 어느 세월에 다만드냐..?일일히 템플릿을 작성하는게 부담되는 경우, 이미 존재하는 리소스를 기반으로 템플릿을 생성할 수 있다.(AWS CloudFormer) 오케스트레이션의 장점인프라 환경 구축 단계 관점서버, 네트워크, 스토리지를 생성할 때 웹 콘솔을 사용하던지 API를 조합한 CLI를 실행하던지 SDK를 활용한 프로그램을 사용할 수 있다. 다만 이런 방법들은 리소스 종류가 달라지면 수정해줘야 한다. 오케스트레이션은 템플릿으로 리소스 관계 및 상태를 정의할 수 있게 돕고, 오케스트레이션 엔진이 리소스 배치와 시스템 상태 유지를 자동으로 지원한다.관리자는 리소스마다 상태 확인할 필요 없이 각 스택의 상태를 확인하면 된다. 그리고 템플릿의 상한 값 설정으로 잘못된 값 입력을 방지할 수 있다. 인프라 환경 운영 단계 관점리소스가 생성되고 나서도 오케스트레이션의 장점이 있다. 먼저 리소스 간 의존 관계를 정의해서 리소스 기동 순서를 제어할 수 있다.또한 오토스케일링과 오토 힐링도 구현할 수 있다. 감시서버를 두고 로드 밸런서가 장애를 통보하면 이를 오케스트레이션 API를 통해 오케스트레이션 엔진에게 알려주고 오케스트레이션 엔진이 서버 API를 통해 리소스를 다시 기동하거나 리소스를 추가하는 방식으로 대응할 수 있다. (오토 힐링과 오토스케일링은 굳이 오케스트레이션이 아니어도 가능하다.) 재사용 템플릿을 활용한 환경 복제 방식 관점오케스트레이션은 템플릿을 통해 동일한 인프라 환경 구성을 빠르게 복제할 수 있다. 특히 파라미터를 통해 하나의 템플릿도 동적으로 변화를 줄 수 있다. 예를 들면 어떤 검증을 해야 할 때 하나의 템플릿을 파라미터를 다르게 해서 여러 환경을 만들어서 병렬로 검증을 해볼 수 있다. 또한 리전 정보를 파라미터로 전달하면 특정 리전에 속한 리소스에 문제가 생겼을 경우, 빠르게 파라미터를 바꾸서 새로운 인프라를 구축해서 활용할 수 있다. 오케스트레이션을 활용한 지속적 통합 관점기존의 지속적 통합은 특정 환경에 애플리케이션을 배포하는 용도로 많이 사용했다. 애플리케이션의 변경 사항만 반영해서 릴리즈하고 서버, 스토리지, 네트워크의 구성 변경에는 관여하지 않았다. 하지만 클라우드 환경에서는 오케스트레이션 기능으로 인프라도 코드처럼 제어할 수 있다. 즉 CI 작업에 인프라 변경도 포한할 수 있게 됐다. 스택에 인프라 환경 뿐만 아니라 애플리케이션을 함께 정의하는 방식으로 구현한다. 오케스트레이션의 주의사항스택으로 생성한 리소스는 개별 액션 API로 변경하지 않는다.스택으로 생성한 리소스, 즉 오케스트레이션 API로 관리하는 리소스를 개별 액션 API로 변경하면 안된다. 왜냐면 개별 액션 API로 스택 내부의 리소스를 변경하면 템플릿 설정 내용과 변경된 상태에 차이가 생겨 정합성이 깨지게 된다. 그렇다고 사소한 작업 모두 오케스트레이션 API를 활용하면 더 느리고 번거로울 수 있다. 그래서 현업에서는 오케스트레이션 API로 관리되는 리소스와 그렇지 않은 리소스를 나눠서 관리하곤 한다. 스택 반영 후 각 리소스에 정상 반영됐는 지 확인한다.오케스트레이션에는 스택을 갱신하는 기능이 있다. 이 작업을 통해 리소스에 정상 반영됐는 지 모니터링 해야 한다. 특히 일부 리소스는 갱신하는 과정에서 일정 시간동안 서비스를 하지 못하는 다운 타임이 발생할 수 있다. (AWS에서는 Update requires: Replacement로 표시된 리소스가 해당) 이런 경우, 스택을 따로 만들어놓고 바꿔치는 이뮤터블 인프라 스터럭처를 고려해본다. 오케스트레이션 기능을 지원하지 않는 컴포넌트나 리소스를 미리 식별한다.내가 사용할 리소스가 오케스트레이션으로 지원하지 않으면 당연히 문제가 된다. 이를 미리 파악하고 사용하자. 스택과 템플릿의 적정 크기와 스택 중첩한 스택에서 관리하는 리소스의 갯수가 점점 늘어나고 리소스마다 릴리즈의 빈도나 서비스 수준이 달라질 수 있다. 이러면 스택을 분리해야 한다.일반적으로 스택 분리는 공통 요소와 서브 시스템으로 나눈다. 서브 시스템으로 분리하면 서로 의존도가 낮아지고 릴리즈가 더 빨라진다.공통 요소는 AWS CloudFormation에서 다음 예시들이 해당한다. 공통 운영 서비스 네트워크(VPC) 인증(IAM) 프론트엔드(DMZ) 데이터스토어(DB, Storage) 이렇게 스택을 여러개로 나누면 스택 사이의 정보 전달이 필요할 수 있다. 이럴 때 쓰이는게 파라미터와 아웃풋이다. 한 스택의 아웃풋을 다른 스택의 파라미터로 활용하여 분리된 스택이 서로 소통할 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"클라우드에서 네트워크 리소스를 제어하는 방법","slug":"cs/infra/infraNetwork","date":"2023-04-04T11:58:22.000Z","updated":"2023-04-05T11:17:02.410Z","comments":true,"path":"2023/04/04/cs/infra/infraNetwork/","link":"","permalink":"https://yangdongjue5510.github.io/2023/04/04/cs/infra/infraNetwork/","excerpt":"","text":"네트워크 리소스의 기본네트워크의 기능은 크게 L2 네트워크(OSI 참조 모델의 데이터링크 계층)과 L3 네트워크(OSI 참조 모델의 네트워크)로 나눠볼 수 있다.L2 네트워크는 같은 네트워크에 속한 장비를 연결한다. 대표적으로 스위치가 이런 역할을 한다.L3 네트워크는 서로 다른 L2 네트워크를 연결한다. 대표적으로 라우터가 이런 역할을 한다. 네트워크에서 중요한 포인트는 IP 주소를 잘 다루느냐이다. 클라우드 환경에서는 IP 관리를 기본으로 포함하는 경우가 많다. 클라우드 환경에서는 IP 주소를 DHCP를 통해 할당된다. 다만 클라우드 환경에서는 DNS 확장성이나 오토 스케일링, 오토 힐링 같은 기능을 이용하기 위해서 IP 주소에 종속되지 않도록 해야 한다. 클라우드 환경의 네트워크 리소스 네트워크 리소스 AWS VPC 오픈스택 Neutron 네트워크 전체 없음 VPC 스위치 네트워크 (서브넷에 포함) 서브넷 서브넷 서브넷 라우터 라우터 게이트웨이, 라우팅 테이블 포트 포트 ENI 시큐리티 그룹 시큐리티 그룹 시큐리티 그룹 네트워크 접근 제어 Fwaas NACL AWS는 한 테넌트가 여러 VPC를 생성할 수 있지만, 오픈스택은 한 테넌트는 하나의 가상 네트워크만 만들 수 있다.두 서비스 모두 가상 네트워크별로 가상 라우터를 배치한다. 스위치가상 스위치는 L2 네트워크 기능을 수행한다. 가상 스위치에 연결된 가상 서버는 별도의 라우팅 없이 서로 통신할 수 있다.가상 스위치는 L3 네트워크에서 쓰이는 IP 주소 범위(CIDR)를 서브넷이라는 이름으로 할당 받는다! 서브넷 범위 내의 IP를 사용자가 자유롭게 할당할 수 있다.클라우드 환경에서는 네트워크끼리 직접 연결되어 있지 않으면 같은 IP 주소를 써도 된다. 다만 공인 IP와 중복되지 않도록 사설 IP 주소의 범위에서 할당되는 게 일반적이다. AWS VPC에서는 가상 스위치에 대응하는 리소스가 없다. 대신 서브넷에서 가상 스위치의 개념과 기능을 한다. 대부분 가상 스위치와 서브넷이 1대1 관계이고 TCP&#x2F;IP를 사용할 때는 서브넷만 정의해도 충분하기 때문이다. IP 주소 범위는 두단계로 지정된다. VPC를 생성할 때 정하고, VPC의 IP 범위 안에서 서브넷에서 사용할 범위를 정할 수 있다. VPC는 한번 할당받은 IP주소 범위를 수정할 수 없기 때문에 애초에 여유있게 정할 필요가 있다. 서브넷서브넷에 연결된 서버는 기동 시 DHCP를 통해 IP 주소를 할당받고 그 IP 주소로 통신하게 된다. 다만 DHCP로 IP 주소를 받는다고 해서 매번 기동할 때마다 다른 주소를 받는게 아니다. 이미 IP 주소가 할당된 것을 DHCP가 전달할 뿐이다. 그래서 한번 기동한 서버를 여러번 재기동해도 같은 IP 주소가 부여된다. 서브넷은 할당된 IP 주소에만 통신을 허용한다. 그래서 사용자가 임의로 IP 주소 설정을 바꿔도 변경된 IP 주소로 통신하지 못한다. 서브넷은 해당 범위 안에서 통신할 수 있는 폐쇄적인 환경이라 다른 사람의 서브넷이나 IP주소가 중복되도 상관없다. IP 주소의 범위 (CIDR)서브넷을 생성할 때 지정하는 IP 주소 범위를 CIDR(사이더)라고 한다. Classless Inter Domain Routing을 줄인 말으로 직역하면 ‘클래스가 없는 내부 도메인 라우팅’이다. CIDR은 IP 주소를 서브넷을 식별하는 네트워크 부분과 서브넷 안에서 개별 통신 장비를 식별하는 호스트 부분으로 나눈다. 그리고 네트워크 부분의 비트 길이를 서브넷 마스크로 표현한다. 인터넷 초창기에는 IP 주소의 상위 비트 값에 따라 서브넷 마스크가 결정됐다.0으로 시작하면 서브넷 마스크가 8비트로 클래스 A로 부른다. 대략 1600만개 주소가 가능하다.128으로 시작하면 서브넷 마스크가 16비트로 클래스 B로 부른다. 대략 65000개 주소가 가능하다.223으로 시작하면 서브넷 마스크가 24비트로 클래스 C로 부른다. 대략 256개 주소가 가능하다.하지만 1600만개 주소가 필요한 서브넷은 별로 없다. 그래서 클래스 A는 남는 주소가 많아 비효율적이다. 이런 고정된 서브넷 마스크 대신 가변 길이의 서브넷 마스크를 가진 CIDR를 통해 효율적으로 IP 주소를 할당한다. 라우터라우터는 서로 다른 네트워크를 연결한다.라우터는 다음과 같은 세가지 유형의 연결 방식이 가능하다. 내부 -&gt; 내부 내부 -&gt; 외부 외부 -&gt; 내부여기서 내부는 클라우드 네트워크를 의미한다. 내부 -&gt; 내부서로 다른 네트워크에 속한 서버끼리 통신한다. 기본적으로 VPC 내의 네트워크들을 연결한다. 경우에 따라서는 다른 테넌트의 네트워크를 라우팅해야 할 때가 있다. AWS에서는 VPC Peering, 오픈스택 Neutron에서는 네트워크 공유 기능을 사용한다. 내부 -&gt; 외부가상 네트워크에 속한 서버가 인터넷을 통해 외부로 접속되는 경우를 의미한다. 이때 라우터에서는 내부 네트워크에서 사용하는 사설 IP 주소를 공인 IP 주소로 변환하는 IP 마스커레이드를 하게된다. IP 마스커레이드는 내부의 호스트들이 하나의 공인 IP로 사용. NAT를 통해 내부 IP에게 전달. 외부 -&gt; 내부외부에서 내부 네트워크로 접근하려면 공인 IP가 필요하다. 오픈 스택에서는 플로팅 IP, AWS에서는 EIP가 활용된다. 이런 공인 IP는 리전 별로 관리가 되고 어드레스 풀에서 확보해서 논리포트에 할당한다. 오픈스택 Neutron의 라우터크게 가상 라우터와 서브넷의 연결 관계로 구성된다. 가상 라우터는 논리 포트로 연결된다.연결된 후 가상 라우터의 라우팅 테이블이 갱신되어 이에 따라 전송 트래픽이 흘러간다.만약 외부 네트워크와 통신하되 각 서브넷끼리 통신을 막고 싶으면 서브넷마다 라우터를 만들어서 각 라우터를 외부 네트워크에 연결해서 사용하면 된다. AWS VPC크게 게이트웨이와 라우팅 테이블로 구성된다. AWS에서는 외부로 통신하기 위해 VPC 안에 게이트웨이를 만든다. 그런 다음 서브넷의 라우팅 테이블에서 외부로 통신할 때 만든 게이트웨이를 통과하도록 라우팅 정보를 설정한다. 게이트웨이는 역할에 따라 여러 종류가 있다. 인터넷 통신을 위한 인터넷 게이트웨이 (IGW) 사설 네트워크 통신을 위한 버추얼 게이트웨이 (VGW) 리전 안에서 VPC끼리 연결하는 피어링 커넥션 (PCX) 인터넷에 연결된 서비스(S3)를 VPC에서 인터넷을 거치지 않고 연결하는 VPC 엔드포인트 AWS에서는 실제로 라우터가 리소스로 존재하지 않는다. 대신 라우팅 테이블을 통해 라우팅을 정한다. 라우팅 테이블은 VPC와 서브넷에 설정할 수 있다. VPC에 설정하는 건 메인 라우팅 테이블이고, 서브넷에 설정하는 것은 서브 라우팅 테이블이라 한다. 포트논리 포트는 물리 스위치의 포트를 가상화한 개념이다. Neutron에서는 가상 스위치의 접점 의미가 강하고, AWS에서는 서버와 네트워크의 연결 인터페이스 개념이 강하고 ENI(elastic network interface)라고 부른다. 논리 포트는 물리적인 포트와 다른 점이 있다. 논리 포트는 생성될 때 자신이 소속된 가상 서브넷으로부터 IP 주소를 할당 받는다. 그리고 해당 포트는 그 IP 주소 외 통신은 차단한다. 논리 포트는 여러개의 IP 주소를 할당 받을 수 있다. 논리 포트(NIC)로 Failover논리 포트를 다른 가상 서버에 옮겨서 할당할 수 있다. 즉 하나의 서버에 문제가 생기면 다른 가상 서버에 논리 포트를 옮겨서 장애에 대응할 수 있다. IP 주소의 변경 없이 사용하는 가상 서버를 교체할 수 있다. 게이트웨이로써 논리 포트논리 포트는 서버와 가상 네트워크 연결에만 사용되지 않는다. 가상 네트워크와 라우터를 연결할 때도 쓰인다. 이런 포트에 할당된 IP 주소는 가상 서브넷의 게이트웨이 역할을 한다. 논리 포트를 통해 서브넷에 연결된 가상 서버는 이 게이트웨이(가상 포트)를 통해 클라우드 외부로 통신할 수 있다. 플로팅 IP(AWS의 엘라스틱 IP)도 논리 포트에 할당한다. 가상의 NAT에서 플로팅 IP로 온 트래픽을 할당된 논리포트로 라우팅한다. 논리 포트와 맥 주소논리 포트는 IP 주소말고 맥 주소도 가진다. 맥 주소는 물리적인 L2 네트워크 정보로 가상 서버와 연결할 때 가상 서버 NIC의 맥 주소로 활용된다. 시큐리티 그룹시큐리티 그룹은 트래픽을 필터링한다.물리 환경에서는 방화벽 장비로 L2 네트워크 간의 트래픽을 제어한다. 서버 OS에서 제어하거나 스위치 장비에서 제공하는 ACL을 통해 접근 제어할 수 있다. 그러나 유지보수 측면에서 손이 많이 간다. 클라우드 환경에서는 논리 포트에 시큐리티 그룹을 설정해서 세밀하게 접근 제어를 할 수 있다.기본적으로 모든 트래픽을 폐기하는 암묵적 Deny 정책을 따른다.네트워크에서 접근 제어를 해야 OS나 어플리케이션에 종속되지 않고 보안 정책을 수립할 수 있다. 시큐리티 그룹 규칙 구성 입력 혹은 출력에 적용할 지 선택 허용할 프로토콜 종류 선택 통신 상대 지정 (통신 상대는 IP 주소 범위나 다른 시큐리티 그룹) 다른 시큐리티 그룹을 상대로 지정서버 대수가 늘어날 때마다 시큐리티 그룹에 대상에 새로 생긴 서버를 추가하면 유지보수에 손이 많이 간다. 대상 서버들이 적용되는 시큐리티 그룹을 대상으로 하면 효율적으로 서버 추가에 대응할 수 있다. 시큐리티 그룹 활용시큐리티 그룹을 웹 서버, DB 서버, 관리용으로 만들어 두고 각 리소스마다 포트에 할당하는 방식으로 운영할 수 있다. 네트워크 액세스 컨트롤 리스트(NACL)서브넷에 대해 필터링한다. 패캣 필터링 하거나 권한을 분리하는 것이 가능하다. 시큐리티 그룹과 차이상태 관점에서 차이가 있다. 상태는 통신 허용 정보를 생각하면 된다. NACL은 Stateless이다. 즉 허용 정보를 관리하지 않는다. 왜냐면 암묵적으로 허용하는 정책을 따르기 때문이다.반면 시큐리티 그룹은 Stateful하다. 즉 허용 정보를 관리한다. 왜냐면 암묵적으로 모두 금지하는 정책을 따르기 때문이다. NACL은 서브넷 단위로 적용한다.반면 시큐리티 그룹은 논리 포트 단위로 적용한다. 네트워크를 구성하기 위한 API 처리 흐름오픈스택 Neutron에서 네트워크 리소스를 구성하는 흐름은 다음과 같다. 가상 네트워크 생성 가상 네트워크에 서브넷 할당 논리 포트 생성 가상 라우터 생성해서 서브넷과 연결 가상 라우터를 외부 L2 네트워크와 연결 각 단계마다 JSON 데이터를 포함해서 요청하면 된다. 네트워크의 CIDR 같은 정보를 JSON 형식으로 정의할 수 있다. 일관된 포맷으로 네트워크 정보를 유지할 수 있다. 한편 AWS에서는 다음과 같다. CreateVPC : VPC(가상 네트워크) 생성 CreateSubnet : 서브넷 생성 CreateNetworkInterface : ENI(포트) 생성 이 과정을 마친 뒤, 논리 포트(ENI)를 가상 서버에 연결하면 가상 서버는 즉시 통신 가능한 상태가 된다. 이런 클라우드 API를 활용한 네트워크 구축은 물리 환경에서 구축하기보다 훨씬 간편하다. 네트워크 리소스의 내부 구성클라우드 환경에서 네트워크를 조작할 때 가상 네트워크가 어떻게 만들어지는 지 알아보자.오픈스택인 Neutron을 기준으로 파악해보자. 가상 네트워크를 제어하는 프로세스오픈스택 Neutron에는 두 종류의 호스트가 있다.사용자가 실행한 API를 처리하는 프로세스가 동작할 호스트(컨트롤러 노드)가상 서버가 기동하고 가상 네트워크를 구성하는 호스트(컴퓨트 노드) 여러 노드를 가진 테넌트의 가상 네트워크 위 예시를 보면 하나의 컴퓨트 노드에 동일한 IP 주소를 가진 두개의 가상 서버가 작동하고 있다. 일반적인 환경이나 가상화 환경에서는 불가능한 구성이다. 왜냐면 다른 호스트의 가상 서버와 통신하려면 IP 주소가 같아서 어떤 가상 서버와 통신하는 지 알 수 없기 때문이다.클라우드 환경에서는 이런 충돌이 발생해도 문제가 되지 않도록 한다. 네트워크 식별컴퓨터 노드에는 br-init과 br-turn 이라는 OVS(Open vSwitch) 브릿지가 만들어져 있다. br-init은 가상 서버와 리눅스의 가상 인터페이스로 연결된다. 이 가상 인터페이스가 논리 포트가 된다.br-init은 br-turn과 연결된다. br-turn은 컴퓨트 노드 사이 패킷 전송을 담당한다. 가상 서버에서 전송되는 패킷은 가상 서버에 연결된 논리 포트(가상 인터페이스)를 통해 가상 서버가 어떤 네트워크에 속한 지 파악한다. 그래서 해당 패킷의 소속 네트워크를 식별하기 위해 VLAN ID를 패킷에 할당한다.즉 하나의 컴퓨트 노드에 분리된 두 네트워크에 각자 속한 같은 IP 주소의 가상 서버는 패킷에 할당된 VLAN ID를 통해 각자의 네트워크를 식별할 수 있게된다. 두 컴퓨트 노드 사이 패킷 전송은 VXLAN이 사용된다. VXLAN은 이더넷 프레임을 캡슐화해서 L3 네트워크 상에 논리적인 L2 네트워크를 구성하는 터널링 프로토콜이다. br-turn에서 내부로 패킷을 받아올 때는 VXLAN ID를 꺼내고 VLAN ID로 할당한다. 외부로 패킷을 내보낼 때는 VLAN ID를 꺼내고 VXLAN ID를 할당한다. VLAN과 VXLAN둘 다 가상 네트워크를 식별하기 위한 네트워크 가상화 기술이다. 두 기술의 차이는 구분 가능한 네트워크 갯수에 있다. VLAN은 4094개, VXLAN은 1600만개를 구분할 수 있다. 클라우드 네트워크와 SDNSDN (Software Defined Networking)는 제어와 전송을 분리해서 API로 제어하겠다는 개념이다. 제어하는 부분은 컨트롤러, 전송을 담당하는 부분은 데이터 플랜이라고 한다. SDN의 구성요소는 클라우드 네트워크 컨트롤러 : 클라우드에서 가상 네트워크를 동작시키기 위한 태스크를 실행 네트워크 오케스트레이터 : 각종 네트워크 장비를 제어하면서 가상 네트워크 기능 구현. 네트워크 장비 : 실제로 패킷을 다루는 장비. 장비를 제어할 수 있도록 API 제공 특히 클라우드 네트워크 컨트롤러는 사용자에게 노출되는 API를 담당한다. 즉 내부의 변화가 사용자에게 최대한 영향을 덜 미치도록 해야한다. 사용자들이 사용하기 편하도록 설계되어야 한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"클라우드에서 서버 리소스를 제어하는 방법","slug":"cs/infra/cloudServerResource","date":"2023-03-29T12:46:38.000Z","updated":"2023-03-29T15:54:04.395Z","comments":true,"path":"2023/03/29/cs/infra/cloudServerResource/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/29/cs/infra/cloudServerResource/","excerpt":"","text":"서버 리소스서버 리소스는 타입과 이미지로 구성된다.타입은 리소스의 크기나 속성을 유형화한 개념이다.이미지는 서버의 기동 이미지로 AWS의 AMI가 이에 해당한다. 서버 리소스 제어 API 흐름인증서버 리소스를 제어하기 위해서 가장 먼저 인증을 해야 한다.인증 요청은 POST로 회원이름과 암호를 보내고 토큰과 엔드포인트를 받는다. 이후 요청에서 헤더에 토큰을 포함해서 인증할 수 있다. 템플릿 이미지 유효성 검증서버 리소스에 사용할 템플릿 이미지가 존재하는지, 접근 권한이 있는지 확인하고 템플릿 이미지를 반환하는 API를 거친다.템플릿 이미지 유효성 검증은 굳이 하지 않아도 서버 리소스 제어에 큰 문제가 생기지 않는다. 다만 이 과정을 거치지 않으면 서버 기동 중에 문제가 발생해서 여러 문제점이 함께 발생하는 기동 중에 문제 파악이 오래걸릴 수 있다. 가상 서버 생성생성할 가상 서버의 조건을 요청 바디에 담아서 가상 서버를 생성할 수 있다.가상 서버 조건 정보는 가상 서버 이름, 플레이버(인스턴스 유형), 템플릿 이미지, 접속할 가상 네트워크, 시큐리티 그룹 등 다양하다.생성에 성공하면 서버의 UUID를 응답한다. 서버 생성 요청에 성공했다고 바로 서버가 생성된 건 아니다. 단지 클라우드 제공자가 서버 생성 요청을 확인한 것이다.실제로 AWS에서 가상 서버를 만들어도 약간의 시간 뒤에 생성된다. 이는 API로 생성 요청을 접수하는 처리와 실제 가상 서버를 만드는 처리가 비동기적으로 분리되어 실행되기 때문이다. 생성된 가상 서버 상태 확인가상 서버 생성 요청의 응답으로 받은 UUID로 가상 서버의 상태를 확인할 수 있다.이때 가상 서버를 만드는 중에도 가상 서버의 상태를 보여줄 수 있다. 가상 서버의 수명 주기 AWS의 경우 여러 단계로 서버 리소스의 상태를 알려준다.pending : running할 준비하는 중running : 인스턴스 실행 중stopping : 인스턴스 중지 혹은 절전 모드로 전환 준비stopped : 인스턴스 종료됨. 하지만 다시 시작 가능shutting-down : 인스턴스가 종료할 준비terminated : 인스턴스가 영구적으로 삭제 메타 데이터와 사용자 데이터메타 데이터와 사용자 데이터는 가상 서버의 환경 설정에 활용되는 데이터이다.메타 데이터는 서버별로 따로 만들어지고 여러 개의 서버가 같은 메타 데이터를 공유하지 못한다. 사용자 데이터는 가상 서버에 액션을 실행해야 할 때 사용한다. 대표적으로 쉘 스크립트 같은 데이터가 있다. 만약 실행되야 할 사용자 데이터가 무수히 많으면 Cloud-init 이란 툴을 사용한다. 이미지 생성과 공유이미지는 가상 머신 템플릿 이미지를 의미한다. 이미지 정보에는 디스크 포맷이나 디바이스 매핑과 같은 구성 정보들이 포함되어 있다. 특이한 점은 정보 여부를 결정할 수 있어서 다른 테넨트의 사용자에게 공개 여부를 정할 수 있다. AWS CreateImage API로 인스턴스 ID를 통해 서버의 이미지를 만들 수 있다.AWS DescribeImages API로 이미지 정보를 가져올 수 있다. VM 이미지 가져오기이미지를 임포트하는 API를 지원한다. AWS에서는 ImportImage, ImportInstance,ImportVolume API로 가상 머신 템플릿을 AMI로 등록할 수 있다.ImportImage는 가상 머신 템플릿을 AMI로 임포트한다.ImportInstance는 AMI를 등록하고 서버 기동까지 한번에 한다.ImportVolume는 볼륨이 분할되어 있는 경우 볼륨 단위로 임포트할 때 사용한다. 서버 리소스의 내부 구성가상 서버의 생성 요청을 접수하고 오픈스택 내부에서 벌어지는 처리 내용을 정리해보자. 가상 서버 생성 요청을 메시지 큐에 넣기가상 서버 생성 API가 실행되면 메시지 큐에 메시지를 넣고 비동기로 처리한다.그리고 가상 서버 생성 요청이 큐에 들어가는 시점에 가상 서버의 구성 정보와 상태정보가 구성 관리 데이터베이스에 저장한다. 스케줄러에 요청 전달스케줄러(컨덕터)라고 부르는 프로세스가 큐에 있는 메시지를 꺼내서 처리한다.스케줄러 프로세스를 다중화하면 가용성이 높아진다. 스케줄러는 하나의 요청을 처리한다. 많은 요청이 오는 경우 여러 스케줄러에 분산되어 처리된다. 가상 서버를 기동할 호스트 결정오픈 스택은 상태 관리 데이터베이스에 각 호스트들의 리소스 사용 상태를 기록하고 갱신한다.스케줄러는 메시지를 꺼낸 후 가상 서버에 필요한 리소스를 가진 호스트를 상태 관리 데이터베이스를 기반으로 찾는다. 호스트에 가상 서버 기동 지시스케줄러가 호스트를 결정했으면 그 호스트에 가상 서버를 기동하라는 요청을 메시지 큐에 넣는다. 메시지 수신과 가상 서버 생성메시지 큐에서 메시지를 받은 호스트는 가상 서버를 구축한다.템플릿 이미지 가져오기, IP 주소 할당, 네트워크 접속 준비 등을 진행한다. 가상 서버 상태 갱신기동에 성공하면 구성 관리 데이터베이스의 상태를 ACTIVE로 갱신한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"IT 인프라의 진화와 API의 기본 철학","slug":"cs/infra/cloudapirevolution","date":"2023-03-28T09:07:01.000Z","updated":"2023-03-28T10:18:39.275Z","comments":true,"path":"2023/03/28/cs/infra/cloudapirevolution/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/28/cs/infra/cloudapirevolution/","excerpt":"","text":"서버를 추가 구축해야 하는 상황에서 물리적 장비와 가상화 장비의 차이물리적 장비로 환경 구축하기웹 서버 요구사항을 수행할 수 있는 물리 장비를 발주해야 한다.장비가 도착하면 데이터 센터의 랙에 물리 장비를 장착해야 한다.이 과정에서 빈 공간이 있는 지, 네트워크 스위치 포트가 비어 있는 지, 네트워크 스위치까지 배선이 가능한 지, 전원 용량이 허용 범위 안에 있는 지 등,,, 수많은 물리적 요소를 확인해야 한다. 랙에 장비를 장착하고 나서 OS와 어플리케이션, 환경설정을 한다. 그리고 개발팀에게 계정 권한 정보를 전달한다. 물리적 장비로 인프라 환경을 구축하면 OS와 어플리케이션을 설치하는 것 외에도 고려할 사항이 많다. 가상화 장비로 환경 구축하기가상화 장비로 환경 구축하면 물리적 요소 고려가 줄어든다. 어떤 장비를 구입해야 할 지 고민하지 않고 필요한 스펙의 리소스만 가상 서버에 할당하면 된다.장비를 데이터 센터 랙에 설치하는 작업은 가상 서버를 물리 서버에 할당하는 과정으로 대체된다. 랙 빈 공간을 찾거나, 네트워크 스위치 포트, 배선, 전원 용량 등 물리적 요소 고려를 하지 않아도 된다.대신 가상화 장비로 환경 구축하면 소프트웨어 요구 사항만 고려하면 된다. 물리적 장비에 OS와 소프트웨어 설치 및 환경 설정할 때도 매번 비슷한 작업을 반복하게 된다.가상화 장비로 환경 설정할 때는 환경 설정이 완료된 템플릿을 복제해오는 방식으로 대체된다. 서버 가상화의 한계가상화 장비로 환경 구축해서 물리적 고려가 줄었다. 하지만 그 외 작업은 여전히 해야 한다.가상 서버 리소스 구성 방식 정하기, 가상 서버를 물리 서버에 할당, IP 주소 확보, 시스템 설계 및 작업 계획서 작성 등 작업들은 가상 장비로 구축해도 동일하다.이런 작업들은 사람이 판단하고 수작업한다는 특성이 있다.시스템이 커지면 위와 같은 작업 때문에 인프라 운영이 번거로워 진다. 클라우드 API는 이런 작업을 더 쉽게 만든다. 클라우드 환경에서 인프라 구축 작업서버 가상화 환경에서도 줄이지 못한 사람이 수작업해야 하는 작업을 클라우드 환경에서 어떻게 줄이는 지 확인하자 클라우드로 환경 구축하기클라우드(오픈스택, AWS)에서 웹서버 추가는 세가지 단계로 나뉜다. 인스턴스 유형 선택 서버 설정 적용 가상 서버 기동 클라우드 적용의 장점가상 서버 스펙 선택클라우드에서는 가상 서버 사양을 인스턴스 유형(플레이버)로 규격화했다.유형이 있으면 재활용하기 쉬워진다. 스펙 결정할 때 고려해야 될 요소를 줄여준다.다만 세밀한 부분까지 설정하지 못할 수 있다. 하지만 리소스 가격은 시간이 갈수록 낮아지고, 사양 고민할 시간을 줄이는 게 더 중요하다.요구사항이 달라졌을 때도 스펙을 처읍부터 다시 정하지 않고 다른 인스턴스 유형을 선택하면 된다. 가상 서버를 배치할 호스트 결정가상화 서버로 환경을 구축하면 가상 서버를 물리 서버에 배치해야 한다.클라우드 환경에서는 가상 서버를 정하고 구축 요청을 하면 프로그램이 자동으로 적절한 물리 서버를 찾아 배치한다.(일반적으로 물리 서버를 정하는 기준은 일반 사용자는 몰라도 된다. 오픈 스택에서는 기준을 사용자화할 수 있다.)사람이 직접 가장 적절한 물리 서버를 찾는 것보다 약간의 리소스 손해를 보더라도 사람이 고민하는 시간을 줄여준다. IP 주소 할당클라우드 환경에서는 가상 서버가 접속할 네트워크를 정하면 사용 가능한 IP 주소가 자동으로 확보된다.IP 주소는 가상 서버가 기동될 때 할당되고, 가상 서버가 제거되면 IP 주소를 회수한다. 클라우드에서는 대량의 가상 서버를 생성했다가 제거하기 때문에 수없이 IP 할당하고 제거한다.만약 IP 할당 및 제거를 자동화하지 않았다면 매우 번거로운 수작업이 된다. IP 주소가 자동 할당되면 가상 서버의 IP 주소를 예상할 수 없다.대신 클라우드는 동적 DNS로 IP 주소를 추상화 한다. 설정 스크립트 작성가상 서버가 구동될 때 설정을 적용하는 스크립트를 작성하면 실수 없이 여러 서버에 자동으로 적용된다.그리고 클라우드에서는 이런 설정 스크립트가 잘 적용됐는지 검증하는 툴도 제공한다. 가상 서버 생성의 자동화클라우드 환경에서 가상 서버 생성할 때 인스턴스 유형과 설정 스크립트만 준비되어 있다면 수많은 작업이 순서대로 자동 진행된다.템플릿 복제, 스크립트 실행, 가상 서버 배치할 호스트, IP 주소 할당과 같은 일련의 작업을 클라우드 사용자가 고민하지 않아도 된다. 클라우드 환경에서는 HTTP&#x2F;HTTPS로 통신하는 API를 제공한다. 다만 JSON 형식이 사람이 이해하기 어려워서 CLI나 웹 콘솔을 제공한다. 스토리지와 네트워크도 효율적으로클라우드 환경에서는 스토리지와 네트워크도 웹 서버 추가하는 것과 비슷하게 효율적으로 수행한다. 스토리지를 추가할 때 디스크 영역을 확보하기 위해 RAID 구성이나 LUN 매핑하는 과정이 필요하다. 이 과정에서 장비나 제조사의 기능이나 설정을 사람이 수작업으로 하게 된다.클라우드 환경은 스토리지 용량과 접속할 서버만 정하면 나머지는 알아서 자동으로 처리한다. 네트워크를 추가할 때 VLAN을 구성하고 포함되는 물리 호스트의 네트워크 설정과 네트워크 기기 설정 모두 맞춰줘야 하낟.클라우드 환경에서는 사용할 네트워크 세그먼트나 가상 라우터를 정하면 다른 설정은 자동으로 설정된다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"Spring Boot에서 잘못된 타입으로 파라미터를 보내면 어떻게 될까?","slug":"spring-validation","date":"2023-03-22T11:01:03.000Z","updated":"2023-03-28T09:04:40.106Z","comments":true,"path":"2023/03/22/spring-validation/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/22/spring-validation/","excerpt":"","text":"목적스프링 부트에서 잘못된 타입으로 파라미터를 보내는 예외 상황에 어떤 예외가 발생하는 지 확인해보고 이를 검증하는 코드를 만들어본다! 컨트롤러 코드123456789101112131415@RestController@RequestMapping(&quot;/api/equipments&quot;)public class EquipmentController &#123; private final EquipmentService equipmentService; public EquipmentController(final EquipmentService equipmentService) &#123; this.equipmentService = equipmentService; &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public EquipmentDetailResponse getEquipment(@PathVariable final Long id) &#123; return equipmentService.findById(id); &#125;&#125; 테스트 코드1234567891011121314151617@WebMvcTest(controllers = &#123;EquipmentController.class&#125;)class EquipmentControllerTest &#123; @Autowired private MockMvc mockMvc; @Test @DisplayName(&quot;id가 문자열이면 400을 응답한다.&quot;) void getEquipment_400_idIsNotNumeric() throws Exception &#123; // given String invalidId = &quot;hi&quot;; // when, then mockMvc.perform(get(&quot;/api/equipments/&quot; + invalidId)) .andExpect(status().isBadRequest()); &#125;&#125; 위 테스트 코드는 PathVariable이 Long이어야 하는데 문자열이 전달된 경우이다.이 테스트 코드를 실행하고 DispatcherServlet의 doDispatch에 break point를 걸고 디버깅을 해보자. 디버깅하면서 찾아보기디버깅을 하다보면 InvocableHandlerMethod (컨트롤러에서 요청을 처리하는 메서드)라는 객체에서 invokeForRequest라는 메서드를 호출하면서 인자를 Object 배열로 변환한다.이 변환 로직을 각 리졸버에게 위임한다. 리졸버는 Object로 변환한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InvocableHandlerMethod extends HandlerMethod &#123; // 생략 @Nullable public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Arguments: &quot; + Arrays.toString(args)); &#125; return doInvoke(args); &#125; // 생략... protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args; &#125; Object로 변환된 인자는 DataBinder가 적절한 타입으로 바꿔준다. 이 과정에서 ConversionException이 발생하고 1234567891011public class DataBinder implements PropertyEditorRegistry, TypeConverter &#123; // 생략... @Override @Nullable public &lt;T&gt; T convertIfNecessary(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType, @Nullable MethodParameter methodParam) throws TypeMismatchException &#123; return getTypeConverter().convertIfNecessary(value, requiredType, methodParam); &#125; // 생략...&#125; DataBinder에서 시작한 형 변환 로직 중 형 변환에 실패하면 ConversionException이 발생하고 이 예외는 TypeMismatchException이 대신 던져진다. 1234567891011121314151617181920public abstract class TypeConverterSupport extends PropertyEditorRegistrySupport implements TypeConverter &#123; // 생략... @Nullable @Override public &lt;T&gt; T convertIfNecessary(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType, @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException &#123; Assert.state(this.typeConverterDelegate != null, &quot;No TypeConverterDelegate&quot;); try &#123; return this.typeConverterDelegate.convertIfNecessary(null, null, value, requiredType, typeDescriptor); &#125; catch (ConverterNotFoundException | IllegalStateException ex) &#123; throw new ConversionNotSupportedException(value, requiredType, ex); &#125; catch (ConversionException | IllegalArgumentException ex) &#123; throw new TypeMismatchException(value, requiredType, ex); &#125; &#125; // 생략..&#125; 그리고 TypeMismatchException은 AbstarctNamedValueMethodArgumentResolver에서 MethodArgumentTypeMismatchException으로 바뀌어 던져지게 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver &#123; // 생략 @Override @Nullable public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; NamedValueInfo namedValueInfo = getNamedValueInfo(parameter); MethodParameter nestedParameter = parameter.nestedIfOptional(); Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name); if (resolvedName == null) &#123; throw new IllegalArgumentException( &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;); &#125; Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); if (arg == null) &#123; if (namedValueInfo.defaultValue != null) &#123; arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue); &#125; else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123; handleMissingValue(namedValueInfo.name, nestedParameter, webRequest); &#125; arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType()); &#125; else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) &#123; arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue); &#125; if (binderFactory != null) &#123; WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name); try &#123; arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter); &#125; catch (ConversionNotSupportedException ex) &#123; throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; catch (TypeMismatchException ex) &#123; throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; // Check for null value after conversion of incoming argument value if (arg == null &amp;&amp; namedValueInfo.defaultValue == null &amp;&amp; namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123; handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest); &#125; &#125; handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest); return arg; &#125; // 생략&#125; 결론만 말하자면 타입이 맞지 않으면 MethodArgumentTypeMismatchException이 발생한다. 예외 처리 코드12345678910@RestControllerAdvicepublic class GlobalExceptionAdvice &#123; @ExceptionHandler(MethodArgumentTypeMismatchException.class) public ResponseEntity&lt;String&gt; handleMethodArgumentTypeMismatch(final MethodArgumentTypeMismatchException e) &#123; return ResponseEntity.badRequest() .body(String.format(&quot;%s이 잘못된 타입으로 입력됐습니다. 입력값 : %s&quot;, e.getParameter().getParameter().getName(), e.getValue())); &#125;&#125; @RestControllerAdvice로 예외를 처리해주면 된다. 파라미터의 이름과 입력값을 가져와서 에러 메시지를 출력하는 코드이다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"클라우드를 제어하는 API의 작동 방식","slug":"cs/infra/cloudapi","date":"2023-03-20T11:24:40.000Z","updated":"2023-03-23T13:46:28.029Z","comments":true,"path":"2023/03/20/cs/infra/cloudapi/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/20/cs/infra/cloudapi/","excerpt":"","text":"클라우드와 API의 관계APIAPI는 어떤 소프트웨어에서 다른 소프트웨어를 제어하기 위해 미리 약속된 인터페이스나 규약을 의미한다.API를 사용하면 내부 구조를 자세히 몰라도 다른 소프트웨어를 무리 없이 사용할 수 있다. 웹 API클라우드에서는 웹 API를 사용하는 것이 일반적이다.웹 API는 HTTP(HTTPS) 같은 웹 프로토콜을 사용해서 네트워크를 통해 호출하는 API를 말한다. 아마존에서 시작도니 클라우드 컴퓨팅에서의 웹 API 적용아마존은 특정 기간에 사용량이 폭주하는 경향이 있었다. 그래서 많은 서버와 스토리지를 구비해놓고 제어하는 웹 API를 구축했다.아마존의 서버와 스토리지 같은 리소스 관리 방식은 AWS의 EC2와 S3의 기반이 된다.이런 웹 API 기반 리소스 관리는 다음과 같은 이점이 있다. 인터넷을 통해 서버나 스토리지를 시간제로 임대해서 사용할 수 있다. API를 통해 사용자가 원하는 시점에 원하는 만큼 리소스를 할당받을 수 있다. 가상화 기술과 클라우드 컴퓨팅물리적인 서버와 스토리지를 직접 확보하려면 장비를 구하고 설치하는 과정에서 많은 시간이 쓰인다.물리적인 서버를 구하지 않고 가상화된 환경에서 API를 호출해서 필요한 리소스를 바로 구할 수 있다. 하지만 가상화가 클라우드 컴퓨팅의 본질은 아니다.성능이나 보안이 중요한 경우, 물리적인 리소스를 직접 사용해야 하는 경우도 있기 때문이다.클라우드의 본질은 리소스의 가상화 여부가 아닌 인터넷을 통해 필요한 자원을 제어할 수 있는 API 방식에 있다. 웹 API의 구성요소웹 API에서는 인증 처리, 제어 대상, 제어 행동으로 구성된다.제어 대상은 리소스를 의미하며 URI로 표현된다.제어 행위는 액션에 해당하며 HTTP 메서드로 표현된다. 리소스와 URI도메인, 도메인 트리, FQDNURI는 크게 네트워크 관련 부분과 경로 관련 부분으로 나뉜다.네트워크 부분에 서버 IP 주소를 사용하는 것보다는 도메인 주소를 사용하는 게 편리하다.(www.naver.com) EC2 자원의 외부 DNS 호스트 이름인 ec2-54-10-10-10.ap-northeast-2.compute.amazonaws.com은 오른쪽부터 점을 기준으로 계층 구조를 나타낸다.TLD(탑 레벨 도메인)인 com2LD(세컨드 레벨 도메인)인 amazonaws… 이런 식으로 상위 도메인에 하위 도메인이 포한되는 방식이다.이런 모습이 마치 트리 구조로 형상화되어서 도메인 트리라고도 한다.그리고 가장 왼쪽에 위치한 부분 ec2-54-10-10-10라는 호스트가 리소스에 해당하게 된다.즉 호스트 명 + 도메인 명을 합친 전체 이름을 FQDN이라고 한다. FQDN은 세상의 수많은 호스트 중 하나를 지정할 수 있게 한다. 클라우드에서 도메인 계층 확장하기 클라우드 리소스에 접속할 때도 계층화된 도메인 명을 사용한다.도메인 명을 정할 때는 일종의 규칙이 있다. AWS의 도메인 예시를 보면, ec2.ap-northeast-2.compute.amazonaws.com에서 ap-northeast-2는 리전을 의미하고, ec2는 서비스(컴포넌트)에 해당한다. (만약 서비스가 리전에 종속되지 않는 경우, 리전 계층에 서비스가 사용될 수 있다.) 이 규칙을 이해하면 다양한 리전에 다양한 서비스를 도메인 명으로 표현할 수 있다. DNS, 가상 호스트, 레지스트리도메인 명은 사람이 쉽게 식별할 수 있기 위한 내용이라 TCP&#x2F;IP으로 통신하기 위해서는 도메인을 IP 주소로 바꿔야 한다.도메인 주소와 IP 주소를 변환하는 역할을 DNS가 한다. 복수 IP와 가상호스트 일반적으로 FQDN과 IP가 1대1 매핑되지만 필요에 따라서 1:N, N:1 매핑이 가능하다.1:N은 대규모 시스템에 활용된다. 하나의 FQDN으로 많은 요청이 오면 하나의 IP로 대응하지 못할 수 있다.이럴 때 여러 IP를 매핑해서 DNS가 순차적으로 IP를 돌려써서 부하를 줄일 수 있다. (DNS 라운드 로빈) 클라우드에서는 CDN이나 로드 밸런서에서 DNS 라운드 로빈 기능을 활용하여 대규모 트래픽에 대응할 수 있다.DNS 라운드 로빈은 사용자 입장에서 주소 변경 없이 확장 할 수 있다. 반면 N:1은 서버 리소스 더 효율적으로 사용하고 싶을 때 사용한다. 도메인과 IP 주소 변환 방법 클라이언트 쪽에서 IP 주소로 변환하려고 하면 스텁 리졸버를 통해 캐시 DNS 서버에 해당 도메인 정보가 있는 지 확인한다.(이 과정을 로컬 쿼리, 재귀적 질의라고 함)만약 없으면 루트 도메인부터 최하위 도메인까지 각 도메인의 네임 스페이스를 관리하는 DNS에게 물어본다. (이를 반복적 질의, 비재귀적 질의라고 함)이렇게 되면 루트 도메인에 상당한 부하가 생기는 데, 이를 방지하기 위한 것이 캐시 DNS 서버이다.(캐시 DNS 서버는 클라이언트 컴퓨터에서 네트워크 설정에서 지정된 DNS 서버이다.) 비재귀적 질의를 많이 사용하는 URL URL을 설계할 때는 비재귀적 질의가 많이 사용되도록 하는 게 좋다. 비재귀적 질의가 많이 사용되는 URL은 다양한 DNS를 거쳐서 IP 주소를 찾도록 하는 것이다. 즉 서버의 특성에 따라 잘 계층화하면 확정성을 확보할 수 있다. ec2-north-east-amazon.com은 계층화가 잘 이뤄지지 않았고 비재귀적 질의가 적다. (루트DNS - com DNS - ec2... DNS)반면 ec2.north-east.amazon.com과 같이 잘 계층화 된 URL은 비재귀적 질의가 많이 사용됐고 각 DNS가 목적에 따라 확장에 더 유리해졌다. (루트 DNS - com DNS - amazon DNS - north-east DNS - ec2 DNS)물론 이런 설계 방법이 성능에는 약간의 손해를 볼 수 있으나 DNS 캐시 서버의 존재 때문에 이런 손해는 줄일 수 있다. 자신이 등록한 도메인 사용하기 자신의 도메인에 CNAME을 등록하면 된다.일반적으로 클라우드 서비스를 제공하는 업체에서는 DNS 서비스를 제공한다. AWS도 Route 53이란 기능을 제공한다. 도메인 레코드 IP 주소와 도메인을 짝 지은 설정정보를 DNS 레코드라고 한다. A : FQDN에 대한 IPv4 주소 정보 AA : FQDN에 대한 IPv6 주소 정보 CNAME : FQDN 별칭 정보 PTR : FQDN 역방향 질의 정보 SOA : DNS 영역에 대한 권한 정보 NS : DNS 서버 정보 MX : 이메일 서버 정보 SPF : 이메일 발신자 자격 증명 정보 SRV : 프로토콜, 포트 번호 등 ㅈ어보 TXT : 호스트의 부가 정보 URI웹 API에서 리소스를 지정하는 식별자를 URI라고 한다. URI에는 URL과 URN이 포함된다. URL URL은 네트워크 상에 있는 리소스의 위치를 알려줄 때 사용한다.URL은 네트워크 부분과 경로 부분으로 나눌 수 있다.스키마, 인증정보, FQDN, 포트번호까지 네트워크 경로이고, 네트워크 부분 이후를 경로 부분이라고 한다. 엔드포인트클라이언트가 공개된 API를 실행하기 위해 접속하는 연결 접점을 엔드포인트라고 한다.웹 API에서는 URI가 엔드포인트로 일종의 게이트웨이 역활을 한다. 엔드 포인트 뒤편에는 컨트롤러가 실제 처리를 수행하게 된다. 물리적인 장비를 사용하는 온프레미스 환경에서는 직접 장비를 설치한 후 장비의 어드레스에 접속해서 제어를 해야 한다.만약 인프라 환경이 커지면 이런 방식은 운영하기 어려워진다. 특히 다른 리전에 있는 리소스를 제어해야 할 경우 어렵다.API의 엔드포인트를 통한 제어는 일관되고 효율적인 작업이 가능하다. 엔드포인트와 도메인 AWS 엔드포인트는 IP가 아닍 도메인으로 접속하게 된다.그 이유는 일단 사람이 알아보기 쉽고, 사용자로부터 IP 주소를 숨길 수 있기 때문이다. IP 주소는 데이터 센터 장비를 옮기거나 부하 분산을 위해 변경될 수 있다. 이런 변경이 사용자에게 노출되지 않기 위해 도메인으로 접속하도록 한다. ROA (리소스 지향 아키텍쳐)리소스 지향 아키텍처란 REST API의 사상을 기반으로 리소스 중심적인 API를 사용하는 아키텍처를 말한다. REST 기반 서비스REST는 프로토콜이 아니라 사고방식이다. REST에는 네가지 설계 지침으로 요약될 수 있다. 상태를 가지지 않는다. : 사태를 가지지 않으므로 구현이 쉽고 캐시를 사용할 수 있고 성능이 우수. URI는 디렉터리 구조처럼 계층적 구조를 가진다. : 가독성과 리소스 구조 이해가 쉬움. HTTP 메서드를 명시적으로 사용 : 리소스 상태 변화를 HTTP 메서드를 통해 리소스 중심으로 표현. 응답은 XML이나 JSON 사용 : 데이텨 표현을 정규화해서 다양한 언어와 기술에도 데이터가 활용될 수 있음. 비동기 멱등성, 재시도 클라우드에서 REST API를 사용할 때는 비동기, 멱등성, 재시도 개념을 알아두자.AWS같은 퍼블릭 클라우드 서비스는 인터넷으로 REST API를 제공한다. 수많은 요청을 처리할 때 반드시 순서대로 처리하지 않고 내부에서 비동기로 요청을 처리한다.멱등성은 여러번 동일한 요청을 날려도 리소스에 변경이 없는 특성을 의미한다. 이런 특성은 네트워크 문제로 오류가 발생하더라도 재시도 했을 때 리소스의 정합성에 문제가 생기지 않는다는 사실을 보장하는 근거가 된다. 클라우드 API 활용 예시 특정 네트워크에 연결된 서버를 기동하되, IP 주소는 공인 IP를 할당하고 해당 IP 주소에 대한 도메인을 DNS에 설정 사설 IP 주소를 확보하기 위해 서브넷을 만듬 -&gt; POST로 서브넷 생성 요청하고 서브넷 ID 반환 서버에 사설 IP 주소를 할당 -&gt; POST로 서브넷 ID를 함께 사설 IP 할당 요청하고 서버 ID 반환 서버에 공인 IP 주소를 할당 -&gt; PUT으로 서버 ID를 함께 해당 서버의 퍼블릭 IP 할당 요청하고 공인 IP 주소 반환 해당 공인 IP 주소에 대한 DNS 레코드를 설정 -&gt; POST로 DNS 레코드에 공인 IP 주소를 A 레코드에 할당. API 이력 확인하기AWS에서는 AWS CloudTrail로 API 호출 이력을 모니터링할 수 있다.AWS에서는 AWS Config로 리소스의 구성 형태와 설정의 변경 이력을 관리한다. 독자적인 API 구성하기독자적으로 만든 API를 게이트웨이처럼 두어 실제 클라우드 엔드포인트나 API를 외부에서 보이지 않도록 구성할 수 있다.독자적으로 구성한 IaaS 상이나 독자적으로 개발한 애플리케이션과 기존 클라우드를 연계할 때, 여러 다양한 클라우드를 조합해야 할 때 사용한다. AWS에서는 Amazon API Gateway를 사용해서 독자적인 API를 구성할 수 있다. 독자적인 API를 정의하고 백엔드에서 오리지널 API를 펑션으로 정의해서 연동할 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"Spring MVC의 ArgumentResolver 파헤치기","slug":"spring/spring-argument-resolver","date":"2023-03-16T12:28:46.000Z","updated":"2023-03-17T12:43:46.524Z","comments":true,"path":"2023/03/16/spring/spring-argument-resolver/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/16/spring/spring-argument-resolver/","excerpt":"","text":"궁금한 점스프링 MVC로 컨트롤러 코드를 작성하다보면 다음과 같이 컨트롤러 메서드의 파라미터에 다양한 값을 받을 수 있음을 알게 된다. 1234567@RestControllerpublic class SomeClass &#123; @GetMapping(&quot;/some&quot;) public ResponseEntity&lt;?&gt; getSome(final Pageable pageable, @RequestBody final String body) &#123; return ResponseEntity.noContent().build(); &#125;&#125; 여기서 파리미터 매핑을 스프링에서 해준다!하지만 어떤 경우에는 어노테이션 (@RequestBody, @PathVariable)을 넣어줘야 되는 경우도 있고, 어떤 경우에는 어노테이션을 생략해도 된다.(@ModelAttribute, @RequestParam) 심지어 어느 경우는 어노테이션이 없는 경우도 있다.(Pageable) 이번 기회에 날잡아서 스프링에서 어떻게 파라미터에 값을 넣어주는지, 어떤 경우에 어노테이션이 필요한 지 살펴보자. 디스패처 서블릿 부터 시작한다스프링 MVC는 프론트 컨트롤러 패턴을 사용한다. 요청을 처리하는 과정에서 중복되는 과정을 프론트 컨트롤러에서 모아서 처리한다. 우리가 궁금해하는 컨트롤러 메서드의 파라미터 처리도 디스패처 서블릿과 관련된 어디에선가 처리할 것이다! doService디스패처 서블릿은 doService라는 메서드를 통해 요청을 처리한다. doService는 doDispatch 메서드로 요청 처리를 넘긴다. 123456789101112131415161718192021222324public class DispatcherServlet extends FrameworkServlet &#123; // 생략 @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // 생략... try &#123; doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (this.parseRequestPath) &#123; ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request); &#125; &#125; &#125; doDispatchdoDispatcher는 핸들러에게 요청을 처리하도록 한다. 정확하게 말하면 ha.handle(processedRequest, response, mappedHandler.getHandler());를 통해 핸들러 어댑터를 통해 핸들러에게 요청을 처리하도록 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class DispatcherServlet extends FrameworkServlet &#123; // 생략 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = HttpMethod.GET.matches(method); if (isGet || HttpMethod.HEAD.matches(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new ServletException(&quot;Handler dispatch failed: &quot; + err, err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new ServletException(&quot;Handler processing failed: &quot; + err, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125;&#125; Handler와 HandlerAdapter위 DispatcherServlet의 ha.handle(processedRequest, response, mappedHandler.getHandler()); 코드가 핸들러 어댑터를 활용해서 핸들러에게 요청을 처리하도록 한다. 여기서 mappedHandler는 HandlerExecutionChain이라는 객체다. HandlerExecutionChain은 핸들러와 같이 실행되는 인터셉터들을 가지고 있다.HandlerMapping 인터페이스는 getHandler(HttpServletRequest request)를 통해 해당 요청을 처리해야하는 핸들러와 적용되야 하는 인터셉터를 포함한 HandlerExecutionChain을 반환한다. 여기서 HandlerExecutionChain은 핸들러를 Object로 저장하고 있다. 즉 요청을 처리할 핸들러가 어떤 메서드를 통해 요청을 처리할 줄 모른다는 뜻이다. 123456789101112public class HandlerExecutionChain &#123; private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class); private final Object handler; private final List&lt;HandlerInterceptor&gt; interceptorList = new ArrayList&lt;&gt;(); private int interceptorIndex = -1; // 생략&#125; 결국 Object로 핸들러를 전달받으면 어떤 메서드를 호출해야 할 지 알 수 없다. 특히 스프링에서는 다양한 종류의 핸들러가 존재해서 하나의 타입으로 캐스팅 할 수도 없다.이래서 HandlerAdapter가 존재한다. HandlerAdapter는 전달받은 핸들러가 어떤 객체이든 해당 핸들러를 호출할 수 있는 방법을 추상화한 인터페이스이다!!! RequestMappingHandlerAdapter에서 ArgumentResolver를 관리한다.그래서 ha.handle(processedRequest, response, mappedHandler.getHandler());를 디버깅을 해보면 AbstractHandlerMethodAdapter의 handle메서드를 호출한다. 1234567@Override@Nullablepublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler);&#125; 여기서 handlerInternal메서드는 AbstractHandlerMethodAdapter를 상속한 RequestMappingHandlerAdapter의 메서드가 호출된다. RequestMappingHandelrAdapter에 우리가 그렇게 찾던 HandlerMethodArgumentResolver를 관리하고 있다!!!! 1234567891011121314151617181920212223242526272829public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123;// 생략... @Nullable private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite argumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers; @Nullable private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers; @Nullable private HandlerMethodReturnValueHandlerComposite returnValueHandlers; @Nullable private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers; private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager(); private final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;(); private final List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList&lt;&gt;(); //생략...&#125; RequestMappingHandlerAdapter에서는 argumentResolver와 customArgumentResolvers를 가지고 있다. argumentResolver는 getDefaultArgumentResolvers메서드를 통해 초기화된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;&gt;(30); // Annotation-based argument resolution resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); // Type-based argument resolution resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); if (KotlinDetector.isKotlinPresent()) &#123; resolvers.add(new ContinuationHandlerMethodArgumentResolver()); &#125; // Custom arguments if (getCustomArgumentResolvers() != null) &#123; resolvers.addAll(getCustomArgumentResolvers()); &#125; // Catch-all resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers;&#125; 여기서 보면 어노테이션을 붙여야 하는 리졸버 -&gt; 타입에 맞춰서 해주는 리졸버 -&gt; 커스텀 리졸버(Pageable리졸버가 해당) -&gt; 그외 모든 대상을 리졸브 대상으로 하는 리졸버 순으로 등록된다! 다시 handlerInternal 메서드로 돌아오면 결국 invokeHandlerMethod를 호출한다. 123456789101112131415161718192021222324252627282930@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; // 생략... return mav;&#125; invokeHandlerMethod는 ServletInvocableHandlerMethod를 만들어서 argumentResolver를 세팅해서 invokeAndHandle한다!! 123456789101112131415161718192021222324252627@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // 생략 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest);&#125; 결론@RequestMapping으로 매핑된 핸들러(메서드)는 RequestMappingHandlerAdapter에서 처리된다!RequestMappingHandlerAdapter에서 핸들러의 인자를 리졸브하는 HandlerMethodArgumentResolver들을 관리한다!RequestMappingHandlerAdapter에서는 정해진 우선순위 (어노테이션이 필요한 리졸버 - 타입으로 리졸브하는 리졸버 - 커스텀 리졸버 - 모든 것을 리졸브하려는 리졸버)로 인자를 리졸브한다!@PathVariable은 어노테이션이 필요한 리졸버이다.ServletRequest나 ServletResponse는 타입 기반으로 리졸브하는 리졸버이다. (그래서 인자에 다른 매개변수가 필요없다!)Pageable은 커스텀 리졸버이다!! (Spring Data에서 제공하는 리졸버이다!)@ModelAttribute나 @RequestParam 은 어노테이션이 있어도 작동하고, 없어도 작동하는 리졸버이다!!! (가장 우선순위가 낮은 리졸버들이다.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"클라우드 컴퓨팅과 API의 역할, 대표적인 컴포넌트","slug":"cs/infra/cloudcomputingAndApi","date":"2023-03-15T04:52:36.000Z","updated":"2023-03-20T08:07:39.136Z","comments":true,"path":"2023/03/15/cs/infra/cloudcomputingAndApi/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/15/cs/infra/cloudcomputingAndApi/","excerpt":"","text":"클라우드 컴퓨팅? 그게 뭐야?클라우드 컴퓨팅은 IT 자원이 필요할 때 즉시 사용할 수 있는 환경을 의미한다. 공용 클라우드와 사설 클라우드를 어떤 차이가 있나?목적이 다르다.공용 클라우드는 IT 리소스를 제공하고 수익을 버는 것!사설 클라우드는 자사에 IT 리소스를 제공하는 것이지만 수익을 위한 것이 아니다. 비용이 다르다.공용 클라우드는 IT 리소스를 사용하는 만큼만 지불해서 하드웨어와 관련된 비용 문제가 없다.사설 클라우드는 하드웨어 비용이 크게 든다. IaaS, PaaS, SaaS가 뭐지?SaaS : 소프트웨어를 제공 -&gt; 바로 사용!PaaS : 플랫폼 (개발 환경, 프레임워크)를 제공 -&gt; 바로 개발!IaaS : 인프라(서버, 네트워크, 스토리지, OS)를 제공 -&gt; 자신만의 서비스 인프라 구성! 컴포넌트 추상화는 뭐지?클라우드 인프라 서비스는 인프라 리소스를 가상화하여 하드웨어와 분리한다.리소스를 다룰 때 하드웨어 문제를 신경쓰지 않아도 된다. 컴포넌트 추상화는 하드웨어와 분리되어 사용자의 요구사항을 인프라로 구현하도록 돕는 개념이다.요구사항을 하드웨어를 통해 구축하는 것보다 요구사항 자체를 컴포넌트에 전달하면 실제 구현을 알아서 적용되도록 한다. 이렇게 요구사항을 컴포넌트를 통해 추상화 해놓으면 컴포넌트를 통해 클라우드 환경에서 시스템 구축 과정을 표준화 할 수 있게 된다. 클라우드 컴퓨팅을 활용하기Iaas에서 컴포넌트를 활용해서 서비스 인프라 구축을 표준화할 수 있게됐다.클라우드는 API를 통해 리소스를 제어할 수 있게 한다. 이를 통해 시스템 구축부터 서버의 설치나 네트워크결 연결까지 자동화할 수 있다. 클라우드의 대표적인 컴포넌트테넌트테넨트는 세입자다. AWS로 치면 사용자 계정이 해당된다.하나의 계정에 여러 시스템을 관리할 수 있다.테넨트는 비용 청구의 단위가 된다.테넨트는 가상 네트워크, 가상 머신 인스턴스, 가상 스토리지 끼리만 서로 연결 가능하다.또한 여러 테넌트를 합쳐서 멀티 테넨트를 하나의 테넨트로 쓸 수 있다. (AWS Organization) 리전클라우드 인프라를 지역단위로 묶어서 관리하기 위해 등장한 개념이다.리전은 각각 독립된 환경이라 여러 리전을 걸친 가상 네트워크를 구현할 수 없다.즉 가상 네트워크는 리전별로 독립된 형태로 만들어진다. 이런 가상 네트워크를 VPC라고 한다. 한 리전에 여러 VPC 가능하다. 다른 리전에 DR다만 다른 리전에 DR 환경을 구축할 수는 있다. DR : disaster recovery 서울에 재난이 생기면 시드니에 동일한 환경을 가진 시스템을 작동시키는 것. 이때 퍼블릭 IP의 범위가 달라질 수 있어서 DNS에 IP를 업데이트 해줘야 할 수 있다.환경 뿐만 아니라 데이터도 다른 리전에 역제해놔야 한다.이때 오브젝트 리소스를 활용한다. 오브젝트 리소스는 리전에 종속되지 않기 때문이다! 가용영역리전이 지역이라면 가용 영역은 그 리전에 속한 데이터 센터라고 이해하자.(AWS의 ap-northeast-2a 같은 것, 오픈 스택에서는 데이터 센터 안에서 가용 영역을 더 나눌 수 있다고 한다.)다른 가용영역에 있는 가상 머신 인스턴스와 블록 스토리지는 서로 연결할 수 없다.(물론 네트워크를 통한 연결은 된다. 블록 스토리지를 마운트 하는 행위 같은 연결이 안된다는 의미다.) 네트워크 리소스라우터 (그냥 공유기)독립된 가상 네트워크(VPC)는 공유기로 구성한 LAN과 같이 외부의 접근이 차단된 네트워크와 비슷하다.가정용 LAN을 인터넷과 연결하기 위해서는 인터넷 라우터가 필요하다.클라우드 환경에서도 가상 네트워크와 물리적인 외부 네트워크를 연결하는 가상 라우터가 있어야 한다.가상 네트워크에서는 LAN과 같이 프라이빗 IP주소를 사용한다.외부 네트워크와 통신할 때는 가상 라우터의 NAT 기능을 사용해서 Public IP로 변환한다.(NAT는 네트워크 계층 포스트를 통해 알아보자.) AWS에서 VPC를 만들면 Internet Gateway가 생기는데, Internet Gateway가 라우터 역할을 한다. 스위치가상 스위치는 가상 라우터와 가상 머신 인스턴스의 가상 NIC가 연결되는 지점가상 스위치는 물리 스위치와 다르게 포트 제한이 없다.(물리 스위치는 포트가 부족하면 허브를 두거나 스위치를 더 둔다.)가상 스위치는 가상 NIC를 써서 포트 문제를 해결한다. (AWS에서는 ENI. 인스턴스가 올라갈 때 ENI가 할당된다)가상 인스턴스와 연결해야 할 때 포트가 추가 → 해당 포트에 서브넷 범위 안에서 사용할 수 있는 IP 주소 할당 → DHCP 방식으로 가상 NIC에 연결됨 서브넷가상 스위치에 해당하는 컴포넌트를 서브넷이라고 한다.가용 영역 별로 서브넷을 구성 할 수 있다.가상 스위치에 하나의 서브넷이 할당된다.서브넷은 가상 머신 인스턴스가 사용할 수 있는 사설 IP 주소의 범위 AWS는 가상 스위치과 서브넷을 합쳐서 서브넷이라고 부른다.AWS에서는 하나의 가상 스위치(서브넷)이 하나의 가용 영있에 할당. 라우터는 집이고 서브넷은 집안에 방이라고 생각하면 된다. 공인 IP 주소사설 IP주소를 가상 라우터의 NAT 기능을 통해 공인 IP(퍼블릭)로 변환하는 방식이걸 IP 마스커레이딩이라 한다. (외부로 통신할 때 나의 사설 IP를 사설 라우터의 공인 IP로 변환!)이런 마스커레이딩은 내부에서 외부로 통신할 수는 있지만, 외부에서 내부의 서버로 통신은 안된다!! 결국 모든 사설 IP(private ip)를 같은 공인 IP로 변환하여 외부 네트워크에 통신한다.이 방식은 private ip가 외부 접근은 되지만 외부에서 사설 ip접근은 안된다. AWS의 엘라스틱 IP미리 개별적으로 확보해둔 퍼블릭 아이피를 라우터가 가상 인스턴스에 할당 (즉 공인 IP를 private ip에 매핑하는 방식)내부 → 외부, 외부 → 내부 모두 가능하다.단 리전마다 따로 확보해야 한다. 다른 리전에서 재사용 불가. 시큐리티 그룹가상 머신 인스턴스가 주고받을 네트워크 패킷을 필터링하는 기능아이피 포트 뿐만 아니라 프로토콜 종류를 통해 필터링도 가능하다.여러개의 가상 스위치에 접속하고 싶으면 여러 가상 NIC가 있어야되고 각 가상 NIC는 스위치 포트에 접속하러 갈 때 시큐리티 그룹을 설정해줄 수 있다. 시큐리티 그룹과 비슷한 방식으로 라우팅 테이블에서도 필터링을 해줄 수 있다.다만 라이퉁 테이블은 서브넷에 접속하기 전에 작동하고, 시큐리티 그룹은 인스턴스에 접근하기 전에 작동한다. 서버 리소스템플릿 이미지가상 머신 인스턴스를 기동하기 위해 게스트 OS가 설치된 기동 디스크가 필요하다.이 기동디스크를 만들어주는 애가 템플릿 이미지.템플릿 이미지가 다운로드 되서 가상 디스크 형태로 만들어지고 가상 머신 인스턴스가 가상 디스크를 연결해서 사용 루트 디스크와 임시 디스크는 가상 머신 인스턴스를 종료하면 날라간다. (남기고 싶으면 블록 스토리지를 사용할 수 있다.)만약 루트 디스크에 저장된 어플리케이션을 보존하고 싶으면 스냅샷을 남기자. (EC2로 DB를 운영할 경우 매일 데이터베이스의 스냅샷을 남길 수 있다.)스냅샷은 루트 디스크를 복제하고 템플릿 이미지로 만든다. 네트워크 접속과 시큐리티 그룹인스턴스의 가상 NIC가 네트워크와 연결되려면 가상 스위치에 연결되어 있어야 한다! (그래야 가상 스위치가 가상 라우터와 연결이 되니까) 인스턴스 하나에 여러 NIC를 연결할 수 있다.다만 컨테이너를 인스턴스에 사용할 때는 ECS ENI Trunking을 유의하자. 시큐리티 그룹은 NIC에 적용된다! 즉 한 인스턴스라도 NIC마다 다르게 시큐리티 그룹을 적용할 수 있다. 로그인 인증과 키페어기본적으로 SSH의 공개 키 인증 방식이 사용한다.테넌트 이용자는 접속 전용 키페어를 만든다.공개키는 클라우드 환경에 등록 &amp; 개인 키는 사용자가 다운로드가상 머신 인스턴스에 템플릿 이미지로 게스트 os를 설치할 때 공개키도 같이 설정된다. 블록 스토리지가상 머신 인스턴스가 종료되어도 내용을 보존하는 영속적인 디스크 영역(AWS에서는 EBS라고 부름.)가상 머신 인스턴스는 어플리케이션을 가동하는 가상 컴퓨터.가상 머신 인스턴스에 블록 스토리지를 마운트 해서 보통의 물리적 디스크 디바이스처럼 쓸 수 있게 된다.블록 스토리지는 여러 가상 머신 인스턴스에도 마운트할 수 있다. 블록 스토리지에 있는 게스트 OS로 가상 머신 인스턴스를 가동하는 방법.AWS에서는 EBS Boot미리 볼륨을 만들어 놓고 템플릿 이미지를 복제해서 가상 머신 인스턴스에 연결.다른 가상 머신 인스턴스에 연결해도 이어서 할 수 잇음 오브젝트 스토리지 리소스파일 단위로 데이터를 저장하는 데이터 스토어.HTTP, HTTPS로 사용하는 파일서버테넨트가 생성한 S3 버킷은 모든 리전과 가용영역에서 접근 가능!컨테이너(버킷)은 디렉토리처럼 계층적 구조는 되지 않지만 파일 이름을 디렉토리처럼(abc&#x2F;file) 묘사해서 비슷한 효과를 낼수 잇다.키와 값으로 메타 데이터를 부여할 수도 있다. 버저닝컨테이너에서 관리하는 오브젝트에 버전 번호를 붙여서 관리하는 기능.롤백같은 기능을 수행할 수 있다. 백업블록 스토리지의 볼륨을 여러 블록으로 분할해서 하나의 파일 형태로 간주하여 오브젝트 스토리지에 저장.리전이나 가용영역을 뛰어넘어서 복원할 수 있다. 웹 애플리케이션 시스템 구축 예시여러 가용 영역으로 가용성 확보AWS는 VPC별로 가상 네트워크가 만들어지고, 가상 네트워크 속 가용 영역 별로 가상 스위치(서브넷)이 생기고,각 사용 용도에 따라 네트워크를 분리하기 위해 가상 스위치(서브넷)를 만들어서 통신할 수 있다.가상 머신 인스턴스에 해당 스위치(서브넷)를 통해서만 통신할 수 있도록 하면 접근을 제한 할수 잇다.다른 가용영역에 현재 가용영역과 동일한 환경을 구축해놓고 문제가 생기면 해당 가용영역으로 접근하도록 로드밸런싱을 해주거나 DNS 설정을 바꿔줘야 한다.가용 영역을 사용한 정적 안정성 오브젝트 스토리지로 데이터 지키기DB 서버가 관리하는 데이터를 블록 스토리지 볼륨에 저장시키면 가상 머신 인스턴스가 잘못되어도 데이터를 지킬 수 있다.근데 블록 스토리지가 잘못될 경우를 예상해서 이마저도 오브젝트 스토리지에 백업해두면 된다.그런데 볼륨 백업은 오브젝트 스토리지로 전송해야 되니까 좀 느릴 순 있다. 백업하기 전에는 볼륨을 가상 머신 인스턴스에서 분리해야 됨.이때는 당연히 디비 서버가 요청을 처리하지 못한다.그러면 볼륨의 스냅샷을 떠서 백업하도록 하면 된다.스냅샷을 만들때도 인스턴스에서 볼륨을 분리하지만 시간이 적게 든다. 가상 머신 인스턴스에 블록 스토리지를 연결해두고 오브젝트 스토리지에 백업해둔다.가용 영역 전환할 때 해당 가용 영역의 블록 스토리지에 오브젝트 스토리지의 데이터를 통해 데이터 구축 가능하다. 다른 방법으로는 데이터베이스가 네트워크를 통해 동기화하는 기능을 사용할 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Infra","slug":"computer-science/infra","permalink":"https://yangdongjue5510.github.io/categories/computer-science/infra/"}]},{"title":"F12 서비스 의존성 개선 리팩토링","slug":"spring/refactor-f12-dependency","date":"2023-03-12T12:35:13.000Z","updated":"2023-03-16T11:00:05.627Z","comments":true,"path":"2023/03/12/spring/refactor-f12-dependency/","link":"","permalink":"https://yangdongjue5510.github.io/2023/03/12/spring/refactor-f12-dependency/","excerpt":"","text":"F12 서비스 링크(https://f12.app/) 기존 상황F12 서비스 백엔드 아키텍처는 도메인 개념 별로 의존성을 그려보면 다음과 같다.총 세가지 양방향 의존이 생긴다. 이런 상황이면 Review에 변경이 생기면 Product -&gt; InventoryProduct -&gt; Member -&gt; Following 까지 변경에 따른 영향이 생길 수 있다. Member &lt;–&gt; InventoryProductMember의 상황회원을 의미한다. 123456789101112131415161718192021222324252627282930313233343536373839404142@Entity@Builderpublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;github_id&quot;, nullable = false) private String gitHubId; @Column(name = &quot;name&quot;) private String name; @Column(name = &quot;image_url&quot;, length = 65535, nullable = false) private String imageUrl; @Column(name = &quot;registered&quot;, nullable = false) private boolean registered; @Column(name = &quot;career_level&quot;) @Enumerated(EnumType.STRING) private CareerLevel careerLevel; @Column(name = &quot;job_type&quot;) @Enumerated(EnumType.STRING) private JobType jobType; @Column(name = &quot;follower_count&quot;, nullable = false) private int followerCount; @Builder.Default @Embedded private InventoryProducts inventoryProducts = new InventoryProducts(); @Builder.Default @Enumerated(EnumType.STRING) @Column(name = &quot;role&quot;, nullable = false) private Role role = Role.USER; // 생략&#125; Member의 엔티티는 InventoryProduct 도메인에 해당하는 InventoryProducts를 멤버로 가지고 있다. InventoryProducts를 통해 사용자의 프로필 장비를 조회할 수 있다. F12 서비스에서 다음과 같은 프로필을 구현할 때 사용자의 회원정보와 그 사용자의 프로필 장비를 같이 보여주기 때문에 멤버 변수로 의존하게 됐다.즉 Member를 조회할 때 InventoryProduct를 함께 조회해서 위와 같은 프로필을 만들기 용이하기 위해 Member가 InventoryProduct에 의존한다. 그리고 Member의 서비스 로직에서 사용자들의 프로필을 만들 때 해당 회원들의 인벤토리 장비도 조회해와야 한다.아래가 사용자들의 프로필을 만드는 서비스 로직이다. Member를 조회해오고 그에 해당하는 InventoryProduct를 조회해서 조립하고 있다. 이렇게 Member와 InventoryProduct를 따로 조회해서 조립하면 InventoryProductRepository에 의존성이 생긴다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Service@Transactional(readOnly = true)public class MemberService &#123; private final MemberRepository memberRepository; private final FollowingRepository followingRepository; private final InventoryProductRepository inventoryProductRepository; public MemberService(final MemberRepository memberRepository, final FollowingRepository followingRepository, final InventoryProductRepository inventoryProductRepository) &#123; this.memberRepository = memberRepository; this.followingRepository = followingRepository; this.inventoryProductRepository = inventoryProductRepository; &#125; // 생략... public MemberPageResponse findBySearchConditions(@Nullable final Long loggedInId, final MemberSearchRequest memberSearchRequest, final Pageable pageable) &#123; final Slice&lt;Member&gt; slice = findBySearchConditions(memberSearchRequest, pageable); if (slice.isEmpty()) &#123; return MemberPageResponse.ofByFollowingCondition(slice, false); &#125; setInventoryProductsToMembers(slice); if (isNotLoggedIn(loggedInId)) &#123; return MemberPageResponse.ofByFollowingCondition(slice, false); &#125; final List&lt;Following&gt; followings = followingRepository.findByFollowerIdAndFollowingIdIn(loggedInId, extractMemberIds(slice.getContent())); return MemberPageResponse.of(slice, followings); &#125; private Slice&lt;Member&gt; findBySearchConditions(final MemberSearchRequest memberSearchRequest, final Pageable pageable) &#123; final CareerLevel careerLevel = parseCareerLevel(memberSearchRequest); final JobType jobType = parseJobType(memberSearchRequest); if (memberSearchRequest.getQuery() == null &amp;&amp; careerLevel == null &amp;&amp; jobType == null) &#123; return memberRepository.findWithOutSearchConditions(pageable); &#125; return memberRepository.findWithSearchConditions(memberSearchRequest.getQuery(), careerLevel, jobType, pageable); &#125; private void setInventoryProductsToMembers(final Slice&lt;Member&gt; slice) &#123; final List&lt;InventoryProduct&gt; mixedInventoryProducts = inventoryProductRepository.findWithProductByMembers( slice.getContent()); for (Member member : slice.getContent()) &#123; final List&lt;InventoryProduct&gt; memberInventoryProducts = mixedInventoryProducts.stream() .filter(it -&gt; it.getMember().isSameId(member.getId())) .collect(Collectors.toList()); member.updateInventoryProducts(memberInventoryProducts); &#125; &#125; private JobType parseJobType(final MemberSearchRequest memberSearchRequest) &#123; final JobTypeConstant jobTypeConstant = memberSearchRequest.getJobType(); if (jobTypeConstant == null) &#123; return null; &#125; return jobTypeConstant.toJobType(); &#125; private CareerLevel parseCareerLevel(final MemberSearchRequest memberSearchRequest) &#123; final CareerLevelConstant careerLevelConstant = memberSearchRequest.getCareerLevel(); if (careerLevelConstant == null) &#123; return null; &#125; return careerLevelConstant.toCareerLevel(); &#125; private List&lt;Long&gt; extractMemberIds(final List&lt;Member&gt; members) &#123; return members.stream() .map(Member::getId) .collect(Collectors.toList()); &#125;&#125; 이렇게 생긴 의존성은 MemberRepository에서 Member를 조회할 때 Left join 기반으로 한 fetch join으로 연관된 엔티티를 한번에 읽어오게 하면 서비스 로직에서 InventoryProductRepository에 의존하지 않고 회원들의 인벤토리 장비를 가져올 수 있다. 여기서 한가지 포인트를 알고가자.fetch join으로 한번에 같이 조회해서 서비스 로직에서 InventoryProduct 의존성을 제거할 수 있다. 하지만 Member 엔티티에서 InventoryProduct를 멤버 변수로 의존하게 된다. 또 MemberRepository에서 InventoryProduct를 알게 된다.Member 엔티티에서 InventoryProduct 의존성을 제거하면 MemberService에서 Member를 조회해올 때 InventoryProduct를 한번에 조회할 수 없고 InventoryProductRepository에 의존하게 된다. Member 입장에서 보면 프로필을 만드는 로직 때문에 서비스 레이어 혹은 엔티티에서 InventoryProduct에 의존하게 된다. InventoryProduct의 상황회원이 리뷰를 남긴 제품을 의미한다.인벤토리 장비가 프로필 장비인 지 구분할 수 있다. 리뷰를 남긴 제품은 자동으로 회원의 인벤토리 장비가 된다.InventoryProduct는 DB 테이블로 생각하면 Member와 Product의 다대다 매핑 테이블 역할도 한다. 123456789101112131415161718192021@Entity@Builder@Getterpublic class InventoryProduct &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;selected&quot;) private boolean selected; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;member_id&quot;) private Member member; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;product_id&quot;) private Product product; // 생략&#125; 엔티티 상으로는 Member와 Product에 의존한다. Product 의존성은 InventoryProduct가 대부분 장비의 정보를 함께 조회해서 멤버 변수로 가져도 괜찮다.하지만 Member가 문제다. InventoryProduct는 Member를 사용하지 않는데 멤버 변수로 갖고 있다.이런 불필요한 직접 참조는 id로 간접 참조하면 쉽게 해결할 수 있다. 1234567891011121314151617181920@Entity@Builder@Getterpublic class InventoryProduct &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;selected&quot;) private boolean selected; @Column(name = &quot;member_id&quot;) private Long memberId; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;product_id&quot;) private Product product; // 생략&#125; 문제는 서비스 레이어에서 Member에 의존하고 있다는 점이다. 특정 사용자id로 해당 사용자의 인벤토리 장비를 조회해야 하는 경우 사용자 Id가 유효한 지 확인해야 한다.그래서 다음과 같은 의존이 생긴다. 123456789101112131415@Servicepublic class InventoryProductService &#123; // 생략... public InventoryProductsResponse findByMemberId(final Long memberId) &#123; validateMember(memberId); final List&lt;InventoryProduct&gt; inventoryProducts = inventoryProductRepository.findWithProductByMemberId(memberId); return InventoryProductsResponse.from(inventoryProducts); &#125; private void validateMember(final Long memberId) &#123; if (!memberRepository.existsById(memberId)) &#123; throw new MemberNotFoundException(); &#125; &#125;&#125; 이런 의존을 AOP로 분리할 수는 있을 것 같다. 하지만 그렇게 하면 서비스 로직이 여러군데 퍼지는 것 같고 실수할 여지가 많을 것 같다.혹은 DIP를 적용해서 MemberValidator라는 인터페이스를 InventoryProduct 패키지에 두고, MemberValidator의 구현체는 Member에 두고 빈 등록하여 InventoryService는 MemberValidator 인터페이스를 주입받아서 사용하면 Member에게 의존하지 않고 Member가 InventoryProduct에 의존하게 할 수 있다. 하지만 InventoryProduct이 Member에 의존하는게 잘못된 걸까?의미 상 InventoryProduct는 특정 회원의 인벤토리 장비이다. InventoryProduct의 로직 상 Member에게 의존해서 협력하는 게 자연스럽고, 이 의존을 없애거나 역전하기 위해 복잡도를 높이는 게 오히려 코드를 이해하는 데 어려울 수 있다. 해결책현재까지 문제점을 정리하자면 다음과 같다.Member는 프로필 관련 기능 때문에 InventoryProduct를 의존할 수 밖에 없다. (서비스 레이어 혹은 엔티티)InventoryProduct는 Member 의존성을 다양한 방법으로 제거할 수 는 있지만 의미 상 의존하는게 자연스럽고 의존을 제거하면 복잡도가 높아질 것 같다. 그렇다면 Member에서 프로필 관련 기능을 아예 다른 패키지로 추출하면 어떨까?profile 이라는 새로운 패키지를 도입해서 프로필 관련 기능을 모을 수 있지 않을까? 프로필 관련 로직을 profile에 모으면 다음과 같이 의존성이 그려진다. 한번 로직을 모아보자! 도메인먼저 프로필 기능에 필요한 도메인 클래스를 만들어보자. 프로필은 특정 대상이 팔로잉하는지 알려줄 수 있어야 하고, 대표장비와 회원정보를 알려줄 수 있어야 한다. 여기서 중요한 점은 프로필의 의미이다. 프로필은 아래 그림을 보면 알 수 있듯이, 특정 회원의 회원정보와 대표장비 그리고 보는 사람이 팔로우 했는지를 알려주는 개념이다.즉 프로필은 보는 사람에 따라 팔로우 여부를 상대적으로 가지게 된다는 사실을 명심하자. 12345678@Getterpublic class Profile &#123; private final Member member; private final InventoryProducts inventoryProducts; private final boolean isFollowing; // 생략&#125; 12345678910111213141516171819@Getterpublic class Profiles &#123; private final List&lt;Profile&gt; profiles; private Profiles(final List&lt;Profile&gt; profiles) &#123; this.profiles = profiles; &#125; public static Profiles of(final List&lt;Member&gt; members, final List&lt;InventoryProduct&gt; inventoryProductsOfMembers, final List&lt;Following&gt; followingRelations) &#123; final Map&lt;Long, List&lt;InventoryProduct&gt;&gt; inventoryProductsGroups = groupByMemberId(inventoryProductsOfMembers); final List&lt;Profile&gt; profiles = members.stream() .map(member -&gt; createProfile(member, inventoryProductsGroups, followingRelations)) .collect(Collectors.toList()); return new Profiles(profiles); &#125; // 생략...&#125; 서비스 코드이제 기존에는 MemberService에서 수행하던 프로필 로직(Member조회하고 InventoryProduct 조회해서 합치기)를 ProfileService에서 하면 된다. 1234567891011121314151617181920212223242526272829@Service@Transactional(readOnly = true)public class ProfileService &#123; private final MemberRepository memberRepository; private final InventoryProductRepository inventoryProductRepository; private final FollowingRepository followingRepository; public ProfileService(final MemberRepository memberRepository, final InventoryProductRepository inventoryProductRepository, final FollowingRepository followingRepository) &#123; this.memberRepository = memberRepository; this.inventoryProductRepository = inventoryProductRepository; this.followingRepository = followingRepository; &#125; public PagedProfilesResponse findBySearchConditions(@Nullable final Long loggedInId, final ProfileSearchRequest profileSearchRequest, final Pageable pageable) &#123; final Slice&lt;Member&gt; slice = findBySearchConditions(profileSearchRequest, pageable); if (slice.isEmpty()) &#123; return PagedProfilesResponse.empty(); &#125; final Profiles profiles = createProfiles(loggedInId, slice.getContent()); return PagedProfilesResponse.of(slice.hasNext(), profiles); &#125; //생략...&#125; 의존성을 정리하고 나면,,이제 Member는 회원 정보 관리와 팔로우 관련 기능만 수행한다.InventoryProduct는 인벤토리 장비 추가, 삭제, 대표장비 수정 관련 기능만 수행하게 된다.Profile은 Member와 InventoryProduct를 기반으로 프로필 생성하는 기능을 수행하게 된다. 이전보다 각 도메인들의 역할이 간단명료해졌다! Product &lt;–&gt; InventoryProduct, ReviewProduct의 상황리뷰 대상인 장비를 의미한다. 엔티티만 살펴보면 특별히 다른 도메인에 의존하지 않는다. 1234567891011121314151617181920212223242526272829303132@Entity@Builder@Getterpublic class Product &#123; private static final int MAXIMUM_IMAGE_URL_LENGTH = 15000; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;name&quot;, nullable = false) private String name; @Column(name = &quot;image_url&quot;, nullable = false, length = MAXIMUM_IMAGE_URL_LENGTH) private String imageUrl; @Column(name = &quot;review_count&quot;, nullable = false) private int reviewCount; @Column(name = &quot;total_rating&quot;, nullable = false) private int totalRating; @Column(name = &quot;avg_rating&quot;, nullable = false) private double rating; @Column(name = &quot;category&quot;, nullable = false, length = 8) @Enumerated(value = EnumType.STRING) private Category category; // 생략&#125; 하지만 Product 도메인은 서비스 레이어에서 여러 도메인들에 의존한다.특히 Product 엔티티가 제거되면 해당 장비에 대한 리뷰와 해당 장비를 인벤토리 장비 설정한 내역도 모두 제거해야 된다.그래서 ProductService에서는 다음과 같이 다른 도메인의 레포지토리를 의존한 경우가 있었다. 1234567891011public class ProductService &#123; //... 생략 @Transactional public void delete(final Long productId) &#123; final Product target = productRepository.findById(productId) .orElseThrow(ProductNotFoundException::new); reviewRepository.deleteByProduct(target); inventoryProductRepository.deleteByProduct(target); productRepository.delete(target); &#125;&#125; InventoryProduct와 Review의 상황InventoryProduct의 경우, 회원이 리뷰를 남긴 장비라는 의미이기 때문에 항상 제품 정보를 함께 보여줘야 한다. 그래서 엔티티에서 멤버로 Product를 의존하고, 서비스 레이어에서도 Product가 유효한 지 체크하는 로직도 있다. Review의 경우, 회원이 장비에 남긴 리뷰를 의미한다. 리뷰도 inventoryProduct와 비슷하게 제품 정보를 같이 보여줘야 하는 경우가 많아서 엔티티에서 멤버로 Product를 의존하고, 서비스 레이어에서도 Product 유효성 검증을 한다. 123456789101112131415161718192021222324252627@Entity@Builder@Getterpublic class Review &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;content&quot;, nullable = false, length = MAXIMUM_CONTENT_LENGTH) private String content; @Column(name = &quot;rating&quot;, nullable = false) private int rating; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;product_id&quot;, nullable = false) private Product product; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;member_id&quot;, nullable = false) private Member member; @CreatedDate @Column(name = &quot;created_at&quot;, nullable = false, updatable = false) private LocalDateTime createdAt; //생략 해결책지금까지 파악한 문제는 InventoryProduct, Review는 Product와 조회되는 일이 많고 Product 검증해야 하는 로직 때문에 Product에 의존하고 있었다. Product는 장비 삭제할 때 해당하는 InvnentoryProduct와 Review를 제거해야 해서 의존성이 생겼었다. 이런 문제는 Product 삭제 시, 이벤트를 발행해서 해당 이벤트를 처리하는 이벤트 리스너를Review와 InvnetoryProduct에 추가하는 방식으로 해결했다. 이벤트 구현product 패키지에 장비가 삭제됐음을 알리는 이벤트를 만들어본다. ApplicationEvent를 상속해야 한다. 12345678910111213public class ProductDeletedEvent extends ApplicationEvent &#123; private final Long productId; public ProductDeletedEvent(final Object source, final Long productId) &#123; super(source); this.productId = productId; &#125; public Long getProductId() &#123; return productId; &#125;&#125; 그리고 ProductDeletedEvent를 장비 삭제 당시에 발행하도록 해보자. 123456789101112131415161718@Service@Transactional(readOnly = true)public class ProductService &#123; private final ProductRepository productRepository; private final ApplicationEventPublisher eventPublisher; // 생략 @Transactional public void delete(final Long productId) &#123; final Product target = productRepository.findById(productId) .orElseThrow(ProductNotFoundException::new); productRepository.delete(target); final ProductDeletedEvent event = new ProductDeletedEvent(this, productId); eventPublisher.publishEvent(event); &#125;&#125; ApplicationEventPublisher를 주입받고 생성한 이벤트를 발행하도록 한다. 이벤트 리스너 구현하기이제 review와 inventoryProduct 패키지에 ProductDeletedEvent를 처리하는 이벤트 리스너를 구현해보자. @EventListener를 이벤트 처리하는 메서드에 붙여주고, 매개변수를 처리할 이벤트로 해놓는다. 1234567891011121314@Componentpublic class ReviewEventListener &#123; private final ReviewRepository reviewRepository; public ReviewEventListener(final ReviewRepository reviewRepository) &#123; this.reviewRepository = reviewRepository; &#125; @EventListener public void handle(final ProductDeletedEvent event) &#123; reviewRepository.deleteByProductId(event.getProductId()); &#125;&#125; 1234567891011121314@Componentpublic class InventoryProductEventListener &#123; private final InventoryProductRepository inventoryProductRepository; public InventoryProductEventListener(final InventoryProductRepository inventoryProductRepository) &#123; this.inventoryProductRepository = inventoryProductRepository; &#125; @EventListener public void handle(final ProductDeletedEvent event) &#123; inventoryProductRepository.deleteByProductId(event.getProductId()); &#125;&#125; 결론양방향 의존성을 새로운 개념의 패키지 추가하기, 이벤트 퍼블리싱 방식으로 패키지 양방향 의존을 해결했다.해결한 뒤 의존성을 그려보면 다음과 같다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"스프링의 프록시","slug":"spring/spring-proxy","date":"2023-02-23T13:01:59.000Z","updated":"2023-02-23T13:46:49.716Z","comments":true,"path":"2023/02/23/spring/spring-proxy/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/23/spring/spring-proxy/","excerpt":"","text":"프록시 패턴의 종류간단하게 프록시 패턴을 어떻게 구현하는 지 간략하게 알아보자. 인터페이스 기반 프록시인터페이스가 있고 그 인터페이스를 구현한 구현체가 있는 상황일 때 사용한다. 그 구현체의 프록시는 인터페이스를 구현하여 만든다. 프록시는 타겟으로 구현체를 멤버 변수로 가지며 퍼블릭 메서드를 수행할 때 타겟 객체의 메서드 호출과 함께 프록시 로직을 수행한다. 클라이언트 코드에서는 인터페이스를 통해 메시지를 던지므로 이때 메시지 수신 객체가 프록시던 원래 구현체건 신경쓰지 않는다. 구현체 기반 프록시인터페이스가 없고 그냥 구현체만 있을 때 사용하는 방식이다. 프록시 클래스가 구현체의 클래스를 상속하도록 하고 멤버 변수로 타겟 구현체를 가진다. 구현체의 퍼블릭 메서드를 오버라이딩 하는데, 프록시 객체의 메서드가 호출 될 때 타겟 객체의 메서드 호출과 함께 프록시 로직도 같이 수행되도록 구현한다. 클라이언트 코드에서는 구현체의 타입을 통해 메시지를 던지므로 실제 구현체의 객체나 프록시의 객체 모두 해당 메시지를 처리할 수 있게 된다. 차이구현체의 종류가 확장되지 않고, 인터페이스가 굳이 없는 상황이면 구현체 기반 프록시가 낫다.하지만 구현체 기반 프록시는 구현체 클래스가 final이거나 확장하려는 메서드가 final이면 프록시를 적용할 수 없다. JDK 동적 프록시프록시 객체를 동적으로 만들어주는 기술이다. JDK 동적 프록시는 인터페이스 기반 프록시이기 때문에 인터페이스가 있어야 가능하다. JDK 동적 프록시는 프록시에 적용할 로직을 InvocationHandler 인터페이스를 구현해서 작성한다. 1234567891011121314151617public class InvocationHandlerImpl implements InvocationHandler &#123; private final Object target; public InvocationHandlerImpl(final Object target) &#123; this.target = target; &#125; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; // 프록시 로직,,, System.out.println(&quot;proxy begin&quot;); final Object result = method.invoke(target, args); // 프록시 로직,,, System.out.println(&quot;proxy end&quot;); return result; &#125;&#125; 리플렉션을 사용해서 호출된 메서드에 프록시 로직을 추가해준다. 12345678910111213141516171819202122interface FooInterface &#123; void foo();&#125;class FooImpl implements FooInterface &#123; @Override public void foo() &#123; System.out.println(&quot;FOO~~~&quot;); &#125;&#125;class JDKProxyTest &#123; @Test void JDKProxyTest() &#123; FooInterface fooRef = new FooImpl(); InvocationHandler handler = new InvocationHandlerImpl(fooRef); final FooInterface proxy =(FooInterface) Proxy.newProxyInstance(FooInterface.class.getClassLoader(), new Class[]&#123;FooInterface.class&#125;, handler); proxy.foo(); &#125;&#125; 인터페이스가 있는 상황에서 Proxy.newProxyInstance 메서드를 통해 ,어떤 클래스 로더에 프록시 클래스를 둘 것인지, 어떤 인터페이스를 구현해야 하는지, 어떤 핸들러(프록시 로직)을 적용할 것인지 정한다. 생성된 프록시는 메시지를 전달받으면 InvocationHandler 를 호출한다. 이때 프록시 로직과 본 객체의 메서드가 실행된다. 프록시 로직은 InvocationHandler 하나만 만들고 프록시를 적용해야 할 대상마다 재활용하면 된다. 하지만 이 방법은 타입 캐스팅을 해줘야 하고 인터페이스가 있어야 하는 단점이 있다. CGLIB바이트 코드를 조작해서 동적으로 클래스를 생성하는 기능. JDK 동적 프록시의 InvocationHandler 처럼 MethodInterceptor 에 프록시 로직을 담아서 사용한다. CGLIB은 상속을 통해 구현체에서 바로 프록시를 만들기 때문에 부모의 기본 생성자가 필요하고 final 클래스이면 안되며, final 메서드인 경우 프록시가 작동하지 않는다. (스프링의 ProxyFactory 에서 모두 해결한다) 상황에 따라 JDK 동적 프록시와 CGLIB을 활용한 프록시를 사용할 수 있다. 하지만 상황마다 일일히 관련 클래스를 구현해서 적용해야 되나? 이런 문제를 스프링의 ProxyFactory 가 해결할 수 있다. 스프링의 ProxyFactory 를 활용할 때 내부에서 CGLIB를 사용한다. 하지만 우리가 CGLIB를 직접 다루진 않는다. ProxyFactory스프링의 프록시 팩토리는 인터페이스 유무에 따라 JDK Proxy 혹은 CGLIB을 선택해서 프록시를 생성해준다. 프록시 팩토리는 InvocationHandler 와 MethodInterceptor 를 대신하는 Advice 를 도입한다. 어떤 방식으로 프록시를 만들던 Advice 를 호출하게 되도록 구현됐다. 즉 AdviceInvocationHandler 와 AdviceMethodInterceptor 를 스프링에서 구현해서 이 객체들이 개발자가 구현한 Advice에게 프록시 로직 실행을 위임하고, Advice는 프록시 로직 수행 후 진짜 객체에게 메시지를 전달한다. Advice 구현org.aopalliance.intercept 패키지의 MethodInterceptor 를 구현하는 방법이 있다. (Advice를 상속한 인터페이스) 12345678910111213@Slf4jpublic class TimeAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); Object result = invocation.proceed(); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime=&#123;&#125;ms&quot;, resultTime); return result; &#125;&#125; 실행 예시12345678FooService target = new FooService();ProxyFactory proxyFactory = new ProxyFactory(target);// 만약 인터페이스가 있어도 CGLIB 방식 프록시를 쓰고 싶다면proxyFactory.setProxyFactoryClass(true);proxyFactory.addAdvice(new FooAdvice());FooService proxy = (FooService) proxyFactory.getProxy(); 포인트컷, 어드바이스, 어드바이저포인트컷 : 어디에 적용할까? (대상 여부 필터) 어드바이스 : 어떤 내용을 적용할까? (프록시 로직) 어드바이저 : 포인트컷 + 어드바이스의 조합 즉 조언자(어드바이저)는 어디에(포인트컷) 조언을(어드바이스) 적용해야 할 지 알고 있다! 12DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());proxyFactory.addAdvisor(advisor); ProxyFactory는 어드바이저를 받아서 프록시를 만든다. 어드바이스만 설정하면 항상 참으로 판단하도록 하는 포인트컷을 적용하여 어드바이저를 만든다. ProxyFactory는 여러 어드바이스를 적용한 하나의 프록시 객체를 만들 수 있다. 여러 AOP 로직을 적용한다고 여러 프록시 객체가 만들어지는 게 아니다. 여러 종류의 포인트컷PointCut 인터페이스는 크게 ClassFilter와 MethodFilter 인터페이스로 필터링한다. 클래스 이름 기준으로 하거나 메서드 이름 기준으로 필터링할 때 사용된다. 스프링에서는 이런 인터페이스 기반으로 여러 포인트컷을 제공한다. NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를사용한다. JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다. TruePointcut : 항상 참을 반환한다. AnnotationMatchingPointcut : 애노테이션으로 매칭한다. AspectJExpressionPointcut : aspectJ 표현식으로 매칭한다. 여기서 제일 중요한 건 마지막 AspectJ 기반 포인트컷이다. 실무에서 제일 많이 사용한다. 빈 후처리기스프링의 도움으로 인터페이스 기반과 구현체 기반 신경쓰지 않고 어드바이저로 프록시를 적용할 수 있게 됐다. 하지만 여전히 ProxyFactory로 프록시 객체를 만들어서 빈 등록해줘야 한다. 그리고 컴포넌트 스캔으로 등록되는 빈은 이 방법을 쓸 수 없다. 이런 문제를 빈 후처리기가 해결한다.빈 후처리기는 빈 객체가 생성되고 스프링 빈 저장소에 등록되기 전에 특정 작업을 실행할 수 있다. 이때 특정 작업은 등록될 객체를 조작하거나 심지어는 아예 다른 객체를 등록시켜버릴 수 있다. 즉 타겟 객체를 빈으로 생성해놓고 빈 후처리기를 통해 타겟 객체를 품고 있는 프록시 객체를 등록시켜버릴 수 있다는 의미이다. 빈 후처리기를 사용하려면 BeanPostProcessor 인터페이스를 구현하고 스프링 빈으로 등록하면 된다. 1234567891011public interface BeanPostProcessor &#123; @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125;&#125; @PostConstruct 같이 초기화 전에 하거나 @PostConstruct 같이 초기화가 일어나고 나서 진행될 수 잇다. 반환되는 객체가 빈으로 등록된다. @PostConstruct 를 구현할 때도 빈 후처리기가 활용된다. CommonAnnotationBeanPostProcessor 를 통해 해당 어노테이션이 붙은 메서드를 호출한다. 컴포넌트 스캔으로 빈 등록되는 객체를 조작하거나 바꾸기 어려웠는데, 빈 후처리기를 통해 조작할 수 있게됐다. 빈 후처리기를 통해 빈 객체를 프록시로 바꿔서 등록할수도 있다는 의미이다!!!! 즉 설정 파일을 통해서 프록시를 하지 않고 빈 후처리기로 바꿔치기하면 된다! 이제 개발자는 프록시 관련 걱정을 안해도 되겟구나~ 1234567891011121314151617181920212223public class PackageLogTracePostProcessor implements BeanPostProcessor &#123; private final String basePackage; private final Advisor advisor; public PackageLogTracePostProcessor(final String basePackage, final Advisor advisor) &#123; this.basePackage = basePackage; this.advisor = advisor; &#125; @Override public Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException &#123; final String packageName = bean.getClass().getPackageName(); if (!packageName.startsWith(basePackage)) &#123; return bean; &#125; final ProxyFactory proxyFactory = new ProxyFactory(bean); proxyFactory.addAdvisor(advisor); return proxyFactory.getProxy(); &#125;&#125; 위 예시는 패키지 이름을 주입받아서 프록시 적용을 판단햇지만 advisor의 포인트컷으로 판단할 수 있다. 스프링이 제공하는 빈 후처리기spring-boot-start-aop 라이브러리를 추가하고 @EnableAspectJAutoProxy 설정을 해주면(스프링 부트는 생략) AOP 관련 빈을 등록해준다.이 과정에서 AnnotationAwareAspectJAutoProxyCreator라는 빈 후처리기가 스프링 빈으로 등록된다! 이 빈 후처리기는 스프링 빈으로 등록된 advisor들을 자동으로 찾아와서 프록시가 필요한 곳에 자동으로 프록시를 적용한다.(@Aspect 도 인식해서 프록시를 적용해서 AOP한다) 즉 모든 어드바이저를 가져와서 그 어드바이저 안에 있는 포인트컷을 통해 각 객체들이 프록시를 만들어야 되는지 확인하고 프록시를 만들어준다.그러면 만들어진 프록시는 포인트컷에 해당하는 어드바이저들과 타겟 객체가 있겟구나! (여러 프록시를 만드는게 아니라 하나의 프록시에 여러 어드바이저를 가진다!!) 즉 스프링에서 제공하는 빈 후처리기가 프록시를 자동으로 등록해주는 과정은 다음과 같다.빈 객체 생성 - 빈 후처리기에 전달 - 빈으로 등록된 모든 어드바이저 조회 - 포인트컷 필터링으로 프록시 객체 필요 여부 확인 - 프록시 생성 - 프록시를 빈 등록 이제 어드바이저만 잘 정의하면 프록시와 관련된 걱정을 하지 않고 추가 기능을 마음껏 구현할 수 있게 됐다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"스프링의 예외 처리","slug":"spring/spring-exception-handling","date":"2023-02-14T13:03:42.000Z","updated":"2023-02-14T13:52:42.405Z","comments":true,"path":"2023/02/14/spring/spring-exception-handling/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/14/spring/spring-exception-handling/","excerpt":"","text":"기본 예외 처리스프링은 기본적으로 예외가 발생하면 /error에 매핑된 핸들러를 찾는다.만약 /error에 매핑되지 않았다면 우리가 흔히 보게 되는 Whitelabel Error Page를 보여주게 된다. 스프링 MVC의 요청 흐름요청이 오면 필터 -&gt; 서블릿(디스패처 서블릿) -&gt; 인터셉터 -&gt; 핸들러 순으로 진행된다.이때 컨트롤러에서 예외가 처리되지 않고 발생하면 컨트롤러 -&gt; 인터셉터 -&gt; 서블릿(디스패처 서블릿) -&gt; 필터 -&gt; WAS(톰캣) 순으로 예외가 전파된다. DispatcherServlet의 예외 처리디스패처 서블릿의 application context는 HandlerExceptionResolver를 구현해서 처리되지 않은 예외를 인터셉트해서 처리한다. 1234public interface HandlerExceptionResolver &#123; ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);&#125; Spring MVC에서는 기본적으로 세가지 예외 리졸버를 만든다. ExceptionHandlerExceptionResolver : 핸들러나 컨트롤러 어드바이스에서 @ExceptionHandler 가 처리할 수 있는 예외를 처리한다. ResponseStatusExceptionResolver : @ResponseStatus 가 붙은 예외를 처리한다. DefaultHandlerExceptionResolver : 스프링의 기본 전략으로 예외를 처리한다. 이 세가지 리졸버는 순서대로 체인되어 실행된다. 서블릿에서 예외서블릿에서는 크게 두가지 로 예외 처리를 지원한다. Exception response.sendError(HTTP 상태 코드, 오류 메시지) 예외자바에서 직접 실행하는 경우, main 함수를 실행하는 main 스레드가 예외를 만나서 처리하지 못하고 main 메서드를 넘어가게 되면 예외 정보를 남기고 스레드가 종료된다. 한편 웹 어플리케이션은 요청 별로 스레드가 할당되고 서블릿 컨테이너 안에서 실행된다. 애플리케이션에서 처리하지 못한 예외는 어디로 가는걸까? 1WAS(여가까지 전파) &lt;- 필터 &lt;- 서블릿 &lt;- 인터셉터 &lt;- 컨트롤러(예외 발생) WAS는 예외를 받으면 상태코드 500으로 처리한다. response.sendError(HTTP 상태 코드, 오류 메시지)이 방식은 당장 예외가 발생한 것은 아니지만 서블릿 컨테이너에게 오류가 발생했음을 알린다. 이 메서드를 호출하면 response 객체 안에 호출 기록을 남겨두고 WAS가 이를 확인하고 예외로 인식한다. 서블릿 예외 처리 - 오류 화면 제공웹서버 팩토리커스터마이저를 통해 상태코드에 따라 주소를 매핑하고, WAS는 상태 코드가 응답하면 매핑된 주소로 진짜 요청을 다시 날린다! WAS가 날린 요청을 처리하기 위해 컨트롤러를 통해 예외 처리된 화면을 보여 줄 수 있다. 여기서 중요한 점은 WAS가 다시 요청을 날릴 때 필터 → 서블릿 → 인터셉터 를 다 거친다는 사실이다.WAS가 다시 요청을 보낼 때는 요청 객체에 예외 관련 정보를 담아서 요청을 보낸다. 필터서블릿은 DispatcherType 을 통해 지금 보낸 요청이 고객이 요청한 것인지 WAS가 에러로 인한 내부 호출한 내용인지 파악하는데 도움을 준다. 그래서 필터가 인증 인가 같은 로직을 예외 처리를 위한 요청에서 적용하지 않고 넘길 수 있게 된다. (필터의 기본 디스패처타입이 REQUEST라서 적용되지 않는다. 만약 예외 처리 요청을 위한 필터를 만들려면 디스패처 타입을 ERROR로 설정해주면 된다.) 인터셉터예외가 발생하는 요청인 경우, postHandle 메서드가 작동하지 않고 afterCompletion 만 작동한다. 하지만 WAS가 예외 처리를 위해 내부 요청을 보내는 경우는 해당 요청 자체는 예외가 발생하지 않으므로 postHandle도 잘 작동한다. 스프링 부트의 예외 처리서블릿은 귀찮게 경로를 정해주고 그 경로에 맞는 컨트롤러를 만들어줘야 했다. 스프링 부트는 /error 를 기본으로 에러 페이지를 설정한다. 그리고 BasicErrorController 라는 스프링 컨트롤러를 자동으로 등록한다. 이 일을 ErrorMvcAutoConfiguration 이라는 클래스가 자동으로 등록해준다. 컨트롤러는 resources/tempalte/error 디렉토리에서 5xx.html, 400.html 와 같은 이름의 파일을 상태코드에 매핑해서 뷰를 보여준다. 그리고 모델로 에러 상황과 관련된 데이터를 전달한다. 만약 컨트롤러 로직을 확장하고 싶으면 기존의 BasicErrorController 를 상속해서 오버라이딩하면 된다. API 예외 처리서블릿의 API 예외 처리WAS가 예외를 감지하고 내부에서 다시 보낸 요청을 처리하는 컨트롤러에서 HTTP header의 accept를 json으로 해주고 ResponseEntity 를 반환하도록 하면 JSON으로 변환 되서 반환된다. 스프링 부트의 API 예외 처리스프링 부트는 기본적으로 accept를 어떻게 하냐에 따라 JSON을 알아서 반환해줄 수도, 뷰를 반환해줄 수도 있다. HandlerExceptionResolverWAS까지 예외가 전달되면 500으로 처리한다. 이를 바꾸고 싶으면 HandlerExceptionResolver를 사용하자. HandlerExceptionResolver 가 디스패처 서블릿에 등록되면 디스패처 서블릿에 전달된 예외를 잡아서 response.sendError(status code) 를 호출하고 빈 ModelAndView 을 반환한다. 즉 WAS까지 안가고 요청도 다시 보내지 않는다. 여기서 빈 ModelAndView 를 반환하면 예외가 처리되고 정상 흐름으로 진행되고 ModelAndView 가 지정되어서 반환되면 해당 내용으로 뷰를 렌더링한다. null을 반환하면 다음 리졸버를 찾는다. 만약 맞는 리졸버가 없으면 WAS까지 예외가 전파된다. 스프링이 제공하는 ExceptionResolver ExceptionHandlerExceptionHandler 특정 컨트롤러에서 발생한 예외를 @ExceptionHandler 로 처리. 참고로 파라미터로 받는 예외를 통해 어떤 예외를 처리할지 선언하는 역할도 한다. ResponseStatusExceptionHandler @ResponseStatus 가 붙은 경우 ResponseStatusException 이 발생시켜서 이미 존재하는 예외를 처리 DefaultHandlerExceptionResolver 스프링 내부에서 발생하는 예외를 적절한 상태코드로 처리 1~3까지 해결이 안되면 다음으로 넘기는 방식. @ControllerAdvice, @RestControllerAdvice대상이 되는 여러 컨트롤러에 @InitBinder, @ExceptionHandler 기능을 부여하는 역할을 한다. 대상을 지정안하는 경우 모든 컨트롤러에 적용된다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"우테코 수료 이후 새로운 프로젝트 준비까지 회고","slug":"20230212-week-review","date":"2023-02-11T12:43:04.000Z","updated":"2023-02-11T14:02:40.862Z","comments":true,"path":"2023/02/11/20230212-week-review/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/11/20230212-week-review/","excerpt":"","text":"실패 그리고 반성우아한테크코스가 끝난 뒤 본 면접들에서 모두 떨어졌다. 이유를 정확히 알 수 없지만 내가 느끼기에는 여러가지 아쉬움이 있었다. 먼저 빠르고 정확하게 학습하는 습관을 만들지 못했다. 우아한테크코스를 하면서 주위 사람들이 공부하는 내용을 따라가기 급급했다. 원하는 지식이 무엇인지 차분히 고민하고, 집중해서 빠르고 정확하게 학습해야 하지 않았나 싶다. 시간 관리도 부족했다. 우아한테크코스에서 팀 프로젝트를 할 때 내 일정을 팀에서 주어지는 업무에 맞춰서 수동적으로 그리고 아무 시간 관리 전략 없이 막무가내로 시간을 보냈다. 시간 관리하기떨어지고 나서 먼저 나만의 시간 관리 시스템을 만들었다. 우아한테크코스 특강 중 칸반으로 자신의 일정을 관리하는 현업자 분의 이야기가 떠올랐다. 그 특강을 들을 당시 잠깐 해볼까 했지만 공부하느라 정신이 없어서 포기했었다. 새로 처음부터 다시 시작하려는 지금이 이런 시간 관리 방법을 고민하기 적절하다고 생각했다. 시간 관리는 노션의 칸반 보드로 구현했다. 대략 백로그-이번주 할 일-오늘 할 일-하고 있는 일-대기 중인 일-다한 일 이렇게 나눴다. 처음에는 매우 간단하게 시작했는데 시간 관리를 해보면서 내 목표와 맞게 추가하다 보니 단계가 늘었다. 칸반을 하면서 좋았던 점은 칸반에 할 일을 추가하는 과정에서 계획이 들어가고 그 계획이 시각화되어서 체감이 잘된다. 그리고 하나하나 일을 완료로 옮길 때마다 성취감을 느낄 수 있었다. 단계 별로 계획하기나는 6개월 이후 취업을 목표로 칸반으로 시간 관리를 한다. 그렇기에 정해진 기간 안에 목표를 이루기 위해 남은 시간을 쪼개서 각 목표를 두고 학습해야 했다. 일단 6개월은 각 6개의 달로 나눌 수 있고, 하나의 달은 여러 주로 나눌 수 있다. 나는 먼저 내가 가고 싶은 기업의 2~3년차 경력직의 필요요건을 찾아서 대략 각 달마다 나눠서 할당했다. 물론 나에게 벅찰 수 있지만, 높은 목표를 설정하고 실행하는 과정에서 조정하면 된다고 판단했다. 그리고 각 달의 목표를 이루기 위해서 그 목표를 구체적인 여러 행동으로 나눠서 매 주마다 할당했다. 그래서 이번 주에 할당된 일은 칸반에서 이번주 할 일에서 시각화 된다. 마지막으로 한 주의 할일은 하루씩 나눠져서 실행된다. 이 내용은 칸반에서 오늘 할 일에서 시각화된다. 새로운 프로젝트나는 면접 탈락 이후 갈 곳이 있다. 썩 달갑지는 않지만 아직 학교를 한 학기를 다녀야 한다. 그래서 학교에서 어떤 수업을 들어야 하나 고민했다. CS 과목을 들을까? 사실 우아한테크코스 이전엔 네트워크와 데이터베이스 수업을 들었다. 학점도 각각 A+를 받았다. 그러나 이 경험이 취업에 큰 도움이 되지는 않았다. 차라리 혼자 공부하거나 스터디를 하는 게 더 유익하다고 판단했다. 그러면 비대면 꿀강의를 찾아서 신청할까? 일단 꿀강의 수강 신청에 실패하면 리스크가 크다. 그리고 꿀강의라고 해서 레포트나 퀴즈같은 성가신 일을 피할 순 없다.마지막으로 남은 선택지는 프로젝트. 우리 학교는 참빛 설계학기라는 제도를 운영한다. 이 제도는 학생들이 주제를 자유롭게 정해서 지도 교수를 섭외해서 한 학기동안 진행하는 제도이다. 학점도 유연하게 받을 수 있고 지원금이 100만원(!)이나 된다! 프로젝트를 하기로 했다! 프로젝트를 하면서 어려웠던 점프로젝트 주제는 학교 기자재 대여 웹 서비스 만들기이다. 대여 내역을 수기로 써서 관리하고 이 내용을 네이버 카페에 관리자들이 다시 전산화하는 불편한 방식을 개선하고자 한다.애자일 방식으로 개발을 진행하려 할 때 어려운 점이 드러났다. 먼저 2주를 스프린트 기간이라고 하면, 그 주간안에 의미있는 소프트웨어 결과물이 나와야 한다. 우리팀은 기획 1명 프론트 2, 백엔드 1로 구성됐다. 한 스프린트 안에서 기능 계획, UX 레이아웃, API 설계 등 각자 작업을 하기전에 먼저 선행되어야 하는 작업이 있다. 그래서 그 작업이 되기 전까지는 개발이 되지 못한다. 이 경우 실질적인 개발 기간이 줄어드는데 이런 상황이 괜찮은 건지 고민된다.그리고 기능을 계획하는 과정에서도 어려움이 있었다. 에픽을 선정하는 과정이 어려웠다. 스토리는 직관적이라 가능했는데, 이를 에픽으로 어떤 기준으로 묶어야 하는지가 어려웠다. 그래서 일단 첫 스프린트는 스토리의 동사에서 에픽을 추출해서 묶기로 했다.","categories":[],"tags":[{"name":"회고","slug":"회고","permalink":"https://yangdongjue5510.github.io/tags/%ED%9A%8C%EA%B3%A0/"}],"keywords":[]},{"title":"스프링과 JPA 환경에서 동시성 문제 해결하기","slug":"spring/JPA/resolve-concurrency-jpa","date":"2023-02-10T12:50:50.000Z","updated":"2023-02-17T11:07:48.513Z","comments":true,"path":"2023/02/10/spring/JPA/resolve-concurrency-jpa/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/10/spring/JPA/resolve-concurrency-jpa/","excerpt":"","text":"동시성 문제동시성 문제는 공유 자원을 여러 스레드가 수정할 때 공유 자원의 일관성이 깨지는 상황을 말한다. 예를 들어 내 계좌에 1000원을 두 스레드가 동시에 입금하려고 한다고 가정해보자. 병렬로 스레드가 작업을 수행하고 위에서 부터 시간순으로 진행됨을 나타낸다.스레드 A가 남은 금액 조회 : 0원스레드 B가 남은 금액 조회 : 0원스레드 A가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)스레드 B가 남은 금액에 1000원을 추가 : 0원 (아직 트랜잭션이 종료되지 않아 반영되지 않았다.)스레드 A가 커밋하면서 금액을 1000원으로 업데이트 : 1000원스레드 B가 커밋하면서 금액을 1000원으로 업데이트 : 1000원(어라? 1000원을 두 스레드가 입금하면 2000원이 되어야 한다!!!!) 위 예시를 보면 알 수 있듯이 공유 자원드 아무 제약 없이 조회(획득)해서 각자 작업을 하고 업데이트 하는 경우 예상하지 못한 결과가 나올 수 있다. 예시 코드먼저 도메인 엔티티는 간략하게 포인트 하나만 둔다. 이 포인트 객체는 사용자의 포인트 누적액과 포인트 적립과 사용에 쓰이는 바코드를 포함한다. 12345678910@Entityclass Point( @Column(nullable = false) var amount: Long, @Column(nullable = false, unique = true) val barcode: String, @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long = 0) 그리고 바코드에 해당하는 포인트 객체를 조회하는 메서드를 포함한 레포지토리 코드이다. 123interface PointRepository: JpaRepository&lt;Point, String&gt; &#123; fun findByBarcode(barcode: String): Optional&lt;Point&gt;&#125; 마지막으로 서비스 코드이다. (주입받는 부분은 생략하고 메서드만 표기했다.)이해를 위해 매우 간략하게 구현된 점을 이해하자. 1234567@Transactionalfun saveUp(shopId: Long, barcode: String, amount: Long): Point &#123; val point = pointRepository.findByBarcode(barcode) .orElseGet &#123; pointRepository.save(Point(0, barcode)) &#125; // 기존의 바코드가 존재하지 않으면 새 객체를 만들어서 영속화한다. point.amount += amount return point&#125; 이제 이를 테스트 하기 위해 테스트 메서드를 만들어보자. 1234567891011121314151617181920212223@Test@DisplayName(&quot;포인트 적립 동시성 문제 검증&quot;)fun saveUp_concurrency() &#123; val threadCount = 20 val executorService = Executors.newFixedThreadPool(10) val countDownLatch = CountDownLatch(threadCount) val barcodeValue = &quot;1234567890&quot; callSaveUp(1, barcodeValue) //적립할 양과 바코드를 받아 적립하는 메서드이다. for (i in 1..threadCount) &#123; executorService.submit &#123; try &#123; callSaveUpAPI( 1, barcodeValue) &#125; finally &#123; countDownLatch.countDown() &#125; &#125; &#125; countDownLatch.await() val point = pointRepository.findByBarcode(barcodeValue) .orElseThrow() assertThat(point.amount).isEqualTo((threadCount + 1).toLong())&#125; CountDownRatch?CountDownRatch는 어떤 스레드가 다른 스레드에서 작업이 완료될 때까지 기다릴 수 있도록 해주는 클래스다. 위 예시에서는 작업을 하는 스레드들이 완료될 때마다 countDown을 해서 모든 스레드들이 작업을 마칠 때까지 await하도록 구현했다. synchronized 키워드먼저 자바 및 코틀린에서 쉽게 생각할 수 있는 synchronized 키워드를 사용할 수 있다. 미리 말하자면, 이 방법은 확장성에 좋지않고 스프링에서는 고려해야할 부분이 있다. 확정성에 좋지 않은 이유.synchronized는 해당 어플리케이션 안에서만 유효하다. 즉 여러 서버를 운영하게 되면 여러 어플리케이션이 요청을 처리하게 되는데, 자신이 아닌 다른 어플리케이션의 요청은 제어할 수 없게된다. 스프링에서 고려해야 하는 부분. @Transactional일반적으로 서비스 계층에서 @Transactional을 사용해서 각 요청에 트랜잭션을 적용한다. 하지만 스프링은 트랜잭션을 프록시로 처리하게 된다. 즉 원래 메서드를 감싼 외부 메서드가 존재하게 된다. 업데이트는 트랜잭션 종료 시 실행되는데 스프링에서는 원래 메서드가 종료되면 외부 메서드에서 트랜잭션 종료 처리릃 하게 된다. 즉 값의 반영이 되지 않은 시점에서 다른 스레드가 원래 메서드를 통해 반영되지 않은 값을 조회할 수 있다. Database에서 해결하기데이터베이스의 Lock을 활용해서 해결할 수 있다. 낙관적 락낙관적 락은 서비스 특성 상 동시성 문제가 발생할 경우가 적은 상황에서 사용한다. 실제로는 락을 사용한다기 보다는 수정 시점을 기록하는 칼럼(버전)을 통해 동시성 문제를 일으키는 쿼리를 감지하는 방식이다. 엔티티에 버전을 기록하는 칼럼을 추가하고, 조회했을 때 버전과 값을 변경해서 반영할 때의 버전이 같아야 반영하고 버전을 +1하는 방식이다. 가령 여러 스레드가 동시에 하나의 데이터를 조회해서 값을 변경하고 반영하려고 한다면, 모두 다 버전이 1인 상황에서 값을 반영하려고 할 것이고, 먼저 하나의 스레드가 반영이 되어서 버전이 2가 되어버리면 그 외 버전 1인 업데이트 쿼리가 모두 반영되지 않도록 막는다. 코드로 살펴보기먼저 도메인 엔티티에 버전을 추가해주자. 12345678910@Entityclass Point( @Column(nullable = false) var amount: Long, @Column(nullable = false, unique = true) val barcode: String, @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long = 0) 그리고 레포지토리 메서드에서 @Lock 어노테이션만 추가해주면 된다. 1234interface PointRepository: JpaRepository&lt;Point, String&gt; &#123; @Lock(LockModeType.OPTIMISTIC) fun findByBarcodeAndShopSector(barcode: String, shopSector: ShopSector): Optional&lt;Point&gt;&#125; 여기서 추가로 낙관적 락은 동시성이 우려된 경우 예외를 발생한다는 사실을 알아두자. 즉 서비스 단에서 예외가 발생한 경우 재시도하는 코드를 추가해야 테스트 코드가 통과 될 것이다! 비관적 락비관적 락은 모든 시도가 동시성 문제를 일으킬 수 있을 경우 사용한다. DB에서 락을 획득해서 다른 스레드가 자원을 접근하지 못하거나 수정을 막는 방식이다. 구현하는 방법은 매우 간단하다. 레포지토리에서 @Lock의 인자를 다르게 해주면 된다. 1234interface PointRepository: JpaRepository&lt;Point, String&gt; &#123; @Lock(LockModeType.PESSIMISTIC_WRITE) fun findByBarcode(barcode: String): Optional&lt;Point&gt;&#125; 락과 트랜잭션락은 반드시 트랜잭션이 존재할 때만 가능하다. 만약 레포지토리 메서드를 트랜잭션이 아닌 환경에서 실행하면 예외가 발생한다. 추가로 더 알아보기 네임드락, 레디스를 활용해서 비슷한 문제를 해결할 수 있다. 코드는 강의 자바 코드이다. 네임드락네임드락은 이름을 가진 메타데이터 락이다. 네임드락은 글로벌 락이라서 이미 한 세션이 A라는 이름의 네임드락을 가지고 있다면 다른 세션들은 같은 이름의 네임드락을 얻지 못한다. 여러 서버들의 동기화를 구현할 때 사용된다.하지만 네임드락은 정해진 시간이 다 지나거나 락을 해제하는 명령어를 실행해야 락이 풀리고 다른 세션에서 접근할 수 있게되므로 사용에 각별한 주의를 해야 한다.그리고 실무에서는 네임드락은 데이터소스를 따로 분리해서 적용하는 걸 추천한다. 커넥션이 부족해질 수 있기 때문이다. 레포지토리일단 이번 예제에서는 하나의 데이터소스로 해보자. MySQL 네이티브 쿼리로 get_lock과 release_lock 함수로 네임드락을 획득하고 해제할 수 있다. 12345678public interface LockRepository extends JpaRepository&lt;Stock, Long&gt; &#123; @Query(value = &quot;select get_lock(:key, 3000)&quot;, nativeQuery = true) void getLock(String key); @Query(value = &quot;select release_lock(:key)&quot;, nativeQuery = true) void releaseLock(String key);&#125; 레포지토리를 주입받아서 서비스 로직이 실행되기 전에 락을 얻고 서비스 로직이 끝나면 락을 반납하는 방식으로 구현하면 된다.네임드락은 데이터소스와 락 직접 해지, 그리고 트랜잭션 주기가 달라지는 부분이 있으므로 주의해서 사용하자. 레디스를 활용하기레디스는 lettuce를 활용하는 방법과 redisson을 활용하는 방법 두가지가 있다. lettuce 사용lettuce는 네임드락과 매우 비슷하다. 키와 밸류를 가지고 특정 세션이 키와 밸류를 레디스에 저장하고 나면 다른 세션은 그 키가 존재하는 한 접근하지 못하는 방식이다. 레포지토리 구현123456789101112131415161718192021222324252627@Componentpublic class RedisRepository &#123; private final RedisTemplate&lt;String, String&gt; redisTemplate; public RedisRepository(final RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public Boolean lock(Long key) &#123; return redisTemplate .opsForValue() .setIfAbsent(generateKey(key), &quot;lock&quot;, Duration.ofMillis(3_000)); &#125; public Boolean unlock(Long key) &#123; return redisTemplate.delete(generateKey(key)); &#125; private String generateKey(final Long key) &#123; if (key == null) &#123; return &quot;0&quot;; &#125; return key.toString(); &#125;&#125; 그리고 lettuce 방식은 락 획득이 실패하면 스핀락으로 재시도를 하기 때문에 만약 락 획득이 실패하는 경우 잠깐 기다리는 로직을 추가로 구현해주자. redisson레디슨은 다른 세션들이 계속 락을 얻기 위해 시도하는게 아니라 락이 해제가 되면 채널을 통해 기다리던 세션들에게 알리는 방식이다.(pub-sub) 그래서 비용이 적게 든다. 하지만 별도의 라이브러리를 추가해야 한다. 1234567891011121314151617181920212223242526272829@Componentpublic class RedissonStockFacade &#123; private final RedissonClient redissonClient; private final StockService stockService; public RedissonStockFacade(final RedissonClient redissonClient, final StockService stockService) &#123; this.redissonClient = redissonClient; this.stockService = stockService; &#125; public void decrease(final Long id, final Long quantity) &#123; RLock rLock = redissonClient.getLock(id.toString()); try &#123; boolean available = rLock.tryLock(5, 1, TimeUnit.SECONDS); if (!available) &#123; System.out.println(&quot;Lock 획득 실패&quot;); return; &#125; stockService.decrease(id, quantity); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(); &#125; finally &#123; rLock.unlock(); &#125; &#125;&#125;","categories":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}],"tags":[],"keywords":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}]},{"title":"서로 연관관계가 없는 엔티티를 DTO로 조회하기","slug":"spring/JPA/queryUnrelatedEntityToDto","date":"2023-02-09T07:32:20.000Z","updated":"2023-02-10T07:49:42.871Z","comments":true,"path":"2023/02/09/spring/JPA/queryUnrelatedEntityToDto/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/09/spring/JPA/queryUnrelatedEntityToDto/","excerpt":"","text":"문제 상황전세계의 프로 축구 선수를 관리하는 시스템을 만든다고 가정하자. 이 시스템에는 나라, 리그, 선수 이렇게 세가지 엔티티가 있다. 이 세 엔티티 모두 직접 참조는 되어 있지 않은 상태로 모두 물리적인 연관관계는 없다. 다만 리그가 나라를 id로 간접 참조하고, 선수가 리그를 id로 간접 참조하고 있다고 하자. 그렇다면 코드는 다음과 같을 것이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Entity@Getterpublic class Nation &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String name; protected Nation() &#123; &#125; public Nation(final String name) &#123; this.name = name; &#125;&#125;@Entity@Getterpublic class League &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String name; @Column(nullable = false) private Long nationId; protected League() &#123; &#125; public League(final String name, final Long nationId) &#123; this.name = name; this.nationId = nationId; &#125;&#125;@Entity@Getterpublic class Player &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String name; private Long leagueId; protected Player() &#123; &#125;&#125; 엔티티가 이런 상황에서 특정 국가에서 뛰고 있는 모든 선수의 이름, 그 선수의 소속 리그 이름, 그 선수 소속 리그의 국가 이름을 조회하려고 한다. 물리적인 관계가 있다면 JPQL fetch join으로 모든 엔티티의 정보를 가져와서 DTO에 매핑하는 방법을 사용할 수 있다. 하지만 간접 참조로 fetch join으로 최적화가 안된다. 이 문제를 해결하기 위해서는 일단 두 단계로 문제를 쪼개보자. 일단 원하는 정보가 여러 테이블에 흩어져 있기 때문에 이를 모아서 조회해야 한다. 즉 조인을 활용해야 한다. 조인 한 결과물을 담을 수 있는 객체가 필요하다. 우리의 문제 상황에서는 조회된 결과물이 한 엔티티에 담을 수 없기 때문에 DTO를 만들어서 담을 것이다. JPQL에서 연관 관계가 없는 엔티티 조인하기사실 SQL과 매우 비슷하다. join &#123;엔티티&#125; on &#123;조건&#125; 이런 형태로 조인을 해주면 된다. 우리의 사레를 JQPL로 표현하면 다음과 같다. 123456789@Query( &quot;&quot;&quot; select &#123;나중에 만들 DTO&#125; from Player p join League l on p.leagueId = l.id join Nation n on n.id = l.nationId where n.name = :name &quot;&quot;&quot;)List&lt;PlayerDto&gt; findDtoByNation(String name); 위의 예시는 각 조인을 명시적으로 표현해줬다. 하지만 조인을 명시적으로 표현하지 않아도 from 절에 명시하고 where 절에서 조인 조건을 명시해도 된다. 1234567@Query( &quot;&quot;&quot; select &#123;나중에 만들 DTO&#125; from Player p, League l, Nation n where p.leagueId = l.id and n.id = l.nationId and n.name = :name &quot;&quot;&quot;)List&lt;PlayerDto&gt; findDtoByNation(String name); 조인 종류여기서 잠깐 JPQL의 조인 종류에 대해서 알아보자. 왜냐면 LEFT JOIN에 대해 잘 모르고 사용했다가 잘못된 테스트임에도 테스트가 통과되고 있었다.일단 조인은 여러 테이블을 하나의 테이블로 합치는 행동이다. 이때 합칠 때 특정 조건을 걸어서 우리가 원하는 결과물만 받을 수 있게 된다.조인의 종류는 이때 중요해지는데, 조인의 종류에 따라 결과물이 달라지기 때문이다. 먼저 INNER JOIN. 이 경우 두 테이블을 합칠 때 조인 조건이 맞는 데이터만 가져와서 합친다.INNER JOIN이 아닌 LEFT JOIN, RIGHT JOIN, OUTER JOIN은 조인 조건을 만족하지 않는 데이터도 결과에 포함된다.LEFT JOIN은 조인 조건에 맞는 데이터 + 왼쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 왼쪽 테이블의 모든 데이터가 결과값으로 반환된다.)RIGHT JOIN은 조인 조건에 맞는 데이터 + 오른쪽 테이블에서 조인 조건이 맞지 않는 데이터까지 포함해서 보여준다. (즉 오른쪽 테이블의 모든 데이터가 결과값에 포함된다.)OUTER JOIN은 조인 조건에 맞는 데이터를 제외한 왼쪽 테이블과 오른쪽 테이블의 모든 데이터를 결과값을 보여준다. (즉 INNER JOIN의 여집합이겠다.) JPQL에서 조인JPQL에서는 위에서 언급한 INNER, LEFT JOIN을 지원한다. (RIGHT JOIN은 지원하지 않으므로 두 테이블의 적용 위치를 바꿔서 LEFT JOIN으로 하면 동일한 결과를 얻을 수 있다.)그리고 FETCH JOIN이라는 것을 지원한다. FETCH JOIN은 연관관계가 있는 엔티티가 Lazy Loading일 때 쿼리 한번에 연관된 객체를 같이 조회해서 가져오는 방법이다. 연관관계가 있는 엔티티를 조회하는 경우 매우 중요한 개념이지만 현재는 연관관계가 없는 엔티티 조회하는 상황이므로 넘어가겠다. 결과값을 DTO로 받기JQPL에서 결과값을 DTO로 받으려면 다음과 같다. SELECT new &#123;패키지&#125;.&#123;DTO 클래스&#125;(...생성자...) 이를 적용한 코드는 다음과 같다! 12345678@Query( &quot;&quot;&quot; select new com.example.jointest.blogging.PlayerDto(p.id, p.name, l.name, n.name) from Player p, League l, Nation n where p.leagueId = l.id and n.id = l.nationId and n.name = :name &quot;&quot;&quot;)List&lt;PlayerDto&gt; findDtoByNation(String name); JPQL에서 엔티티나 값 객체가 아닌 (@Entity나 @Embeddable이 안붙은 클래스) 경우는 이렇게 패키지 명을 써줘야 해서 매우 코드가 불편한 게 단점이다.그래서 QueryDSL을 활용하면 더 깔끔한 코드를 작성할 수 있게 된다!!! 나중에 QueryDSL로 더 개선해보자!!","categories":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}],"tags":[],"keywords":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}]},{"title":"애노테이션과 리플렉션","slug":"kotlinInAction/kotlinInActionCh10","date":"2023-02-05T06:51:34.000Z","updated":"2023-02-05T15:51:40.198Z","comments":true,"path":"2023/02/05/kotlinInAction/kotlinInActionCh10/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/05/kotlinInAction/kotlinInActionCh10/","excerpt":"","text":"애노테이션 선언과 사용애노테이션 적용코틀린 애노테이션 적용은 자바와 매우 비슷하다. 12@Deprecated(&quot;Use removeAt(index) instead&quot;, ReplaceWith(&quot;removeAt(index)&quot;))fun remove(index: Int) &#123; ... &#125; 애노테이션에 인자로는 원시 타입 값, 문자열, enum, 클래스 참조, 다른 어노테이션 클래스, 마지막으로 앞서 말한 요소의 배열을 전달해줄 수 있다.다만 인자를 전달할 때는 자바와 다른 점이 있다. 클래스를 인자로 전달할 때 ::class로 전달한다 어노테이션 인자로 다른 어노테이션을 전달할 때는 @를 빼고 전달한다. 배열을 인자로 전달하려면 arrayOf 함수를 사용한다. 다만 가변인자로 전달할 때는 그러지 않아도 된다. 어노테이션 인자를 컴파일 시점에서 알아야 한다. 따라서 어노테이션 인자로 프로퍼티를 전달할 때 임시 프로퍼티나 일반 프로퍼티는 사용하지 못한다. const가 붙은 프로퍼티를 인자로 전달할 수 있다. 어노테이션 대상사용 지점 대상 선언으로 어노테이션을 붙일 요소를 정할 수 있다. 1@get:Rule 위 예시를 보면 앞에 사용 지점 대상을 적고 콜론으로 어노테이션 이름적는다. 이런 방식으로 getter 메서드에 어노테이션을 적용해야 되는 경우를 프로퍼티를 통해 적용할 수 있다. 사용 지점 대상 목록 property : 프로퍼티 전체. field ; 프로퍼티에 생성되는 필드(뒷받침하는 경우도 포함) get : 프로퍼티 게터 set : 프로퍼티 세터 receiver : 확장 함수나 프로퍼티의 수신 객체 파라미터 param : 생성자 파라미터 setparam : 세터 파라미터 delegate : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드 file : 파일 안에 선언된 최상위 함수와 프로퍼티를 담아둔 클래스 어노테이션 선언객체를 직렬화하는 제이키드 라이브러리의 어노테이션을 예제로 어노테이션 선언에 대해 알아본다. 1annotation class JsonExclude 어노테이션 클래스는 오직 메타데이터의 구조를 정의하기 때문에 내부에 아무 코드도 들어있을 수 없다. 파라미터가 있는 어노테이션은 주 생성자를 통해 파라미터를 정의한다. 1annotation class JsonName(val name: String) 이를 자바 어노테이션 선언과 비교하면 다음과 같다. 123public @interface JsonName &#123; String value();&#125; 메타어노테이션: 어노테이션을 처리하는 방법 제어어노테이션 클래스에 적용할 수 있는 어노테이션을 메타어노테이션이라고 부른다.표준 라이브러리에 있는 메타어노테이션 중 가장 흔히 쓰이는 메타어노테이션은 @Target이다. 12@Target(AnnotationTarget.PROPERTY)annotation class JsonExclude @Target 메타어노테이션은 어노테이션을 적용할 수 있는 요소 유형을 지정한다. 메타어노테이션을 직접 만들어야 한다면 다음과 같이 구현한다. 123456@Target(AnnotationTarget.ANNOTATION_CLASS)annotation class BindingAnnotation//사용@BindingAnnotationannotation class MyBinding 어노테이션 파라미터로 클래스 사용어떤 클래스를 선언 메타데이터로 참조할 수 있는 기능이 필요한 때가 있다. 클래스 참조를 파라미터로 하는 어노테이션 클래스를 선언하면 그런 기능을 사용할 수 있다.제이키드 라이브러리의 @DeserializeInterface를 통해 이해해보자. 이 어노테이션은 인터페이스 타입인 프로퍼티를 역직렬화할 때 사용한다. 1234data class Person ( val name: String, @DeserailizeInterface(CompanyImpl::class) val company: Company) 이제 이 어노테이션의 정의를 살펴보자. 1annotation class DeserializeInterface(val targetClass: KClass&lt;out Any&gt;) KClass는 java.lang.Class 타입과 같은 역할을 하는 코틀린 타입이다. 여기서 제네릭 타입에 out이 붙었다. out이 붙지 않고 KClass&lt;Any&gt;로 하면 해당 어노테이션에 CompanyImpl::class를 인자로 넘기지 못하고 Any::class만 인자로 넘길 수 있다. out이 없으면 하위타입이 되지 못하기 때문이다! 어노테이션 파라미터로 제네릭 클래스 받기파라미터로 제네릭 클래스를 받는 어노테이션을 정의해보자. 123annotation class foo( val barClass: KClass&lt;out SomeClass&lt;*&gt;&gt;) 제네릭 클래스인 SomeClass를 구현한 클래스만 파라미터로 받을 수 있게 구현된 예시이다.여기서 아직 어떤 타입이 인자로 올 지 확정할 수 없기 때문에 스타 프로젝션이 적용됐다. 리플렉션: 실행 시점에 코틀린 객체 내부 관찰리플렉션은 실행 시점에 동적으로 객체의 프로퍼티와 메서드에 접근할 수 있게 해주는 방법이다.리플렉션은 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메서드나 프로퍼티 이름을 오직 실행 시점에서 알 수 있는 경우(JSON 직렬화)에 리플렉션이 필요하다.코틀린에서는 java.lang.reflect 패키지를 통해 제공되는 표준 자바 리플렉션과 kotlin.reflect 패키지를 통해 제공되는 코틀린 리플렉션 API를 다룬다. 코틀린 리플렉션은 자바 리플렉션의 복잡한 기능을 아직 지원하지 않는 경우가 있어서 아직 자바 리플렉션을 필요로 한다. 다만 코틀린 리플렉션이 자바 클래스도 다룰 수 있다. 코틀린 리플렉션 API: KClass, KCallable, KFunction, KPropertyKClassKClass는 java.lang.class에 해당하며 클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등 작업이 가능하다. 특정 인스턴스의 KClass를 얻기 위해서는 &#123;instance&#125;.javaClass.kotlin으로 얻을 수 있다. KCallableKCallable은 함수와 프로퍼트를 아우르는 공통 상위 인터페이스다. 그 안에는 call 메서드가 있다. call 메서드를 호출하면 함수나 프로퍼티의 게터를 호출할 수 있다. 1234interface KCallable&lt;out R&gt; &#123; fun call(vararg args: Any?): R ...&#125; KFunctionKFunction는 함수의 상위 인터페이스이다. call로 메서드를 호출할 수 있는데 이때 매개변수 갯수가 안맞으면 예외가 발생한다. 이를 방지 하기위해 KFunctionN&lt;…&gt;을 사용할 수 있다. 이 인터페이스는 invoke함수를 통해 정해진 매개변수를 받도록 제한한다. 다만 이런 경우 적용가능한 메서드가 적다. KProperty, KMutablePropertyKProperty는 call로 프로퍼티의 게터를 호출한다. 하지만 프로퍼티 인터페이스는 더 좋은 방법으로 게터를 호출할 수 있다.KProperty0은 최상위 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 이 인터페이스에 get메서드가 정의되어 있다.KProperty1은 멤버 프로퍼티 인스턴스를 담을 수 있는 인터페이스다. 멤버 프로퍼티는 객체가 있어야 가능하므로, 인자가 하나인 get 메서드가 정의되어 있다. 그리고 제네릭 클래스이기 때문에 수신 객체의 타입을 검증할 수 있다.KMutableProperty0, KMutableProperty1은 각 KProperty0, KProperty1를 확장한 인터페이스로 세터를 제공한다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"코틀린의 제네릭스","slug":"kotlinInAction/kotlinInActionCh9-1","date":"2023-02-03T04:23:07.000Z","updated":"2023-02-03T07:49:24.949Z","comments":true,"path":"2023/02/03/kotlinInAction/kotlinInActionCh9-1/","link":"","permalink":"https://yangdongjue5510.github.io/2023/02/03/kotlinInAction/kotlinInActionCh9-1/","excerpt":"","text":"코틀린의 제네릭스는 자바와 비슷한 점이 많다. 자바와 다른 부분도 많으니 이 점을 살펴보자! 제네릭 타입 파라미터코틀린의 제네릭 타입 파라미터는 자바와 매우 비슷하지만 몇 가지 새로운 기능에 대해 배워보자. 타입 파라미터 제약코틀린은 타입 파라미터 제한으로 클래스나 함수에 사용할 수 있는 타입 인자를 제한할 수 있다. 1fun &lt;T: Number&gt; List&lt;T&gt;.sum(): T 이렇게 함수를 선언하면 숫자를 원소로 갖는 리스트 객체만 sum 함수를 호출할 수 있게 된다!! 와우~ 타입 파라미터 제약을 사용한 예시를 살펴보자 123456789fun &lt;T: Person&gt; List&lt;T&gt;.hello() &#123; this.forEach &#123;println(&quot;$&#123;it.name&#125; hello~&quot;)&#125;&#125;val numbers = listOf(1,2,3)val people = listOf(Person(&quot;Bob&quot;), Person(&quot;Tom&quot;))// numbers.hello() 컴파일 에러people.hello() 타입 파라미터 제한에 따라 함수도 제한한 예시이다. 여기서 더 실전적인 예시를 보자. 12345fun &lt;T : Comparable&lt;T&gt;&gt; max(first: T, second: T) : T &#123; return if (first &gt; second) first else second&#125;println(max(&quot;airplane&quot;, &quot;zebra&quot;)) Comparable을 구현한 타입, 즉 원소 간 비교가 가능한 타입 파라미터만 사용할 수 있는 함수를 구현했다. 타입 파라미터에 여러 제약 걸기1234fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable &#123; if (!seq.endsWith(&#x27;.&#x27;)) seq.append(&#x27;.&#x27;)&#125; 함수 시그니처 뒷 쪽에 where 절로 타입 파라미터가 여러 조건을 만족하도록 제한을 걸 수 있다. 위 예시에서는 T가 CharSequence와 Appendable의 하위 타입이어야 가능함을 의미한다. 타입 파라미터를 널이 될 수 없는 타입으로 한정타입 파라미터에 아무런 제약 없이 사용하면 Any?를 상한으로 하는 것과 마찬가지다. 만약 널을 허용하지 않는 타입으로 제한하고 싶으면 &lt;T: Any&gt;로 상한을 걸어주자.터 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다. 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다. 실행 시점의 제네릭: 타입 검사와 캐스트코틀린도 자바와 마찬가지로 제네틱 타입 인자 정보는 런타임에 지워진다. 타입 소거는 저장해야 하는 타입 정보의 크기가 줄어들어서 메모리 사용량이 줄어드는 장점은 있다.하지만 타입 소거 때문에 실행 시점에 타입 인자를 검사할 수 없다. 예를 들면 다음과 같은 코드는 컴파일 에러가 발생한다. 1if (value is List&lt;String&gt;) &#123; ... &#125; 왜냐면 실행 시점에서 value가 List인지 아닌지는 명확히 판별할 수 있지만, List&lt;String&gt;인지, List&lt;Long&gt;인지는 확인할 수 없기 때문이다. 하지만 방법은 있다. 스타 프로젝션을 사용하면 된다. 1if (value is List&lt;*&gt;) &#123; ... &#125; 인자를 알 수 없는 제네릭 타입을 표현할 때 스타 프로젝션을 사용한다.(자바의 와일드카드와 비슷)스타 프로젝션을 사용하면 as나 as? 캐스팅도 가능하다. 문제는 타입 파라미터를 정확히 모르니 컴파일은 가능해도 런타임에 캐스팅 에러가 발생할 수 있다. 실체화한 타입 파라미터를 사용한 함수 선언타입 소거에 의해 런타임에는 타입 인자 정보를 알 수 없다. 하지만 코틀린 인라인 함수의 타입 인자는 알 수 있다!!! 123inline fun &lt;reified T&gt; isA(value: Any) = value is Tprintln(isA&lt;String&gt;(&quot;hello&quot;)) // true 인라인 함수의 타입 파라미터 앞에 reified로 지정하면 실행 시점에서 타입 파라미터를 사용할 수 있다. 이때 파라미터에 람다를 받지 않는데도 타입 파라미터를 실체화 하기 위해서 inline 했읆을 주목하자. 즉 성능을 위해 inline 한 게 아니라 타입 파라미터 사용을 위해서 inline 선언한 것이다. 이때 해당 함수의 길이에 따라 성능 문제가 발생할 수 있다. 그럴 경우 반드시 필요한 부분을 분리해서 성능을 최적화 할 수 있다. 왜 inline은 타입 파라미터를 실체화 할 수 있나? 컴파일러가 인라인 함수의 본문을 바이트코드로 호출한 곳에 집어 넣을 때, 호출 할 때 제네릭 타입에 전달된 클래스를 알 수 있어서 타입 파라미터 자리에 정확한 클래스를 넣을 수 있다.위 예시의 경우 다음과 같이 인라이닝된다. 1println(&quot;hello&quot; is String) 자바에서는 실체화한 타입 파라미터를 가진 inline 함수를 호출할 수 없다. 자바에서 인라인 함수를 호출할 수 있다. 이 경우 일반 함수처럼 사용되서 인라이닝 되지 않는다. 실체화 된 타입 파라미터가 있는 inline 함수의 경우 반드시 인라이닝이 되어야 하기 때문에 자바에서는 해당 함수를 호출하지 못하도록 했다. 실체화한 타입 파라미터의 제약실체화한 타입 파라미터는 몇가지 제약이 있다. 실체화한 타입 파라미터 개념 자체에서 오는 제약과 코틀린에서 실체화한 타입 파라미터를 구현하는 과정에서 오는 제약이 있다. 따라서 구현이 달라지면 나중에 완화될 제약이 있다. 가능한 것 타임 검사와 캐스틍 (is, as 등) 코틀린 리플렉션 API (::class 등) 코틀린 타입에 대응하는 java.lang.Class 얻기 (::class.java) 다른 함수를 호출할 때 타입 인자로 사용 불가능한 것 타입 파라미터 클래스의 인스턴스 생성 타입 파라미터 클래스의 동반 객체 메서드 호출 실체화된 타입 파라미터 자리에 실체화 되지 않은 타입 파라미터로 받은 타입을 넘기기 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기 변성: 제네릭과 하위 타입변성 개념은 List&lt;Any&gt;와 List&lt;String&gt;과 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다. 변성이 있는 이유: 인자를 함수에 넘기기List&lt;Any&gt;를 인자로 받는 함수에 List&lt;String&gt; 객체를 전달해도 괜찮을까?보통 Any가 더 상위 객체이니 별 문제 없을 것 같다. 하지만 경우에 따라 컴파일 에러가 발생한다. (책에서는 경우에 따라 런타임에서 문제가 될 수 있다고 했지만 실제로는 아예 컴파일이 되지 않는다.) 문제가 되는 경우: 원소 추가, 변경하는 경우아래 코드를 보면 리스트의 원소를 추가, 변경 가능한 MutableList를 매개변수로 갖는 함수에게 타입 인자가 하위 계층인 리스트를 전달하면 컴파일 자체가 되지 않는다. 그렇지 않은 함수는 별 문제 없이 잘된다. 1234567891011fun addContent(contents: MutableList&lt;Any&gt;) &#123; contents.add(123)&#125;fun printContents(contents: List&lt;Any&gt;) &#123; println(contents.joinToString())&#125;val strings = mutableListOf(&quot;a&quot;, &quot;b&quot;)printContents(strings)addContent(strings) // 컴파일 에러! 클래스, 타입, 하위 타입클래스와 티입의 구분타입과 클래스는 다른 개념이다. 예를 들어 String이라는 클래스는 코틀린에서 String과 String?두가지 타입을 만들어낸다. 즉 하나의 클래스에서 두가지의 타입이 나온다.그렇다면 List는 어떨까? List는 하나의 클래스이다. 다만 타입 매개변수에 따라 수많은 타입이 가능하다. (List&lt;String&gt;, List&lt;Int&gt; 등…) 이제 타입과 클래스가 구분된다는 의미가 와닿는다. 하위 타입, 상위 타입타입 A 자리에 타입 B가 와도 문제가 없을 때 B가 A의 하입 타입이다 라고 말한다. 반면 A는 B의 상위 타입이라고 한다. 컴파일러는 변수에 값을 대입할 때 변수의 타입이 값의 타입보다 상위 타입인지 확인한다. 간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다. 하지만 널 가능성과 제네릭 클래스의 경우 하위 타입과 하위 클래스의 차이가 두드러진다.Int는 Int?의 하위 타입이라고 볼 수 있다. 하지만 두 타입 모두 같은 클래스를 기반으로 한 타입이다. 제네릭 클래스의 경우 List&lt;Any&gt;는 List&lt;String&gt;의 상위 타입이라고 볼 수 있다. 하지만 MutableList&lt;Any&gt;는 MutableList&lt;String&gt;의 상위 타입이라고 볼 수 없다. (이유는 문제가 되는 이유라는 소제목을 보자.)즉 타입 인자가 서로 다른 타입이 들어갔을 경우 두 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않는 상황을 무공변이라고 한다! (참고로 자바에서는 모든 클래스가 무공변이라 한다.)지 공변성: 하위 타입 관계를 유지같은 제네릭 클래스 기반의 서로 다른 타입 인자를 가진 두 인스턴스의 하위 타입 관계가 유지되면 공변이라고 얘기한다. 코틀린에서 공변한 클래스를 선언하는 방법을 소개한다. 123interface Producer&lt;out T&gt; &#123; fun produce(): T&#125; out 키워드를 타입 파라미터 앞에 붙여주자. 공변인 타입 파라미터는 함수 정의에 사용된 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다. 즉 하위 관계인 타입 인자가 함수에 사용되어도 된다는 의미다. 아웃, 인, 생산, 소비모든 클래스를 공변으로 만들면 안된다. 타입 안정성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에 있어야 한다.이는 클래스가 타입의 값을 생산(반환)할 수는 있지만, 타입 값을 소비(파라미터 타입 선언)할 수 없다는 의미다. 1234interface Transformer&lt;T&gt; &#123; fun transformIn(t: T) &#123; ... &#125; // 타입을 소비 (in) fun transformOut() : T &#123; ... &#125; // 타입을 생산 (out)&#125; 정리하자면 공변성은 타입 인자를 아웃(생산, 반환) 위치에만 사용하는 클래스만 가능하다. 공변의 규칙에서 자유로운 생성자 &amp; private 메서드공변은 인스턴스가 생성되고 나서 하위 타입 관계를 유지할 수 있도록 하는 규칙이므로 생성자는 관련없다. 그리고 인, 아웃 규칙은 외부에서 볼 수 있는 클래스 API 관점에서 정의이다. private 메서드는 인, 아웃 둘 다 해당하지 않는다. 반공변성: 뒤집힌 하위 타입 관계반공변성은 공변성의 반대다. 즉 타입 A가 타입 B의 하위 타입인데, Consumer&lt;B&gt;가 Consumer&lt;A&gt;의 하위 타입이 될 때 반공변성이라고 한다. 인 아웃 규칙도 반대다. 인 위치에서만 타입이 사용되어야 반공변성이 성립한다. 123interface Consumer&lt;in T&gt; &#123; fun consume(value: T)&#125; 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정클래스에서 in과 out으로 타입 매개변수에 변성을 지정해주지 않고 타입이 언급되는 곳마다 변성을 적용하는 방법이 사용 지점 변성이다. 자바에서 와일드카드 기능을 통해 ? extends String 이런 식으로 사용 지점 변성을 사용한다. (물론 기존의 선언 지점 변성이 코드 중복을 줄여주는 장점이 있어 더 간결하다.) 123fun &lt;T, R&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;T&gt;) &#123; for (item in source) destination.add(item)&#125; 무공변인 MutableList를 인자로 받아 인과 아웃에서 모두 사용하고 있다. 123fun &lt;T, R&gt; copyData(source: MutableList&lt;out T&gt;, destination: MutableList&lt;in T&gt;) &#123; for (item in source) destination.add(item)&#125; in, out 키워드를 통해 적절한 변성을 적용했다. 이때 in, out 키워드를 붙인 타입에서는 타입 프로젝션이 일어난다. 일반적인 MutableList가 아닌 변성이 적용된 MutableList 타입으로 만들어서, 해당 변성에 맞는 메서드만 호출할 수 있게 된다. 스타 프로젝션: 타입 인자 대신 * 사용스타 프로젝션은 어떤 구체적인 타입이 타입 인자로 정해졌는데, 정확히 어떤 타입인지 추론할 수 없을 때 사용한다. 일반적으로 타입 인자가 중요하지 않은 경우 주로 사용한다. MutableList&lt;*&gt;를 통해 스타 프로젝션에 대해 이해해보자. Any?와 차이MutableList&lt;*&gt;와 MutableList&lt;Any?&gt;는 의미가 다르다. 후자는 어떤 객체든 담을 수 있는 리스트이다. 전자는 구체적인 타입 인자가 정해졌는데 추론할 수 없는 상황이므로 아무 객체나 담으면 안된다. 반면 전자에서 값을 꺼낼 때는 타입을 정확히 추론할 수는 없지만 Any?의 하위타입일 것은 명확하므로 반환하는 타입은 Any?가 된다. 따라서 MutableList&lt;*&gt;는 아웃 프로젝션 타입이 된다. 즉 생성(반환)만 되고 소비(인자로 사용)은 안되는 타입이다!","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"고차 함수(파라미터와 반환 값으로 람다 사용)","slug":"kotlinInAction/kotlinInActionCh8","date":"2023-01-31T07:41:02.000Z","updated":"2023-01-31T16:31:47.317Z","comments":true,"path":"2023/01/31/kotlinInAction/kotlinInActionCh8/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/31/kotlinInAction/kotlinInActionCh8/","excerpt":"","text":"고차 함수고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다. 코틀린의 고차 함수가 인자나 반환값으로 함수를 사용하기 위해서는 함수 타입이 필요하다. 함수 타입자바에서 람다 식을 매개변수나 반환값으로 사용하기 위해서는 함수형 인터페이스를 사용했다. 코틀린에서는 함수 타입이 존재한다. 12val sum: (Int, Int) -&gt; Int = &#123;x, y -&gt; x + y&#125;val action: () -&gt; Unit = &#123; println(42) &#125; 위 코드를 보면 함수 타입에 대해 알 수 있다. 마치 람다 식처럼 생겼다. 널을 반환하거나 함수 타입 자체가 널이 될 수 있다. 12val canReturnNull: (Int) -&gt; Int? = &#123; null &#125;val funOrNull: ((Int, Int) -&gt; Int)? = null 함수 타입이 파라미터로 활용될 때 함수 타입의 파라미터에 이름을 정해줄 수 있다.고차 함수에서 함수 타입 호출은 일반 함수 호출처럼 괄호 안에 인자를 넣어서 한다. 1234567fun doSomething(callback: (code:Int, content:String) -&gt; Unit) &#123; callback(1, &quot;content&quot;)&#125;fun main() &#123; doSomething &#123; code, content -&gt; println(&quot;code = $code, content = $content&quot;) &#125;&#125; 자바에서 코틀린 함수 타입 사용코틀린의 함수 타입은 자바에서 FunctionN이라는 인터페이스로 바뀐다. 매개 변수 갯수에 따라 FunctionN&lt;R&gt;, Function&lt;R, P1&gt; 등으로 바뀐다. 이렇게 바뀐 인터페이스 안에는 invoke 메서드가 정의되어 있다. invoke를 통해 함수를 실행시킬 수 있다. 이때 Unit을 반환하는 함수 타입을 자바에서도 사용할 수 있으나 자바에서 void를 반환하는 람다를 Unit을 반환하는 함수 타입에 전달해줄 수 없다. 코틀린의 Unit은 값이 있지만 자바의 void는 값이 없기 때문이다. 디폴트 값을 지정한 파라미터와 널이 될수 있는 함수 타입 파라미터 활용고차 함수에 함수 타입 파라미터에 디폴트 값을 넣어줄 수 있다. 또한 널이 될 수 있도록 타입을 정할 수 있다. 다만 이런 경우 고차 함수에서 함수 타입에 해당하는 객체를 바로 호출할 수 없고 안전하게 호출해야 한다. 12345678fun doSomethingWithDefault(callback: ((code: Int, content: String) -&gt; Unit)? = null) &#123; callback?.invoke(1, &quot;content&quot;) ?: run &#123; println(&quot;input null&quot;) &#125;&#125;fun main() &#123; doSomethingWithDefault() // input null&#125; 람다를 활용한 중복 제거사이트 방문 데이터에 대항 정보를 통계내는 코드를 작성할 때 람다로 중복을 제거해보자. 일단 데이터는 다음과 같다. 1234567891011121314151617enum class OS &#123; WINDOWS, MAC, IOS, ANDROID&#125;data class SiteVisit( val path: String, val duration: Double, val os: OS)val log = listOf( SiteVisit(&quot;/&quot;, 1.0, OS.WINDOWS), SiteVisit(&quot;/hello&quot;, 2.0, OS.MAC), SiteVisit(&quot;/welcome&quot;, 3.0, OS.ANDROID), SiteVisit(&quot;/goodbye&quot;, 4.0, OS.ANDROID), SiteVisit(&quot;/welcome&quot;, 5.0, OS.IOS),) 이제 안드로이드 사용자들의 평균 방문 시간을 출력해보자. 하드 코딩한 필터를 사용한 예시 12345val averageAndroidDuration = log .filter &#123; it.os == OS.ANDROID &#125; .map(SiteVisit::duration) .average()println(averageAndroidDuration) 이렇게 구현하면 다른 os의 평균을 구할 때마다 중복된 코드를 적어줘야 한다. 이를 개선해보자. 개선한 예시 1234fun List&lt;SiteVisit&gt;.averageDurationFor(os: OS) = filter &#123; it.os == os &#125; .map(SiteVisit::duration) .average() 이제 디바이스 별로 방문시간 통계를 내는 상황을 코드로 짜보자. 하드코딩한 예시 12345val averageMobileDuration = log .filter &#123; it.os in setOf(OS.IOS, OS.ANDROID) &#125; .map(SiteVisit::duration) .average()println(averageMobileDuration) 이를 고차 함수를 활용해서 개선해보자. 개선한 예시 123456fun List&lt;SiteVisit&gt;.averageDurationFor(predicate: (SiteVisit) -&gt; Boolean) = filter(predicate) .map(SiteVisit::duration) .average()println(log.averageDurationFor &#123; it.os in setOf(OS.ANDROID, OS.IOS) &#125;) 와우! 재활용이 엄청 잘되겠다~ 인라인 함수: 람다의 부가 비용 없애기코틀린은 람다를 보통 무명 클래스로 컴파일 하지만 람다 식을 사용할 때마다 클래스를 만들지는 않는다.람다가 변수를 포획하면 람다가 생성되는 시점에 무명 클래스 객체가 생긴다.따라서 람다는 같은 작업을 하는 일반 함수에 비해 덜 효율적인 것 같다. 하지만 inline 변경자를 통해 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트 코드로 바꾸치기 한다. 인라이닝이 작동하는 방식어떤 함수를 inline으로 선언하면 해당 함수를 호출하는 코드 대신 해당 함수의 본문이 바이트 코드로 컴파일된다. 12345678910111213inline fun doSomething2(callback: () -&gt; Unit) &#123; println(&quot;start to do Something&quot;) callback() println(&quot;end of something&quot;)&#125;fun foo() &#123; println(&quot;it&#x27;s foo function!&quot;) doSomething2 &#123; println(&quot;do foo things~!&quot;) &#125; println(&quot;end of foo function!&quot;)&#125;foo() 이런 식으로 inline을 적용하는 경우 foo 함수는 다음 코드와 같은 바이트 코드로 컴파일 된다. 1234567fun foo() &#123; println(&quot;it&#x27;s foo function!&quot;) println(&quot;start to do Something&quot;) println(&quot;do foo things~!&quot;) println(&quot;end of something&quot;) println(&quot;end of foo function!&quot;)&#125; 위 예시를 유심히 보면 함수 본문과 전달받은 람다가 인라이닝 된 것을 볼 수 있다.이때 람다 대신 함수 타입의 변수에 람다를 담아서 전달하는 경우 해당 변수에 어떤 값이 담긴지 모르기 때문에 람다 부분은 인라이닝이 되지 않고 함수 본문만 인라이닝 된다. 만약 특정 람다를 인라이닝하고 싶지않으면 noinline 변경자를 파라미터 이름 앞에 붙이면 된다. 123456inline fun doSomething2(noinline callback: () -&gt; Unit, otherCallback: () -&gt; Unit) &#123; println(&quot;start to do Something&quot;) callback() otherCallback() println(&quot;end of something&quot;)&#125; 모듈 밖이나 자바에서 인라인 함수를 호출하는 경우는 컴파일러는 일반 호출로 컴파일한다. 컬렉션 연산 인라이닝filter, map과 같은 컬렉션 연산은 람다를 매개변수로 받아 사용하는 인라인 함수이다. 이 경우 전달받은 람다와 컬렉션 연산 함수의 본문이 인라인된다!하지만 컬렉션 연산은 매번 연산마다 연산 결과를 컬렉션으로 만들어내서 여러 연산을 하는 경우 비효율적이다. 이런 비효율을 줄이는 게 시퀀스인데, 시퀀스를 사용하면 중간 시퀀스가 전달 받은 람다를 필드로 저장하는 객체로 표현되며 최종 연산이 진행될 때 중간 시퀀스에 있는 여러 람다를 연쇄 호출하는 방식으로 진행된다. 즉 시퀀스는 람다를 저장해야 하므로 람다를 인라인하지 않는다. 따라서 지연 계산을 통해 성능 개선하려고 모든 컬렉션 연산을 시퀀스로 하면 안된다. 컬렉션의 크기가 작은 경우 컬렉션 연산을 통한 인라이닝이 더 성능에 도움이 될 수 있다. 컬렉션 크기가 매우 큰 경우에만 시퀀스를 활용하자. 함수를 인라인으로 선언해야 하는 경우inline 키워드를 남용하면 안된다. 왜냐면 일반 함수 호출은 JVM이 이미 강력하게 인라이닝하기 때문이다. JVM은 바이트코드가 기계어로 번역되는 과정에서 일어난다. JVM의 최적화는 바이트코드 상에서 호출된 함수 부분에서 따로 함수 코드가 중복되지 않는다. 반면 코틀린의 인라인 함수는 바이트코드에서 함수 호출 지점을 함수 본문으로 변환해서 코드 중복이 생긴다. 게다가 함수 직접 호출은 스택 트레이스가 더 깔끔해진다. 반면 람다를 인자로 받는 함수를 인라이닝하면 이익이 많다. 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요가 없어진다. JVM이 함수 호출과 람다를 인라이닝할 정도로 똑똑하지는 않다. 인라이닝을 사용하면 일반 람다에서 사용 못하는 기능을 사용할 수 있다.(넌로컬) 인라이닝을 적용할 때는 해당 함수의 크기를 고려하자. 길이가 매우 긴 함수를 인라이닝하면 바이트코드의 용량이 매우 커질 수 있다. 이런 경우 매개변수의 람다를 선택적으로 인라이닝하지 않거나 하는 방식을 고려해볼 수 있다. 고차 함수 안에서 흐름 제어람다를 호출하는 함수에서 return을 호출하면 어떻게 될까?사람들 중 Alice라는 이름의 사람을 찾는 코드 예시로 흐름 제어 사례를 살펴보자. 명령형 코드 예시 1234567891011val people = listOf(Person(&quot;Alice&quot;, 27), Person(&quot;Bob&quot;, 25))fun lookForAlice(people: List&lt;Person&gt;) &#123; for (person in people) &#123; if (person.name == &quot;Alice&quot;) &#123; println(&quot;FOUND!!!&quot;) return &#125; &#125; println(&quot;Alice is not found...&quot;)&#125; 람다 안의 return문: 람다를 둘러싼 함수로 반환123456789fun lookForAlice2(people: List&lt;Person&gt;) &#123; people.forEach &#123; if (it.name == &quot;Alice&quot;) &#123; println(&quot;FOUND!!&quot;) return &#125; &#125; println(&quot;Alice is not found...&quot;)&#125; 람다 안에서 return을 사용하면 람다로부터만 반환되느게 아니라 람다를 호출하는 함수가 실행을 끝내고 반환된다. 이렇게 나를 감싼 블록보다 더 바깥의 블록을 반환하게 만드는 return문을 넌로컬 return이라 부른다. 마치 자바 for 루프 내부에서 return을 하면 해당 루프를 사용하는 함수가 종료되는 것과 같은 논리이다. 이렇게 return이 바깥쪽 함수를 반환시킬 수 있는 경우는 람다를 인자로 받는 함수가 인라인 함수인 경우에만 그렇다!!!!!!! 인라인 함수가 아닌 함수는 변수에 저장되어 호출 시점이 바깥 함수 호출 시점과 분리될 수 있다. 그래서 함수 내부의 return이 바깥쪽 함수 반환을 시킬 수 없게 된다. 람다로부터 반환: 레이블을 사용한 return람다 식에서 for 루프의 break과 비슷한 역할을 하는 로컬 return이 있다. break 시킬 람다나 함수를 레이블로 사용하면 된다. 123456789101112131415161718fun lookForAlice3(people: List&lt;Person&gt;) &#123; people.forEach label@&#123; if (it.name == &quot;Alice&quot;) &#123; println(&quot;FOUND!!&quot;) return@label &#125; &#125;&#125;fun lookForAlice4(people: List&lt;Person&gt;) &#123; people.forEach &#123; if (it.name == &quot;Alice&quot;) &#123; println(&quot;FOUND!!&quot;) return@forEach &#125; &#125;&#125; 무명 함수: 기본적으로 로컬 return넌로컬 반환문을 여럿 사용해야 하는 경우 무명 함수로 코드를 더 쉽게 만들 수 잇다. 123456fun lookForAlice4(people: List&lt;Person&gt;) &#123; people.forEach(fun (person) &#123; if (person.name == &quot;Alice&quot;) return println(&quot;$&#123;person.name&#125; is not Alice&quot;) &#125;)&#125; 무명 함수 내부 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킨다. (무명 함수 바깥 함수를 반환시키지 않는다!!!) 애초에 return은 fun으로 정의된 가장 안쪽 함수를 반환시키는 데, 람다식은 fun으로 정의되지 않아 람다 밖의 함수를 반환시킨 것이다. 무명 함수는 fun으로 함수 선언되었으니 바깥 함수를 종료시키지 않을 수 있다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"연산자 오버로딩과 기타 관례","slug":"kotlinInAction/kotlinInActionCh7","date":"2023-01-26T08:38:17.000Z","updated":"2023-01-27T15:30:19.651Z","comments":true,"path":"2023/01/26/kotlinInAction/kotlinInActionCh7/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/26/kotlinInAction/kotlinInActionCh7/","excerpt":"","text":"산술 연산자 오버로딩코틀린에서 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서 관례라고 부른다.코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자다. 기존 자바에서는 원시 타입과 문자열 정도에 산술 연산자를 쓸 수 있다. 하지만 관례를 적절히 사용하면 다른 클래스에도 산술 연산자를 쓸 수 있다. 이항 산술 연산 오버로딩1234567891011data class Point(val x: Int, val y: Int) &#123; operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125;&#125;val p1 = Point(1, 2)val p2 = Point(3, 4)val p3 = p1 + p2println(p3) // x = 4, y = 6 산술 연산자 +는 plus 라는 이름의 함수로 오버로딩할 수 있다. 이때 산술 연산 오버로딩은 함수 앞에 operator가 붙어야 한다.연산자 오버로딩은 확장함수로도 가능하다. 123operator fun Point.plus(other: Point) : Point &#123; return Point(x + other.x, y + other.y)&#125; 이항 산술 연산자는 times, div, mod(rem), plus, minus 등 정해진 함수 이름을 사용해야 하며 기존 연산자의 우선순위와 같다. 연산자 함수와 자바코틀린 연산자는 함수로 정의된다. 긴 이름을 사용하면 일반 함수로 호출할 수 있다. 코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음123456789operator fun Point.times(scale: Int) : Point &#123; return Point(x * scale, y * scale)&#125;val p1 = Point(1, 2)val p2 = Point(3, 4)println(p1 * 2) // x = 2, y = 4// p1 * 2는 컴파일 되지 않는다. 연산자 오버로딩은 다양한 매개변수를 가질 수 있다. 위의 예시도 그런 상황인데, 이때 일반적인 산술연산자 처럼 교환법칙을 지원하지는 않는다.그리고 오버로딩된 연산자의 반환값이 반드시 두 피연산자 중 하나여야만 하는 것도 아니다. 복합 대입 연산자 오버로딩+=, -= 같은 복합 대입 연산자는 사실 +, - 같은 연산자를 오버로딩하면 자연스럽게 지원된다.하지만 이런 경우 새로운 객체를 만들어서 반환하게 된다. (위 예시를 보면 새로운 객체를 만들어서 반환한다.) 이를 대비해 복합 대입 연산자도 오버로딩을 지원한다. 123456789101112data class Point(var x: Int, var y: Int)operator fun Point.plusAssign(other: Point) &#123; this.x += other.x this.y += other.y&#125;var p1 = Point(1, 2)var p2 = Point(3, 4)p1+=p2println(p1) // x = 4, y = 6 이때 주의해야 할 점은 복합 대입 연산자와 이에 필요한 이항 산술 연산자를 같이 재정의하면 컴파일러가 어떤 연산자를 사용해서 코드를 실행해야 할 지 알 수 없어서 컴파일 에러가 생긴다.그래서 이 두가지 산술 연산자를 동시에 재정의하지 않도록 하자. 위 예시에서는 plus와 plusAssign을 동시에 재정의하면 +=를 할 때 컴파일 오류가 생긴다. 객체의 프로퍼티를 변경할 수 없는 경우는 plus와 같은 이항 산술 연산자만 오버로딩하고 변경 가능한 클래스를 설계한다면 plusAssign만 제공하는 방식을 고려할 수 있다. 코틀린 컬렉션에서 대응 예시코틀린 컬렉션에서는 변경 가능한 컬렉션에는 +=와 -=를 통해 메모리에 있는 객체 상태를 변경시킬 수 있게 해놨다. 반면 읽기 전용 컬렉션에서는 +=와 -=는 변경을 적용한 복사본을 반환하도록 했다. 단항 연산자 오버로딩단항 연산자도 크게 다르지 않다. unaryPlus, unaryMinus, not 등 정해진 이름을 통해 오버로딩한다. 123operator fun Point.unaryMinus() : Point &#123; return Point(-x, -y)&#125; 이때 ++와 -- 같은 전위와 후위 증가(감소) 연산자는 연산해서 반환할 값만 정해주면 연산자를 어떻게 사용하느냐에 따라 컴파일러가 알아서 전위 혹은 후위 연산을 처리해준다.inc와 dec을 사용하면 된다. 123456operator fun Point.inc() : Point &#123; return Point(++x, ++y)&#125;println(p2++)println(++p2) 비교 연산자 오버로딩equals코틀린에서 ==가 참조 주소를 비교하는 동일성 비교가 아닌 값을 비교하는 동등성 비교로 작동한다. 이를 가능하게 하는 것도 관례의 힘이다.대략 다음과 같은 코드가 작동하는 셈이다. 12//a == ba?.equals(b) ?: (b == null) 참고로 != 또한 ==의 결과를 반전시키면 되니 자연스럽게 지원된다. compareTo코틀린에서 관례를 통해 compareTo를 &lt;,&gt;, &lt;=, &gt;=로 해결할 수 있다. 1234567data class Point(var x: Int, var y: Int) : Comparable&lt;Point&gt; &#123; override fun compareTo(other: Point): Int &#123; return compareValuesBy(this, other, Point::x, Point::y) &#125;&#125;println(Point(3, 4) &lt;= Point(4, 3)) // true Point가 Comparable을 구현하여 compareTo를 재정의 했다. 이때 기존 인터페이스에 operator 선언이 되어 있어서 위 예시에는 생략됐다. 컬렉션과 범위에 대해 쓸 수 있는 관례코틀린에서 관례를 통해 컬렉션의 원소에 접근해 읽거나 쓰는 연산을 함수가 아닌 연산자로 할 수 있다. 인덱스로 원소에 접근: get과 setmutableMap[key] = newValue 처럼 코틀린에서는 맵에서 대괄호로 원소에 접근하거나 원소를 쓸 수 있다.코틀린에서는 이를 인덱스 연산자라고 한다. Map과 MutalbeMap 인터페이스에는 두 메서드가 이미 들어있다. 1234567891011121314151617181920operator fun Point.get(index: Int) : Int &#123; return when(index) &#123; 0 -&gt; x 1 -&gt; y else -&gt; throw IllegalArgumentException() &#125;&#125;operator fun Point.set(index: Int, value: Int) &#123; when(index) &#123; 0 -&gt; this.x = value 1 -&gt; this.y = value else -&gt; throw IllegalArgumentException() &#125;&#125;val point = Point(1, 2)println(point[0]) // 1point[0] = 2println(point[0]) // 2 in 관례코틀린에서 지원하는 in 연산자는 contains 함수에 대응한다. 12345operator fun Point.contains(other: Point): Boolean &#123; return other.x &lt;= x &amp;&amp; other.y &lt;= y&#125;println(Point(1, 1) in Point(3, 3)) // true rangeTo 관례범위를 만드는 .. 연산자는 rangeTo 함수에 대응한다.알아둘 점은 Comparable 인터페이스를 구현하면 rangeTo를 구현할 필요가 없다. 왜냐면 코틀린 표준 라이브러리에 Comparable 객체에 대해 적용 가능한 rangeTo 함수가 정의되어 있기 때문이다.rangeTo는 다른 산술 연산자나 범위 메서드보다 우선순위가 낮아서 되도록 괄호로 감싸서 표현해주자.0..(n + 1) 이렇게 가독성을 높게 하거나 (0..n).forEach &#123;...&#125; 이렇게 컴파일이 되도록 할 수 있다. for 루프를 위한 iterator 관례코틀린의 for 루프는 in 연산자를 사용한다. 하지만 contains에 대응하는 in과는 다른 연산자이다.for (x in list) &#123;...&#125; 이렇게 for 루프 안에 있는 in은 iterator 함수에 대응한다.코틀린은 확장 함수를 통한 관례를 통해 문자열을 for 루프를 돌 수 있다. 1operator fun CharSequence.iterator(): CharIterator 특정 클래스에 적용도 가능하다. 123456operator fun ClosedRange&lt;Point&gt;.iterator(): Iterator&lt;Point&gt; = object : Iterator&lt;Point&gt; &#123; var current = start override fun hasNext(): Boolean = current &lt;= endInclusive override fun next(): Point = current.apply &#123; current = Point(current.x + 1, current.y + 1) &#125; &#125; 구조 분해 선언과 component 함수구조분해 선언을 관례로 구현하면 다음과 같은 코드를 가능하게 한다. 1234val point = Point(1, 2)val (x, y) = pointprintln(x) // 1println(y) // 2 구조분해 선언은 내부적으로 다음과 같이 작동한다. 123// val (x, y) = pointval x = point.component1()val y = point.component2() 즉 componentN 함수에 대응한 관례를 만들면 된다. 12operator fun Point.component1() = xoperator fun Point.component2() = y 구조 분해 선언은 Map과 for 루프에서 효과적이다. 1for ((key, value) in map) &#123; ... &#125; Map의 Entry가 확장함수로 구조 분해를 제공해서 위와 같은 코드가 가능하다. 프로퍼티 접근자 로직 재활용위임 프로퍼티에도 코틀린의 관례가 뒷받침 된다. 위임 프로퍼티를 사용하면 값을 뒤받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있다. 위임 프로퍼티 소개위임 프로퍼티의 일반적인 문법은 다음과 같다. 123class Foo &#123; var p: Type by Delegate()&#125; 프로퍼티 p는 접근자 로직을 다른 객체(Delegate)에게 위임한다.컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다.프로퍼티 p는 자신의 작업을 위임 객체에게 전달한다. 123456class Foo &#123; private val delegate = Delegate() var p: Type set(value:Type) = delegate.setValue(..., value) get() = delgate.getValue(...)&#125; 이때 위임 프로퍼티를 위해 생성된 위임객체는 setValue와 getValue 메서드 호출을 통해 위임한다.위임 프로퍼티를 위한 위임 객체이 되려면 setValue와 getValue 메서드를 가져야 한다.다양한 매개변수가 있지만 현재 기본 구조 설명을 위해 생략했다. 1234class Delegate &#123; operator fun getValue(...) &#123;...&#125; operator fun setValue(..., value: Type) &#123;...&#125;&#125; 위임 프로퍼티 사용: by lazy() 사용한 프로퍼티 초기화 지연Person 클래스의 email을 가져오는 loadEmail 메서드가 오래걸리는 작업이라 최초 접근에만 초기화하는 경우를 생각해보자.만약 뒷받침하는 프로퍼티 기법을 사용하면 다음과 같이 null로 초기화 해놓고 사용할 것이다. 12345678class Person(val name: String) &#123; private var _emails: List&lt;String&gt;? = null val emails:List&lt;String&gt; get() &#123; if (_emails == null) _emails = loadEmail() return emails &#125;&#125; 일단 이 방법은 코드가 복잡하고 스레드 안전하지도 않다! 위임 프로퍼티를 사용해보자. 123class Person(val name: String) &#123; val emails: List&lt;String&gt; by lazy &#123; loadEmail() &#125;&#125; lazy는 첫 호출 시 지연 초기화하는 함수이고 람다를 매개변수로 받는다.lazy는 기본적으로 스레드 안전하고 필요에 따라 락을 람다에 전달할 수 있고, lazy가 동기화를 하지 못하게 할 수도 있다. 위임 프로퍼티 컴파일 규칙123class Foo &#123; var p: Type by Delegate()&#125; 이런 코드가 있다고 할 때 컴파일러는 Delegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티를 &lt;delegate&gt;라는 이름으로 부른다. 컴파일러는 프로퍼티를 포현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 &lt;property&gt;라는 이름으로 부른다. 123456class Foo &#123; private val &lt;delegate&gt; = Delegate() var p: Type get() = &lt;delegate&gt;.getValue(this, &lt;property&gt;) set(value: Type) = &lt;delegate&gt;.setValue(this, &lt;property&gt;, value)&#125; 위임 프로퍼티의 특징을 보면 프로퍼티를 꼭 초기화 하지 않아도 된다. 즉 프로퍼티 값이 저장될 곳을 바꿀 수 있고 간단한 로직을 추가할 수 도 있다. 프로퍼티 값을 맵에 저장프로퍼티를 동적으로 정의할 수 있는 확장 가능한 객체라고 부른다. 12345678910class Person &#123; private val _attributes = hashMapOf&lt;String, String&gt;() fun setAttribute(attrName: String, value: String) &#123; _attributes[attrName] = value &#125; val name: String get() = _attributes[&quot;name&quot;]!!&#125; 이런 식으로 프로퍼티를 담을 수 있는 맵을 가지고, 필수 프로퍼티를 선언하고 접근 로직을 맵을 통해 가져오도록 구현했다.이를 위임 프로퍼티로 구현할 수 있다. 123456789class Person3 &#123; private val _attributes = hashMapOf&lt;String, String&gt;() fun setAttribute(attrName: String, value: String) &#123; _attributes[attrName] = value &#125; val name: String by _attributes&#125; by 뒤에는 위임 객체가 와야 한다. Map과 MutableMap은 기본적으로 getValue와 setValue를 제공하기 때문에 가능하다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"퀴즈로 학습하는 운영체제와 정보기술의 원리","slug":"cs/os/퀴즈로_학습하는_운영체제와_정보기술의_원리","date":"2023-01-22T13:39:01.000Z","updated":"2023-02-27T12:50:36.252Z","comments":true,"path":"2023/01/22/cs/os/퀴즈로_학습하는_운영체제와_정보기술의_원리/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/","excerpt":"","text":"3장 메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가? 컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다. 운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가 운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코드만 메모리에 올리는데, 이 코드를 커널이라고 부른다. 입출력 장치에서 읽어온 데이터를 임시 저장하는 하드웨어 장치는 무엇이라고 하는가? 컨트롤러는 데이터를 데이터를 입출력 장치로 보내거나 가져오기 전에 임시 저장하는 메모리를 로컬 버퍼라고 한다. 데이터를 읽어오는 명령을 컨트롤러가 완료하여 로컬 버퍼로 읽어오는 작업을 완료한 경우 어떻게 CPU에게 해당 사실을 알리는가? 그 사실을 안 CPU는 어떻게 행동하는가? 컨트롤러는 데이터를 모두 읽어온 경우, CPU의 인터럽트 라인에 인터럽트를 추가하여 해당 작업을 완료했음을 알린다. CPU는 매번 명령을 실행하기 전에 자신의 인터럽트 라인을 확인해서 처리해야할 인터럽트가 있는지 확인한다. 인터럽트가 존재하는 경우 인터럽트 벡터를 통해 인터럽트 처리 루틴이 존재하는 주소로 가서 인터럽트에 맞는 처리 로직을 실행한다. 인터럽트의 종류와 각 종류의 차이점을 설명해보자. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 입출력 컨트롤러같은 하드웨어가 인터럽트 라인을 설정하고, 소프트웨어 인터럽트는 소프트웨어가 인터럽트 라인을 설정한다. 소프트웨어 인터럽트의 종류에 대해 설명해보자. 소프트웨어 인터럽트는 예외 상황과 시스템콜과 있다. 예외상황은 프로세스가 잘못된 메모리를 접근하려거나 값을 0으로 나누려는 잘못된 연산을 할 때 발생한다. 반면 시스템콜은 사용자 프로그램이 운영체제 코드를 사용해야 할 때 운영체제에게 해당 코드를 실행해주기를 요청하는 방법이다. 인터럽트를 처리할 때 CPU의 상태를 어떻게 저장되는가? 인터럽트를 처리해야 할 때 CPU의 레지스터 값, 하드웨어 상태, 실행 중인 코드 메무리 주소, 실행중인 위치 등을 PCB에 저장하고 CPU의 레지스터를 지운 다음 인터럽트 루틴을 실행한다. 입출력 방식 두가지에 대해서 설명해보자. 입출력은 동기식 입출력, 비동기식 입출력이 있다. 동기식 입출력은 한 프로세스가 CPU를 점유해 진행 중에 입출력을 해야 하는 경우 그 프로세스가 해당 입출력 작업이 완료될 때까지 기다리고 CPU는 해당 프로세스의 점유를 뺏고 다른 프로세스를 진행시키는 방식이다. 이때 입출력 작업 완료를 기다리는 프로세스는 봉쇄 상태가 되어서 CPU 자원을 할당받지 못하게 된다. 반면 비동기식 입출력은 입출력을 해야 하는 경우 해당 입출력이 끝날 때까지 기다리지 않고 해당 프로세스에서 입출력 작업이 완료되지 않아도 수행할 수 있는 작업을 이어서 진행한다. 동기식 입출력에서 입출력 발생 시 다른 프로세스에게 CPU를 할당했을 때 이 프로세스에서도 입출력이 발생하면 어떤 문제가 발생할 수 있고 이를 어떻게 방지하는가? 만약 먼저 실행하던 프로세스에서 입출력이 발생해서 다른 프로세스에게 CPU를 할당했는데 다음 프로세스도 입출력이 발생하면 여러 입출력 요청이 발생할 수 있다. 이 경우 입출력의 동기화가 지켜지지 않는 문제가 발생할 수 있다. 나중에 실행된 프로세스의 입출력 요청을 먼저 수행하고 처음 프로세스의 입출력이 같은 자원에 대한 입출력 요청을 했을 때 처음 프로세스는 예상하지 못한 결과를 얻을 수 있다. 이를 막기 위해 장치 별로 큐를 두어 요청한 순서대로 처리할 수 있게 한다. DMA라는 장치의 필요성에 대해 설명해보시오 입출력이 완료되어 로컬버퍼에 담긴 내용을 메모리에 올려야 할 때, 컨트롤러가 인터럽트 라인을 세팅해서 CPU가 메모리에 데이터를 적재하도록 한다. 문제는 이런 입출력 처리를 매번 인터럽트를 통해 CPU가 메모리에 적재하도록 하면 너무 여러번 CPU는 인터럽트 처리를 해야된다. DMA는 CPU가 메모리에 로컬버퍼의 데이터를 적재하는 일을 대리한다. 그래서 로컬버퍼 데이터를 메모리에 적재하는 일 때문에 CPU가 인터럽트 당하지 않도록 한다. DMA는 바이트 단위가 아니라 블록이라는 단위로 메모리를 읽어온 후 다 읽어온 경우 CPU에게 인터럽트를 통해 완료를 알린다. 저장장치 계층 구조에 대해 설명해보자. 컴퓨터의 저장장치는 주기억장치와 보조기억장치로 나뉜다. 주기억장치는 메모리를 휘발성이고 일반적으로 RAM을 매체로 사용한다. 보조기억장치는 비휘발성으로 하드디스크나 SSD를 매체로 사용한다. 저장장치 계층 구조는 레지스터 - 캐시 메모리 - 메인 메모리 - 마그네틱 디스크- 광디스크- 마그네틱 테이프 이런 구조로 빠를 수록 비싸고 용량이 적다. 앞 세가지는 주기억장치이고 나머지는 보조기억장치이다. 보조기억 장치의 목적에 대해 설명해보자. 각 목적의 비교를 해보자 보조기억 장치는 비휘발성의 특징을 통해 파일 시스템을 구현하는데 사용된다. 또한 주기억장치인 메모리의 연장 공간인 스왑 영역 역할을 한다. 운영체제는 프로그램 수행에 당장 필요하지 않은 부분은 디스크 스왑 영역에 적재한다. 이렇게 스왑 아웃된 영역은 필요하게 될 때 메모리에 올려서 사용하게 된다. 파일 시스템은 비휘발성을 활용하지만 스왑 영역은 메모리의 연장이므로 휘발성인 특징을 나타낸다. 캐싱 기법에 대해서 설명하고 왜 효과적인지 설명해라. 상대적으로 빠른 저장장치를 이용해 느린 저장장치의 선응을 향상 시키는 총체적 기법을 일컫는다. 느린 저장장치에서 자주 사용되거나 당장 사용되는 정보를 빠른 저장장치에 선별적으로 저장해서 두 저장 장치 사이의 속도를 완충시킨다. 컴퓨터 내의 데이터나 프로그램을 구성하는 부분이 균등하게 사용되지 않고 일부분만 주로 사용하는 특성이 있기 때문에 적은 양의 캐시로도 효과를 볼 수 있다. 하드웨어 보안이 필요한 이유와 어떻게 달성하는 지 설명해보라 여러 프로그램이 실행될 때 다른 프로그램의 메모리 영역에 침범하는 일이 발생할 수 있다. 이런 문제를 막기 위해 운영체제는 커널모드와 사용자모드를 분리해서 사용자 프로그램이 보안에 예민한 부분을 직접 제어하지 못하게 막고 운영체제에게 서비스를 요청하는 방식으로 구현했다. 모드비트를 통해 사용자 프로그램이 어떤 모드인지 검증하는 방식으로 위험한 연산을 하지 못하도록 막는다. 메모리 보안을 어떻게 달성하는 지 설명해보고 한계를 설명해보라 사용자 프로그램이 정해진 메모리 주소 이내에 위치할 수 있도록 기준 레지스터와 한계 레지스터를 정해서 시작주소와 끝 주소를 정해놓는다. 해당 프로그램으로 직접 접근하려는 주소가 기준 레지스터와 한계 레지스터 사이에 없다면 잘못된 접근이라고 판단한다. 다만 이는 하나의 프로그램이 연속적으로 위치하는 단순한 메모리 관리 기법을 사용하는 경우로 한정했을 때 가능하다. 한 프로그램이 CPU의 자원을 오랫동안 독점하는 상황을 막는 역할을 하는 하드웨어에 대해 설명해보자. 타이머라는 하드웨어를 통해 여러 프로그램이 돌아가면서 CPU를 점유하도록 한다. 특정 시간이 지나면 인터럽트를 일으켜서 운영체제가 CPU 제어권을 획득할 수 있도록 하는 역할을 수행한다. 4장 CPU에서 프로그램이 실행되려면 메모리에 적재가 되어야 한다. 이때 프로그램 메모리 구조에 대해 설명해보자. 프로그램 메모리 구조는 네가지로 나뉜다. 소스 코드가 기계어로 변역된 코드가 저장되는 코드 영역, 프로그램의 전역 변수가 저장되는 데이터 영역, 프로그램에서 동적으로 할당된 메모리에 해당하는 힙 영역, 프로그램의 함수 호출 기록과 함수 내에서 사용한 지역 변수를 저장하는 스택 영역으로 나뉜다. 준비 되는 경우 IO 요청에 의해 실행 -> 봉쇄 되는 경우 CPU 작업 완료되어 실행 -> 종료 되는 경우 선점형과 비선점형 CPU 스케줄러를 구분지어 설명해보자. 선점형 스케줄러는 특정 프로세스가 실행 중일 때 실행 중인 프로세스보다 우선순위가 더 높은 프로세스가 준비큐에 진입하면 그 프로세스에게 CPU 자원을 넘기는 방식이다. 비선점형 스케줄러는 그런 경우에도 뺏기지 않는다. 디스패처에 대해 설명해보자. 문맥교환이 일어날 때 PCB의 값을 하드웨어에 세팅해야 하는 일을 하는 운영체제 코드이다. 스케줄링 성능 평가에 사용되는 다섯 가지 지표를 설명해보자. CPU 이용률 : 주어진 시간동안 CPU가 작업을 처리한 시간 비율 처리량 : 주어진 시간동안 작업 완료한 프로세스 비율 소요 시간 : 한 프로세스가 CPU를 기다린 시간과 CPU 할당 받아 실행한 시간의 합 대기 시간 : 한 프로세스가 CPU 버스트동안 준비큐에서 기다린 시간 응답 시간 : 한 프로세스가 준비큐에 들어가서 처음 CPU를 할당받은 시간. 선입선출 스케줄링의 장단점은? 먼저 온 프로세스를 완료할 때까지 CPU 자원 점유를 보장해주니 평균 소요시간과 평균 대기시간이 짧은 편이다. 하지만 CPU 버스트가 긴 프로세스가 점유하면 다른 프로세스들이 오랫동안 CPU를 점유하지 못하게 되는 콘보이 현상을 겪을 수 있다. 최단 작업 우선 스케줄링의 장단점은? CPU 버스트가 짧은 프로세스를 먼저 할당해서 IO 자원을 비교적 효율적으로 활용할 수 있고 선입선출 스케줄러의 콘보이 현상도 방지한다. 다만 준비큐에 CPU 버스트가 긴 프로세스가 있을 때 준비큐로 CPU 버스트가 짧은 프로세스가 계속 진입하면 CPU 버스트가 긴 프로세스는 CPU 자원을 점유하지 못하게 되는 기아 현상이 발생할 수 있다. 우선순위 스케줄링의 장단점은? 우선순위 스케줄링도 기아 현상이 발생할 수 있다. 하지만 CPU 할당을 받지 못한 준비 상태의 프로세스들의 우선순위를 동적으로 한단계 올려주는 노화 기법으로 기아 현상을 해결할 수 있다. 라운드 로빈 스케줄링에서 할당시간을 너무 길게 혹은 너무 짧게 설정하면 생기는 일에 대해 설명해보자. 라운드 로빈 스케줄링 할당 시간을 너무 늘리면 사실상 선입선출 스케줄링과 같아진다. 그래서 선입선출 스케줄링의 단점을 그대로 가져오게 된다. 할당 시간을 너무 짧게 하면 문맥 교환이 그만큼 더 자주 일어나게 되서 오버헤드가 커진다. 선입선출 스케줄링에 비해 라운드 로빈 스케줄링의 장단점은? 라운드 로빈 스케줄링은 선입 선출에 비해 평해 소요시간이 길다는 단점이 있다. 하지만 평균 응답시간이 빠르다는 장점이 있다. 멀티레벨 큐에 대해 설명해보자. 각 프로세스의 특징에 따라 여러 형태의 스케줄링 큐를 운영하는 방식이다. 응답을 빨리 해야되는 프로세스를 할당하는 라운드 로빈 전위 큐와 CPU 버스트가 긴 프로세스를 할당하는 선입 선출 후위 큐를 운영하는 방식으로 구현될 수 있다. 멀티레벨 피드백 큐에 대해 설명해보자. 우선 순위가 다른 여러 큐를 운영하되, 프로세스가 각 큐를 이동할 수 있는 방식이다. 우선순위가 높은 큐에서 할당 받지 못하면 낮은 큐로 이동하는 방식인데, 이때 해당 프로세스의 우선순위를 높이는 노화 방식을 도입할 수 있다. 스케줄링 알고리즘 평가 방법에 대해 설명해보자. 큐잉 모델, 시뮬레이션, 구현 및 실축 7장 컴퓨터 시스템의 주소 체계의 32비트, 64비트는 어떤 의미인가? 주소 체계는 컴퓨터가 해당 비트만큼 서로 다른 메모리를 구분할 수 있다는 의미이다. 32비트 주소 체계는 2^32가지의 주소를 부여할 수 있다. 컴퓨터는 각 주소마다 1바이트를 부여하므로 32비트 주소 체계는 2^32 바이트 만큼의 주소 공간을 가진다. 프로세스의 논리적 주소는 무엇인가? 프로세스마다 주어지는 독립된 논리적인 주소 공간을 의미한다. 주소 바인딩이란 무엇인가 각 프로세스의 독립된 논리적인 주소를 실제 물리적인 메모리 주소로 변환하는 과정을 말한다. 실행시간 바인딩에 대해 설명해보자. 프로세스의 논리적 주소에 매핑된 물리적 주소를 실행시간에서 바뀔 수 있는 바인딩 방법이다. 이 경우 물리적인 주소에 접근할 때마다 실제로 매핑되어 있는지 확인해야 한다. 이때 사용되는 것이 주소 매핑 테이블, 기준 레지스터, 한계 레지스터, MMU이다. MMU 기법에 대해 설명해보자. MMU(메모리 관리 유닛) 기법은 논리적 주소에 기준 레지스터를 더해서 물리적 주소를 찾아내는 기법이다. 이 기법은 기본적으로 프로세스의 물리적 주소 매핑이 연속되어 있다는 점을 전제로 한다. 각 프로세스마다 기준 레지스터가 달라지기 때문에 MMU는 문맥교환마다 새롭게 세팅되어야 한다. 동적 로딩과 동적 연결에 대해 설명해보자. 동적 로딩은 프로세스의 모든 내용을 메모리에 적재하는 것이 아닌 필요한 내용만 적재하는 것을 의미한다. 필요하지 않은 내용은 스왑 영역에 두었다가 호출 시 메모리에 할당하는 방식으로 운영한다. 동적 연결은 여러 프로세스가 사용하는 라이브러리 파일을 하나만 메모리에 적재하고 여러 프로세스가 해당 파일을 공유해서 사용하도록 하는 기법이다. 중첩과 동적로딩의 차이를 설명해보자. 중첩은 메모리가 부족한 상태에서 큰 메모리 용량을 차지하는 프로세스를 당장 필요한 부분만 메모리에 적재하는 기술이다. 동적 로딩은 동시에 여러 프로세스를 메모리에 적재하기 위해 각 프로세스마다 필요한 부분을 적재하는 방식인 반면 중첩은 부족한 메모리에서 큰 프로세스를 나눠서 실행하기 위한 방법이다. 연속할당 방식의 두가지 할당 방식에 대해 설명해보고 장단점을 설명해보자. 연속할당 방식은 고정 분할 방식과 가변 분할 방식이 있다. 고정 분할 방식은 메모리를 정해진 크기 만큼 균등하게 나눠서 각 조각 마다 프로세스를 할당하는 방식이다. 이 경우 프로세스가 할당되고 남은 부분인 내부 조각이 발생할 수 있다. 또한 각 조각대로 분할하고 남은 외부조각이 남을 수도 있다. 가변 분할 방식은 분할의 형태가 가변적으로 변하는 형태다. 이때 프로세스를 여러 공간 중 어디에 할당해야할 지 결정해야 하는 문제가 생길 수 있고, 가변 분할 방식도 외부조각 문제가 발생할 수 있다. 불연속할당 방식에서 페이징 기법에 대해서 설명해보자. 페이징 기법은 프로세스 메모리를 일정한 크기의 페이지로 균등하게 나눠서 물리적인 메모리를 균등하게 나눈 프레임에 불연속되게 할당하는 방식이다. 페이징 기법은 프로세스가 자신의 페이지가 어떤 프레임에 할당됐는 지 찾아 갈 수 있도록 페이지 테이블을 가진다. 페이징 기법의 성능에서 문제와 해결 방법을 제시해라. 페이징 기법은 프로세스의 페이지가 실제 물리적인 주소를 찾아야 한다. 이 과정에서 페이지 테이블을 순회하면서 자신의 물리적인 주소를 찾게 되므로 오버헤드를 갖게 된다. 이를 해결하기 위해 TLB라는 캐시를 활용한다. TLB는 병렬로 엔트리를 순회해서 더 빠르게 매핑된 물리 주소를 얻을 수 있다. 다만 TLB는 문맥교환 때 지워진다. 불연속할당 방식에서 세그먼테이션 기법에 대해서 설명해보자. 세그멘테이션 기법은 균등하게 프로세스 메모리를 나눠서 할당하는 것이 아닌 의미에 따라서 분할 하여 할당하는 방식이다. 크기가 가변적이라 외부조각 문제가 생길 수 있는데, 이를 방지하기 위한 페이지드 세그먼테이션 기법이 있다. 먼저 의미 기준으로 메모리를 나누고 나뉜 메모리들을 균등한 페이지로 다시 나눠서 불연속되게 프레임에 할당하는 방식이다. 이 경우 1차로 세그먼트 테이블, 2차로 페이지 테이블을 통해 물리적인 주소를 찾는다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[{"name":"운영체제와 정보기술의 원리","slug":"운영체제와-정보기술의-원리","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/"}],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"패키지 설계의 원칙","slug":"package","date":"2023-01-20T07:27:45.000Z","updated":"2023-01-27T16:08:52.651Z","comments":true,"path":"2023/01/20/package/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/20/package/","excerpt":"","text":"단위 크기: 패키지 응집도의 원칙개발자가 어떻게 클래스를 패키지에 분류해 넣을지 결정할 때 도움이 되는 규칙 세가지를 알아보자. 이때 각 클래스의 상호 관계가 일부분이라도 밝혀져 있음을 가정한다.모듈의 응집도는 모듈이 단 하나의 기능을 수행하는 속성을 의미했지만 패키지 응집도는 그보다 복잡하다. 재사용성과 개발 용이성에서 상충하는 가치를 검토하고 어플리케이션의 요구사항에 따라 패키지를 만들어야 한다. 재사용 릴리즈 등가 원칙 (REP, Reuse-Release Equivalence Principle) 재사용 단위가 릴리즈의 단위이다 재사용성 릴리즈 등가 원칙은 재사용 단위(예를 들면 패키지)는 릴리즈 단위보다 작을 수 없다. 재사용하는 모든 것은 반드시 릴리즈된 다음 추적되어야 한다. 단일 클래스 달랑 만들고 재사용할 수 있다고 말하기 힘들다. 해당 재사용 단위의 안정성과 지원에 대한 보장을 제공해야 재사용성이라는 말을 할 수 있다.패키지 내용물을 볼 때 잠재적인 재사용자의 입장에서 봐야 한다. 만약 패키지에 재사용될 소프트웨어가 들어 있다면, 그 패키지에는 재사용을 목적으로 설계뙤지 않은 소프트웨어는 들어 있지 않아야 한다. 패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않든지 해야 한다. 패키지 안의 모든 클래스는 동일한 재사용자를 대상으로 해야 한다. 어떤 사람의 관점에서 봤을 때, 한 패키지 안에서 일부 클래스는 필요하지만 일부는 전혀 필요 없으면 안된다. 공통 재사용 원칙(CRP, Common-Reuse Principle) 패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 모두 재사용되어야 한다. 함께 자주 재사용되는 클래스들은 동일한 패키지에 속하도록 해야 한다. 혼자 재사용되는 클래스는 거의 없다. 대부분 재사용 가능성에 대해 같은 추상적 범주에 있는 클래스들끼리 협력한다.두 개의 패키지가 하나의 클래스로 인해 의존 관계가 생긴다고 가정하자. 그렇다면 의존되는 패키지가 변경되면 의존하는 패키지도 검증하고 다시 릴리즈 해야 한다. 따라서 어떤 패키징p 의존한다면 그 패키지의 모든 클래스에 의존하는지 확실히 해두어야 한다.즉 CRP에 따르면 클래스 관계로 서로 단단히 묶여 있지 않은 클래스들은 같은 패키지에 넣지 말아야 한다. 공동 폐쐐 원칙(CCP, Common-Closure Principle) 같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야 한다. 어떤 한 패키지를 변경할 이유도 여러가지면 안된다. 동일한 이유로 변할 것 같은 클래스들은 한 장소에 모아놓아야 한다.이 원칙은 개방 폐쇄 원칙(OCP)과 밀접한 관련이 있다. OCP는 특정 오류의 변화에 개방되어 있는 클래스들은 같은 패키지 안에 몰아넣어서 이 전략을 더욱 확대한다. 따라서 요구사항에 변화가 오더라도 그에 따라 변경할 패키지 수를 최소화 할 수 있다. 안전성: 패키지 결합도의 원칙패키지 상호 관계에서 개바 ㄹ용이성과 논리적 설계 사이의 균형을 찾아 설계하는데 도움이 되는 세가지 규칙을 알아보자. 의존 관계 비순환 원칙(ADP, Acyclic-Dependecies Principle) 패키지 의존성 그래프에서 순환을 허용하지 말라 이런 형태의 패키지 의존성 그래프가 있다고 가정해보자. 이 상황에서 만약 Service A 패키지를 변경하고 새롭게 릴리즈 하려고 하면 누가 영향 받는지 알기 쉽다. Controller A 패키지가 영향을 받을 것이다. 즉 Service A를 새롭게 릴리즈 되어도 Controller A 패키지만 신경 쓰면 된다. 다른 패키지들은 관심이 없다. 여기서 Repository A 패키지가 불행하게도 Controller A 패키지를 의존하게 됐다고 해보자. 이 상황에서 Service A를 새롭게 변경하고 릴리즈 하려는 경우에 얼마나 많은 패키지를 확인해봐야 할까? Controller A 뿐만 아니라 Repository A까지 검사를 해야 한다. 즉 양방향 의존성이 생기게 되면 그 사이클 안에 패키지가 새롭게 릴리즈 되어야 할 때 그 사이클의 모든 패키지가 영향을 받을 수 있으니 확인해야 하는 문제가 생긴다!!! 순환 끊기의존성 순환이 생긴 경우 두가지 해결법이 있다. 의존 관계 역전 원칙을 적용한다.위 예시의 경우 Repository A가 필요로 하는 내용을 추상화해서 인터페이스로 만들어 Repository A에 놓고, 그 구현체를 Controller A에 둬서 의존 관계가 역전이 되게 만든다. 두 패키지가 서로 의존하는 새로운 패키지 만들기위 예시의 경우 Repository A와 Controller A 모두 의존하는 패키지를 새롭게 추가할 수 있다. 패키지는 하향식 설계를 할 수 없다.패키지 의존 관계 다이어그램은 애플리케이션의 기능을 기술하는 일과는 관련없다. 단지 애플리케이션의 빌드 용이성을 보여준다. 설계와 구현 초기 단계에 클래스가 적은 경우 어떤 것을 폐쇄해야 할 지, 재사용 가능한 것은 무엇인지를 알기 어렵다. 그래서 패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 성장하고 진화해야 한다. 설계와 구현을 해가면서 클래스 수가 점점 증가함 SRP와 CCP를 통해 변경되기 쉬운 클래스를 함께 묶어둠 애플리케이션이 성장하면서 재사용 가능 요소를 고려하면서 CRP를 고려 순환이 나타나게 되면 ADP를 통해 구조 개선 안정된 의존 관계 원칙(SDP) 의존은 안정적인 쪽으로 향해야 한다. 설계는 완전히 정적일 수 없다. 설계를 계속 유지보수하려면 어느 정도 변동성이 필요하다. 우리는 공통 폐쇄 원칙(CCP)를 지킴으로써 이것을 달성할 수 있다. 이제 안정된 의존 관계 원칙을 사용해서 어떤 종류의 변화에는 민감한 패키지를 만든다. 쉽게 바뀔 것이라고 예상되는 패키지들이 바뀌기 어려운 패키지들의 의존 대상이 되어서는 안된다. 이렇게 되면 쉽게 바뀔 패키지들도 바꾸기 어렵게 되어버린다. SDP를 지킴으로써 쉽게 변경할 수 있도록 의도한 모듈이 변경하기 어려운 모듈의 의존 대상이 되지 않도록 보장할 수 있다. 여기서 안정적인 패키지란 무엇인가? 특정 패키지 X가 있다고 할 때 그 패키지를 여러 곳에서 사용하고 있다고 하자. 그렇다면 X는 변경되기 어렵다. 즉 안정적이라고 볼 수 있다.반면 X가 만약 여러 패키지를 사용하고 있다면? 변경에 제한이 없다. 그래서 변경되기 쉽고 불안정적이라고 볼 수 있다. 안정성 측정법 a : 이 패키지에 의존하는 외부 클래스 갯수 b : 외부 패키지에 의존하는 이 패키지의 클래스 갯수 안정성 측정법은 불안전성 = b / (a + b)이다!!만약 불안정성은 0과 1사이이며 클 수록 외부에 의존하는 경향이 크다.결론은 남들 나에게 많이 의존하면 책임을 많이 지는 패키지이며 안정적이고, 내가 남들을 많이 의존하면 책임을 많이 지지 않으며 불안정적이다. SDP를 위반한다면?불안정한 패키지와 안정한 패키지가 의존하게 되는 불안정한 패키지의 클래스를 찾아서 DIP로 추출한 인터페이스를 새로운 패키지에 둘 수 있다. 안정된 추상화 원칙(SAP) 패키지는 자신이 안정적인 만큼 추상적이기도 해야 한다 어떤 패키지가 언정적이라면 확장할 수 있도록 추상 클래스들로 구성되어야 한다. 확장이 가능한 안정적인 패키지는 유연하며, 따라서 설계를 지나치게 제약하지 않는다. 추상성 측정법 a: 패키지 안에 들어 있는 클래스 개수 b: 패키지 안에 들어있는 추상 클래스 개수 추상성 측정법은 추상성 = b/a이다. 이상적인 상황과 비교패키지는 안정성에 비해 너무 추상적이지 않고 추상성에 비해 너무 불안정하지도 않은 게 좋다. 자신이 추상적인 만큼 의존의 대상이 되고 자신이 구체적인 정도 만큼 다른 패키지에 의존한다.x를 안정성이라하고 y를 추상성이라 할 때, (1,0)과 (0,1)을 잇는 직선을 주계열이라 하고 앞서 말한 좋은 패키지는 주계열에 근접할 수록 좋다. 이런 이상적인 상황과 거리를 구하는 공식은 다음과 같다.정규화된 거리 = | 안전성 + 추상성 - 1 |거리가 클 수록 주계열과 멀어지고 이상적이 상황과 멀어진다.","categories":[],"tags":[{"name":"Clean Software","slug":"clean-software","permalink":"https://yangdongjue5510.github.io/tags/clean-software/"}],"keywords":[]},{"title":"코틀린 타입 시스템","slug":"kotlinInAction/kotlinInActionCh6","date":"2023-01-19T12:07:55.000Z","updated":"2023-01-19T16:31:42.462Z","comments":true,"path":"2023/01/19/kotlinInAction/kotlinInActionCh6/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/19/kotlinInAction/kotlinInActionCh6/","excerpt":"","text":"널 가능성널이 될 수 있는 타입어떤 타입이든 타입뒤에 ?를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다. 널 가능성이 있는 타입은 호출 가능한 메서드가 제한된다. 또한 파라미터에 널 가능성이 없는 타입이 선언된 경우 널 가능성이 있는 타입은 인자로 전달할 수 없다. 널 가능성이 있는 타입은 널 체크 이후 널 가능성이 없는 타입처럼 사용할 수 있다. 자바에서 NPE 오류를 다루는 방법어노테이션을 활용해서 널이 될 수 있는 여부를 표시.(@Nullable, NotNull) 하지만 이런 방식이 정식 자바 컴파일에 해당하는 것도 아니고 모든 NPE 발생 가능 지점에 사용하기도 어렵다. null 대신 optional을 사용할 수 있는데 성능이 저하될 수 있고 외부 라이브러리에서 Null 반환을 막을 수 없다. 널 가능성이 있는 타입과 널 가능성이 없는 타입의 객체는 같다.널이 될 수 있는 타입이 특별한 래퍼 클래스는 아니다. 모든 검사는 컴파일 시점에 수행되고 런타임에 부가 비용이 들지 않는다. 안전한 호출 연산자 : ?.?.은 null 검사와 메서드 호출을 한번의 연산으로 수행한다. 1234val s: String? = nullval upperS = s?.uppercase()// 즉 이 코드와 같다.if (s != null) s.uppercase() else null 이때 안전한 호출의 반환값도 널 가능성이 있는 타입임을 명심하자. 엘비스 연산자 : ?:특정 객체가 null 인 경우 디폴트값을 줄 때 엘비스 연산자를 사용하면 된다. 1val result : String = s?: &quot;it&#x27;s null&quot; 안전한 호출과 연쇄해서 사용하기도 한다. 1val result : String = s?.uppercase()?: &quot;it&#x27;s null&quot; 엘비스 연산자 우항에는 식이 올 수 있다. 그래서 return이나 throw도 활용할 수 있다. 안전한 캐스트: as?코틀린은 타입 캐스트를 as로 하는데, 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다. 그래서 as를 하기 전에 is로 해당 타입으로 검사가 가능한지 확인할 수 있다. 하지만 이보다 더 좋은 방법이 as?이다as?는 해당 타입으로 변경할 수 없으면 null을 반환한다. 12345fun equals(o1: Any?, o2: Any?): Boolean &#123; val person1: Person = o1 as? Person ?: return false val person2: Person = o2 as? Person ?: return false return person1.name == person2.name &amp;&amp; person1.age == person2.age&#125; 널 아님 단언 : !!널이 될 수 있는 타입을 명시적으로 널이 될 수 없는 타입으로 바꾸는 연산자가 !! 이다. 널 아님 단언을 사용했는데 대상 객체가 null이면 NPE가 발생하니 다른 연산자를 통해 처리하도록 하자. let 함수let은 널 가능성이 있는 타입이 null이 아닌 경우에만 람다를 실행하도록 하는 함수이다. 12345fun sayHello(name: String?) &#123; name?.let &#123; println(&quot;hi my name is $name&quot;) &#125;&#125; 만약 여러 값이 널인지 검증해야 된다면 let을 중첩시켜서 할 수는 있지만 코드가 복잡해지니 if로 여러값을 한번에 검사하는 게 낫다. 나중에 초기화할 프로퍼티코틀린에서는 클래스 안에 널이 될 수 없는 프로퍼티는 생성자 안에서 초기화되어야 한다. 만약 초기값으로 널이 아닌 값을 주지 못하면 널이 될 수 있는 프로퍼티로 선언해야 한다. 하지만 널이 될 수 있는 타입을 쓰면 모든 프로퍼티 접근에 널 검사를 하거나 !! 연산자를 사용해야 되는 불편함이 생긴다. 이를 해결하기 위해 나중에 초기화하는 기능을 사용할 수 있다. 나중에 초기화는 lateinit 변경자를 붙여서 특정 프로퍼티를 나중에 초기화 할 수 있다. 12345678910111213class Manitto &#123; private lateinit var manitto: Person fun setManitto(person: Person) &#123; this.manitto = person &#125; fun hello() = println(&quot;hi my name is $&#123;manitto.name&#125;&quot;)&#125;val manitto = Manitto()manitto.setManitto(Person(&quot;Bob&quot;, 11))manitto.hello() 널이 될 수 있는 타입 확장널 가능성이 있는 타입에 확장 함수를 정의할 수 있다. 확장 함수는 해당 객체를 통해 디스패치된 메서드가 아니기 때문에 해당 변수가 널인지 검사를 내부에서 할 수 있다. 이렇게 되면 안전한 호출을 사용하지 않아도 된다. 12345678fun String?.printHello() &#123; if (this == null) println(&quot;it&#x27;s null&quot;) else println(&quot;hello $this&quot;)&#125;var str: String? = &quot;hey&quot;str.printHello()str = nullstr.printHello() 타입 파라미터의 널 가능성코틀린의 모든 타입 파라미터는 기본적으로 널이 될 수 있다. 그래서 안전한 호출을 써야한다. (물론 예시코드는 안전한 호출없이도 된다.) 123fun &lt;T&gt; printHashCode(t: T) &#123; println(t?.hashCode())&#125; 만약 타입에 널이 될 수 없게 하려면 상한을 걸어두자. 123fun &lt;T: Any&gt; printHashCode(t: T) &#123; println(t.hashCode())&#125; 널 가능성과 자바자바에서 타입을 코틀린으로 옮길 때는 어노테이션의 유무에 따라 달라진다.먼저 어노테이션이 있는 경우(@Notnull, @Nullable)는 자연스럽게 널 가능성이 없거나 널 가능성이 있는 타입으로 치환된다. 문제는 어노테이션이 없는 경우인데, 이 경우 코틀린에서 플랫폼 타입을 사용한다. 플랫폼 타입플랫폼 타입은 널 가능성을 판단할 수 없는 타입을 말한다. 이 경우 널 가능성이 없다고 판단하고 사용해도 되고, 널 가능성이 있다고 판단하고 널 처리를 해도 된다. 개발자에게 판단을 넘긴 셈이다. 자바 메서드를 오버라이딩할 때 널 주의코틀린에서 자바 메서드를 오버라이딩할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할 지 널이 될 수 없는 타입으로 선언할 지 결정해야 한다. 만약 널 가능성이 있는 파라미터로 개발하면 코틀린 컴파일러가 널이 아님을 검사하는 단언문을 만들어줁다. 내부에서 사용하지 않는 파라미터도 널 체크가 되기 때문에 이를 유의하자. 코틀린의 원시 타입코틀린은 숫자나 불린을 래퍼타입으로 구분하지 않는다. 다만 런타임에 숫자 타입은 가장 효율적인 방식으로 표현된다. 원시타입으로 컴파일이 안되는 제네릭 클래스 같은 경우에 래퍼타입이 들어간다. 널이 될 수 있는 원시 타입: Int?, Boolean?코틀린의 Int가 자바의 원시타입 int로 대부분 변환되고 제네릭 같은 경우에만 래퍼 클래스로 활용된다는 건 자연스럽다. 둘다 널 가능성이 없기 때문이다. 한편 코틀린에서 널 가능성이 있는 원시타입을 사용하면 자바에서는 래퍼 타입으로 변환된다. 또한 제네릭 클래스의 경우 래퍼 타입을 사용한다. 1val listOfInts = listOf(1, 2, 3) 위 예시는 자바에서 리스트 안에 원시 타입이 오지 못하므로 래퍼 클래스인 Integer가 오는 게 자연스럽다. 숫자 변환코틀린은 한 숫자 타입이 정해지면 다른 숫자 타입으로 자동으로 변환되지 않는다. 대신 직접 변환 메서드를 호출해야 한다. 12val i = 1val l: Long = i.toLong() Any, Any? : 최상위 타입자바에 Object가 있다면 코틀린에는 Any가 있다. 자바에서는 모든 객체의 조상이 Object이지만 코틀린은 원시 타입도 포함한 모든 값과 객체의 조상이 Any이다.다만 널 가능성에 따라 두 종류로 나뉘며, toString, equals, hashCode 외에 다른 Object 메서드는 지원하지 않는다. 만약 그런 메서드를 호출해야 하는 경우엔 캐스트해서 호출해야 한다. Unit 타입 : 코틀린의 void코틀린의 Unit은 자바의 void와 매우 흡사하다. 다만 Unit은 타입 인자로 사용할 수 있다. Unit도 값이 있다. 단 하나 Unit에 속하는 값은 이름도 Unit이다. 엄밀히 말하면 Unit은 반환값이 없는 것이 아니다. 기본 반환값으로 이해하면 좋다.코틀린에서 인터페이스에 반한값을 적지 않으면 묵시적으로 Unit을 반환하는 것을 의미하며 return Unit을 하지 않아도 컴파일러가 알아서 넣어준다. Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다.예외를 던져서 항상 제대로 값을 돌려주지 않는 함수에 Nothing을 사용한다. 123fun fail(message: String): Nothing &#123; throw IllegalStateException(message)&#125; Nothing의 진가는 엘비스 연산자의 우항으로 쓰일 때 진면목을 보인다. 12val address = Company(null).address ?: fail(&quot;no address&quot;)println(address.length) null 인 경우 Nothing인 메서드가 실행된다면, 이후 address에는 반드시 null이 아니라는 것을 확신할 수 있어서 널 가능성이 없는 타입으로 취급하고 사용할 수 있다. 컬렉션과 배열읽기 전용과 변경 가능한 컬렉션코틀린 컬렉션은 자바 컬렉션과는 다르게 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션안의 데이터를 변경하는 인터페이스를 분리했다는 점이 다르다.kotlin.collections.Collection 은 이터레이션, 사이즈 조회, 값 유무 검사, 데이터 조회 등을 지원하지만 컬렉션에 추가 및 제거는 지원하지 않는다. 변경 가능한 컬렉션은 이를 확장한 kotlin.collections.MutableCollection 인터페이스를 활용한다. 하지만 컬렉션 인터페이스를 활용할 때 주의점은 읽기 전용 인터페이스로 컬렉션을 활용하다고 그 컬렉션 객체가 실제로 불변 객체는 아니라는 점이다. 즉 다른 변경 가능한 컬렉션 인터페이스를 참조 변수로 접근하면 충분히 해당 객체에 변경이 생길 수 있고 이는 읽기 전용 컬렉션이 스레드 안전하지는 않음을 의미한다. 코틀린 컬렉션과 자바코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스 두가지 표현을 제공한다.코틀린은 코틀린 컬렉션 인터페이스가 마치 자바 컬렉션 클래스의 상위 타입인 것처럼 취급한다. 이를 통해 자바 호환성을 제공한다. 컬렉션 생성 함수와 자바 객체일반적으로 listOf는 읽기 전용을, mutableListOf는 변경 가능한 객체를 반환하는 식으로 작동한다. 이때 setOf와 mapOf는 자바 표준 라이브러리에 속한 클래스의 인스턴스를 반환한다. 즉 내부는 변경 가능한 컬렉션 객체인 셈이지만 절대 그 사실에 의존하지 않도록 하자 지비 메서드에서 Collection을 매개변수로 코틀린 컬렉션 받을 때 주의 사항코틀린에서 읽기 전용과 변경 가능한 컬렉션을 구분해도 자바 메서드에서 Collection을 매개변수로 받을 때는 이 구분이 의미가 없어지게 된다. 즉 읽기 전용으로 제한하던 인스턴스를 Collection을 매개변수로 갖는 자바 메서드에 전달하면 해당 메서드에서 변경 가능하게 할 수 있다는 의미다. 그래서 자바에서 올바른 파라미터 타입을 사용하고, 자바에서 코틀린에서 온 컬렉션을 사용해야 하는 경우 제한을 잘 확인하고 사용하자. 컬렉션을 플랫폼 타입으로 다루기자바에서 코틀린으로 오면 플랫폼 타입으로 온다. 이는 컬렉션도 마찬가지다. 플랫폼 타입인 컬렉션은 기본적으로 읽기 전용과 변경 가능 컬렉션 모두 사용할 수 있도록 한다. 문제는 플랫폼 타입은 그렇듯이 자바의 시그니처를 오버라이딩 할 때가 문제가 된다. 즉 자바 인터페이스의 시그니처에 컬렉션이 있는 경우 null 가능성과 컬렉션의 변경 가능성을 토대로 타입을 구체화해야 한다. 컬렉션이 null 가능한가 컬렉션의 원소가 null 가능한가 오버라이딩할 메서드가 컬렉션을 수정할 수 있는가 객체의 배열과 원시값의 배열코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소 타입은 타입 파라미터에 의해 정해진다.문제는 코틀린 배열이 항상 제네릭 타입을 받다보니 자바 코드로 바뀔 때 코틀린에서 원시 타입 배열이어도 자바에서는 래퍼 타입 배열이 되버린다. Array&lt;Int&gt; 가 Intger[]이 되어버린다. 이럴 경우 박싱하지 않은 원시 타입 배열을 의미하는 특별한 클래스를 활용해야 한다. IntArray, ByteArray 등 원시 타입마다 제공해준다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"람다로 프로그래밍","slug":"kotlinInAction/kotlinInActionCh5","date":"2023-01-17T10:21:40.000Z","updated":"2023-01-19T08:12:17.152Z","comments":true,"path":"2023/01/17/kotlinInAction/kotlinInActionCh5/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/17/kotlinInAction/kotlinInActionCh5/","excerpt":"","text":"람다 식과 멤버 참조람다 식의 문법코틀린의 람다 식은 항상 중괄호로 둘러 쌓여 있다. 그리고 인자 목록을 괄호로 싸지 않는다. 람다를 변수에 저장하고 함수처럼 사용할 수 있다. 123val sum = &#123;x: Int, y: Int -&gt; x + y&#125;println(sum(1, 2)) 실행 시점에서 코틀린 람다 호출에는 아무 부가 비굥이 들지 않으며 프로그램의 기본 구성 요소와 비슷한 성능을 낸다. 사람 목록에서 가장 연장자를 찾는 예제를 작성해본다. 12val people = listOf(Person(&quot;Bob&quot;, 10), Person(&quot;Rob&quot;, 11))println(people.maxBy &#123; it.age &#125;) maxBy 함수에 나이를 반환하는 람다를 전달했다. 이때 maxBy 부분을 최대한 풀어서 쓰면 다음과 같다. 1people.maxBy(&#123; p:Person -&gt; p.age &#125;) 하지말 이렇게 쓰면 너무 번잡하다. 어떻게 간편하게 개선되는지 알아보자. 먼저 함수의 맨 마지막 인자가 람다면 괄호 밖으로 뺄 수 있다. 1people.maxBy() &#123; p:Person -&gt; p.age &#125; 그리고 람다만 가지고 있는 함수에서 람다를 밖으로 빼면 빈 괄호를 생략할 수 있다. 1people.maxBy &#123; p:Person -&gt; p.age&#125; 마지막으로 람다 파라미터를 컴파일러가 예상할 수 있어서 생략할 수 있다. 1people.maxBy &#123; p.age &#125; 하지만 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않아서 파라미터 타입을 명시해야 한다. 12val getAge = &#123; p: Person -&gt; p.age &#125;people.maxBy(getAge) 코틀린에서 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it 키워드를 통해 파라미터를 표현할 수 있다. 1people.maxBy &#123; it.age &#125; 람다의 본문에 여러 줄이 될 수 있다. 그럴 때는 마지막 줄이 해당 람다의 반환값이 된다. 1234val sum = &#123; x: Int, y: Int -&gt; println(&quot;$x and $y&quot;) x + y&#125; 현재 영역에 있는 변수에 접근람다는 함수 파라미터를 람다 안에서 사용하 ㄹ수 있다. 12345fun printMessageWithPrefix(messages: Collection&lt;String&gt;, prefix: String) &#123; messages.forEach &#123; println(&quot;$prefix&quot;) &#125;&#125; 자바와 다르게 코틀린의 람다는 파이널 변수가 아닌 변수에 접근할 수 있다. 123456789101112fun printProblemCounts(responses: Collection&lt;String&gt;) &#123; var clientErrors = 0 var serverError = 0 responses.forEach &#123; if (it.startsWith(&quot;4&quot;)) &#123; clientErrors++ &#125; else if (it.startsWith(&quot;5&quot;)) &#123; serverError++ &#125; &#125; println(&quot;$clientErrors and $serverError&quot;)&#125; 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 만약 함수가 변수를 포획한 람다를 반환한다면 변수의 생명 주기는 함수와 달라지게 된다. 함수가 종료되어도 변수를 포획한 람다를 실행하면 해당 변수를 일고 쓸 수 있다. 파이널 변수를 포획한 경우 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수는 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다. 다만, 람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수 있다. 12345fun tryToCountButtonClick(button: Button) : Int &#123; var clicks = 0 button.onClick &#123; clicks++&#125; return clicks&#125; 이미 함수에서 로컬변수를 반환해서 변수의 변화를 볼 수 없다. 멤버 참조자바 8의 메서드 참조와 동일한 기능을 코틀린의 멤버 참조로 할 수 있다. 코틀린은 메서드뿐만 아니라 프로퍼티도 가능하다. 1people.maxBy(Person::age) 그리고 최상위로 선언된 함수나 프로퍼티를 참조할 수 있다. 또한 생성자를 참조할 수 있다. 12345fun salute() = pritnln(&quot;Salute!&quot;)run(::salute)val createPerson = ::Personval person = createPerson(&quot;Bob&quot;, 11) 바운드 멤버 참조123val p = Person(&quot;Bob&quot;, 11)val personAgeFunc = Person::ageprintln(personAgeFunc(p)) 코틀린 1.0에서는 클래스의 메서드나 프로퍼티에 참조를 얻고 클래스 인스턴스를 전달해줘야 가능했다. 하지만 코틀린 1.1부터는 바운드 멤버 참조를 지원한다. 바운드 멤버 참조는 클래스 인스턴스를 함께 저장한 다음 그 인스턴스에 대해 멤버를 호출한다. 123val p = Person(&quot;Bob&quot;, 11)val personAgeFunc = p::ageprintln(personAgeFunc()) 컬렉션 함수형 API필수적인 함수: filter, mapfilter는 특정 조건에 해당하는 원소만 남길 수 있다.map은 원소를 바꾸어서 새 컬렉션을 만든다. all, any, count, find: 컬렉션에 술어 적용count는 조건을 만족하는 원소의 갯수를 반환한다. 참고로 filter를 한 컬렉션의 size를 측정하는 것보다 count를 사용하는 것이 결과 컬렉션을 만들지 않아서 더 효과적이다.find는 조건을 만족하는 원소의 첫번째 원소를 반환한다.all은 모든 원소가 조건에 만족하는 지 반환한다.any는 조건에 만족하는 원소가 하나라도 존재하는 지 확인한다. groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경1234val list = listOf(&quot;a&quot;, &quot;ab&quot;, &quot;b&quot;)fun main() &#123; println(list.groupBy(String::first)&#125; Map&lt;Int, List&lt;String&gt;&gt;을 만들어서 반환한다. 위 예시는 &#123;a=[a, ab], b=[b]&#125; flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(map) 결과로 얻어지는 여러 리스트를 한 리스트로 모은다(flat). 12val strings = listOf(&quot;abc&quot;, &quot;def&quot;)println(strings.flatMap &#123; it.toList() &#125;) 문자열을 list로 매핑하고, 각 매핑된 컬렉션들을 하나의 컬렉션으로 모은다.중첩된 리스트이 원소를 한 리스트로 단순히 모아야 하는 경우 flatten 함수를 사용할 수 있다. 지연 계산(lazy) 컬렉션 연산map, filter 같은 컬렉션 함수는 컬렉션을 즉시 생성해서 반환한다. 즉 컬렉션 함수를 연쇄적으로 사용하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다. 12people.map(Person::name) .filter &#123; it.startsWith(&quot;A&quot;) &#125; 이 경우에 map과 filter의 결과를 리스트로 만들어 저장한다. 즉 중간 계산 결과가 두번 저장된다. 중간 게산 결과값이 크면 중간 계산 결과 저장이 비효율적일 것이다. 코틀린에서는 시퀀스를 통해 중간 임시 컬렉션을 사용하지 않도록 할 수 있다. 123people.asSequence() .map(Person::name) .filter &#123; it.startsWith(&quot;B&quot;) &#125; 코틀린 지연 연산 시퀀스는 Sequence 인터페이스에서 시작한다. 이 인터페이스는 iterator라는 메서드를 통해 원소값을 얻어 낸다. 하지만 하나씩 접근하는 것 외에 인덱스로 접근이나 다른 API를 사용하려면 시퀀스를 다른 컬렉션으로 다시 바꿔주자. 시퀀스 연산 실행: 중간 연산과 최종 연산시퀀스에 적용되는 함수는 일반적인 컬렉션 함수와 다르게 작동한다. 컬렉션 함수는 적용 즉시 컬렉션을 반환하지만, 시퀀스 함수에는 중간 연산과 최종 연산을 나눠서 생각해야 한다. 중간 연산은 최초 시퀀스에서 중간 연산을 적용할 줄 아는 시퀀스이다. 최종 연산은 연산들을 모두 적용한 결과를 반환한다. 123people.asSequence() .map(Person::name) .filter &#123; it.startsWith(&quot;B&quot;) &#125; 이 예시는 중간 연산만 적용되어 있어서 아직 연산이 적용된 결과 값이 만들어지지 않았다. 하지만 다음 예시처럼 최종 연산이 들어가면 비로소 모든 연산이 적용되고 결과값이 반환된다. 1234people.asSequence() .map(Person::name) .filter &#123; it.startsWith(&quot;B&quot;) &#125; .toList() 여기서 컬렉션과 시퀀스의 연산 적용 방식에 차이를 알아보자.컬렉션은 하나의 연산마다 모든 컬렉션에 적용을 한다. 반면 시퀀스는 하나의 원소에 모든 연산을 모아서 한번에 적용한다. 123listOf(1,2,3,4).asSequence() .map &#123; it*it &#125; .find &#123; it &gt; 3 &#125; 위와 같은 예시에서 컬렉션으로 연산했다면, 1 2 3 4 모두 map해야 한다. 그 다음 find를 진행한다.하지만 시퀀스의 경우 1 2만 모든 연산이 적용된다. 왜? 마지막 find는 최초 원소를 찾는데 2에 모든 연산을 적용하고 나서 조건을 만족함을 확인했기 때문에 3 4에 연산을 적용하지 않는 것이다. 자바 스트림과 코틀린 시퀀스의 차이사실 스트림과 매우 비슷하나 스트림의 병렬 처리를 시퀀스에서 제공하지 않는다. 다만 시퀀스는 자바 8보다 낮은 버전에서도 활용할 수 있다. 시퀀스 만들기asSequence함수와 generateSequence 함수를 통해 시퀀스를 만들 수 있다.generateSequence 함수는 첫 원소를 인자로 받고 다음 원소들을 계산하는 법을 람다로 받아서 만든다. 123val printZeroTo100 = generateSequence(0) &#123; it + 1&#125; .takeWhile &#123; it &lt;= 100 &#125; .forEach &#123; println(it) &#125; 자바 함수형 인터페이스 적용자바 메소드에 람다로 인자 전달함수형 인터페이스를 인자로 요구하는 자바 메서드에 코틀린 람다를 전달해줄 수 있다. 이 경우 컴파일러가 자동으로 람다를 해당 인터페이스의 인스턴스로 변환해준다. 12// void compute(Runnable computation); 이란 자바코드가 있다고 가정compute &#123; println(&quot;hi&quot;) &#125; 물론 무명 객체를 전달해줄 수 있다. 12345compute(object : Runnable &#123; override fun run() &#123; println(&quot;hi&quot;) &#125;&#125;) 하지만 람다를 전달하는 것과 무명 객체를 전달하는 것은 차이가 있다. 객체를 명시적으로 선언하면 메서드를 호출할 때마다 새로운 객체가 생성된다. 반면 람다는 람다에 대응하는 무명 객체를 메서드가 호출 할때마다 반복 사용한다. (하지만 함수의 변수에 접근하는 람다는 제외) 람다와 무명 클래스 객체의 this 차이무명 클래스 객체의 this는 자기 자신을 가리킨다. 반면 람다는 컴파일 타임에 아직 인스턴스가 없으므로 자기 자신을 가르킬 방법이 없다. 람다에서 this를 가르킬 경우 람다를 감싼 클래스 객체를 가리키게 된다. 만약 자기 자신을 가르켜야 되는 경우는 람다 대신 무명 객체를 활용하자. 람다를 무명 클래스의 인스턴스로 변환하는 것은 함수형 인터페이스를 받는 자바 메서드의 경우에만 그렇다.컬렉션 확장 함수 (inline 표시된 코틀린 함수)에게 람다를 전달해도 무명 클래스가 만들어지지 않는다. SAM 생성자: 람다를 함수형 인터페이스로 명시적 변경SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동 생성한 함수다. 컴파일러가 자동으로 람다를 함수형 인터페이스의 무명 클래스 인스턴스로 변환하지 못할 때 사용한다. 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 경우 람다로 반환하지 못한다.SAM 생성자는 함수형 인터페이스의 이름과 람다식을 전달해주면 된다. 1234fun createAllRunnable() : Runnable &#123; //람다는 안됨 return &#123; println(&quot;GOOD!&quot;)&#125; return Runnable &#123; println(&quot;GOOD!&quot;) &#125;&#125; 수신 객체 지정 람다 : with &amp; apply수신 객체를 명시하지 않고 람다에서 다른 객체의 메서드를 호출하는 기능을 수신 객체 지정 람다라고 한다. withwith의 힘을 느껴보기 위해 하나의 예시를 들어보고 with로 리팩토링 해보자 12345678fun alphabet(): String &#123; val result = StringBuilder() for (letter in &#x27;a&#x27;..&#x27;z&#x27;) &#123; result.append(letter) &#125; result.append(&quot;\\n alphabet end~\\n&quot;) return result.toString()&#125; 여기서 StringBuilder를 with로 처리하면 다음과 같다. with에 수신 객체를 적어두면 람다 내부에서 수신 객체를 적는 대신 this로 접근할 수 있다. 이렇게 하면 다양한 StringBuilder에서 해당 로직을 재활용 할 수 있다. 123456789fun alphabet(): String &#123; return with(StringBuilder()) &#123; for (letter in &#x27;a&#x27;..&#x27;z&#x27;) &#123; this.append(letter) &#125; append(&quot;\\n alphabet end~ \\n&quot;) this.toString() &#125;&#125; 여기서 this를 생략할 수도 있다. 123456789fun alphabet(): String &#123; return with(StringBuilder()) &#123; for (letter in &#x27;a&#x27;..&#x27;z&#x27;) &#123; append(letter) &#125; append(&quot;\\n alphabet end~ \\n&quot;) toString() &#125;&#125; 메서드 이름 충돌만약 위 예시의 toString이 StringBuilder가 아닌 해당 함수를 감싼 클래스의 toString을 호출하고 싶다면 어떻게 해야되나? this@OuterClass.toString()와 같은 방식으로 적어주면 된다. applyapply는 with와 같다. 다만 항상 수신 객체를 반환한다. 그리고 확장함수로 정의되어 있다. 12345678fun alphabet3(): String &#123; return StringBuilder().apply &#123; for (letter in &#x27;a&#x27;..&#x27;z&#x27;) &#123; append(letter) &#125; append(&quot;\\n alphabet end~ \\n&quot;) &#125;.toString()&#125; 마지막으로 수신 객체 지정 람다를 사용하는 더 구체적인 예시로 buildString 같은 함수가 있다. 인자로 수신 객체 지정 람다를 받으며(매번 수신 객체는 StringBuilder로 고정), StringBuilder 객체 생성과 toString 호출을 알아서 해주는 녀석이다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"구글 엔지니어는 이렇게 일한다. 문화 편","slug":"sofrwareEngineeringAtGoogle","date":"2023-01-12T12:37:52.000Z","updated":"2023-01-13T17:38:43.511Z","comments":true,"path":"2023/01/12/sofrwareEngineeringAtGoogle/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/12/sofrwareEngineeringAtGoogle/","excerpt":"","text":"구글 엔지니어는 이렇게 일한다 라는 책에서 필요한 부분을 읽고 기록해두는 포스트다. 많은 부분이 생략되어 있다. 혼자 일하지 말라초기 설계에는 근본적인 실수가 있을 수 있다. 바퀴를 재발명하려는 실수를 범할 수 있다. 우리가 올바른 일을 하고 있는지, 제대로 하고 있는지, 그리고 다른 누군가가 이미 해놓은 일을 아닌지를 확인해봐야 한다. 가능한 일찍 피드백받고, 가능한 일찍 테스트하자. 코드 뿐만 아니라 계획이나 설계 변경이 필요한 시점을 즉시 알려줄 피드백 루프를 팀 플레이를 통해 달성할 수 있다. 모든 건 팀에 달렸다.중요한 소프트 스킬 세가지 겸손 : 모든 것을 알고있다고 생각하지말고 배움에 열려있어야 한다. 존중 : 함께 일하는 동료를 진심으로 생각한다. 신뢰 : 동료들이 유능하고 올바른 일을 하리라 믿는다. 이 세가지를 바탕으로 사회적 관계에 힘을 써라. 자존심 버리기자신이 팀에서 제일 중요한 사람을 드러내지 말라. 모든 걸 다 아는 듯 행동하지 말라. 집단적 자존심을 찾아라. 팀의 성취와 단체의 자부심을 높이려 노력하라. 비평하고 비평받는 법 배우기상대방을 존중하고 건설적이고 공손하게 비평해라. 우리의 자존감을 우리가 작성한 코드와 동일시 해서 비평을 거부하지 말라. 빠르게 실패하고 반복하기실패하지 않는다면 충분히 혁신적이지 않거나 위험을 충분히 감수하지 않은 것이다.실패를 배우고 다음 단계로 넘어갈 수 있는 절호의 기회라고 생각하자. 비난 없는 포스트모템 문화실패의 원인을 분석해 문서로 남기는 것이 중요하다. 이를 포스트모템이라고 한다.포스트모템은 쓸모 없는 사죄, 변명, 지적으로 채워지지 않고 무엇을 배웠는지 앞으로 어떻게 바꿀지가 담겨야 한다. 훌륭한 포스트모템 사건의 개요 사건을 인지하고 이를 해결하기 까지 타임라인 사건 근본 원인 파악 영향과 피해 평가 문제를 즉시 해결하기 위한 조치 항목(소유자 명시) 재발 방지를 위한 조치 항목 해당 경험에서 얻은 교훈 지식 공유심리적 안전자신이 이해하지 못한 게 있음을 인정해야 무언가를 배울 수 있다. 모르는 것을 인정하는 사람을 질책하지 말고 반겨야 한다. 배움에는 시도해서 실패해도 안전하다는 인식이 중요하다. 질문을 던지고, 틀리고, 새로운 지식을 얻는 걸 편안하게 생각해야 한다. 질문하기항상 배우고 항상 질문하기를 잊지마라. 잘 모르겠으면 주위 동료들에게 질문하는게 내가 성장하는게 도움이 된다. 아무리 잘하는 사람이라도 모르는 분야가 반드시 있다. 이를 두려워 말고 도움을 청해본다.특히 상급자라고 모든 것을 안다는 인식이 생겨나지 않도록 하라. 사소한 질문이더라도 친절하게 답변해주자. 적절한 도움은 개인과 팀 생산력에 큰 도움이 된다.특히 일대일로 무언가를 배울 때는 기록해두는 습관을 가지자. 좋은 리더가 되기 위해서섬기는 리더십내가 누군가를 관리하는 것이 아닌 팀을 떠받드는 것이 중요하다. 겸손, 존중, 신뢰의 분위기를 조성하는 데 힘써야 한다. 혼자서 제거하기 힘든 관료적 장애물을 치워주고, 합의에 이르도록 이끄는 등 팀이 앞으로 나아가는데 필요한 기술적, 사회적 건강 관리를 한다. 오늘날의 엔지니어링 관리자 전통적인 관리자는 일을 어떻게 처리해야지를 고민하는 반면 훌륭한 관리자는 무슨 일을 처리할지를 고민한다. 관리자는 팀원을 아이처럼 대하지 말고 직원들을 신뢰하자. 직원들은 그 신뢰에 부응해야한다는 긍정적인 압박을 느낀다. 자존심 버리기겸손과 자신감 결여는 구분하자. 자만하지 않아도 자신감과 의견을 가질 수 있다. 팀을 하나로 모으고 방향을 정하게 도와주는게 리더의 역할이다. 구체적인 방법은 실무자들에게 맡기는 게 그들의 주인의식과 책임감 향상에 더 도움이 된다.리더가 모든 걸 알아야 된다는 강박에서 벗어나자. 완벽한 듯 행동하면 오히려 팀원들의 존경을 빠르게 잃어가고 자리 지키기에만 급급할 것이다.팀의 최종 목표를 명심하고 피드백을 수용하고 비판에 마음을 열자.실수했다면 인정하고 사과하자. 리더가 실수했다는 사실을 언젠간 팀원들이 반드시 알게 된다. 이를 사과할 줄 아는 리더를 팀원들은 존경한다. 마음 다스리기리더는 항상 무대 위에 있다고 생각하는 방법이 좋다. 리더는 주변 사람들이 리더의 일거수일투족을 항시 두 눈 똑바로 뜨고 쳐다보고 있다는 뜻이다. 리더의 몸짓, 사소한 이야기에 돌아오는 반응, 점심식사를 하며 보내는 미묘한 신호들로부터 단서들을 얻어간다. 아무리 사소한 것이라도 리더가 내비치는 거의 모든 것이 무의식적으로 알려지고 팀에 전염된다. 촉매자 되기리더는 합의를 이끌어 낼 줄 알아야 한다. 시작부터 끝까지 과정을 주도할 수 있고 올바른 방향으로 가속이 붙도록 조금만 관여할 수도 있다. 팀이 가야할 방향에 대한 합의를 이끌어내야 하는게 리더의 역할이고 이 과정에서 팀원들이 모두 합의할 수 있도록 촉매자가 되보자. 장애물 치우기리더는 해야할 일에 대한 합의를 이끌어냈지만, 장애물 때문에 진행이 안될 수 있다. 이런 장애물을 해결하는 것도 리더의 역할이다. 이때 리더가 모든 장애물을 직접 해결해야 한다는 의미는 아니다. 다만 해당 장애물을 해결할 줄 아는 사람을 알고 있는 게 바람직하다. 선생이자 멘토 되기내가 하면 더 빨리 될 일이더라도 팀원의 성장을 위해 그 일을 팀원에게 맡기는 일을 감수할 수 있어야 한다. 멘토는 팀의 프로세스와 체계에 대한 경험, 설명하는 능력, 멘티에게 도움이 얼마나 필요한지를 측정하는 능력이 필요하다. 명확한 목표 세우기목표를 명확히 세우고 팀이 제품을 한 방향으로 끌게 해야 한다. 가장 쉬운 방법은 팀이 이루어야 할 임무를 구체적인 문장으로 적어놓는 것이다. 목표를 정하고 나면 팀원들이 각자 책임을 가지고 리더는 잘 가고 있는지 주기적으로 확인하자. 정직하기리던느 팀원에게 모든 것을 알려줄 수 없는 상황에 있는 상황인 경우가 많다. 만약 그런 부분을 묻는다면 차마 말해줄 수 없다 라고 솔직하게 말하자. 그리고 모르는 사실은 모른다고 사실대로 말하자.팀원에게 곤란한 피드백을 줘야 하는 경우는 존중을 담아서 솔직하게 전달하자. 칭찬으로 피드백을 둘러 쌓아서 하지 않도록 하자. 행복한지 확인하기팀원들의 행복을 위해서 일대일 면담을 하거나 다음 업무를 수행하는 데 어려운 점은 없는 지 확인하는 방식을 선택할 수 있다. “더 필요한 것은 없나?”라고 물어보자. 파도를 일으켜야 할 타이밍을 알자문제가 생긴 상황을 지켜보기만 하지 말자. 너무 방치하지 않고 적절한 조치를 찾아 실행시켜라. 혼란으로부터 팀을 보호하자혼란과 불확실성으로 가득 찬 상황을 팀원들이 영향 받지 않도록 보호해야 한다. 다만 회사 위쪽에서 어떤 일이 일어나는 지 공유해주는 것도 중요하다. 다만 팀에 영양가가 없는 조직 차원의 광기로 팀 업무가 방해받지 않도록 하자. 내적 동기 일으키기금전적 보상과 같은 외적 동기와 안에서부터 샘솟는 내적 동기가 있다. 사람들을 행복하게 하는 것은 내적 동기이다. 내적 동기는 자율성, 숙련, 목적이 키워준다. 자율성 : 스스로 행동할 수 있는 것. 제품과의 관계가 더 끈끈해진다. 제품에 대한 주인 의식이 커진다. 숙련 : 기술 수준을 높이고 새로운 것을 배울 기회를 제공하는 것. 목적 : 팀원들의 노력에서 의미를 찾고 그 의미를 분명하게 인식시켜주는 형태로 동기를 부여하자. 성장하는 조직 이끌기하나의 팀이 아닌 여러 팀을 이끌기 위한 행동 지침을 알아보자. 늘 결정하라리더는 팀이 매주 무엇을 해야 하는지 결정해야 한다. 트레이드오프가 명확할 때가 있지만 때로는 시간이 한참 지나야 피해를 주는 예상치 못한 결과를 가져다오기도 한다.리더는 어렵고 명확한 해법이 보이지 않는 문제를 풀게 사람들을 이끄는 것이다. 어느 경우든 문제를 탐구하고 훑어보고 뜯어보면서 통제할 수 있는 상태로 만들어야 한다.이 과정은 세 단계로 나뉜다. 눈가리개를 찾아내고 트레이드오프를 파악한다 해법을 결정하고 반복해야 한다. 눈가리개 찾기항상 그래왔다는 문제에 대해 질문을 던지고, 현재 방식에 대해 문제가 있을 수 있는지 확인해본다. 핵심 트레이드오프 파악하기모든 트레이드오프를 테이블 위에 올려놓고 모두에게 설명한 다음 어떻게 균형을 맞출지를 결정하도록 도와야 한다. 결정하고 반복하기트레이드오프를 파악하고 특정 방법을 결정할 수 있다. 그러나 이 방법에 계속 유지하지 말고 상황이 변하면 트레이드오프를 다시 평가하고 새로운 방법을 결정하도록 하자. 이게 늘 결정한다라는 말의 의미이다.트레이드오프의 지속적인 재조정을 프로세스에 녹여야 한다. 지금 선택한 방법이 계속 유지되지 않을 수 있음을 공유하자. 늘 떠나라리더는 모호한 문제를 풀어줄 뿐만 아니라 맡은 조직이 리더 없이도 스스로 문제를 풀 수 있게 유도해야 한다. 리더가 SPOF가 되면 안된다.","categories":[],"tags":[{"name":"Software Engineering At Google","slug":"software-engineering-at-google","permalink":"https://yangdongjue5510.github.io/tags/software-engineering-at-google/"}],"keywords":[]},{"title":"코틀린의 클래스, 객체, 인터페이스","slug":"kotlinInAction/kotlinInActionCh4","date":"2023-01-10T14:52:43.000Z","updated":"2023-01-12T09:18:52.248Z","comments":true,"path":"2023/01/10/kotlinInAction/kotlinInActionCh4/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/10/kotlinInAction/kotlinInActionCh4/","excerpt":"","text":"요약코틀린 인터페이스open, final, abstact가시성 변경자중첩 클래스와 봉인된 클래스뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언데이터 클래스와 클래스 위임object 키워드 클래스 계층 정의코틀린 인터페이스코틀린의 인터페이스는 자바와 매우 유사하다. 상태를 가질 수 없지만 구현된 메서드(마치 디폴트 메서드)를 가질 수 있다. 인터페이스를 구현하는 쪽에서는 :을 통해 나타낸다. 코틀린에서는 클래스의 상속과 인터페이스의 구현 모두 :를 사용한다. 자바와 마찬가지로 코틀린에서 인터페이스는 무제한으로 구현할 수 있지만, 클래스는 하나만 가능하다. 자바의 @Override와 비슷한 override 변경자가 있다. 코틀린에서는 override 변경자를 반드시 적어줘야 한다. 12345678910interface Clickable &#123; fun click() fun methodImpl() = println(&quot;implemented Method in interface.&quot;)&#125;class Clicker :Clickable &#123; override fun click() = println(&quot;click!&quot;) &#125; 만약 여러 인터페이스를 구현할 때 각 인터페이스에서 구현된 메서드의 시그니처가 중복되는 경우위 예시에서 기존의 인터페이스에서 구현된 메서드와 같은 시그니처를 갖는 인터페이스를 만들고 이 또한 클래스에서 구현해보려고 한다면 문제가 생긴다. 12345678910interface Focusable &#123; fun focus() fun methodImpl() = println(&quot;implemented too!&quot;)&#125;class Clicker :Clickable, Focusable &#123; // 컴파일 에러가 생길 것이다! override fun click() = println(&quot;click!&quot;) override fun focus() = println(&quot;focus!&quot;)&#125; 이런 경우 구현하는 클래스에서 충돌되는 구현 메서드를 새롭게 오버라이딩해서 재정의 해줘야 한다.이때 상위 타입의 구현을 사용하려면 다음 코드블럭을 지켜보자. super&lt;상위타입&gt;.메서드() 이런 문법으로 상위 타입의 메서드를 호출할 수 있다. 12345678class Clicker : Clickable, Focusable &#123; override fun click() = println(&quot;click!&quot;) override fun focus() = println(&quot;focus!&quot;) override fun methodImpl() &#123; super&lt;Focusable&gt;.methodImpl() super&lt;Clickable&gt;.methodImpl() &#125;&#125; 사실 코틀린에서는 아직 자바의 디폴트 메서드를 지원하지 않는다.코틀린은 자바의 디폴트 메서드가 등장하기 전인 자바 6에 호환되도록 설계됐다. 그래서 자바 인터페이스에 디폴드 메서드가 있으면 코틀린에는 해당 메서드를 추상 메서드로 인터페이스에 해놓고 따로 클래스를 만들어서 디폴트 메서드의 구현을 정적 메서드로 놓는다. 이렇게 되면 자바 클래스가 디폴트 인터페이스가 포함된 코틀린 인터페이스를 구현하려고 하면 디폴트 메서드도 자바 클래스에서 구현해줘야 한다. 왜냐면 자바에서는 코틀린의 디폴트 메서드 구현(정적 메서드)를 의존하지 않기 때문이다. open, final, abstract 변경자: 기본적으로 finalopen, final자바에서는 final 선언되지 않은 클래스를 상속해서 사용할 수 있다.문제는 상속은 부모 클래스의 가정을 이해하지 않고 자식 클래스에서 가정을 깨는 구현을 했을 때, 부모 클래스가 약간의 변경이 생겨도 자식 클래스가 예상과 다르게 작동할 수 있다. (취약한 기반 클래스 문제)코틀린에서는 상속을 제한적으로 쓰고자 기본적으로 모두 final 선언되어 있는 셈이다. 만약 상속을 하고 싶으면 부모 클래스에 open 키워드를 붙여야 한다. 그와 더불어 자식 클래스에서 오버라이딩이 가능한 메서드나 프로퍼티에도 open을 붙여야 오버라이딩이 가능하다. 1234567open class RichButton: Clickable &#123; fun cannotOverride() &#123;&#125; open fun animate() &#123;&#125; override fun click() = print(&quot;rich click&quot;)&#125; override 된 메서드는 당연히 오버라이딩에 열려있다. 하지만 이런 메서드도 앞에 final을 붙이면 하위에서 오버라이딩을 막을 수 있다. 열린 클래스와 스마트 캐스트기본적으로 클래스를 final로 상속을 막으면 스마트 캐스트하기에 유리하다. 스마트 캐스트는 타입 검사 뒤 변경될 수 없는 변수에만 적용된다. 즉 val 이면서 커스텀 접근자가 있어서는 안된다. 여기에 더 나아가 프로퍼티가 final이어야 한다는 조건이 필요하다. 왜냐면 다른 클래스가 상속해서 커스텀 접근자를 정의할 수 있음을 막아야 하기 때문이다. abstractabstract는 자바와 거의 비슷하다. 추상 메서드나 추상 클래스를 정의할 때 사용된다. 가시성 변경자: 기본적으로 공개가시성 변경자는 클래스 외부 접근을 제어한다. 자바와 다르게 코틀린은 아무 가시성 변경자를 안 적으면 public으로 취급한다.코틀린에는 자바처럼 패키지 전용이 없다. 코틀린에서 패키지는 네임 스페이스를 관리하기 위함이지 가시성을 제어하기 위함이 아니다. internal: 패키지 전용 가시성을 대체패키지 전용 가시성를 대신하는 internal이 있다. internal은 모듈 내부에서만 볼 수 있는 변경자이다. 모듈은 같이 컴파일 되는 단위를 말한다. 패키지 기준은 다른 프로젝트더라도 같은 패키지에 클래스를 선언해서 접근 할 수 있게 되는 단점이 있다. 그 외 차이점private는 내부에서만 접근 가능한 변경자인데 코틀린은 최상위 선언(클래스, 프로퍼티, 함수)에도 사용할 수 있다.protected는 코틀린에서 패키지 전용 가시성이 아닌 하위 클래스 가시성을 제공할 때 쓰인다. 다만 최상위 선언에는 사용할 수 없다. 의존하려면 더 엄한 가시성을 가져야 한다.다음 예제를 보자 123456789internal open class TalkativeButton &#123; private fun hello() = &#123;&#125; protected fun bye() = &#123;&#125;&#125;fun TalkativeButton.doSomething() &#123; // public한 확장함수는 internal 클래스에 사용할 수 없다. hello() // public한 확장함수는 private 메서드에 접근할 수 없다. bye() // public한 확장함수는 protected 메서드에 접근할 수 없다.&#125; 위와 같이 다른 클래스에 의존해서 사용하려는 경우 해당 함수나 클래스의 가시성이 사용하려는 클래스의 가시성과 같거나 더 엄해야 한다. 위 경우는 확장함수의 가시성을 internal로 바꾸거나 수신 객체 타입의 가시성을 public으로 올리는 방법이 있다.그리고 private나 protected 조건을 만족하지 않으므로 확장 함수의 메서드 호출이 안된다. 코틀린 가시성 변경자와 자바코틀린의 public, protected, private 변경자는 자바 바이트 코드에도 그대로 들어간다. 다만 private 클래스는 다르게 처리된다. 자바에서는 private 클래스가 안되기 때문인데, 이 경우 코틀린에서 private 클래스를 protected 클래스로 변환해서 컴파일한다.코틀린의 internal은 자바에서 public이 된다. 모듈의 특성 상 어쩔 수 없는 부분이다.이렇게 더 열리게 되면 의도하지 않은 접근이 가능해지는데 코틀린 컴파일러가 internal 멤버 이름을 보기 나쁘게 바꾼다. 이는 예상치 못한 상속에서 생기는 우연한 오버라이딩을 피하고 internal 클래스를 외부에서 사용하지 않도록 하기 위함이다. 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근을 할 수 없다. 자바에서는 클래슨 내부에서 클래스를 선언하면 묵시적으로 내부 클래스가 된다. 즉 외부 클래스에 대한 참조를 묵시적으로 포함한다. 자바에서 이런 보이지 않는 참조를 제거하려면 중첩된 클래스에 static을 붙여주면 된다. 코틀린은 반대다. 기본적으로 외부 클래스에 대한 참조가 끊긴 중첩 클래스로 취급하고 만약 내부 클래스로 만들려면 안쪽 클래스에 inner 변경자를 붙여야 한다. 만약 내부 클래스에서 외부 클래스 참조를 접근하려면 this@외부클래스이름 으로 하면 된다. 12345class Outer &#123; inner class Inner &#123; fun getOuterReference() : Outer = this@Outer &#125;&#125; 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한sealed 변경자를 통해 자신의 상속해줄 수 있는 자식 클래스를 제한 할 수 있다. 이때 적용되는 클래스는 코틀린 1.0에는 부모의 중첩 클래스로만 해야하고, 1.1에는 같은 파일 안에 있기만 하면 된다. 1234sealed class Expr &#123; class Num : Expr() class Sum : Expr()&#125; 이렇게 정해놓으면 유리한 점이 분기 처리할 때가 유리하다. 자식이 무한하게 허용되면 when 식으로 처리할 때 else로 그 외 처리를 해줘야 한다. 그리고 자식이 생길 때 분기로 처리하기를 놓칠 수 있다. 123456fun eval(e: Expr): Int = when (e) &#123; is Num -&gt; 1 is Sum -&gt; 2 else -&gt; throw Exception() &#125; 하지만 sealed 되어 있으면 자식이 한정적이라 정해진 자식들만 체크하면 된다. 만약 놓친 자식이 있으면 컴파일 에러가 나서 미리 알 수 있다. 12345fun eval(e: Expr) : Int = when (e) &#123; is Expr.Num -&gt; 1 is Expr.Sum -&gt; 2 &#125; 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언코틀린은 주 생성자와 부 생성자가 있다. 주 생성자는 클래스를 초기화할 때 쓰이고 클래스 본문 밖에서 정의된다. 부 생성자는 클래스 본문 안에서 사용되는 생성자이다.또한 코틀린에서는 초기화 블록을 지원해서 초기화 로직을 모을 수 있다. 클래스 초기화: 주 생성자와 초기화 블록코틀린에서 주 생성자는 다음과 같이 쓰인다. 1class User(val nickName: String) 클래스 이름뒤에 괄호로 둘러 쌓인 내용을 주 생성자라고 한다. 이를 최대한 명시적으로 풀어쓰면 다음과 같다. 1234567class User constructor(_nickName: String) &#123; val nickName: String init &#123; nickName = _nickName &#125;&#125; 여전히 주 생성자는 존재하는데 이때 constructor는 생성자의 정의를 시작함을 의미한다.그리고 init은 클래스의 객체가 만들어질 때 실행되는 초기화 로직을 모은 초기화 블록을 선언한다. 초기화 블록은 별도의 코드를 포함할 수 없는 주 생성자와 함께 많이 쓰인다.그리고 생성자 파라미터 앞 _는 프로퍼티와 파라미터를 구분하기 위해서 적었는데 기존 자바의 this.nickName = nickName 이렇게 해도 된다. 위 예시를 좀 더 개선하면, 일단 주 생성자 앞에 별도의 어노테이션이나 가시성 변경자가 없다면 constructor를 생략해도 된다. 그리고 프로퍼티 초기화는 굳이 초기화 블록에서 할 필요가 없고 프로퍼티 선언에서 해도 된다. 123class User (_nickName: String) &#123; val nickName = _nickName&#125; 하지만 위 예시도 굳이 val 파리미터를 본문에서 하지말고 주 생성자 안에서 해버리면 간단하다. 1class User(val nickName: String) 참고로 주 생성자에서 디폴트 값과 이름 있는 선언도 가능하다. 1234class User(val nickName: String = &quot;untitled&quot;)User().nickName // untitledUser(nickName = &quot;Klay&quot;) // Klay 모든 파라미터에 디폴트값이 있으면 자동으로 파라미터가 없는 생성자를 만들어준다.DI 프레임워크 중 기본 생성자가 반드시 필요한 경우에 이런 기능이 유리하다고 한다. 만약 기반 클래스가 있다면 다음과 같이 기반 클래스에 파라미터를 넘겨줄 수 있다. 1class GoodUser(val nickName: String) : User(nickname) 참고로 만약 기반 클래스가 기본 생성자만 있다하더라도 하위 클래스는 생성자 (괄호) 를 적어줘야 한다. 123open class Bookclass GoodBook : Book() 인터페이스는 생성자가 없으니 하위 클래스가 구현할 때 괄호를 써주지 않는다. 마지막으로 private 한 생성자를 만드는 방법이다.이는 동반 객체에 유용하다고 한다. (반면 유틸 클래스나 싱글턴에는 이렇게 하지 않느다. 확장 함수나 객체 선언하는 방식을 한다.) 1class CannotConstructUser private constructor() 부 생성자일반 적으로 코틀린에서는 디폴트 값을 지원해서 여러 생성자를 만들 일이 없다.그래도 여러 생성자가 필요한 경우가 있다면 부 생성자를 이용한다.super를 통해 기반 클래스의 생성자에 인자 전달도 되고, this를 통해 자신의 다른 생성자에게 생성을 위임할 수 있다. 123456789open class View &#123; constructor(i: Int) &#123;&#125; constructor(s: String) &#123;&#125;&#125;class GoodView : View &#123; constructor(i:Int) : this(i.toString()) &#123;&#125; constructor(s: String) : super(s) &#123;&#125;&#125; 인터페이스에 선언된 프로퍼티 구현추상 프로퍼티코틀린에서는 인터페이스에 추상 프로퍼티를 선언할 수 있다. 123interface User &#123; val nickName: String&#125; 이는 해당 인터페이스를 구현하는 쪽은 nickName을 접근할 수 있는 방법을 제공해야 함을 의미한다. 인터페이스가 실제 상태를 가지는 것은 아니다. 추상 프로퍼티를 구현하는 세가지 예시를 보자 1. 주 생성자로 프로퍼티 구현 1class PrivateUser(override val nickName: String) : User5 간단하다 override만 붙여주면 된다. 2. 커스텀 게터 1234class EmailUser(val email: String) : User5 &#123; override val nickName: String get() = email.substringBefore(&#x27;@&#x27;)&#125; 역시 override가 붙은 프로퍼티에 커스텀 게터를 구현하면 된다. 다만 커스텀 게터는 호출때마다 구현된 내용이 실행된다. 3. 프로퍼티 초기화 식 12345class FacebookUser(val id: Int) : User5 &#123; override val nickName = getFacebookName(id)&#125;fun getFacebookName(id: Int) = id.toString() 프로퍼티 초기화 식은 프로퍼티에 접근할 때마다 구현된 내요을 실행하지 않는다. 초기화 할 때 한번만 한다. 이 점이 2번과 가장 큰 차이다. 만약 getFacebookName이 비용이 큰 메서드라고 상상해보면 프로퍼티에 접근할 때마다 호출되는 커스텀 게터 방식이 많이 불리햇을 것이다. 마지막으로 인터페이스에는 커스텀 게터와 세터가 있는 프로퍼티를 추가할 수 있다. 물론 실제 값이 있는 건 아니니까 참조할 수 없다. 12345interface User &#123; val nickName: String val email: String get() = email.substringBefore(&#x27;@&#x27;)&#125; 게터와 세터에서 뒷받침하는 필드에 접근프로퍼티에 저장된 값을 변경할 때 특정 문자열을 출력하려고 한다고 해보자. 1234567class User(val name: String) &#123; var address = &quot;undefined&quot; set(_address) &#123; println(&quot;$field -&gt; $_address&quot;) field = _address &#125;&#125; 흠 세터를 직접 구현해줬다. 그런데 field는 무엇인가? field는 현재 접근자에 해당하는 필드에 접근할 수 있게 한다. field를 사용하지 않는 커스텀 접근자는 뒷받침 하는 필드가 생기지 않는다. 접근자의 가시성 변경접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 get이나 set앞에 접근자를 선언해서 가시성을 변경할 수 있다. 1234class User8 &#123; var name: String = &quot;hi&quot; private set&#125; 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임모든 클래스가 정의해야 하는 메서드모든 코틀린 클래스는 toString, equals, hashCode 등을 오버라이딩해야 한다.코틀린은 이런 메서드 구현을 자동으로 생성해줄 수 있다. 1class Client(val name: String, val postalCode: Int) 다음과 같은 클래스를 예시로 오버라이딩 해보자. toString()12class Client(val name: String, val postalCode: Int) &#123; override fun toString() = &quot;client&quot; equals()참고로 코틀린은 == 연산자가 내부적으로 equals메서드를 호출해서 객체를 비교한다. 참조 비교를 위해서는 === 연산자를 호출해서 사용할 수 있다. 1234567class Client(val name: String, val postalCode: Int) &#123; override fun equals(other: Any?): Boolean &#123; if (other == null || other !is Client) return false; return name == other.name &amp;&amp; postalCode == other.postalCode &#125;&#125; hashCode자바에서 equals를 재정의할 때는 반드시 hashCode도 재정의해야 한다. JVM 언어에서는 equals가 true를 반환하는 두 객체를 반드시 같은 hashCode를 반환해야 한다. Hash를 활용하는 자료구조에서는 원소 비교 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 같은 경우에만 실제 값을 비교한다. 1234class Client(val name: String, val postalCode: Int) &#123; //... override fun hashCode() : Int = name.hashCode() * 31 + postalCode&#125; 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성코틀린은 이런 메서드를 컴파일러가 생성해준다.data 변경자를 붙여주기만 하면 된다. data 변경자가 붙은 클래스를 데이터 클래스라고 부른다. 1data class Client(val name: String, val postalCode: Int) 이때 주의할 점은 equals와 hashCode는 주 생성자에서 선언된 모든 프로퍼티를 기준으로 만들어진다. 주 생성자 외부에서 선언된 프로퍼티는 고려되지 않는다. 데이터 클래스는 equals, hashCode, toString 외에도 유용한 메서드 몇 개를 더 만들어준다. 불변한 데이터 클래스를 쉽게 복사: copy데이터 클래스를 쉽게 복제하는 메서드를 제공해준다. 밑은 copy 메서드를 이해를 돕기위해 직접 구현한 예시이다. 123456789class Client(val name: String, val postalCode: Int) &#123; fun copy(name: String = this.name, postalCode = this.postalCode) &#123; return Client(name, postalCode) &#125;&#125;// 사용법val client = Client(&quot;Klay&quot;, 1)val copiedClient = client.copy(&quot;Curry&quot;) 클래스 위임: by 키워드 사용어떤 클래스에 기능을 추가해야 할 때 데코레이터 패턴을 사용한다고 해보자. 데코레이터 패턴은 기존 클래스의 인터페이스를 데코레이터가 제공하되 데코레이터 내부에 기존 클래스 인스턴스를 필드로 갖고 메서드 호출시 기존 클래스에게 메시지를 전달하는 것이다. 그리고 데코레이터에 추가하고자 하는 메서드를 구현하면 된다. 이때 새로운 기능에 기존 클래스의 메서드를 활용할 수 있다. 하지만 이런 방법은 지나치게 준비 코드가 많다. 코틀린에서는 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에게 위임 중이라는 사실을 명시할 수 있다. 예를 들어 ArrayList를 감싸는 클래스를 만들어보자. Collection의 인터페이스를 내부 리스트에게 위임하도록 구현해야 했다. 123456789class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt; &#123; private val innerList = arrayListOf&lt;T&gt;() override val size: Int get() = innerList.size override fun containsAll(elements: Collection&lt;T&gt;) = innerList.containsAll(elements) override fun contains(element: T) = innerList.contains(element) override fun isEmpty() = innerList.isEmpty() override fun iterator(): Iterator&lt;T&gt; = innerList.iterator()&#125; 하지만 코틀린의 by를 써보자. Set에서 추가된 원소를 카운팅하는 기능을 추가해보자.구현한 인터페이스 뒤에 by와 함께 프로퍼티 이름을 적어준 것을 확인할 수 있다. 이러면 위임 메서드를 컴파일러가 알아서 만들어준다. 다만 여기서 자동으로 만들어진 메서드 대신 개발자가 직접 구현하고 싶으면 override 붙여서 구현해주면 된다. 12345678910111213141516class CountingSet&lt;T&gt; ( val innerSet :MutableCollection&lt;T&gt; = HashSet()) : MutableCollection&lt;T&gt; by innerSet &#123; var addCount = 0 override fun add(element: T): Boolean &#123; addCount++ return innerSet.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; addCount += elements.size return innerSet.addAll(elements) &#125;&#125; object 키워드: 클래스 선언과 인스턴스 생성코틀린에서 object 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다. 다양한 상황에 대해서 알아보자. 객체 선언: 싱글턴을 쉽게 만들기코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다. 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다. 모든 직원의 급여 대장을 관리하는 객체가 필요하다고 해보자. 이 객체가 굳이 여러개일 필요는 없으니 객체 선언으로 싱글턴 객체로 만들어보자. 12345object Payroll &#123; val allEmployees = arrayListOf&lt;Person&gt;() fun doSomething() &#123;&#125;&#125; 객체 선언은 object 키워드를 사용하면 된다.객체 선언은 그 클래스를 정의하고 해당 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.하지만 생성자는 객체 선언에 사용할 수 없다. 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문이다. 객체 선언도 클래스나 인스턴스를 상속받을 수 있다. 예를 들어 특정 클래스를 위해 Comparator를 구현한 객체는 여러 개가 필요없다. 1234object FileComparator : Comparator&lt;File&gt; &#123; override fun compare(o1: File, o2: File) = o1.path.compareTo(o2.path, ignoreCase = true)&#125; 싱글톤과 의존관계 주입싱글턴 패턴과 마찬가지로 객체 선언은 대규모 시스템에서 안좋은 경우가 있다.객체 생성을 제어할 수 없고 파라미터를 지정할 수 없기 때문이다.그래서 단위 테스트하거나 시스템 설정이 바뀔 때 의존 객체를 바꿔줄 수 없다. 만약 이런 기능이 필요하다면 의존 관계 주입 프레임워크를 사용해보자. 클래스 안에 객체 선언클래스 안에 객체 선언을 해도 그 객체는 싱글톤이다. 외부 클래스가 인스턴스화 된다고 객체 선언이 여러번 객체로 만들어지는게 아니다! 123456789101112data class OuterClass(val name: String) &#123; object InnerObject &#123; fun hello() &#123; println(&quot;hello&quot;) &#125; &#125;&#125;fun main() &#123; OuterClass.InnerObject.hello()&#125; 자바에서 코틀린 객체 선언된 객체를 접근하기코틀린 객체 선언은 자바에서 정적 필드를 가진 클래스로 컴파일된다. 이때 정적 필드 이름은 항상 INSTANCE다.OuterClass.InnerObject.INSTANCE.hello() 동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소코틀린 클래스 안에는 정적인 멤버가 없다. 코틀린은 static 키워드를 지원하지 않는다. 대신 최상위 함수와 객체 선언을 사용한다. 일반적으로 최상위 함수를 추천하지만 특정 클래스 내부의 private 프로퍼티나 메서드에 접근하지 못하는 경우는 해당 클래스 안에서 객체 선언을 통해 접근하기도 한다. 123456789101112data class NamedPerson(private val name: String) &#123; object InnerObject &#123; fun hello(namedPerson: NamedPerson) &#123; println(&quot;hello $&#123;namedPerson.name&#125;&quot;) &#125; &#125;&#125;fun hello(namedPerson: NamedPerson) &#123; println(&quot;hello $&#123;namedPerson.name&#125;&quot;) // 접근하지 못한다.&#125; 이를 companion 키워드를 통해 중첩된 객체 선언에서 클래스 이름을 제거할 수 있다.(물론 이름을 붙여줄 수도 있다.) 마치 자바의 정적 멤버 처럼 활용할 수 있게 된다. 1234567891011data class NamedPerson2(private val name: String) &#123; companion object &#123; fun hello(namedPerson: NamedPerson2) &#123; println(&quot;hello $&#123;namedPerson.name&#125;&quot;) &#125; &#125;&#125;fun main() &#123; NamedPerson2.hello(NamedPerson2(&quot;Klay&quot;))&#125; 동반 객체를 통해 private 생성자 호출: 팩토리 메서드동반 객체는 외부 클래스의 private 프로퍼티, 메서드, 생성자에 접근할 수 있다. 그래서 팩토리 패턴을 사용하기 좋은 조건을 가졌다. 12345678class Man private constructor(val name: String) &#123; companion object &#123; fun create(name: String) = Man(name) &#125;&#125;fun main() &#123; Man.create(&quot;Klay&quot;)&#125; 팩터리 패턴이냐 여러 부 생성자냐상황에 따라 여라가지 부 생성자로 객체를 만들어주도록 할 수 있다. 이를 동반 객체를 통한 팩토리 패턴을 활용해서 이름 있는 메서드로 가독성을 높일 수 있는데, 문제는 클래스를 확장해야 할 경우 동반 객체 멤버를 오버라이딩 할 수 없으므로 여러 생성자를 사용하는 편이 낫다. 동반 객체를 일반 객체처럼 사용1234567891011interface Creatable&lt;T&gt; &#123; fun of(name: String) : T&#125;class Boy(val name: String) &#123; companion object : Creatable&lt;Boy&gt; &#123; override fun of(name: String) = Boy(name) &#125;&#125;fun &lt;T&gt; createSomething(name:String, creatable: Creatable&lt;T&gt;) = creatable.of(name) 동반 객체도 인터페이스를 구현할 수 있으며, 만들어진 동반 객체가 매개변수로 사용됐음을 주목하라. 이때 동반 객체의 이름이 없어서 Boy로 인자를 전달해줬음을 주목하자. 자바에서 코틀린 동반 객체자바에서 코틀린 동반 객체는 이름이 있으면 해당 이름으로 정적 멤버 접근하면 되고 이름이 없는 경우는 Companion이라는 이름의 정적 멤버로 접근하면 된다. 동반 객체 확장이름 없는 동반 객체를 만들어서 비즈니스 객체에서 보고 싶지 않은 코드를 분리할 수 있다. 예를 들어 JSON으로부터 역직렬화 함수를 만들어서 제공하고 싶은데 이를 비즈니스 클래스 내부에 위치하고 싶지 않을 때 사용해보자. 123456789// 비즈니스 모듈class Human(val id: Int) &#123; companion object&#125;// 클라이언트 서버 통신 모듈fun Human.Companion.fromJson(jsonValue: String) : Human &#123; return Human(jsonValue.toInt())&#125; 객체 식: 무명 내부 클래스를 다른 방식으로 작성무명 객체를 정의할 때도 object 키워드를 사용한다. 무명 객체는 자바의 무명 내부 클래스를 대신한다.이때 중요한 점은 무명 객체로 object 키워드를 사용하면 싱글톤이 아님을 명심하자. 무명 객체와 동반 객체나 객체 선언과 다르다. 123456789var listener = object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent?) &#123; // logic... &#125; override fun mousePressed(e: MouseEvent?) &#123; // logic... &#125;&#125; 그리고 무명 객체(객체 식)은 그 식이 포함된 함수의 변수에 접근할 수 있다. 123456789fun foo(window: Window) &#123; var clickAmount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent?) &#123; clickAmount++ &#125; &#125;)&#125;","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"코틀린 함수 정의와 호출","slug":"kotlinInAction/kotlinInActionCh3","date":"2023-01-09T07:52:10.000Z","updated":"2023-01-10T14:57:30.749Z","comments":true,"path":"2023/01/09/kotlinInAction/kotlinInActionCh3/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/09/kotlinInAction/kotlinInActionCh3/","excerpt":"","text":"이번 포스트에서는 코틀린의 컬렉션, 문자열, 정규식 영역에서 함수 정의와 호출을 알아보자. 요약함수를 사용하기 쉽게 만들기확장 함수확장 프로퍼티가변인자, 중위 호출로컬 함수 코틀린에서 컬렉션 만들기코틀린에서는 &#123;컬렉션 종류&#125;Of(~) 이런 형태로 쉽게 컬렉션을 만들 수 있다. 123val set = hashSetOf(1, 2, 3)val list = arrayListOf(1, 2, 3)val map = hashMapOf(1 to &quot;hi&quot;, 2 to &quot;ho&quot;) 코틀린은 자기만의 컬렉션 객체를 가지지 않고 자바의 컬렉션 프레임워크를 사용한다. 자바에서 사용하던 컬렉션을 코틀린에서도 그대로 사용하므로 특별한 변환 작업이 필요없다. 함수를 호출하기 쉽게 만들기자바에서 toString 메서드를 커스텀하게 구현해본 경험이 있을 것이다. 코틀린에서는 이를 어떻게 쉽게 해결하는 지 체험해보자! 우리는 리스트의 원소들을 다양한 구분자와 접두사, 접미사를 추가해서 문자열을 만드는 함수를 만들어 볼 것이다! 무식하게 구현하기1234567891011121314fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String) : String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element); &#125; result.append(postfix) return result.toString()&#125; 제네릭을 활용해서 확장성이 좋은 함수를 만들었다. 만든 함수를 사용하는 코드도 살펴보자. 12val list = listOf(1, 2, 3)println(joinToString(list, &quot;:&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;)) 흠.. 호출하는 쪽은 조금 난잡하다. 함수를 호출할 때 인자 4개를 모두 전달하지 않는 방법은 없을까?? 이름 붙인 인자코틀린에서는 함수를 호출할 때 매개변수의 이름을 통해 인자를 전달해줄 수 있다. 1println(joinToString(prefix = &quot;&#123;&quot;, collection = list, separator = &quot;:&quot;, postfix = &quot;&#125;&quot;)) 이름을 붙인 인자를 활용할 때는 이름이 붙은 첫 인자 뒤로 모든 인자들에게 이름을 붙여줘야 한다. 왜냐면 이름을 명시하면 순서가 의미가 없어지기 때문에 이름을 붙여주지 않으면 혼동이 올 수 있다.함수 호출하는 코드에서 인자들의 역할이 명확해졌다. 하지만 여전히 난잡한 느낌을 지울 수 없다. 디폴트 파라미터 값12345678910fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;:&quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;) : String &#123; // 생략...&#125;println(joinToString(prefix = &quot;&#123;&quot;, collection = list, postfix= &quot;&#125;&quot;)); 이렇게 매개변수 선언부에 디폴트값을 할당해서 적어줄 수 있다. 이렇게 디폴트값을 활용하면 비효율적인 생상자 오버로딩을 대폭 줄일 수 있다. 자바 메서드를 코틀린에서 디폴트 값 적용해서 사용하기매개변수의 디폴트값을 지원하지 않는 자바 메서드를 코틀린에서 디폴트 값으로 활용하기 까다롭다는게 문제다. 이를 위해서 자바 메서드에 @JvmOverloads 어노테이션을 붙이면 맨 뒤 매개변수부터 하나씩 빼서 오버로딩된 메서드가 만들어진다. 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티최상위 함수자바의 경우 모든 메서드는 클래스 안에 있어야 했다. 그래서 우리가 원하는 건 작동하는 함수 하나여도 클래스를 선언해서 해당 메서드를 포함해야 했다. 하지만 코틀린은 그럴 필요가 없다.코틀린은 함수를 최상위 수준으로 위치할 수 있다. 다음과 같이 특정 패키지 바로 다음에 함수가 올 수 있다. 12345678910package stringfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;:&quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;) : String &#123; // 생략...&#125; 이런 최상위 함수는 컴파일 될 때 새로운 클래스를 정의해서 컴파일한다. 코틀린만 사용하면 그냥 특정 클래스가 생기나보다 하고 넘기면 되지만, 자바에서 코틀린의 최상위 함수를 호출해야 할 경우에는 코틀린의 최상위 함수를 위한 클래스가 어떤 모양인지 알아야 한다. 최상위 함수를 위한 클래스는 최상위 함수를 포함하는 파일 이름에 따라 달라진다. 예를 들어 join.kt파일에 joinToString메서드를 구현한 경우에는 다음과 같이 자바 클래스가 만들어진다. 12345678public class JoinKt &#123; public static void &lt;T&gt; joinToString(...) &#123; ... 생략 &#125;&#125;// 사용JoinKt.joinToString(...); 최상위 함수를 위한 클래스 명 바꾸기@file:JvmName(&quot;ClassName&quot;)을 패키지 선언문 위에 적으면 클래스 이름도 바꿀 수 있다. 최상위 프로퍼티프로퍼티도 최상위에 둘 수 있다. 연산 수행 횟수를 재는 프로퍼티 같은 경우 사용할 수 있다. 12val count = 0fun blahBlah() &#123;...&#125; 이런 경우 프로퍼티는 정적 필드에 저장된다. 이때 특이한 점은 최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 제공하는데 만약 최상위 프로퍼티를 상수처럼 보이는 데 실제로는 접근자 메서드를 통해 접근하는 것이 어색할 수 있다. 그렇다면 const 키워드를 사용해서 public static final 필드로 컴파일 되게 할 수 있다. 12345// kotlinconst val count = 0// javapublic static final count = 0; 메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티확장 함수확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다. 확장 함수는 기존 자바 API에 코틀린의 추가 기능을 쉽게 제공할 수 있도록 돕기 위해 등장했다. 확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장하려는 클래스 이름을 덧붙이면 된다. 1234fun String.lastChar(): Char = this[this.length - 1]// 사용하는 코드println(&quot;hello&quot;.lastChar()) // o 위 예시는 String 클래스에 마지막 문자를 찾아 반환하는 확장 함수를 추가했다.확장 함수에서 붙여진 클래스 이름을 수신 객체 타입(receiver type) 이라고 부르며 확장 함수가 호출되는 대상이 되는 값을 수신 객체(receiver object)라고 부른다.fun String.lastChar(): Char = this.get(this.length - 1)위 확장 함수에서는 String이 수신 객체 타입이고, this가 수신 객체가 된다.확장 함수는 자바 클래스로 컴파일한 클래스 파일이 있는 한 원하는대로 확장할 수 있다. 그리고 멤버 메서드와 확장 함수를 통틀어 메서드라고 부르겠다. 하지만 멤버 메서드와 가장 큰 차이점은 private나 protected 멤버는 확장 함수가 접근할 수 없다.그리고 확장 함수를 사용할 때는 임포트를 해야 한다. (다른 함수와 동일한 이름을 가져서 충돌할 수 있으므로.) 12import &#123;패키지&#125;.&#123;확장함수 명&#125;import &#123;패키지&#125;.&#123;확장함수 명&#125; as &#123;다른 이름&#125; 자바에서 확장 함수 활용하기확장 함수는 내부적으로 수신 객체를 첫 매개변수로 가지는 정적 메서드다. 위 예시에서 자바는 다음과 같이 작성하면 된다. 1char c = StringUtilKt.lastChar(&quot;hello&quot;); 이제 joinToString 메서드를 확장 함수로 리팩토링 해보자. 12345678910111213141516fun &lt;T&gt; Collection&lt;T&gt;.joinToString( separator: String = &quot;:&quot;, prefix: String = &quot;&quot;, postfix: String = &quot;&quot;) : String &#123; val result = StringBuilder(prefix) for ((index, element) in withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element); &#125; result.append(postfix) return result.toString()&#125;// 호출 코드println(list.joinToString2(prefix = &quot;&#123;&quot;, postfix = &quot;&#125;&quot;)) 확장 함수를 더 엄격하게 사용확장 함수 수신 타입 객체를 더 엄격한 타입을 사용하면 확장 함수를 사용하는 수신 객체를 제한할 수 있다.fun &lt;T&gt; Collection&lt;String&gt;.joinToString(...) &#123;...&#125;이런 식으로 구현하면 문자열 리스트만 확장 함수를 사용할 수 있게 된다. 확장 함수는 오버라이드 할 수 없다.오버라이드는 변수에 저장된 객체의 동적인 타입에 따라 호출할 메서드가 달라지는 기능이다.왜 확장 함수는 오버라이드 할 수 없을까? 확장 함수는 정적으로 선언된 메서드이기 때문이다. 확장 함수는 인스턴스 메서드가 아닌 인스턴스를 매개변수로 받는 정적 메서드이므로 오버라이딩이 불가능하다. 멤버 함수와 확장 함수의 시그니처가 같으면 멤버 함수가 우선한다. 확장 프로퍼티확장 프로퍼티를 사용하면 기존 클래스 객체에 프로퍼티 형식의 구문을 사용할 수 있는 API를 추가할 수 있다. 이때 중요한 점은 확장 프로퍼티는 아무 상태도 가질 수 없다. 기존 클래스의 인스턴스 객체에 필드를 추가할 방법이 없기 때문이다. 하지만 프로퍼티 문법으로 더 짧게 코드를 작성할 수 있다.확장 프로퍼티는 마치 프로퍼티 접근 방식과 유사하게 API를 제공하는 것이지 실제로 필드를 가져서 접근자 메서드를 제공하는 것이 아님을 명심하자. 123456789var StringBuilder.lastChar: Char get() = get(length - 1) set(value) &#123; this.setCharAt(length - 1, value) &#125;val sb = StringBuilder(&quot;Kotlin?&quot;)sb.lastChar2 = &#x27;!&#x27;println(sb) 만약 자바에서 사용하려면 다음과 같을 것이다. 1Char lastChar = StringUtilKt.getLastChar(); 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의자바에서는 ...으로 가변 인자를 표현할 수 있었다. 코틀린에서는 vararg 변경자를 앞에 붙여주면 된다.대표적인 가변 인자 함수인 listOf 함수의 경우를 살펴보자. 123var list = listOf(1, 2, 3)fun listOf&lt;T&gt;(varargs values: T): List&lt;T&gt; &#123; ... &#125; 코틀린은 자바처럼 배열을 바로 가변 인자로 넘겨줄 수 없다. 배열의 원소를 풀어서 각 원소가 인자로 전달되게 해야한다.이 역할을 스프레드 연산자 *가 한다. 스프레드 연산자를 활용하면 배열과 함께 다른 인자들도 같이 전달해줄 수 있다. 1234fun main(args: Array&lt;String&gt;) &#123; val list = listOf(&quot;args &quot;, *args) println(list)&#125; 값의 쌍 다루기: 중위 호출과 구조 분해 선언대표적인 중위 호출인 map에서 to 메서드 호출을 살펴보자. 1val map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;) 중위 호출은 수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣는다. 다음 두 호출은 동일하다! 121.to(&quot;one&quot;)1 to &quot;one&quot; 중위 호출은 수신 객체의 메서드 중 매개변수가 하나뿐인 경우에 사용할 수 있다. 실제 to 메서드의 구현을 살펴보자. 1public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 일단 infix 키워드를 통해 중위 호출을 사용할 수 있도록 했다. 제네릭을 활용해서 A 수신 객체 타입에 확장 함수로 구현했다. 구조 분해 선언to 메서드는 Pair 인스턴스를 반환하는데 Pair 인스턴스로 두 변수를 즉시 초기화 할 수 있다. 1val (number, name) = 1 to &quot;one&quot; 이렇게 number 와 name 두 변수를 Pair를 구조 분해해서 할당했다. 이런 구조 분해 선언은 루프에서도 사용할 수 있다. 1for ((index, element) in collection.withIndex()) &#123; ... &#125; 문자열과 정규식 다루기코틀린 문자열은 자바 문자열과 같다. 다만 코틀린은 확장 함수로 더 다양한 기능을 제공한다. 문자열 나누기코틀린의 split은 정규식으로 나눠야 하는 경우 Regex 객체를 요구한다. 이로써 개발자가 혼동하는 일이 없도록 한다.또한 여러 구분 문자열을 지정할 수 있도록 지원한다. 123val line = &quot;12.345-6.A&quot;println(line.split(&quot;\\\\.|-&quot;.toRegex()))println(line.split(&quot;.&quot;, &quot;-&quot;)) 코드 다듬기: 로컬 함수와 확장코드 중복을 줄이기 위해서 메서드 추출을 통해 작은 메서드로 분리하기 시작하면 메서드가 너무 많아져서 코드가 파악하기 어려워진다.코틀린은 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 먼저 중복되는 예시를 보자. 1234567891011class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) &#123; if (user.name.isEmpty()) &#123; throw IllegalArgumentException(&quot;$&#123;user.id&#125; empty name&quot; ) &#125; if (user.address.isEmpty()) &#123; throw IllegalArgumentException(&quot;$&#123;user.id&#125; empty email&quot; ) &#125;&#125; 보면 비슷한 검증로직이 존재한다. 이를 로컬 함수로 개선해보자. 12345678910fun saveUser(user: User) &#123; fun validate(user: User, value: String, fieldName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException(&quot;$&#123;user.id&#125; empty $fieldName&quot;) &#125; &#125; validate(user, user.name, &quot;Name&quot;) validate(user, user.address, &quot;Address&quot;) // save logic...&#125; 함수 안에 함수를 만들어서 중복 코드를 줄였다. 하지만 User 객체를 로컬 함수에게 일일히 전달하는게 아쉽다.사실 그러지 않아도 된다. 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다. 12345678910fun saveUser(user: User) &#123; fun validate(value: String, fieldName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException(&quot;$&#123;user.id&#125; empty $fieldName&quot;) &#125; &#125; validate(user.name, &quot;Name&quot;) validate(user.address, &quot;Address&quot;) // save logic...&#125; 아재 곰중 로직을 확장 함수로 추출해보자. 이렇게 하면 외부에서 사용되지 않는 로직은 도메인 클래스에서 제거할 수 있다. 1234567891011121314fun User.validateBeforeSave() &#123; fun validate(value: String, fieldName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException(&quot;$id empty $fieldName&quot;) &#125; &#125; validate(name, &quot;Name&quot;) validate(address, &quot;Address&quot;)&#125;fun saveUser4(user: User) &#123; user.validateBeforeSave() // save logic...&#125;","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"자바 식의 결과 타입","slug":"java/java-basic/javaExpressionType","date":"2023-01-09T04:39:35.000Z","updated":"2023-01-09T05:14:22.261Z","comments":true,"path":"2023/01/09/java/java-basic/javaExpressionType/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/09/java/java-basic/javaExpressionType/","excerpt":"","text":"10^6 개 중 중복 없이 2개를 조합하는 경우의 수를 계산하는 코드를 다음과 같이 작성했다.하지만 실행해보면 완전 엉뚱한 값이 반환된다. 123int a = Math.pow(10, 6);long b = a * (a - 1) / 2;System.out.println(b); //-364189984라는 값이 나온다. 음수가 나오는 것으로 봐서는 타입에서 감당할 수 있는 범위를 벗어난 값을 표현하려고 해서 오버플로우가 발생했음을 추측할 수 있다.하지만 10^6 * (10^6 - 1) / 2는 499999500000이다.long은 8바이트(64비트)로 최대 2^63까지 저장할 수 있다. 즉 b에는 충분히 계산값을 저장할 수 있어야 한다. 하지만 왜 오버플로우가 발생했을까?이를 위해서는 자바의 식 결과 타입을 어떻게 결정하는 지 알아야 한다. 일단 식 (expression)은 하나의 결과 값을 반환하는 코드로 변수, 연산자, 함수 호출 등으로 이뤄져있다.1 + 2, int a = 1 이런 코드들이 모두 식이다.식의 반환 타입은 식의 구성 요소들에 따라 달라진다. 여기서 우리가 작성했던 코드를 다시 보자.문제가 됐었던 부분은 바로 이 부분이다. 1long b = a * (a - 1) / 2; 여기서 코드는 한 줄이지만 여러 식으로 분해할 수 있다. a * (a - 1) -&gt; 이 식도 여러 식으로 나눌 수 있겠지만 생략. &#123;결과 값&#125; / 2 long b = &#123;결과 값&#125; 여기서 1번식은 어떤 타입을 반환할까? 산술 연산은 서로 다른 타입이 연산될 경우 피연산자를 일반적인 타입으로 변환하고 연산을 진행한다.하지면 1번식은 모두 int 타입만 사용되고 있다. 즉 1번 식의 반환 값은 int 타입이다.int형은 4바이트(32비트)로 최대 20억의 값만 저장할 수 있다. 그러나 1번식의 결과값은 999999000000이다. 그래서 식의 결과를 제대로 저장하지 못하고 오버플로우가 발생했다. 이런 문제를 해결하려면 식의 피연산자의 타입을 long으로 캐스팅하면 된다. 12long b = (long) a * (a - 1) / 2;long b = a * (long) (a - 1) / 2; 하지만 다음과 같이 식 밖에서 캐스팅을 하면 안된다. 이미 식이 수행되고 나서 캐스팅은 의미가 없기 때문이다. 1long b = (long) (a * (a - 1)) / 2;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"코틀린 기초","slug":"kotlinInAction/kotlinInActionCh2","date":"2023-01-02T01:32:24.000Z","updated":"2023-01-02T19:43:55.796Z","comments":true,"path":"2023/01/02/kotlinInAction/kotlinInActionCh2/","link":"","permalink":"https://yangdongjue5510.github.io/2023/01/02/kotlinInAction/kotlinInActionCh2/","excerpt":"","text":"요약함수와 변수클래스와 프로퍼티enum과 whenwhile과 for 루프예외 처리 기본 요소: 함수와 변수함수123fun &#123;함수이름&#125;(&#123;매개변수 이름&#125;: &#123;매개변수 타입&#125;) : &#123;반환값 타입&#125; &#123; ...&#125; 반환값이 없는 함수 예시 123fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;)&#125; 반환값이 있는 함수 예시 123fun max(a: Int, b: Int) : Int &#123; return if (a &gt; b) else b&#125; 문(statement)과 식(expression)의 구분코틀린의 if는 식이지 문이 아니다. 반환값이 있는 함수 예시를 보면 반환값에 if식이 들어 간 것을 확인할 수 있다. 식은 값을 만들어내며 다른 식의 하위 요소로 계싼에 참여할 수 있다. 반면 문은 자신이 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 자바는 모든 제어 구조가 문인 반면, 코틀린은 루프를 제외한 모든 제어 구조가 식이다. 식이 본문인 함수max 함수를 좀 더 간결하게 줄여보자.먼저 본문이 식 하나인 블록으로 구성되어 있어서 이를 식으로 대체할 수 있다. 1fun max(a: Int, b: Int) : Int = if (a &gt; b) a else b 위 처럼 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 하고, 본문이 중괄호로 쌓인 함수를 블록이 본문인 함수라고 한다. 그리고 식이 본문인 함수인 경우 반환 타입을 생략할 수 있다. 식이 본문인 경우 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다. 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 타입추론 이라고 부른다. 1fun max(a: Int, b: Int) = if (a &gt; b) a else b 변수코틀린에서는 변수를 초기화할 때 타입을 생략할 수 있다. 타입을 생략하는 경우 타입추론을 활용한다. 123val statement = &quot;중요한 문장입니다.&quot;val number = 1val numberWithType: Int = 1 초기화 식을 사용하지 않고 변수를 선언하려면 반드시 타입을 적어줘야 한다. 변수에 저장될 값에 대한 정보가 없어서 타입추론을 할 수 없기 때문이다. 12val value : Intvalue = 2 변경 가능한 변수와 변경 불가능한 변수12345// 값을 뜻하는 value - 초기화 이후 변경 불가val value = 1// 변수를 뜻하는 variable - 초기화 이후 변경 가능var variable = 1 이때 재밌는 점은 자바 final은 선언과 동시에 초기화해줘야 하지만 코틀린의 val은 한번만 초기화된다. 즉 다음과 같은 제어 구조를 구성할 수 있다. 1234567891011fun doMessage(input : String) &#123; val message : String if (input.length == 0) &#123; message = &quot;빈 문자열 전달받음.&quot; // 연산... &#125; else &#123; message = input + &quot; 전달받음&quot; // 연산... &#125;&#125; 문자열 템플릿12345fun stringTemplate(input: String) &#123; val name = input.ifEmpty &#123; &quot;Kotlin&quot; &#125; println(&quot;Hello $name!&quot;) println(&quot;HELLO $&#123;name.uppercase()&#125;&quot;)&#125; 문자열 리터럴 안에서 변수를 사용할 수 있도록 하는 방법이다. $를 앞에 붙여주고 변수명을 적어주면 상요할 수 있다.중괄호를 써주면 변수명이 아닌 간단한 식을 넣어줄 수도 있다. 클래스와 프로퍼티자바빈 클래스인 Person을 자바와 코틀린으로 구현해보자.자바 1234567891011public class Person &#123; private final String name; public Person(final String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 코틀린 1class Person(val name: String) 와우! 어떻게 이렇게 된 것일까?코틀린에서는 생성자를 통해 필드 대입 로직을 묵시적으로 생략해도 된다. 그리고 가시성 변경자가 public 인 경우 생략할 수 있다. 프로퍼티클래스라는 개념의 목적은 데이터를 캡슐화 하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.자바에서는 데이터를 필드에 저장하고 해당 데이터를 접근할 수 있는 접근자 메서드를 제공한다. (보통 게터, 세터)자바에서는 이런 필드와 접근자 메서드를 묶어서 프로퍼티라고 정의한다.코틀린은 프로퍼티를 언어 기본 기능으로 제공한다. 코틀린 프로퍼티는 자바의 필드 + 접근자 메서드를 완전히 대체한다. 1234class Person( val name: String, var isMarried: Boolean) 변수 선언과 비슷하게 val과 var 키워드로 선언할 수 있다. 이때 두 키워드에 따라 프로퍼티 유형이 달라진다. val : 읽기 전용 프로퍼티, 비공개 필드 + 게터 var : 쓸 수 있는 프로퍼티, 비공개 필드 + 게터 + 세터 is가 붙은 변수명의 게터 세터isMarried와 같이 변수명이 is로 시작하는 경우 게터가 get이 붙지 않고 원래 이름 그대로 사용한다.그리고 세터는 is 부분을 set으로 바꿔 사용한다. isMarried는 setMarried가 될 것이다. 그렇다면 자바와 코틀린의 클래스 활용법을 비교해보자.자바 1234Person person = new Person(&quot;yang&quot;, false);System.out.println(person.getName());person.setMarried(true);System.out.println(person.isMarried()); 코틀린 1234val person = Person(&quot;yang&quot;, false)println(person.name)person.isMarried = trueprintln(person.isMarried) 커스텀 접근자프로퍼티는 그 값을 저장하기 위해 프로퍼티를 뒷받침하는 필드가 존재한다. 그런데 필요하면 프로퍼티 값을 그때그때 계산할 수도 있다. 커스텀 게터를 사용하면 그런 프로퍼티를 구현할 수 있다. 12345678class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; return height == width &#125; val isSquare2: Boolean get() = height == width&#125; 직사각형이 정사각형인지를 굳이 필드로 저장하지 않고 커스텀 접근자로 구현한 예시이다. 본문이 식인 경우와 블록인 경우 모두 가능하다. 식이 복잡하면 블록으로 구현할 수 있다. 선택 표현과 처리: enum과 whenenum 클래스 정의123enum class Color &#123; RED, ORANGE, YELLOW&#125; 코틀린에서 enum은 소프트 키워드이다. 소포트 키워드는 특정 조건에서만 특정한 의미를 갖는 키워드이다. 소프트 키워드는 변수 명 같이 다른 이름으로 사용할 수 있다. 하지만 class는 키워드이고 다른 곳에서 이름으로 사용할 수 없다. 코틀린 enum도 프로퍼티와 메서드를 추가해줄 수 있다. 12345678910111213enum class Color( val r: Int, val g: Int, val b: Int) &#123; RED(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0); // 반드시 끝에 세미콜론 fun rgb() = (r * 256 + g) * 256 + b&#125;fun main(args: Array&lt;String&gt;) &#123; println(Color.YELLOW.rgb())&#125; 일반적인 클래스와 비슷하게 생성자를 통해 프로퍼티를 선언할 수 있다. 각 상수마다 프로퍼티 값을 정의해준다.그리고 중요한 점은 enum에 메서드가 존재하는 경우 마지막 enum 상수 끝에 세미콜론을 넣어줘야 한다! when으로 enum 클래스 다루기자바의 switch가 있다면 코틀린에는 when이 있다. 각 색깔에 맞는 과일 이름을 반환하는 메서드를 when을 활용해서 구현할 수 있다. 123456789101112fun getFruitNameOf(color: Color) = when (color) &#123; Color.RED -&gt; &quot;Apple&quot; Color.ORANGE -&gt; &quot;Orange&quot; Color.YELLOW -&gt; &quot;Banana&quot; &#125;fun getTemperatureOf(color: Color) = when (color) &#123; Color.RED, Color.ORANGE -&gt; &quot;Hot&quot; Color.YELLOW -&gt; &quot;warm&quot; &#125; 코틀린의 when은 if와 마찬가지로 값을 반환하는 식이다. 그래서 식이 본문인 함수로 구현할 수 있다. 자바 switch와는 다르게 매번 break을 넣어주지 않아도 된다. when과 임의의 객체를 함께 사용when은 분기 조건에 임의의 객체도 지원해서 상수(enum 상수나 숫자 리터럴)만 허용하는 switch보다 강력하다. 123456fun mix(c1: Color, c2: Color) = when (setOf(c1, c2)) &#123; setOf(RED, YELLOW) -&gt; ORANGE setOf(RED, ORANGE) -&gt; RED else -&gt; throw Exception(&quot;Dirty Color&quot;) &#125; 분기 조건에 두 색을 가진 집합 객체를 받아서 사용할 수 있다. 이때 임의의 객체를 분기 조건으로 사용하면 해당 분기가 맞는지는 동등성을 통해 확인한다.하지만 위 코드는 매번 메서드를 실행할 때마다 여러 Set 객체를 만들어서 비교한다. 메서드 호출이 굉장히 많을 경우 불필요한 가비지 객체가 많아짐을 의미한다. 인자 없는 when 사용인자가 없는 when 식 사용하면 불필요한 객체 생성을 막을 수 있다. 코드는 장황해지만 성능 상의 이점을 얻을 수 있다. 12345678fun mixOptimized(c1: Color, c2: Color) = when &#123; (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE (c1 == RED &amp;&amp; c2 == ORANGE) || (c1 == ORANGE &amp;&amp; c2 == RED) -&gt; RED else -&gt; throw Exception(&quot;Dirty Color&quot;) &#125; when 식에 인자가 없으려면 매 분기가 참 거짓을 판별하는 식이어야 한다. 스마트 캐스트: 타입 검사와 타입 캐스트를 조합(1 + 2) + 4 와 같이 덧셈을 계산하는 함수를 만들어보자.우선 식을 인코딩하는 방법을 생각해본다. 우리는 식을 트리 구조로 저장한다. 노드는 Num(값)과 Sum(합) 두가지 형식을 가지고, 최하단 노드는 항상 Num이고 Sum은 자식을 가진 중간 노드다. Expr 인터페이스를 선언하고 Sum과 Num 모두 구현하도록 하자. 123interface Exprclass Num(val value: Int): Exprclass Sum(val left: Expr, val right: Expr): Expr 그렇다면 (1 + 2) + 4라는 식은 Sum(Sum(Num(1), Num(2)), Num(4)) 이런 객체로 표현할 수 있다. 그렇다면 해당 Expr 객체의 값을 반환하는 eval 메서드를 통해 값을 구한다고 하면 다음과 같은 코드가 된다.println(eval(Sum(Sum(Num(1), Num(2)), Num(4)))) Expr 객체가 Sum과 Num에 따라 eval이 다르게 작동해야 한다. Num : 그 값을 반환 Sum : 좌항과 우항을 계산한 다음 두 값을 합한 값을 반환 이런 분기를 처리하는 코드를 짜보는데, Java 방식으로 Kotlin 코드를 짜보자. 1234567891011fun eval(e: Expr): Int &#123; if (e is Num) &#123; val n = e as Num return n.value &#125; if (e is Sum) &#123; val n = e as Sum return eval(n.left) + eval(n.right) &#125; throw IllegalArgumentException(&quot;unknown expression&quot;)&#125; is는 Java의 instancof와 비슷하고, as는 캐스팅하는 역할을 한다.Kotlin에서는 is로 검사하고 나면 해당 변수는 컴파일러가 검사했던 타입으로 캐스팅해준다. 이를 스마트 캐스트라고 부른다. 스마트 캐스트를 적용하면 캐스팅하던 코드가 사라진다. 123456789fun eval(e: Expr): Int &#123; if (e is Num) &#123; return e.value &#125; if (e is Sum) &#123; return eval(e.left) + eval(e.right) &#125; throw IllegalArgumentException(&quot;unknown expression&quot;)&#125; 리팩토링: if를 when으로 변경Kotlin의 if는 값을 만들어내는 식임을 더 활용해보자. 1234fun eval(e: Expr): Int = if (e is Num) e.value else if (e is Sum) eval(e.left) + eval(e.right) else throw IllegalArgumentException(&quot;unknown expression&quot;) 식이 본문인 함수로 변경됐다. 하지만 if를 when으로 변경해서 더 다듬을 수 있다. 123456fun eval(e: Expr): Int = when (e) &#123; is Num -&gt; e.value is Sum -&gt; eval(e.left) + eval(e.right) else -&gt; throw IllegalArgumentException(&quot;unknown expression&quot;) &#125; 분기 조건에 값 동등성 조건 대신 다른 기능을 활용하였다. 이 경우에도 스마트 캐스트가 작동한다. if와 when의 분기에서 블록 사용if와 when의 분기에서 복잡한 로직을 실행하려면 블록을 사용한다. 그리고 각 블록은 반환하려는 값을 맨 마지막에 작성하면 된다. 즉 블록의 마지막 식이 블록의 결과이다. 1234567891011121314fun evalWithLogging(e: Expr): Int = when (e) &#123; is Num -&gt; &#123; println(&quot;num: $&#123;e.value&#125;&quot;) e.value &#125; is Sum -&gt; &#123; val right = evalWithLogging(e.right) val left = evalWithLogging(e.left) println(&quot;num: $&#123;left + right&#125;&quot;) left + right &#125; else -&gt; throw IllegalArgumentException(&quot;unknown expression&quot;) &#125; 대상을 이터레이션: while과 for 루프while코틀린의 while은 자바와 별반 다르지 않다. 1234567while (조건) &#123; ...&#125;do &#123; ...&#125; while (조건) 수에 대한 이터레이션: 범위와 수열전통적인 for문을 코틀린에서 제공하지 않는다. 이를 대신하기 위해 코틀린에서는 범위를 사용한다.범위는 val oneToTen = 1..10 이런 방식으로 만든다. 코틀린의 범위는 폐구간 혹은 양 끝을 포함하는 구간이다. 이때 역방향으로 수열을 만들고 싶으면 100 downTo 1 이런 식으로 구현할 수 있다. 이때 감소폭을 다루고 싶으면 step 키워드를 붙이면 된다. 즉 100 downTo 1 step 2 이런 식으로 구현할 수 있다. 코틀린은 기본적으로 개발자가 작성한 마지막 끝 점을 포함한 수열을 만든다. 만약 닫힌 구간을 구현하고 싶으면 until 키워드를 사용하자. 0 until 101은 0..100과 같다. 맵에 대한 이터레이션123for ((key, value) in someMap) &#123; println(&quot;$key = $value&quot;)&#125; 이런 형태로 맵 객체를 구조 분해해서 사용할 수 있다.물론 굳이 맵이 아니더라도 구조 분해할 수 있다. 123for ((index, element) in someList.withIndex()) &#123; println(&quot;$index: $element&quot;)&#125; in으로 컬렉션이나 범위의 원소 검사in 연산자로 순회 뿐만아니라 원소가 포함됐는지 검사할 수 있다. 12fun isLetter(c: Char) = c in &#x27;a&#x27;..&#x27;z&#x27; || c in &#x27;A&#x27;..&#x27;Z&#x27;fun isNotDigit(c: Char) = c !in &#x27;0&#x27;..&#x27;9&#x27; when 절에서도 분기를 구분할 때 사용할 수 있다. 123456fun recognize(c: Char) = when(c) &#123; in &#x27;a&#x27;..&#x27;z&#x27; -&gt; &quot;is lower case&quot; in &#x27;A&#x27;..&#x27;Z&#x27; -&gt; &quot;is upper case&quot; in &#x27;0&#x27;..&#x27;9&#x27; -&gt; &quot;is numeric value&quot; else -&gt; &quot;don&#x27;t know&quot;&#125; in 절로 원소 겁사할 수 있는 범위는 비교가 가능한 클래스(Comparable을 구현한 클래스)면 무엇이든 된다. 예외 처리코틀린의 예외 발생은 자바와 거의 비슷하다. 다만 코틀린에서는 throw 키워드가 식을 만든다는 점만 알고 있자. 그래서 다른 식 내부에서 사용될 수 있다. 12345fun main(args: Array&lt;String&gt;) &#123; val percentage = if (number in 0..100) number else throw Exception()&#125; try, catch, finally자바와 마찬가지로 try, catch, finally를 사용한다. 다만 throws IOException이 없다는 점을 주목하자. 자바는 체크 예외를 반드시 어떻게든 처리해줘야 하는데 코틀린은 체크 예외와 언체크드 예외를 구분하지 않는다. 체크 예외가 발생한다고 해서 클라이언트 프로그램이 취할 수 있는 의미있는 동작이 마땅하지 않은 경우가 많기 때문에 의미 없는 예외를 다시 던지거나 예외를 잡고 처리하지 않도록 구현하는 경우가 많기 때문이다. 12345678910fun readNumber (reader: BufferedReader): Int? &#123; try &#123; val line = reader.readLine() return Integer.parseInt(line) &#125; catch (e: NumberFormatException) &#123; return null &#125; finally &#123; reader.close() &#125;&#125; try를 식으로도 사용할 수 있다. 12345678fun readNumber(reader: BufferedReader) &#123; val number = try &#123; Integer.parseInt(reader.readLine()) &#125; catch (e: NumberFormatException) &#123; return &#125; println(number)&#125; 이 경우 catch 블록을 보면 return 문을 통해 메서드를 종료시키고 있다. 이런 방식은 catch 됐을 때 메서드를 종료시키고 싶은 경우 적절하다. 하지만 다른 값을 반환해야 하는 경우는 다르게 작성할 수 있다. 12345678fun readNumber(reader: BufferedReader) &#123; val number = try &#123; Integer.parseInt(reader.readLine()) &#125; catch (e: NumberFormatException) &#123; null &#125; println(number)&#125; 이렇게 마지막줄에 블록의 결과를 넣는 규칙에 따라 null을 결과값으로 반환되도록 구현했다.","categories":[],"tags":[{"name":"Kotlin in Action","slug":"kotlin-in-action","permalink":"https://yangdongjue5510.github.io/tags/kotlin-in-action/"}],"keywords":[]},{"title":"널 오브젝트 패턴","slug":"java/java-basic/design-pattern/nullObject","date":"2022-12-28T07:25:25.000Z","updated":"2022-12-28T07:42:56.179Z","comments":true,"path":"2022/12/28/java/java-basic/design-pattern/nullObject/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/28/java/java-basic/design-pattern/nullObject/","excerpt":"","text":"1234Employee e = DB.getEmployee(&quot;Yang&quot;);if (e != null &amp;&amp; e.isTimeToPay(today)) &#123; e.pay();&#125; 이런 식의 코드가 있다고 하자. 데이터베이스에서 조회하는 직원이 존재하지 않으면 null을 반환할 수 있기 때문에 조건문에서 먼저 null 여부를 체크해줬다. 이런 번거로운 작업을 줄이고 로직 코드를 보다 더 깔끔하게 만드는 패턴이 널 오브젝트 패턴이다. 널 오브젝트 패턴널 오브젝트 패턴은 추상화하려는 객체의 인터페이스를 만들고 그 구현체로 null을 의미하는 구현체와 진짜 객체를 의미하는 구현체를 만들어서 활용한다.null을 의미하는 클래스의 메서드는 ‘아무 일’도 하지 않도록 구현한다. ‘아무 일’의 경우 각 메서드에 따라 다르다. isTimeToPay 메서드 같은 경우 null인 객체는 false를 반환하는게 자연스럽다. 널 오브젝트 패턴으로 코드를 고치면 다음과 같다. 1234Employee e = DB.getEmployee(&quot;Yang&quot;);if (e.isTimeToPay(today)) &#123; e.pay();&#125; 물론 자바 8이후에는 Optional을 사용하면서 이런 문제가 많이 해소되었다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"퍼사드와 미디에이터 패턴","slug":"java/java-basic/design-pattern/facadeAndMediator","date":"2022-12-23T09:43:38.000Z","updated":"2023-01-02T00:57:46.666Z","comments":true,"path":"2022/12/23/java/java-basic/design-pattern/facadeAndMediator/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/23/java/java-basic/design-pattern/facadeAndMediator/","excerpt":"","text":"퍼사드 패턴퍼사드는 외관, 건물의 정면을 의미한다.퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 객체 그룹을 간단하고 구체적인 인터페이스를 제공한다. DB를 활용하기 위해 java.sql 패키지의 복잡한 인터페이스를 가진 객체들을 상위 모듈에서 사용하기는 어렵다.이를 위해 퍼사드 역할을 하는 객체를 만들 수 있다. Application 입장에는 java.sql을 알지 못해도 DB에 접근할 수 있게 된다.다만 퍼사드 패턴은 반드시 퍼사드 객체를 통하기를 강요한다. 미디에이터 패턴미디에어터는 중재자라는 뜻을 의미한다. 복잡한 객체들의 관계를 캡슐화해서 관리하는 패턴이다. 미디에이터 패턴은 구성 요소들이 서로 직접 통신하지 말고 중재자를 거쳐서 통신한다. 간단한 비유를 해보자면, 관제탑과 비행기들의 관계가 미디에이터 패턴에 해당한다. 비행기들은 이착륙할 때 서로 부딪히지 않기 위해 비행기들끼리 직접 통신하지 않는다. 대신 관제탑과 통신하여 수많은 다른 비행기들과 부딪히지 않고 이착륙을 할 수 있게 된다. 구현은 다음을 참고하자.https://refactoring.guru/design-patterns/mediator/java/example","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"의존성 분리를 통해 설계 개선하기 2편 (우아한객체지향)","slug":"java/javadependency2","date":"2022-12-22T13:37:19.000Z","updated":"2022-12-23T16:12:55.980Z","comments":true,"path":"2022/12/22/java/javadependency2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/22/java/javadependency2/","excerpt":"","text":"도메인 컨셉 문제점사용자가 가게에서 메뉴 A를 골라서 장바구니에 저장해놓은 상태에서 가게 주인이 메뉴 A의 세부 내용을 바꾸면 사용자 장바구니에 있는 메뉴 A와 가게에서 판매 중인 메뉴 A의 불일치가 생긴다.그래서 이제 주문할 때마다 사용자가 주문하려는 메뉴 A가 실제 가게에서 판매 중인 메뉴 A와 일치하는 지 검증하려고 한다. 주문 검증 메뉴 이름 &#x3D;&#x3D; 주문 항목의 이름 옵션 그룹의 이름 &#x3D;&#x3D; 주문 옵션 그룹 이름 옵션 이름 &#x3D;&#x3D; 주문 옵션 이름 옵션 가격 &#x3D;&#x3D; 주문 옵션의 가격 가게가 영업중인지 확인 주문금액 &gt;&#x3D; 최소 주문 금액 이런 식으로 협력 구조를 잡으면 어떻게든 런타임에서 같은 방향으로 의존성을 가져야 한다.그렇다면 의존성의 방향을 어떤 종류의 의존성으로 구현할 지 선택하면 된다. 협력은 연관관계와 의존관계로 구현할 수 있다. 연관관계연관관계는 영구적인 탐색 구조이다. 매우 빈번하게 협력해야 하는 경우에 사용한다.연관 관계는 탐색 가능성을 의미한다. 즉 객체 A를 알면 객체 B를 탐색할 수 있음을 의미한다. 일반적인 연관관계 구현 방식 : 객체 참조 1234567891011121314151617class Order &#123; private List&lt;OrderLineItem&gt; orderLineItems; public voidrplace() &#123; public Long getShopId() &#123;...&#125; public Money getTotalPrice() &#123;...&#125; validate() ordered(); &#125; private void validate() &#123; // ... for (OrderLineItem orderLineItem : orderLineItems) &#123; orderLineItem.validate(); // 협력! &#125; &#125;&#125; 참고로 연관관계는 개념이고 객체 참조는 그 개념의 구현방법이다. 연관관계가 즉 객체 참조는 아니다! 지금 예시의 도메인 모델에서는 다음과 같이 연관관계를 객체 참조로 가지고 있다 설계 진화시키기설계를 개선하기 위해서는 의존성을 그려보자. 의존성이 순환하는 경우는 코드를 잘못 나눴거나 같이 있어야 할 코드를 잘못 위치시킨 것을 판단할 수 있다. 대표적인 문제 객체 참조로 결합도 상승 패키지 의존성 사이클 위 그림을 보면 알 수 있듯이 shop 패키지와 order 패키지가 서로 의존성이 순환되고 있다. 이렇게 되면 의존성 방향이 잘못 됐거나 패키지 분리를 잘못한 것이다. 자 이제 이런 문제를 해결하는 몇가지 방법을 배워보자 중간 객체 이용해서 의존성 사이클 끊기중간 객체를 둬서 두 패키지 간 의존성이 한 방향으로 흐르게 만들었다.이렇게 구현하면 OrderOptionGroup을 통해 OptionGroup을 생성하고 OptionGroupSpecification이 생성된 OptionGroup과 비교하여 데이터 불일치를 검증하는 방식으로 구현한다. 객체 참조의 문제점. 성능 문제 : 어디까지 조회 할 것인가? 수정 시 도메인 규칙을 함께 적용할 경계는? : 즉 트랜잭션의 범위가 어디까지인가? 수정 시 도메인 규칙을 함께 적용할 경계 문제간단한 예시를 들어보자.배달 완료됐음을 알리는 서비스 로직이 있다. 주문 객체의 상태를 배달 완료로 변경 가게 객체의 수수료를 부과 배달 객체의 상태를 배달 완료로 변경 언뜻 보면 이 세 객체를 한 트랜잭션으로 묶어서 수정하는 게 큰 문제가 없어보인다.그러나 문제는 주문, 가게, 배달 이 세가지 객체의 트랜잭션 주기가 다르다는 사실이다! 가게는 주인이 가게 정보를 바꾸려고 할 때도 트랜잭션이 걸릴 수 있다.주문은 고객이 주문을 취소할 때도 트랜잭션이 걸릴 수 있다.배달은 배달 성공 실패에 트랜잭션이 걸릴 수 있다. 즉 만약 개발자가 서비스의 모든 가게 객체의 특정 정보를 일괄 수정하는 트랜잭션을 실행한다고 가정하자.우리가 개발한 배달 완료 로직은 개발자가 수행한 모든 가게 정보 수정 트랜잭션이 완료될 때까지 기다려야 될 것이다!!!이는 트랜잭션 주기가 다른 여러 객체들이 한 트랜잭션에 묶여있어서 생긴 문제이다! 그렇다면 언제 객체 참조를 해야하나?도메인 규칙마다 다르다. 생명 주기가 같은 객체. 즉 같이 생성되고 같이 제거되는 객체는 객체 참조할 법하다.혹은 도메인 제약 사항을 공유하는 객체들을 함께 묶어라! (도메인 제약 사항에 다른 객체가 필요한 경우!)이렇게 객체 참조로 연결된 단위는 트랜잭션&#x2F;조회&#x2F;비즈니스 제약의 단위이다! 객체 참조 문제 해결법 : 레포지토리를 활용한 간접 참조12345678910public class Shop &#123; private Long id;&#125;public class Order &#123; private Long shopId; // ...&#125;Shop shop = shopRepository.findById(order.getShopId()); 이렇게 구현하면 Shop과 Order 사이의 강한 결합이 제거된다! 검증 로직은 Validator 객체를 만들어서 도입하기문제는 이렇게 구현하면 기존에 객체들이 가지고 있던 검증 로직을 도메인 객체에서 수행할 수 없게 된다!Validator라는 객체를 만들어서 주입해서 사용하는 건 어떨까? 1234567891011121314151617181920212223242526272829303132@Componentpublic class OrderValidator &#123; private ShopRepository shopRepository; private MenuRepository menuRepository; public OrderValidator(ShopRepository shopRepository, MenuRepository menuRepository) &#123; this.shopRepository = shopRepository; this.menuRepository = menuRepository; &#125; public void validate(Order order) &#123; validate(order, getShop(order), getMenus(order)); &#125; void validate(Order order, Shop shop, Map&lt;Long, Menu&gt; menus) &#123; if (!shop.isOpen()) &#123; throw new IllegalArgumentException(&quot;가게가 영업중이 아닙니다.&quot;); &#125; if (order.getOrderLineItems().isEmpty()) &#123; throw new IllegalStateException(&quot;주문 항목이 비어 있습니다.&quot;); &#125; if (!shop.isValidOrderAmount(order.calculateTotalPrice())) &#123; throw new IllegalStateException(String.format(&quot;최소 주문 금액 %s 이상을 주문해주세요.&quot;, shop.getMinOrderAmount())); &#125; for (OrderLineItem item : order.getOrderLineItems()) &#123; validateOrderLineItem(item, menus.get(item.getMenuId())); &#125; &#125; 이런 방식이 낯설 수 있다. 객체가 주도적으로 행동하는 것이 아닌 외부에 따로 객체를 만들어서 검증 책임을 하는 것처럼 보인다. 이런 방식은 객체지향적이지 않은 대신 제약조건을 한 눈에 볼 수 있고, 객체들의 응집도(검증 로직과 비즈니스 로직이 하나의 객체가 아닌 다른 객체로 분리)가 높아진다. 다른 서비스 객체를 만들어서 도입하기그리고 객체 참조를 제거하면 다른 문제가 또 생긴다. 배달 완료 로직에서 객체 참조가 끊겨서 객체 내부에서 협력을 통해 로직을 실행 시킬 수 없다-&gt; 그렇다면 다른 Service를 객체를 추가해서 로직을 절차지향적으로 구성할 수 있다! 12345678910111213@Servicepublic class OrderDeliveredService &#123; @Transactional public void deliverOrder(Long orderId) &#123; Order order = orderRepository.findById(orderId); Shop shop = shopRepository.findById(order.getShopId()); Delivery delivery = deliveryRepository.findById(orderId); order.delivered(); shop.billComissionFee(order.calculateTotalPrice()); delivery.complete(); &#125;&#125; 이 서비스를 주입받아서 사용하면 된다. 이때 서비스를 새로 만들면서 의존성 사이클이 도는 경우는 DIP를 활용한 인터페이스를 추가해서 적용해보자. 이 방법은 객체간의 결합도를 낮추는 대신 로직간의 결합도를 높이는 방법이다. 도메인 이벤트 퍼블리싱위 방법들 외에도 도메인 이벤트 퍼블리싱 방법을 사용할 수 있다. 도메인 이벤트는 객체 간 결합은 최대한 느슨하게 하는 방법이다.도메인 객체가 이벤트 객체를 발행하면 다른 패키지의 이벤트 리스너들이 이를 감지해 해당 패키지의 도메인 객체에게 알리는 방식이다. 주문 완료의 예시에서는 Order 객체가 배달 완료됐다는 메시지를 받는다. Order는 OrderDeliveredEvent라는 이벤트를 발행한다 shop 패키지는 발행된 이벤트를 감지해 가게에 수수료를 부과하는 로직을 실행한다. delivery 패키지도 발행된 이벤트를 감지해 Delivery 객체의 상태를 완료로 변경한다. 도메인 이벤트 발행 코드로 이해하기이런 식으로 Order 객체는 이제 이벤트를 발행하기만 한다. 다른 패키지 도메인 객체에는 관심이 없다.예제는 Spring Data의 AbstractAggregatedRoot를 상속받아서 registerEvent 메서드를 활용해서 이벤트를 등록한다. registerEvent 메서드는 이벤트를 모아놨다가 DB에 커밋될 때 이벤트를 발행한다. 이런 클래스의 도움을 받기 보다는 직접 구현하는 게 낫다고 한다. 1234567891011121314public class Order extends AbstractAggregatedRoot&lt;Order&gt; &#123; public void delivered() &#123; this.orderStatus = OrderStatus.DELIVERED; registerEvent(new OrderDeliveredEvent(this)); &#125;&#125;public class OrderDeliveredEvent &#123; private Order order; public Long getOrderId() &#123;...&#125; public Long getShopId() &#123;...&#125; public Money getTotalPrice() &#123;...&#125;&#125; 이벤트 발행을 받는 쪽(shop 패키지)은 Spring의 이벤트 리스너를 활용해서 이벤트 핸들러를어만들어 사용하면 된다. 1234567891011@Componentpublic class BillShopWithOrderDeliveredEventHandler &#123; // DI 생략... @Async //비동기로 처리. 동기로도 가능 @EventListener @Transactional // 다른 트랜잭션으로 분리해서도 가능 public void handle(OrderDeliveredEvent event) &#123; Shop shop = shopRepository.findById(event.getShopId()); shop.billCommissionFee(event.getTotalPrice()); &#125;&#125; 문제는 이렇게 이벤트와 관련된 객체를 만들고 나서 다시 의존성 사이클이 발생할 수 있다는 사실이다.이벤트를 받아 처리하는 리스너에서 파라미터로 order 패키지의 이벤트를 받도록 했기 때문에 shop과 order가 서로 의존하고 있다. 이 문제는 order에서 발행한 이벤트를 처리하는 이벤트 핸들러가 shop 패키지에 있기 때문이다!그렇다면 문제가 되는 이벤트 핸들러를 패키지 분리하면 어떨까? 그리고 이벤트 핸들러가 의존하던 수수료 관련 코드를 Shop과 분리하자! 기존의 Shop 객체는 다음과 같이 수수료 모으는 코드가 존재했었다. 12345678public class Shop &#123; private Ratio commissionRate; private Money commissin = Money.Zero; public void billCommissionFee(Money price) &#123; commission = commission.plus(commissionRate.of(price)); &#125;&#125; 이를 Billing 이란 객체를 도입해서 역할을 분리하자!!! 12345678910111213141516public class Billing &#123; private Long shopId; private Money commission = Money.ZERO; public void billCommissionFee(Money commission) &#123; commission = commission.plus(commission); &#125;&#125;public class Shop &#123; private Ratio commissionRate; public Money calculateCommissionFee(Money price) &#123; return commissionRate.of(price); &#125;&#125; 그리고 이벤트 핸들러도 shop과 billing을 구분해서 협력하도록 하자. 123456789101112@Componentpublic class BillShopWithOrderDeliveredEventHandler &#123; // DI 생략... @Async //비동기로 처리. 동기로도 가능 @EventListener @Transactional // 다른 트랜잭션으로 분리해서도 가능 public void handle(OrderDeliveredEvent event) &#123; Shop shop = shopRepository.findById(event.getShopId()); Billing billing = billingRepository.findById(event.getShopId()); billing.billCommissionFee(shop.calculateCommissionFee(event.getTotalPrice())); &#125;&#125; 이러면 패키지끼리 순환하지 않게 된다! 패키지 의존성 사이클 제거하는 세가지 방법 정리! 중간 객체 추가! 의존성 역전 시키기! -&gt; 새로운 서비스 객체를 사용할 때 생긴 의존성 제거에 유용했다. 새로운 패키지 추가! -&gt; 도메인 이벤트 퍼블리싱을 사용할 때 생긴 의존성 제거에 유용했다. 의존성과 시스템 분리도메인 패키지 간의 의존성 사이클을 제거하면 각 패키지를 분리해서 배포할 수 있게된다!그리고 이벤트는 메시징을 통해 외부 시스템으로 보내줄 수 있다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"의존성 분리를 통해 설계 개선하기 1편 (우아한객체지향)","slug":"java/javaDependency1","date":"2022-12-22T12:41:03.000Z","updated":"2022-12-22T13:39:04.512Z","comments":true,"path":"2022/12/22/java/javaDependency1/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/22/java/javaDependency1/","excerpt":"","text":"의존성두 클래스 A, B가 있을 때 어느 한 쪽이 변화가 생길 때 다른 한 쪽도 함께 변경될 가능성이 있는 경우를 의존성이 있다고 말한다. 여기서 변경이란클래스의 이름 변경, 메서드의 이름 변경, 메서드의 구현 변경 등을 의미한다. 의존에는 클래스 간 의존성과 패키지 간 의존성이 존재한다. 클래스 의존성의 종류연관 관계 Association 123class A &#123; private B b;&#125; A에서 B로 연결되어 있는 관계를 의미한다. 쉽게 말해 A에서 B의 객체 참조가 있는 경우를 의미한다. A라는 클래스에 B로 가는 영구적인 연결 통로가 생긴다. 의존 관계 Dependency 12345class A &#123; public B method(B b) &#123; return new B(); &#125;&#125; 코드 상에서 인자 혹은 리턴 값으로 해당 타입을 사용하거나 메서드 안에서 해당 인스턴스를 생성하면 의존 관계이다. 이 관계는 해당 메서드를 사용할 때 일시적으로 맺어지는 관계이다. (영구적인 관계인 연관 관계와 다르다.) 상속 관계 Inheritance 1class A extends B &#123; ... &#125; 상속 관계는 B 클래스의 구현을 그대로 가져와서 재사용하는 방식이다. 그래서 B 클래스의 구현이 변경되면 해당 구현을 사용하고 있던 A 클래스에 영향이 생긴다. 실체화 관계 Realization 1class A implements B &#123; ... &#125; 실체화 관계는 인터페이스 B의 시그니처만 가져와서 사용하는 방식이다. 상속 관계와는 다르게 시그니처가 변경되지 않는 한 A 클래스에 영향이 생기지 않는다. 패키지 의존성패키지 의존성은 A 패키지의 클래스 중 어느 하나라도 B 패키지의 클래스에 의존하는 경우 A 패키지가 B 패키지에 의존함을 의미한다. 좋은 설계를 위한 의존성 규칙양방향 의존성을 피하라양방향 Bi-Directional1234567891011121314151617181920212223class A &#123; private B b; public void setB(B b) &#123; if(b != null) &#123; // 동기화 this.b.setA(null); &#125; this.b = b; this.b.setA(this); // 동기화 &#125;&#125;class B &#123; private A a; public void setA(A a) &#123; if (a != null) &#123; // 동기화 this.a.setB(null); &#125; this.A = a; this.A.setB(this); // 동기화 &#125;&#125; A와 B가 서로 의존한다는 의미는 A가 변할 때 B가 변할 수 있고, B가 변할 때 A가 변할 수 있다는 의미이다. 이런 경우 원래 이 두 클래스가 하나의 클래스로 묶어야 될 수 있다. 양방향 의존 관계에서는 setter 메서드를 사용할 때 동기화 해줘야 한다. 동기화를 왜 해줘야 하는 지 코드로 간략하게 알아보자.만약 A와 B에서 주석으로 동기화라고 적혀 있는 코드가 없는 상태로 setter를 사용한다고 가정해보자. 123456789A a1 = new A();B b1 = new B();B b2 = new B();// 1. 서로 양방향 의존하도록 설정.a1.setB(b1);b1.setA(a1);// 2. 이때 의존하는 인스턴스를 다른 인스턴스로 바꾸고 싶으면?a1.setB(b1); // 이렇게 되면 b2는 a1에 연결되지 않은 상태다!!!! 그리고 심지어 b1은 아직 의존하고 있게 된다. 이렇게 양방향은 고려해야 할 부분이 많고 예상하지 못한 버그가 발생할 수 있다. 다중성이 적은 방향을 선택하라.즉 일대다 대신 다대일 관계를 선택하는 게 좋다. 일대다를 JPA를 사용하다보면 N+1 문제에서 큰 성능 저하를 일으키게 된다. 123456789// 일대다 관계 (비추!)class A1 &#123; private Collection&lt;B&gt; bs;&#125;// 다대일 관계 (추천!)class A2 &#123; private B b;&#125; 패키지 사이의 의존성 사이클을 제거하라의존성 사이클은 여러 패키지의 의존성 방향이 결국 연결되는 것을 의미한다. 크게 보면 결국 양방향 의존인 셈이다. 패키지가 양방향 의존하게 되면 하나가 바뀌면 다같이 바뀌게 될 가능성이 존재한다는 의미이다. 즉 원래 같이 묶여야 될 패키지라는 의미일 수 있다. 구체적인 실습은 2편에서 해보자!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"커맨드와 액티브 오브젝트 패턴","slug":"java/java-basic/design-pattern/commandAndActiveObjectPattern","date":"2022-12-21T05:02:25.000Z","updated":"2022-12-22T10:24:06.201Z","comments":true,"path":"2022/12/21/java/java-basic/design-pattern/commandAndActiveObjectPattern/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/21/java/java-basic/design-pattern/commandAndActiveObjectPattern/","excerpt":"","text":"커맨드 패턴123public interface Command &#123; void do();&#125; 여러 행동을 호출해야 하는 경우 여러 행동을 커맨드로 추상화하여 사용하는 쪽에서는 커맨드가 어떻게 행동하는 지 관심없이 사용하기만 하도록 구현하는 패턴이다.이 패턴은 커맨드를 사용하는 쪽에서 커맨드를 실행하기 위해서 어떤 객체가 사용되는지 알아지 않아도 되는 장점이 있다. 커맨드 패턴은 명령의 개념을 캡슐화해서 시스템과 연결된 장치의 논리적인 상호 연결을 분리해낼 수 있다. 물리적 분리커맨드 패턴을 사용하면 사용자에게서 데이터를 받는 코드와 그 데이터를 검증하고 작업을 하는 코드, 도메인 객체를 분리할 수 있다. 데이터를 받는 코드에서 커맨드의 실행 코드와 검증 코드와 물리적으로 분리 된다. 시간적 분리사용자에게서 데이터를 입력받는 역할과 그 데이터를 검증하고 작업을 하는 코드를 물리적으로 분리할 수 있다고 했다. 이를 다르게 생각해보면 데이터를 입력받았다고 바로 검증과 실행을 하지 않아도 된다는 의미다. 즉 명령을 일단 다 생성해서 모아놓고 특정 시점에 몰아서 명령을 검증하고 실행할 수 있다는 의미이다. 되돌리기1234public class Command &#123; void do(); void undo();&#125; 커맨드에 실행하는 메서드말고 되돌리기 메서드를 선언해놓으면 롤백 기능도 구현할 수 있다. 위처럼 인터페이스로 실행과 실행 취소 메서드를 선언해놓고 각 명령마다 실행과 실행 취소 로직을 구현해놓으면 된다.직원 임금 관리 서비스에서 직원을 추가하는 명령이 있다고 할 때 실행시키는 메서드는 직원 객체를 생성하고 저장소에 저장하는 방식으로 구현된다. 실행 취소 메서드는 저장소에 해당 직원의 데이터를 제거하는 방식으로 구현할 수 있을 것이다. 액티브 오브젝트 패턴액티브 오브젝트 패턴은 커맨드 패턴의 응용된 버전으로 다중 제어 스레드 구현을 위해 등장했다.액티브 오브젝트 패턴은 하나의 스레드로 멀티 스레드가 이벤트 방식으로 작동하는 것처럼 구현할 수 있어서 런타임 스택을 여러개 만들지 않아도 된다. 즉 멀티 스레드를 활용하고 메모리가 부족한 상황에서 사용할 만한 대안이다. 액티브 오브젝트 패턴은 커맨드를 모아두고 꺼내서 실행하는 엔진과 실행 시킬 커맨드, 마지막으로 실행 시킬 조건을 다루는 커맨드 이렇게 세가지로 구성된다. 엔진123456789101112131415public class ActiveObjectEngine &#123; private final LinkedList&lt;Command&gt; commands = new LinkedList&lt;&gt;(); public void add(Command c) &#123; commands.add(c); &#125; public void run() throws Exception &#123; while(!commands.isEmpty()) &#123; commands.pop() .execute(); &#125; &#125;&#125; 엔진을 실행시키면 자신이 가진 모든 커맨드를 순차적으로 실행한다. 실행 조건을 다루는 커맨드특정 시간만큼 sleep하고 커맨드를 실행 이라는 조건을 달성하기 위해 커맨드를 만들어보자. 123456789101112131415161718192021222324252627282930public class SleepCommand implements Command &#123; private final long sleepMilliSeconds; private final ActiveObjectEngine engine; private final Command wakeUpCommand; private long startedTime = 0; private boolean started = false; public SleepCommand(final long sleepMilliSeconds, final ActiveObjectEngine engine, final Command wakeUpCommand) &#123; this.sleepMilliSeconds = sleepMilliSeconds; this.engine = engine; this.wakeUpCommand = wakeUpCommand; &#125; @Override public void execute() throws Exception &#123; final long currentTime = System.currentTimeMillis(); if (!started) &#123; started = true; startedTime = currentTime; engine.add(this); return; &#125; if (currentTime - startedTime &lt; sleepMilliSeconds) &#123; engine.add(this); return; &#125; engine.add(wakeUpCommand); &#125;&#125; 자신이 엔진에 의해 실행된 경우가 없다면 현재 시간을 시작 시각으로 기록하고 다시 엔진에 자신을 집어넣는다.자신이 엔진에 의해 실행된 경우가 있으면 현재 시각과 시작 시각을 비교해서 커맨드 실행 조건에 달성했는 지 체크한다.조건에 달성했다면 wakeUpCommand 즉 우리가 원래 실행하려고 했던 커맨드를 실핸한다. 실행하려는 커맨드123456789101112131415161718192021public class DelayedTyper implements Command &#123; private final ActiveObjectEngine engine; private final long itsDelay; private final char itsChar; public DelayedTyper(final ActiveObjectEngine engine, final long itsDelay, final char itsChar) &#123; this.engine = engine; this.itsDelay = itsDelay; this.itsChar = itsChar; &#125; @Override public void execute() throws Exception &#123; System.out.print(itsChar); delayAndRepeat(); &#125; private void delayAndRepeat() throws Exception &#123; engine.add(new SleepCommand(itsDelay, engine, this)); &#125;&#125; 주어진 글자를 출력하고 특정 시간만큼 sleep 이후 다시 출력하는 커맨드이다. 마지막으로 이를 실행하는 코드를 통해 실제 결과물을 확인할 수 있다. 123456789101112public class Application &#123; private static final ActiveObjectEngine ENGINE = new ActiveObjectEngine(); public static void main(String[] args) throws Exception &#123; ENGINE.add(new DelayedTyper(ENGINE, 100, &#x27;1&#x27;)); ENGINE.add(new DelayedTyper(ENGINE, 300, &#x27;3&#x27;)); ENGINE.add(new DelayedTyper(ENGINE, 500, &#x27;5&#x27;)); ENGINE.add(new DelayedTyper(ENGINE, 700, &#x27;7&#x27;)); ENGINE.add(new SleepCommand(20000, ENGINE, () -&gt; System.exit(0))); ENGINE.run(); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"Elastic Beanstalk와 Github Actions를 활용해서 CICD 무중단 배포 구현하기","slug":"nonStopDeployWithEB","date":"2022-12-14T03:45:27.000Z","updated":"2022-12-14T06:33:41.766Z","comments":true,"path":"2022/12/14/nonStopDeployWithEB/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/14/nonStopDeployWithEB/","excerpt":"","text":"Elastic Beanstalk란AWS에서는 인프라에 대한 지식이 없어도 배포 환경을 구축할 수 있는 Elastic Beanstalk(EB)를 제공한다. EB에 어플리케이션을 전달하면 EB에서 용량 프로비저닝, 로드 밸런싱, 조정, 어플리케이션 상태 모니터링을 자동으로 처리한다. 다음은 EB가 어떻게 어플리케이션을 관리하는 지 보여주는 워크플로우다. Elastic Beanstalk 구조EB는 여러 종류의 환경을 제공할 수 있다. 웹 서버 환경을 중점적으로 살펴보자.Auto Scaling Group에 여러 EC2 인스턴스들이 존재한다. 이 인스턴스에서 어플리케이션이 실행되는데 여기서 HM(호스트 매니저) 이라는 개념이 있다. HM는 어플리케이션의 로그를 S3에 개시하거나 서버 인스턴스의 상태를 보고하는 역할을 한다. Auto Scaling Group의 EC2들 앞에는 Elastic Load Balancer가 로드 밸런싱을 한다. EB의 ELB는 CNAME(URL)을 가진다. 그리고 EB 환경도 CNAME을 가진다. 이때 환경의 CNAME은 ELB의 CNAME의 별칭으로 지정된다. Elastic Beanstalk 직접 구성해보기EB를 생성할 때 중요한 몇가지 위주로 설명하겠다. 플랫폼 설정하기 및 추가 옵션 구성AWS EB 콘솔에서 새 어플리케이션 만들기를 선택하면 어플리케이션이 어떤 플랫폼인지 그리고 그 플랫폼을 어떤 운영체제에서 실행할지를 정해야 한다.필자의 경우는 Spring Boot 어플리케이션이므로 Java 플랫폼에 Linux 2를 설정했다. 즉 EB 환경의 EC2가 Linux 2 기반으로 생성된다는 의미이다. 그리고 이때 중요한 건 바로 애플리케이션 생성을 누르지 말고 무중단 배포를 위해 추가 옵션 구성을 선택한다. 추가 옵션 구성을 클릭하면 여러가지 설정 가능한 옵션이 나온다. 이때 사전 설정에서 사용자 지정 구성으로 우리 상황에 맞도록 구성할 수 있도록 해보자. 인스턴스 보안그룹 설정하기Auto Scaling Group의 인스턴스들이 적용되는 보안그룹을 반드시 설정해줘야 한다. 그렇지 않으면 외부에서 인스턴스에 SSH로 접근해서 의도하지 않은 작업을 진행할 수 있다.F12-PROD 보안그룹은 80 포트와 8080 포트를 모든 IP가 접근할 수 있도록 했고, SSH는 개발자 IP만 접근 가능하도록 인바운드 규칙을 적용했다.ec2-rds-1 보안그룹은 mysql 포트인 3306 포트를 아웃바운드 규칙으로 적용되어 있다. Auto Scaling Group 및 로드 밸런싱 설정하기먼저 Auto Scaling Group에 어떤 인스턴스를 몇 개나 수용할 지를 정해야 한다. 우리는 프리티어 한도 내에서 인프라를 구축해야 하기 때문에 인스턴스를 한 개만 사용하도록 했다. 다음으로 로드 밸런서를 설정해야 한다. 로드 밸런서는 크게 Classic Load Balancer(ELB)와 Application Load Balancer(ALB)를 선택할 수 있다. ELB가 먼저 출시되어 많은 참고 자료가 존재하지만 갑작스러운 트래픽이 발생할 경우에 대응이 좋지 않다고 한다. 그래서 우리는 ALB를 선택했다. 그리고 추가로 프론트엔드에서 8080포트로 요청하는 상황이라 로드 밸런서의 리스너를 8080포트도 열어줬다. 무중단 배포 설정이제 EB에서 새 버전을 배포하려고 할 때 무중단 배포가 되도록 설정해야 한다. 롤링 업데이트와 배포 수정에 가서 애플리케이션 배포 방식을 정할 수 있다. 우리는 추가 배치를 사용한 롤링 방식을 선택했다. 만약 새 버전이 배포되면 새 EC2 하나를 만들어서 새 버전을 배포하고 배포가 완료되면 로드 밸런서 설정을 바꾸고 기존의 Auto Scaling은 폐기하는 방식으로 운영된다. 다만 이 방식은 배포가 되고나면 롤백하지 못한다. EC2 키 페어 설정EB에서 생성된 EC2 인스턴스에 접근할 수 있는 PEM 키를 설정해 줄 수 있다. 우리는 기존에 만들어놨던 PEM 키를 활용했다. 이제 EB 설정은 어느정도 끝났으니 EB를 생성하면 된다. EB 어플리케이션 구성EB 어플리케이션을 실행할 때 인스턴스에서 설정해줘야 하는 것들이 있을 수 있다. 예를 들어 EC2의 타임존 설정이나 리버스 프록시 설정이 필요할 수 있다. 그 설정을 EB에서는 .ebextensions 디렉토리, .platform 디렉토리로 설정해줄 수 있다. EC2 리버스 프록시 설정하기로드 밸런서가 보내는 트래픽을 EC2에서 애플리케이션으로 전달 할 때 리버시 프록시를 설정해줄 수 있다. 우리가 사용하는 Linux 2 플랫폼은 Nginx로 리버스 프록시를 구현할 수 있다. 이때 .platform/nginx/nginx.conf 파일을 통해서 EC2의 Nginx의 설정을 오버라이딩 할 수 있다. .platform/nginx/conf.d/&#123;설정파일이름&#125;.conf에 파일을 만들면 기존의 Nginx 설정 파일에 설정을 추가하는 방식으로 구현할 수 있다. 우리는 .platform/nginx/nginx.conf 파일을 프로젝트에 추가해서 Nginx 설정을 오버라이딩 하는 방식으로 구현했다. /로 오는 모든 요청은 로컬의 8080포트로 보내도록 구현했다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556user nginx;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;worker_processes auto;worker_rlimit_nofile 33282;events &#123; use epoll; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; include conf.d/*.conf; map $http_upgrade $connection_upgrade &#123; default &quot;upgrade&quot;; &#125; upstream springboot &#123; server 127.0.0.1:8080; keepalive 1024; &#125; server &#123; listen 80 default_server; location / &#123; proxy_pass http://springboot; proxy_http_version 1.1; proxy_set_header Connection $connection_upgrade; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; access_log /var/log/nginx/access.log main; client_header_timeout 60; client_body_timeout 60; keepalive_timeout 60; gzip off; gzip_comp_level 4; # Include the Elastic Beanstalk generated locations include conf.d/elasticbeanstalk/healthd.conf; &#125;&#125; EB 환경 커스텀하기EB에서 가동 중인 EC2에 파일을 추가한다던지 커맨드를 실행하고 싶은 경우 .ebextensions 디렉토리에 config 확장자로 파일을 추가하면 된다. 우리는 JAR 배포 스크립트와 로깅 설정파일을 생성하고 EC2 타임존 설정 커맨드를 실행하도록 구현해보자.ebextension/00-makeFiles.config 12345678910111213141516171819202122232425262728293031323334353637383940files: &quot;/sbin/appstart&quot; : mode: &quot;000755&quot; owner: webapp group: webapp content: | #!/usr/bin/env bash JAR_PATH=/var/app/current/application.jar # run app killall java java -Dfile.encoding=UTF-8 -Dspring.profiles.active=main -jar $JAR_PATH &quot;/opt/elasticbeanstalk/tasks/taillogs.d/applogs.conf&quot;: mode: &quot;000755&quot; owner: webapp group: webapp content: | /var/app/current/logs/log/*.log &quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/applogs.conf&quot;: mode: &quot;000755&quot; owner: webapp group: webapp content: | /var/app/current/logs/log/*.log &quot;/opt/elasticbeanstalk/tasks/taillogs.d/dblogs.conf&quot;: mode: &quot;000755&quot; owner: webapp group: webapp content: | /var/app/current/logs/db/*.log &quot;/opt/elasticbeanstalk/tasks/bundlelogs.d/dblogs.conf&quot;: mode: &quot;000755&quot; owner: webapp group: webapp content: | /var/app/current/logs/db/*.log .ebextension/01-setupKSTTimezone.config 123commands: set_time_zone: command: ln -f -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime Procfile을 사용해서 애플리케이션 프로세스 구성애플리케이션이 실행하기 위한 커맨드를 모은 파일이다. Procfile의 프로세스는 계속 실행 될 것으로 기대하고 EB에서 해당 프로세스를 모니터링하고 종료된 프로세스는 재시작한다. Procfile 1web: appstart Github Actions로 CICD 구축하기CI 스크립트 작성사실 CI 스크립트는 매우 간단하다. Github Actions에 대한 지식이 있으면 구현할 수 있다. .github/workflows/backend.yml 1234567891011121314151617181920212223242526272829303132333435363738name: backendon: pull_request: branches: - main - release paths: - &#x27;backend/**&#x27;defaults: run: working-directory: backendjobs: build: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 - name: set up JDK uses: actions/setup-java@v3 with: java-version: &#x27;11&#x27; distribution: &#x27;temurin&#x27; - name: grant execute permission for gradlew run: chmod +x gradlew - name: gradle build run: ./gradlew build - name: add comments to a pull request uses: mikepenz/action-junit-report@v3 if: always() with: report_paths: backend/build/test-results/test/TEST-*.xml IAM 인증키 발급받아 Github Actions에서 사용하기외부에서 AWS 리소스에 접근하려면 IAM을 통해 액세스 키가 필요하다. AWS IAM에 가서 사용자를 추가해주자. 해당 IAM 사용자에게 EB에 접근할 수 있는 권한을 설정해주면 된다. 이렇게 IAM 사용자를 만들면 액세스 키와 시크릿키가 생성된다. 이 두 키를 깃허브 레포지토리에 액션 시크릿으로 추가해준다. 필자는 액세스 키는 AWS_ACCESS_KEY_ID, 시크릿 키는 AWS_SECRET_ACCESS_KEY로 설정했다. CD 스크립트 작성우리는 beanstalk-deploy라는 Github Actions 플러그인을 사용해서 배포 스크립트를 작성해본다.스크립트에 주석으로 각 단계가 어떤 의미 인지 기록해두었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172name: deploy eb backendon: workflow_dispatch: push: branches: - main defaults: run: working-directory: backendjobs: build: runs-on: ubuntu-latest steps: - name: Set up JDK uses: actions/setup-java@v3 with: java-version: &#x27;11&#x27; distribution: &#x27;temurin&#x27; - name: Checkout source code uses: actions/checkout@v2 with: submodules: &#x27;true&#x27; # 서브 모듈이 존재하는 경우 반드시 넣어준다. token: $&#123;&#123; secrets.GH_ACCESS_TOKEN &#125;&#125; - name: Setup Gradle uses: gradle/gradle-build-action@v2 with: cache-read-only: $&#123;&#123; github.ref != &#x27;refs/heads/main&#x27; &#125;&#125; - name: Grant execute permission for gradlew run: chmod +x gradlew - name: Execute Gradle build run: ./gradlew bootJar - name: Get current time # 현재 시각을 기록해둔다. uses: 1466587594/get-current-time@v2.0.2 id: current-time with: format: YYYY-MM-DDTHH-mm-ss utcOffset: &quot;+09:00&quot; - name: Generate deployment package # JAR 파일과 함께 이전에 만들었던 설정파일을 함께 zip파일로 압축한다. run: | mkdir -p deploy cp build/libs/f12-0.0.1-SNAPSHOT.jar deploy/application.jar cp Procfile deploy/Procfile cp -r .ebextensions deploy/.ebextensions cp -r .platform deploy/.platform cd deploy &amp;&amp; zip -r deploy.zip . - name: Deploy to EB uses: einaregilsson/beanstalk-deploy@v21 with: aws_access_key: $&#123;&#123; secrets.AWS_ACCESS_KEY_ID &#125;&#125; # IAM aws_secret_key: $&#123;&#123; secrets.AWS_SECRET_ACCESS_KEY &#125;&#125; # IAM application_name: f12-prod-backend environment_name: F12prodbackend-env-2 version_label: github-action-$&#123;&#123;steps.current-time.outputs.formattedTime&#125;&#125; # 버전명을 아까 기록한 시간을 토대로 구분하게 했다. region: ap-northeast-2 deployment_package: backend/deploy/deploy.zip wait_for_environment_recovery: 180 # 배포가 Green으로 돌아오는 시간을 고려해 환경 회복 시간을 180초로 하였다. - name: add comments to a pull request uses: mikepenz/action-junit-report@v3 if: always() with: report_paths: backend/build/test-results/test/TEST-*.xml 참고https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.htmlhttps://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/concepts-webserver.htmlhttps://docs.aws.amazon.com/elasticbeanstalk/latest/dg/platforms-linux-extend.htmlhttps://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/java-se-procfile.htmlhttps://techblog.woowahan.com/2539/","categories":[{"name":"Infra","slug":"infra","permalink":"https://yangdongjue5510.github.io/categories/infra/"}],"tags":[],"keywords":[{"name":"Infra","slug":"infra","permalink":"https://yangdongjue5510.github.io/categories/infra/"}]},{"title":"AWS의 Blue-Green 배포 구현 방법 알아보기","slug":"awsBlueGreen","date":"2022-12-13T09:55:21.000Z","updated":"2022-12-13T16:46:33.137Z","comments":true,"path":"2022/12/13/awsBlueGreen/","link":"","permalink":"https://yangdongjue5510.github.io/2022/12/13/awsBlueGreen/","excerpt":"","text":"문제 배경우아한테크코스에서 프로젝트를 진행할 때는 우아한테크코스에 AWS 계정을 제공해줘서 EC2를 비용 걱정없이 갯수 상관없이 사용할 수 있었다. 하지만 우아한테크코스를 수료하고 나서는 AWS 계정 제공이 되지 않아서 팀원들이 자체 AWS 계정을 만들어서 인프라를 구축해야 했다. 이때 AWS에서는 프리티어로 RDS 인스턴스 한 개와 EC2 인스턴스 한 개를 제공해주는 점을 활용해서 최대한 비용을 줄일 수 있다.하지만 기존 프로젝트는 CD와 무중단 배포를 위해 젠킨스를 EC2로 띄워서 구현했다. 그리고 Nginx를 따로 EC2로 띄워서 리버스 프록시 및 로드밸런싱 기능을 할 수 있도록 구축했다. 그래서 하나의 EC2로는 기존의 인프라 구조를 구현하기 어렵다. AWS 무중단 배포를 구현하는 여러 방법들기존에는 젠킨스의 스크립트로 Nginx를 조절하는 방식으로 우리가 직접 Blue-Green 무중단 배포를 구현하는 방식이었다.하지만 EC2 사용 갯수가 제한된 상황이기 때문에 AWS에서 제공하는 Blue-Green 무중단 배포 방법들을 참고해서 문제를 해결해보자. Route 53으로 DNS 라우팅 업데이트AWS의 DNS 서비스인 Route 53을 활용해서 무중단 배포를 구현할 수 있다. 다음과 같은 가중분포의 경우는 점진적으로 Green 환경으로 트래픽을 분산시킬 수 있다. 트래픽의 일부를 새로운 환경에서 처리해보도록 하는 카나리아 배포를 구현할 수 있다. ELB를 사용하면 Green 환경이 점차적으로 전체 프로덕션 부하를 감당하도록 점진적으로 스케일 아웃 할 수 있다. 다만 ELB에서 스케일 아웃은 즉시 이뤄지지 않으니 스케일 아웃이 잘 작동하는 지 모니터링하고 문제를 감지할 수 있도록 구현하는 게 중요하다. Green 환경에서 문제가 발견되면 Route 53의 DNS 레코드를 롤백하는 방식으로 Blue 환경으로 롤백시킨다. 하지만 DNS 라우팅은 DNS TTL(클라이언트가 DNS 쿼리를 어느 시간만큼 캐시)를 고려해야 하고, 심지어는 클라이언트에 따라서는 특정 세션이 이전 환경에 연결되어 있는 경우가 존재할 수 있다. Elastic Load Balancer 뒤에서 Auto Scaling 그룹 교체DNS 라우팅 업데이트를 활용한 방법이 복잡하다면 ELB와 Auto Scaling 그룹을 활용해서 Blue-Green 배포를 구현할 수 있다. 다음과 같이 Blue 환경을 대기 상태로 만들어 놓고 유사 시에 빠르게 이전 버전으로 롤백할 수 있게 구현할 수도 있다. 만약 그럴 필요가 없는 경우는 이전 Auto Scaling 그룹을 폐기하면 된다. 이 방식은 DNS 방식만큼 세분하게 구현할 수는 없지만 DNS가 복잡하다면 도입해볼만 하다. Elastic Beanstalk 애플리케이션 환경 교체EB를 활용하면 인프라에 대한 지식이 많지 않아도 쉽게 애플리케이션을 배포할 수 있다. 배포하려는 어플리케이션 번들과 어플리케이션 버전, 멏 가지 정보를 제공하면 EB가 해당 정보를 기반으로 어플리케이션을 배포하고 어플리케이션에 액세스할 수 있는 URL을 제공한다. EB는 Auto Scaling 그룹을 추가하는 방식이나 일부 인스턴스를 업데이트하는 방식으로 하나의 환경 안에서 롤링 방식으로 무중단 배포를 구현할 수 있다. EB를 활용해서 Blue-Green 배포를 할 수도 있다. 배포되고 있던 환경과 동일한 환경을 만들고 해당 환경을 새 버전 어플리케이션으로 교체한 다음 새로운 환경의 URL을 DNS에서 업데이트 하는 방식으로 설계할 수 있다. 참고https://docs.aws.amazon.com/whitepapers/latest/blue-green-deployments/implementation-techniques.html","categories":[{"name":"Infra","slug":"infra","permalink":"https://yangdongjue5510.github.io/categories/infra/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Infra","slug":"infra","permalink":"https://yangdongjue5510.github.io/categories/infra/"}]},{"title":"Java11의 HttpClient로 서버에서 다른 API로 요청 보내기","slug":"java/woowa-tech-course/howToUseHttpClient","date":"2022-10-26T14:47:05.000Z","updated":"2022-10-31T00:52:56.788Z","comments":true,"path":"2022/10/26/java/woowa-tech-course/howToUseHttpClient/","link":"","permalink":"https://yangdongjue5510.github.io/2022/10/26/java/woowa-tech-course/howToUseHttpClient/","excerpt":"","text":"도입 배경Github Oauth를 통해 인증인가를 구현하던 과정에서 깃허브에서 발급된 코드를 통해 Github API에 Github Access Token을 발급 요청을 보내야했다. 그리고 발급된 Github Access Token을 통해 해당 사용자의 정보를 요청해야 했다. 선택 가능한 방법들서버에서 HTTP 요청을 보낼 수 있는 방법은 여러가지가 있다. HTTPClient RestTemplate WebClient 간단하게 세가지 방법을 비교하자면 다음과 같다. HttpClient RestTemplate WebClient 논블락킹 방식 제공 여부 제공 X (블락킹 방식) 제공 비동기 방식 제공 여부 제공 X (동기 방식) 제공 필요한 의존성 없음(Java 11에 포함) spring-boot-starter-web에 포함 webFlux에 포함 스프링 부트를 활용해서 프로젝트를 하는 경우 RestTemplate를 사용하는 경우가 많다. 하지만 스프링 공식문서의 RestTemplate 설명을 보면 작은 버그 수정만 앞으로 진행되고 큰 개선은 진행되지 않을 것이니 WebClient를 사용할 것을 권장한다.(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html) 하지만 WebClient를 사용하기 위해서는 webFlux를 의존성에 추가해줘야 한다. webFlux는 리액티브 프로그래밍을 스프링에서 제공하기 위한 모듈이다. 현재 우리 프로젝트는 스프링 MVC 기반 블락킹 동기 기반 어플리케이션인데 WebClient를 사용하기 위해 리액티브 프로그래밍을 지원하는 모듈을 추가해주는 것은 지나치다고 생각했다. 반면 HttpClient는 Java 11에 포함되어 있기 때문에 자바 버전만 지원된다면 다른 의존성을 추가해주지 않아도 된다. 그래서 우리 프로젝트에는 HttpClient를 사용하기로 했다. HttpClient 간단한 사용법동기 방식으로 GET, POST 요청 보내는 예시먼저 외부 API 역할을 하게 될 컨트롤러를 간단하게 구현해보자. 이를 위해서는 HttpCliet를 실행하는 프로젝트와 외부 API 역할을 할 스프링 부트 프로그램을 서로 다른 프로젝트로 분리해서 구현하기로 한다. 초간단 컨트롤러1234567891011121314@Controller@RequestMapping(&quot;/test&quot;)public class ExampleController &#123; @GetMapping(&quot;/sync&quot;) public ResponseEntity&lt;String&gt; syncGet() &#123; return ResponseEntity.ok(&quot;동기 GET 요청 처리 성공!&quot;); &#125; @PostMapping(&quot;/sync&quot;) public ResponseEntity&lt;String&gt; syncPost() &#123; return ResponseEntity.ok(&quot;동기 POST 요청 처리 성공!&quot;); &#125;&#125; 이제 초간단 컨트롤러의 프로젝트를 로컬에서 구동시킨다.이제 http://localhost:8080을 기본으로 작동한다. HttpClient를 활용한 HttpClientExample 구현이제 외부 API에 요청을 보내는 HttpClient를 구현해보자.일단 동기 방식으로 요청을 처리하는 간단한 예시를 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class HttpClientSyncExample &#123; private final Logger logger = LoggerFactory.getLogger(HttpClientSyncExample.class); private final ObjectMapper objectMapper = new ObjectMapper(); private final HttpClient httpClient = HttpClient.newBuilder() .version(Version.HTTP_2) .followRedirects(Redirect.NORMAL) .connectTimeout(Duration.ofSeconds(10)) .build(); public HttpResponse&lt;String&gt; requestSyncGetApi(final String uri) throws IOException, InterruptedException &#123; final HttpRequest request = HttpRequest.newBuilder(URI.create(uri)) .GET() .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE) .build(); final HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString()); validateSuccess(response); return response; &#125; private &lt;T&gt; void validateSuccess(final HttpResponse&lt;T&gt; response) &#123; final HttpStatus status = HttpStatus.resolve(response.statusCode()); if (status == null || status.isError()) &#123; logger.warn(&quot;URI: &#123;&#125;, STATUS: &#123;&#125;&quot;, response.uri(), response.statusCode()); throw new RuntimeException(&quot;요청 처리 실패&quot;); &#125; logger.info(&quot;URI: &#123;&#125;, STATUS: &#123;&#125;, BODY : &#123;&#125;, &quot;, response.uri(), response.statusCode(), response.body()); &#125; public HttpResponse&lt;String&gt; requestSyncPostApi(final String uri, final Object requestBody) throws IOException, InterruptedException &#123; final String requestBodyString = objectMapper.writeValueAsString(requestBody); final HttpRequest request = HttpRequest.newBuilder(URI.create(uri)) .POST(BodyPublishers.ofString(requestBodyString)) .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE) .build(); final HttpResponse&lt;String&gt; response = httpClient.send(request, BodyHandlers.ofString()); validateSuccess(response); return response; &#125;&#125; HttpClient 객체를 만들어 놓고, 필요할 때마다 HttpRequest를 만들어서 HttpClient 객체에 send 메서드를 통해 요청을 보낸다. 그리고 POST 요청을 보낼 때는 Body 값을 Object Mapper로 객체를 문자열로 만들어서 보내줘야 한다. 테스트 코드로 작동 확인하기이제 테스트 메서드 몇 개를 만들어서 동작을 확인해보자. 12345678910111213141516171819202122232425262728293031323334353637class HttpClientTest &#123; private final HttpClientSyncExample httpClientSyncExample = new HttpClientSyncExample(); @Test @DisplayName(&quot;동기 방식으로 GET 요청을 보낸다.&quot;) void syncGet() throws IOException, InterruptedException &#123; // given final String uri = &quot;http://localhost:8080/test/sync&quot;; // when final HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncGetApi(uri); // then assertAll( () -&gt; assertThat(response.statusCode()).isEqualTo(200), () -&gt; assertThat(response.body()).isEqualTo(&quot;동기 GET 요청 처리 성공!&quot;) ); &#125; @Test @DisplayName(&quot;동기 방식으로 POST 요청을 보낸다.&quot;) void syncPost() throws IOException, InterruptedException &#123; // given final String uri = &quot;http://localhost:8080/test/sync&quot;; final String requestBody = &quot;bodyValue&quot;; // when final HttpResponse&lt;String&gt; response = httpClientSyncExample.requestSyncPostApi(uri, requestBody); // then assertAll( () -&gt; assertThat(response.statusCode()).isEqualTo(200), () -&gt; assertThat(response.body()).isEqualTo(&quot;동기 POST 요청 처리 성공!&quot;) ); &#125;&#125; 테스트를 실행해보면 다음과 같이 모두 잘 작동하는 것을 볼 수 있다. 참고 https://www.baeldung.com/java-9-http-clienthttps://golb.hplar.ch/2019/01/java-11-http-client.htmlhttps://github.com/yangdongjue5510/http-client Java 11의 HttpClient 사용법을 배울 수 있는 레포지토리.동기 방식 뿐만 아니라 비동기 방식도 학습 테스트를 통해 배울 수 있도록 구현해놨다.github.com](https://github.com/yangdongjue5510/http-client)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"RestDocs의 Custom Snippet으로 에러코드 쉽게 문서화하기","slug":"restDocsErrorCode","date":"2022-10-25T08:21:29.000Z","updated":"2022-10-30T22:43:07.264Z","comments":true,"path":"2022/10/25/restDocsErrorCode/","link":"","permalink":"https://yangdongjue5510.github.io/2022/10/25/restDocsErrorCode/","excerpt":"","text":"배경RestDocs로 테스트를 통과한 API에 대해서 문서화를 할 수 있다.우리 프로젝트에서는 정상 요청 흐름을 중점으로 API 문서화했다.하지만 해당 API에서 발생 가능한 애외 상황에 대한 응답도 정리해줘야 했다.그래서 우리는 백엔드 단에서 발생하는 예외에 매핑되는 예외 코드를 만들어서 예외 상황 발생 시 해당 예외 코드를 바디에 담아서 반환하도록 해서 대해 API 사용자들이 어떤 문제가 발생해는 지 알 수 있도록 했다.문제는 특정 API에 해당하는 예외 코드들을 어떻게 문서화하는 지 였다. 코드 예시restDocs 환경 설정은 생략했다. 예시 컨트롤러만약 id값이 1보다 작으면 예외를 반환하는 아주 간단한 예시 컨트롤러이다. 123456789101112@RestControllerpublic class SimpleController &#123; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public ResponseEntity&lt;String&gt; getSimple(@PathVariable final Long id) &#123; if (id &lt; 1) &#123; throw new IllegalArgumentException(&quot;id값은 무조건 1보다 커야 합니다.&quot;); &#125; final String body = String.format(&quot;simple id is %d&quot;, id); return ResponseEntity.ok(body); &#125;&#125; 예시 에러코드사용자에게 알려줄 예외 코드를 enum으로 관리한다. 12345678910111213141516public enum ErrorCode &#123; ILLEGAL_ARGUMENT(&quot;40000&quot;); private final String value; ErrorCode(final String value) &#123; this.value = value; &#125; @JsonValue public String getValue() &#123; return value; &#125;&#125; 예시 테스트성공 사례를 확인하는 예시 테스트이다. 123456789101112131415161718@AutoConfigureRestDocs@WebMvcTest(SimpleController.class)@ExtendWith(RestDocumentationExtension.class)class SimpleControllerTest &#123; @Autowired private MockMvc mockMvc; @Test void getSimple() throws Exception &#123; final ResultActions actual = mockMvc.perform(get(&quot;/simple/1&quot;) .accept(MediaType.APPLICATION_JSON)) .andDo(print()) .andDo(document(&quot;get-simple&quot;)); actual.andExpect(jsonPath(&quot;$&quot;).value(&quot;simple id is 1&quot;)); &#125;&#125; 예시 adoc 파일새로운 adoc 파일을 만들어서 다음과 같이 생성된 스니펫을 넣어주고 테스트를 실행시켜서 성공하면 스니펫이 적용된 html을 얻을 수 있다. 1operation::get-simple[snippets=&#x27;http-request,http-response&#x27;] 에러 코드를 어떻게 문서화할까?초창기 프로젝트에서 각 API에 에러코드를 명시했던 방법은 매우 간단하다.그냥 adoc파일에 에러코드를 같이 적어주는 것이다.(…) 12345=== 발생 가능한 예외- 40000 (예시)operation::get-simple[snippets=&#x27;http-request,http-response&#x27;] 이렇게 하면 다음과 같이 그대로 API 예시 요청과 응답에 해당하는 예시코드를 문서화 할 수는 있다. 문제는 API를 추가로 개발하거나 에러 상황이 바뀌게 되면 일일히 adoc 파일에 들어가서 해당 에러코드를 수정해줘야 한다. 그리고 예외 코드를 직접 적어줘야 하니 헷갈리는 여지가 많았다. RestDocs의 커스텀 스니펫을 활용해보기커스텀 스니펫은 사용자가 특정한 데이터를 전달받아서 restDocs에 사용되는 스니펫의 형태를 직접 정해서 렌더링할 수 있게 하는 방법이다. 스니펫 형식 만들기우리가 문서화할 형식을 먼저 만들어보자. 문서에서 에러코드를 어떤 식으로 표현할지를 만들어주면 된다. 우리는 표 형식으로 에러코드를 만들고자 한다. 이때 mustache 문법을 활용해서 전달받은 error-codes를 순회하면서 표를 만들도록 작성했다.그리고 이 내용을 src/test/resources/org/springframework/restdocs/templates/asciidoctor 이 경로에 저장해주면 된다. 우리는 src/test/resources/org/springframework/restdocs/templates/asciidoctor/error-code-table.snippet 으로 저장했다. 1234567|===|분류|코드&#123;&#123;#error-codes&#125;&#125;|&#123;&#123;name&#125;&#125;|&#123;&#123;value&#125;&#125;&#123;&#123;/error-codes&#125;&#125;|=== TemplateSnippet 정의하기이제 커스텀 스니펫에 어떤 데이터를 넣어서 만들 것인지 정의해보자. spring framework의 RestDocs에는 TemplatedSnippet이라는 추상 클래스를 지원한다.RestDocs는 TemplatedSnippet을 기본으로 다양한 스니펫을 만들어서 문서화 한다. 위에서 예시로 봤던 요청 스니펫과 응답 스니펫도 TemplatedSnippet을 상속받은 HttpRequestSnippet이나 HttpResponseSnippet을 통해서 스니펫을 만든다. 1234567891011121314151617181920212223public abstract class TemplatedSnippet implements Snippet &#123; private final Map&lt;String, Object&gt; attributes = new HashMap&lt;&gt;(); private final String snippetName; private final String templateName; protected TemplatedSnippet(String snippetName, Map&lt;String, Object&gt; attributes) &#123; this(snippetName, snippetName, attributes); &#125; protected TemplatedSnippet(String snippetName, String templateName, Map&lt;String, Object&gt; attributes) &#123; this.templateName = templateName; this.snippetName = snippetName; if (attributes != null) &#123; this.attributes.putAll(attributes); &#125; &#125; // 생략...&#125; 이제 우리가 원하는 스니펫을 정의해보자 12345678910public class ErrorCodeSnippet extends TemplatedSnippet &#123; public ErrorCodeSnippet(ErrorCode... errorCodes) &#123; super(&quot;error-code-table&quot;, Map.of(&quot;error-codes&quot;, errorCodes)); &#125; @Override protected Map&lt;String, Object&gt; createModel(final Operation operation) &#123; return operation.getAttributes(); &#125;&#125; 스니펫을 생성할 때 에러 코드를 가변 인자로 전달해주면 그 가변인자를 생성자를 통해 전달해주고 TemplateSinppet의 생성자를 호출해서 스니펫을 생성한다. 이때 우리가 스니펫의 이름을 전달해주고 해당 스니펫 속성에 해당하는 Map에 담아 전달해준다. 커스텀 스니펫 적용해보기이제 adoc 파일에 직접 에러 코드를 적는 방식을 우리의 커스텀 스니펫으로 개선해보자! 먼저 기존의 테스트 코드에 우리의 커스텀 스니펫을 생성해서 문서화할 에러 코드를 생성자의 인자로 전달해준다! 이때 실제 코드가 아닌 자바 enum을 전달해주면 되고 테스트 코드 안에서 문서화 할 내용을 관리해 줄 수 있어서 더 간편한다! 123456789101112131415161718@AutoConfigureRestDocs@WebMvcTest(SimpleController.class)@ExtendWith(RestDocumentationExtension.class)class SimpleControllerTest &#123; @Autowired private MockMvc mockMvc; @Test void getSimple() throws Exception &#123; final ResultActions actual = mockMvc.perform(get(&quot;/simple/1&quot;) .accept(MediaType.APPLICATION_JSON)) .andDo(print()) .andDo(document(&quot;get-simple&quot;, new ErrorCodeSnippet(ErrorCode.ILLEGAL_ARGUMENT))); actual.andExpect(jsonPath(&quot;$&quot;).value(&quot;simple id is 1&quot;)); &#125;&#125; 그리고 adoc에도 우리가 만든 커스텀 스니펫을 쓰겠다고 적어줘야 한다! 스니펫에 error-code-table이 추가됐음을 확인할 수 있다. 123=== 발생 가능한 예외operation::get-simple[snippets=&#x27;error-code-table,http-request,http-response&#x27;] 이렇게 해놓고 테스트를 성공시키면 다음과 같이 문서화가 된다. 참고문서https://techblog.woowahan.com/2597/ https://docs.spring.io/spring-restdocs/docs/2.0.3.RELEASE/reference/html5/#documenting-your-api-customizing https://medium.com/@rfrankel_8960/generating-custom-templated-snippets-with-spring-rest-docs-d136534a6f29","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"인증 인가에 사용되는 토큰을 어디에서 관리할까? (이론 편)","slug":"refreshTokenTheory","date":"2022-10-19T15:07:07.000Z","updated":"2022-10-31T00:52:16.158Z","comments":true,"path":"2022/10/20/refreshTokenTheory/","link":"","permalink":"https://yangdongjue5510.github.io/2022/10/20/refreshTokenTheory/","excerpt":"","text":"이번 포스트에서는 우아한테크코스 팀 프로젝트에서 리프레시 토큰을 적용하게 된 계기를 정리해본다. 배경우아한기크코스 팀 프로젝트 회의 중 현재 우리가 사용하고 있는 인증 인가 방식을 현업에서도 유효한가에 대해 의논한 적이 있다.당시 팀 프로젝트의 인증 인가는 JWT 액세스 토큰을 세션 스토리지에 저장해놓는 방식으로 운영하고 있었다. 문제 상황이 방식에는 크게 두가지 문제가 있다고 생각했다.먼저 세션 스토리지에 저장할 경우 브라우저를 닫으면 저장된 토큰 정보가 날아간다.대부분의 서비스는 탭이나 브라우저를 닫는다고 로그아웃되지 않는다.우리는 세션 스토리지에 사용자 인증 정보를 담아서는 안되겠다고 판단했다. 대안 비교하기브라우저를 닫아도 사용자가 로그인 한 상태가 유지되려면 사용자 인증 정보를 세션 스토리지가 아닌 다른 곳에 저장해야 했다.쿠키나 로컬 스토리지가 가능한 선택지였다 쿠키먼저 쿠키에 대해 고민해보자.쿠키의 가장 큰 문제점은 CSRF 공격이 위험하다는 점이다.쿠키는 매번 HTTP 요청에 같이 포함되서 가기 때문에 공격자가 [POST] /review/1 이런 URL을 실행시키도록 유도해서 사용자가 의도하지 않은 행동을 실행시킬 수 있다.서버에서는 같이 온 쿠키로 사용자 정보를 확인에 성공했으니 더 의심하지 않고 요청을 수행하게 되서 문제가 된다. 반면 쿠키는 httpOnly 속성을 활용하면 xss 공격을 막을 수 있다.httpOnly 속성을 사용하면 자바스크립트로 접근이 불가능하기 때문에 xss 공격으로 스크립트를 실행해도 쿠키의 내용을 알지 못한다. 로컬 스토리지반면 로컬 스토리지는 어떨까?로컬 스토리지는 세션 스토리지와 함께 HTML5 스토리지라고 불린다.로컬 스토리지를 사용하게 되면 세션 스토리지와는 다르게 브라우저를 닫아도 정보가 사라지지 않는다.프론트엔드는 로컬 스토리지에 담겨있는 토큰을 꺼내서 Authorization 헤더에 담아 요청을 보낸다. 이 방법은 CSRF 공격에 비교적 안전하다.왜냐면 쿠키와 다르게 자동으로 요청에 함께 포함되지 않고 자바스크립트로 로컬 스토리지로 꺼내서 Authorization 헤더에 담는 추가적인 행위가 필요하므로 CSRF 공격으로는 하기 어렵다. 하지만 로컬 스토리지(뿐만 아니라 HTML5 스토리지 모두) XSS 공격에 취약하다는 문제가 있다.쿠키와 다르게 로컬 스토리지는 애초에 자바스크립트에서 사용하기 위해 등장한 개념이라 httpOnly를 적용한 쿠키처럼 자바스크립트의 접근을 막을 수 없다. 그래서 다음과 같은 HTML 코드를 삽입하는 XSS 공격에 취약할 수 있다. 1&lt;script&gt;alert(localStorage.getItem(&#x27;access-token&#x27;))&lt;/script&gt; 지금까지 대안을 정리하면 다음과 같다. 비교 세션 스토리지 로컬 스토리지 쿠키 회원 정보 유지 불가능 가능 가능 CSRF 공격 방어 방어 취약 XSS 공격 취약 취약 httpOnly 사용시 방어 대안 선택 기준우리는 대안을 선택할 때 다음과 같은 기준을 정해두고 생각했다. 브라우저를 닫아도 회원 정보가 유지될 것 CSRF 공격과 XSS 공격을 최대한 막아볼 것 만에 하나 액세스 토큰이 탈취되었더라도 피해를 최소화 할 것 인증 인가를 통한 DB 부하를 줄일 수 있을 것 먼저 1번을 고려했을 때 세션 스토리지(기존 방식)은 제외해야 했다. 2번을 고려하면 로컬 스토리지와 쿠키 모두 각자 다른 곳에서 취약함을 알 수 있었다.다만 로컬 스토리지 XSS 공격은 리액트에서 어느정도 막아줄 수 있다. 하지만 리액트에 의존해서 XSS 공격을 막는 것은 부족하다고 생각했다. 반면 쿠키의 CSRF 공격은 추가적인 방어 수단을 고려해야 한다.쿠키의 CSRF 공격 취약성은 CSRF 토큰을 도입해서 해결할 수 있다고 한다.CSRF 토큰은 난수를 서버에서 저장하고 매 요청마다 클라이언트가 난수를 같이 보내서 서버에서 난수가 일치하는 지 확인하는 방식이다.문제는 난수를 서버에서 관리하는 비용이 있고 만약 난수를 DB에서 관리할 경우 매 요청마다 DB에 접근해서 난수를 비교해야하는 비용도 존재했다. 또한 CSRF 공격을 referer 헤더를 체크하는 방식으로 막을 수도 있다.referer는 공격자가 위조할 수 있는 요소라서 referer 체크로는 CSRF 공격을 막기 힘들다고 생각했다. 3번은 우리가 예상하지 못한 경우를 대비한다.즉 어찌됐건 토큰이 유출됐을 경우 피해를 최소화하기 위해서는 액세스 토큰의 유효 시간을 짧게 설정할 필요가 있었다.하지만 액세스 토큰 유효시간을 짧게 설정하면 너무 빠르게 로그아웃되어버리는 현상이 발생할 수 있었다. 이럴 때 사용되는 것이 리프레시 토큰이다. 리프레시 토큰은 다른 포스트로 이어서 설명해보겠다. 4번은 간단하다 보안을 생각하는 것은 좋으나 그렇다고 지나치게 DB 서버에 부하를 주는 방식은 곤란하다. 왜냐면 우리 프로젝트의 서비스가 금융과 관련된 보안에 민감한 서비스는 아니기 때문에 보안 때문에 성능을 포기하면 안된다고 생각했다. 4번 관점에서는 CSRF 토큰을 사용하기는 어려웠다. 대안 선택 하기우리가 선택한 방법은 리프레시 토큰을 httpOnly 쿠키에 담고 액세스 토큰을 자바스크립트 변수로 관리하는 방식이었다. 이렇게 하면 우리의 선택 기준을 충족할 수 있었다. 브라우저를 닫아도 쿠키에 저장된 리프레시 토큰으로 다시 액세스 토큰을 발급받으면 되니 회원 정보를 유지할 수 있었다. XSS 공격은 httpOnly 속성으로 방지하고 CSRF 공격은 리프레시 토큰만으로는 액세스 토큰 발급을 제외한 다른 행위를 할 수 없으니 해커의 공격 가능한 범위를 줄이는 방식으로 대응했다.만약 액세스 토큰을 발급하는 데 성공해도 해커는 이 응답값에 접근할 수 없으므로 큰 위협이 되지 않는다. 액세스 토큰이 만에 하나 갈취되어도 짧은 유효시간을 적용하면 해커가 공격 가능한 시간이 적어져 대응 가능하다고 판단했다.만약 유효시간이 훨씬 긴 리프레시 토큰이 갈취 되었을 경우에는 액세스 토큰을 발급하면 만료시키는 방식으로 대응했다.이렇게 하면 리프레시 토큰이 갈취되어도 액세스 토큰 한 개의 시간 만큼만 공격에 노출된다. 리프레시 토큰을 통해 액세스 토큰을 발급받을 때 추가적인 DB 접근 비용이 필요했다.하지만 CSRF 토큰을 도입했을 경우처럼 매 요청마다 DB를 접근하는 것이 아닌 액세스 토큰을 발급할 때만 DB에 접근해서 감당 가능하다고 봤다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"Spring boot에서 JWT 토큰 발급 구현하기","slug":"spring/springBootJwt","date":"2022-09-26T14:28:39.000Z","updated":"2022-10-26T14:54:03.597Z","comments":true,"path":"2022/09/26/spring/springBootJwt/","link":"","permalink":"https://yangdongjue5510.github.io/2022/09/26/spring/springBootJwt/","excerpt":"","text":"도입 배경우아한테크코스에 프로젝트를 진행하는데 사용자의 정보를 기억해야 하는 상황이 필요한 경우가 있다. 예를 들면 사용자가 작성한 리뷰를 삭제하거나 수정할 수 있어야 한다. 그러려면 현재 접속한 사용자가 이전에 리뷰를 작성한 사용자임을 알아낼 수 있어야 한다. 일단 사용자를 구분하기 위해서 로그인을 해서 사용자를 구분해서 관리할 수 있도록 했다. 이때 사용자 인증하는 역할은 깃허브Oauth를 활용해서 깃허브에서 사용자를 인증하고 사용자의 정보를 반환한다. 이제 사용자에 대한 정보를 우리 프로젝트 서버로 가져왔다. 이 정보를 어딘가에 기억해놔야 사용자가 다음에 요청을 했을 때 같은 사용자임을 알 수 있다. 세션, JWT 토큰정보를 어디에 저장할 지, 어떻게 저장할 지에 따라 세션, JWT 토큰을 활용하는 방법이 있다.(쿠키에 사용자 정보를 그대로 저장하는 방법도 있지만 보안에 취약해서 제외했다.) 세션세션 방식은 서버의 세션에 사용자의 정보를 저장하고 해당 세션에 저장할 때 발급되는 JSESSIONID를 클라이언트에게 전달해서 클라이언트는 JSESSIONID를 요청 보낼 때 같이 보낸다. 서버는 요청과 함께 온 JSESSIONID를 통해 서버의 세션에 저장된 정보를 찾아 사용자를 식별한다.즉 세션 방식은 사용자의 정보를 서버에 저장하는 방식이다. 문제는 만약 서버가 다중화가 되는 경우다. 필자가 사용하는 Spring의 경우 세션을 톰캣 내부에 저장하는 게 기본이다. 그럴 경우 사용자가 다른 서버로 요청을 보내게 되면 해당 서버의 세션에는 사용자 정보가 저장된 적 없으니 문제가 생긴다. 즉 여러 서버의 세션이 동기화를 해줘야 한다. 그래서 세션을 사용하는 실 서비스에서는 세션을 위한 DB 서버를 따로 관리한다. 세션을 위한 저장소를 따로 관리하는 경우 기존의 API 서버와 IO 비용을 생각해야 한다. 특히 여러 API 서버가 한 세션 서버에 요청을 보낼 경우 세션 서버에 지나친 부하가 생길 수 있다. JWT 토큰JWT 토큰은 JWT 토큰이라는 것에 사용자의 정보를 인코딩하여 담고 서버가 가진 시크릿키로 서명해서 만든 다음 클라이언트 쪽에서 저장하는 방법이다. 클라이언트는 자신이 가진 JWT 토큰을 요청을 보낼 때 같이 보내서 서버가 이를 받아 디코딩해서 사용하는 방식이다. 문제는 JWT 토큰에 담긴 정보는 누구나 디코딩 할 수 있다는 점이다. JWT 토큰의 페이로드에 담긴 값은 애초에 암호화한 값을 집어넣는 것이 아니라면 누구나 그 값이 어떤 값인지 디코딩 해서 볼 수 있다. 그래서 보안에 민감한 값은 JWT 토큰에 담지 않도록 한다. 더 큰 문제는 시크릿키가 노출되면 공격자가 JWT 토큰을 얼마든지 만들 수 있다는 점이다. 그래서 JWT 토큰을 사용할 때는 시크릿키를 깃허브같은 곳에 노출되지 않도록 주의해야 한다. 쿠키에 사용자 정보 그대로 저장 (비추천)쿠키에 사용자의 정보를 그대로 저장하는 방법은 추천하지 않는다. 일반적인 쿠키는 JS로 접근해서 내용을 볼 수 있기 때문에 XSS(Cross Site Scripting)을 통해 탈취 될 수 있다. 또한 스니핑(Sniffing, 서버와 클라이언트의 네트워크 중간에서 패킷을 탈취해서 도청) 공격을 통해 탈취 될 수 있다. 위 두 문제점은 막으려면 1. 쿠키의 Http-Only 옵션을 켜서 JS가 접근할 수 없도록 해야 한다. 2. 서버와 클라이언트의 통신을 HTTPS로 설정해서 중간에 도청해도 알 수 없도록 해야 한다. JWT 토큰을 고른 이유JWT 토큰은 서버에서 토큰을 어떻게 저장할 지 고민하지 않아도 되는 점이 컸다. 특히 서비스의 특성에 따라 달라지는데, 우리 서비스는 단순 리뷰 서비스이기 때문에 지금 단계에서는 JWT 토큰으로 간단하게 사용자를 식별해도 괜찮다고 판단했다. JWT 토큰에 사용되는 시크릿키는 서브 모듈로 따로 Private 레포지토리를 만들어서 관리하면 해결된다고 판단했다. Spring Boot에서 JWT 토큰 발급하기일단 JWT 토큰에 어떤 값을 저장해서 서버와 클라이언트가 주고 받을 것인지 결정해야 한다. 우리 서비스는 사용자의 정보를 DB에 저장할 때 생성된 MemberID를 페이로드에 담았다. 로그인을 할 때 인증 인가 로직 흐름은 다음과 같다. 클라이언트에서 깃허브에 코드를 요청한다. 깃허브는 해당 클라이언트가 깃허브의 사용자인지 확인하고 코드를 반환한다. 클라이언트는 서버에 깃허브에서 받은 코드를 넘겨서 로그인 요청을 날린다. 서버는 코드를 통해 깃허브 API용 access token을 요청한다. 깃허브는 코드를 확인하고 깃허브 API에 접근할 수 있는 access token을 발급한다. 서버는 깃허브 API access token을 통해 사용자의 정보를 요청한다. 깃허브는 access token을 확인하고 해당 사용자의 정보를 반환한다. 서버는 사용자의 정보를 받고 이를 DB에 최신화한다. (만약 깃허브 이름이 변했을 경우 반영해주기 위함) 서버는 DB에 저장된 사용자의 ID를 통해 JWT 토큰을 만들어서 클라이언트에게 반환한다. 이제 클라이언트는 인가가 필요한 요청에 받은 JWT 토큰을 요청 헤더(Authorization)에 담아서 보낸다. 서버는 클라이언트의 Authorization 헤더에 저장된 JWT 토큰이 우리 서버가 발급한 것인지, 유효한 것인지 확인하고 요청을 수행한다. 서버 입장에서는 3, 4, 6, 8, 9, 11을 처리해주면 된다. AuthController먼저 3번 먼저 구현해보자. 로그인 요청을 받는 AuthController 예시이다. 12345678910111213141516@RestController@RequestMapping(&quot;/api/v1&quot;)public class AuthController &#123; private final AuthService authService; public AuthController(final AuthService authService) &#123; this.authService = authService; &#125; @GetMapping(&quot;/login&quot;) public ResponseEntity&lt;LoginResponse&gt; login(@RequestParam final String code) &#123; final LoginResult loginResult = authService.login(code); return ResponseEntity.ok(LoginResponse.from(loginResult)); &#125;&#125; 여기서 파라미터로 오는 코드는 깃허브에서 사용자 인증에 성공했을 경우 돌려받는 코드이다. AuthService에서 코드를 전달해서 로그인 처리를 위임하고 있다. AuthServiceAuthService에서 logIn을 어떻게 처리하는 지 살펴보자. 12345678910111213141516171819202122232425262728293031323334353637@Service@Transactional(readOnly = true)public class AuthService &#123; private final GitHubOauthClient gitHubOauthClient; private final MemberRepository memberRepository; private final JwtProvider jwtProvider; public AuthService(final GitHubOauthClient gitHubOauthClient, final MemberRepository memberRepository, final JwtProvider jwtProvider) &#123; this.gitHubOauthClient = gitHubOauthClient; this.memberRepository = memberRepository; this.jwtProvider = jwtProvider; &#125; @Transactional public LoginResult login(final String code) &#123; final GitHubProfileResponse gitHubProfileResponse = getGitHubProfileResponse(code); final Member member = addOrUpdateMember(gitHubProfileResponse); final Long memberId = member.getId(); final String applicationAccessToken = jwtProvider.createAccessToken(memberId); return new LoginResult(applicationAccessToken, member); &#125; private GitHubProfileResponse getGitHubProfileResponse(final String code) &#123; final String gitHubAccessToken = gitHubOauthClient.getAccessToken(code); return gitHubOauthClient.getProfile(gitHubAccessToken); &#125; private Member addOrUpdateMember(final GitHubProfileResponse gitHubProfileResponse) &#123; final Member requestedMember = gitHubProfileResponse.toMember(); final Member member = memberRepository.findByGitHubId(gitHubProfileResponse.getGitHubId()) .orElseGet(() -&gt; memberRepository.save(requestedMember)); member.update(requestedMember); return member; &#125;&#125; AuthService의 getGitHubProfileResponse 메서드는 4번과 6번을 GithubOauthClient에게 위임하고 있다. (GithubOauthClient는 다른 포스트로 더 설명해보고자 한다.) AuthService의 addOrUpdateMember 메서드는 8번을 수행하고 있다. AuthService의 login 메서드에서 JwtProvider를 통해 9번을 수행하고 있다. 그리고 LoginResult라는 DTO에 결과를 담아서 컨트롤러로 반환하고 있다. JwtProvider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Componentpublic class JwtProvider &#123; private static final String TOKEN_TYPE = &quot;Bearer&quot;; private static final String ACCESS_TOKEN_SUBJECT = &quot;AccessToken&quot;; private final AuthTokenExtractor authTokenExtractor; private final Key secretKey; private final long validityInMilliseconds; public JwtProvider(final AuthTokenExtractor authTokenExtractor, @Value(&quot;$&#123;security.jwt.secret-key&#125;&quot;) final String secretKey, @Value(&quot;$&#123;security.jwt.expire-length&#125;&quot;) final long validityInMilliseconds) &#123; this.authTokenExtractor = authTokenExtractor; this.secretKey = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8)); this.validityInMilliseconds = validityInMilliseconds; &#125; public String createAccessToken(final Long id, final Role role) &#123; final Date now = new Date(); final Date validity = new Date(now.getTime() + validityInMilliseconds); return Jwts.builder() .setSubject(ACCESS_TOKEN_SUBJECT) .setIssuedAt(now) .setExpiration(validity) .claim(&quot;id&quot;, id) .claim(&quot;role&quot;, role) .signWith(secretKey, SignatureAlgorithm.HS256) .compact(); &#125; public boolean isValidToken(final String authorizationHeader) &#123; final String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE); try &#123; final Jws&lt;Claims&gt; claims = getClaimsJws(token); return isAccessToken(claims) &amp;&amp; isNotExpired(claims); &#125; catch (JwtException | IllegalArgumentException e) &#123; return false; &#125; &#125; private Jws&lt;Claims&gt; getClaimsJws(final String token) &#123; return Jwts.parserBuilder() .setSigningKey(secretKey) .build() .parseClaimsJws(token); &#125; private boolean isAccessToken(final Jws&lt;Claims&gt; claims) &#123; return claims.getBody() .getSubject() .equals(ACCESS_TOKEN_SUBJECT); &#125; private boolean isNotExpired(final Jws&lt;Claims&gt; claims) &#123; return claims.getBody() .getExpiration() .after(new Date()); &#125; public MemberPayload getPayload(final String authorizationHeader) &#123; final String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE); Claims body = getClaimsJws(token).getBody(); try &#123; Long id = body.get(&quot;id&quot;, Long.class); Role role = Role.valueOf(body.get(&quot;role&quot;, String.class)); return new MemberPayload(id, role); &#125; catch (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123; throw new TokenInvalidFormatException(); &#125; &#125;&#125; return claims.getBody() .getExpiration() .after(new Date()); &#125; public MemberPayload getPayload(final String authorizationHeader) &#123; final String token = authTokenExtractor.extractToken(authorizationHeader, TOKEN_TYPE); Claims body = getClaimsJws(token).getBody(); try &#123; Long id = body.get(&quot;id&quot;, Long.class); Role role = Role.valueOf(body.get(&quot;role&quot;, String.class)); return new MemberPayload(id, role); &#125; catch (RequiredTypeException | NullPointerException | IllegalArgumentException e) &#123; throw new TokenInvalidFormatException(); &#125; &#125;&#125; JwtProvider는 Jwt 토큰을 만들고, 검증하는 역할을 한다. 이때 JwtProvider에는 io.jsonwebtoken 라이브러리를 사용한다. 이를 위해서는 build.gradle에 다음과 같이 의존성을 추가해주자. 12345678dependencies &#123; // 생략... // jwt implementation &#x27;io.jsonwebtoken:jjwt-api:0.11.5&#x27; runtimeOnly &#x27;io.jsonwebtoken:jjwt-impl:0.11.5&#x27; runtimeOnly &#x27;io.jsonwebtoken:jjwt-jackson:0.11.5&#x27;&#125; JwtProvider는 생성자로 시크릿키, 만료 시간, AuthTokenExtractor를 주입받는다. AuthTokenExtractor는 Authorization 헤더 형식에서 토큰값만 추출하는 책임을 진다. (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) 만료시간은 변경해줘야 할 경우 JwtProvider의 코드를 살펴보면서 바꾸면 위험하기 때문에 따로 주입해주는 방식을 썼다. 문제는 시크릿키이다. 시크릿키는 한번 유출되면 누구나 서버가 만든 JWT 토큰과 동일한 서명을 가진 JWT 토큰을 만들어 낼 수 있다. 그래서 따로 설정파일 (yaml)을 만들어서 보안이 중요한 내용을 관리하도록 했다. 이런 보안이 중요한 파일들은 .gitignore로 깃에 등록되지 않도록 관리하거나, 서브 모듈을 활용해서 private repository에서 버전 관리를 할 수 있다. 1234security: jwt: secret-key: secretKeyExample expire-length: 3600000 참고https://github.com/woowacourse-teams/2022-f12","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"JPA를 왜 쓰나요?","slug":"spring/JPA/whyUseJpa","date":"2022-06-29T10:21:28.000Z","updated":"2022-07-03T05:22:23.128Z","comments":true,"path":"2022/06/29/spring/JPA/whyUseJpa/","link":"","permalink":"https://yangdongjue5510.github.io/2022/06/29/spring/JPA/whyUseJpa/","excerpt":"","text":"요약 JPA는 객체지향 언어인 자바와 데이터베이스의 구조가 달라서 생기는 문제를 개발자가 더 쉽게 해결할 수 있도록 돕는다.객체지향은 행동과 책임 중심으로 설계되고, 데이터베이스는 데이터 중심으로 설계된다.객체지향은 참조의 방향이 정해져있지만, 데이터베이스는 하나의 외래키로 양쪽 모두 참조 가능하다.동일성 비교를 객체는 인스턴스의 주소값으로 하고 데이터베이스는 기본키로 한다.JPA는 이런 차이를 개발자가 신경쓰지 않게 해준다.JPA는 반복적인 SQL 작성을 줄여준다. 반복적인 SQL 작성JDBC API로 Member 객체를 저장하거나 조회해보자. 12345678910111213141516public class MemberDao &#123; public void save(Member member) &#123; final Connection connection = getConnection(); final String sql = &quot;insert into member (id, name) values (?, ?)&quot;; try &#123; final PreparedStatement statement = connection.prepareStatement(sql); statement.setString(1, member.getId()); statement.setString(2, member.getName()); statement.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; Member 객체를 저장하는 데 정말 많은 코드가 많이 필요하다.만약 테이블이 100개이면 저장하는 메서드 100개를 반복해서 만들어줘야 한다. 만약 데이터베이스를 컬렉션이라고 상상해보면 다음과 같지 않을까? 1members.add(member); JPA를 사용하면 컬렉션처럼 객체를 데이터베이스에 저장시킬 수 있다. 1entityManager.persist(member); JPA는 객체와 매핑 정보를 보고 적절한 SQL을 알아서 실행시킨다.개발자는 반복적인 SQL 작성을 하지 않아도 된다. 상속 구조 구현 문제 데이터베이스는 객체 지향 상속을 지원하지 않으니 위 그림처럼 DTYPE 칼럼을 추가해서 어떤 자식 테이블과 관계가 있는지 확인할 수 있어야 한다. 문제는 이런 경우 개발자가 Keyboard 객체를 저장하려면 ITEM 테이블에 insert 하는 쿼리 KEYBOARD 테이블에 insert 하는 쿼리 두 개의 쿼리를 작성해야 한다. 데이터베이스에서 객체를 가져올 때는 ITEM과 KEYBOARD을 조인해서 데이터를 가져온 다음, Keyboard 객체를 생성해야 한다. JPA의 경우 그냥 해당 객체를 저장(혹은 조회)하면 적절한 SQL을 실행해서 처리한다. 1234// 저장entityManager.persist(keyboard);// 조회Keyboard keyboard = entityManager.find(Keyboard.class, keyboardId); 연관 관계 문제Member 클래스가 Team과 연관 관계가 있다고 하자. 12345678910111213public class Member &#123; private Long id; private String name; private Team team; //...&#125;public class Team &#123; private Long id; private String name; //...&#125; 이때 Member를 조회하는 두 개의 SQL이 있다. 123456SELECT id, name FROM USER WHERE id = ?;SELECT u.id, u.name, t.id, t.name FROM member u JOIN team t ON member.team_id = team.id WHERE u.id = ?; 만약 굳이 Team 객체를 사용하지 않는 경우에는 첫번째 쿼리를 사용해서 Member 객체를 만드는게 낫다.Team 객체를 사용해야 하는 경우는 두번째 쿼리로 Team 객체를 만들어서 Member 객체를 만들어야 한다. 문제는 개발자가 Member객체가 Team 객체에 값이 들어와 있는지를 확신할 수 없다는 점이다. 첫번째 쿼리로 만들어진 Member객체에게 getTeam()을 할 경우 Id만 채워진 객체가 반환되서 문제를 일으키게 된다. 그리고 만약 Team 객체에도 연관되는 객체가 있으면 쿼리는 더 복잡해질 가능성이 있다.이 경우에도 Team 객체의 연관 객체의 데이터를 채워서 만들어 줄 것인지에 따라 SQL을 다르게 작성해야 한다.다양한 연관관계를 상황에 따라 맞는 쿼리를 작성하는 건 상당히 힘든 작업이다. 반면 JPA에서는 연관 관계의 객체의 프로퍼티에 접근할 때 쿼리를 실행시켜서 해당 객체를 초기화한다! 12345// 아직 Team 객체는 id값만 채워져있다.Member member = entityManager.find(Member.class, memberId);// 이때 Team 객체의 데이터가 채워진다.member.getTeam().getName(); 동일성 보장 문제자바는 인스턴스의 주소값이 같으면 같은 객체로 분류하고, 데이터베이스는 기본키 값이 같으면 동일하다고 인식한다.자바 객체를 저장하고 다시 조회했을 때 같은 객체를 반환하기 어렵다. 123456public class Member &#123; private Long id; private String name; //...&#125; 이런 Member 객체를 조회하려면 DB에서 조회한 데이터로 새로운 객체를 만들어서 반환하게 된다. 12345678910111213141516171819public Member findById(String id) &#123; final Connection connection = getConnection(); final String sql = &quot;select id, name from member where id = ?&quot;; try &#123; final PreparedStatement statement = connection.prepareStatement(sql); statement.setString(1, id); ResultSet resultSet = statement.executeQuery(); if (!resultSet.next()) &#123; return null; &#125; return new Member( resultSet.getString(&quot;id&quot;), resultSet.getString(&quot;name&quot;) ); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null;&#125; 문제는 이렇게 되면 객체를 저장하고 해당 객체를 다시 조회했을 때 같은 객체가 반환되지 않는다는 점이다. 1234Member member = new Member(null, &quot;name&quot;);memberDao.save(member);Member foundMember = memberDao.findById(1L);assertThat(member).isEqualTo(foundMember);//실패!! 분명 논리적으로는 같은 객체인데 DB에 저장하고 찾아온 객체가 자바에서는 다른 객체로 인식하게 된다. JPA에서는 객체를 DB에 저장하고 조회해도 같은 객체(인스턴스 주소값이 같은)를 반환해준다. 1234Member member = new Member(null, &quot;name&quot;);entityManager.persist(member);Member foundMember = entityManager.find(Member.class, 1L);assertThat(member).isEqualTo(foundMember);//성공!!","categories":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}],"tags":[{"name":"자바 ORM 표준 JPA 프로그래밍","slug":"자바-orm-표준-jpa-프로그래밍","permalink":"https://yangdongjue5510.github.io/tags/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"keywords":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}]},{"title":"Transactional 어노테이션","slug":"spring/transactional","date":"2022-05-16T08:35:14.000Z","updated":"2022-05-19T06:51:18.853Z","comments":true,"path":"2022/05/16/spring/transactional/","link":"","permalink":"https://yangdongjue5510.github.io/2022/05/16/spring/transactional/","excerpt":"","text":"요약 트랜잭션이 무엇인지 알아본다.@Transactional의 Propagation 옵션을 알아본다.@Transactional의 롤백 기준을 알아본다.@Transactional 적용 실패하는 경우를 알아본다. 트랜잭션?모두 반드시 성공해야 하는 연속된 작업들을 트랜잭션이라 한다.만약 작업들 중 하나만 실패해도 모든 작업들이 어플리케이션의 상태를 변경시키지 않은 상태로 돌려놔야 한다. 만약 하나의 지하철 노선에 등록할 때 구간도 같이 저장해야 한다고 가정하자.이때 INSERT 문이 두 번 사용될 것이다.개발자는 이를 하나의 작업 단위로 인식해서 하나의 트랜잭션으로 관리할 수 있다.노선을 등록하는데 성공했더라도 구간이 저장안되면 노선도 저장되서는 안되기 때문이다. 트랜잭션 진행 중에 문제가 생길 경우 그 작업을 진행하기 이전으로 DB를 롤백시킨다. JDBC의 트랜잭션JDBC는 statement를 트랜잭션에서 진행할 수 있게한다.JDBC의 한 Connection의 수행마다 auto-commit한다.즉 모든 statement를 하나의 트랜잭션이라 생각하고 수행 이후 자동으로 반영한다. 만약 여러 statement를 하나의 트랜잭션에서 진행하고 싶다면 connection의 autoCommit을 꺼놓고 트랜잭션을 종료하고 싶을 때 명시적으로 커밋해주면 된다. 123connection.setAutoCommit(false); // auto-commit 꺼놓음.// ... 작업들...connection.commit(); //명시적으로 커밋. 스프링의 트랜잭션스프링에서는 여러가지 트랜잭션 관리 기능을 제공한다. 명시적 트랜잭션트랜잭션의 범위를 자세하게 정하고 싶을 땐 명시적 트랜잭션을 사용한다. Transaction Template는 개발자가 직접 트랜잭션 범위를 명시적으로 결정할 수 있다. 선언적 트랜잭션 @Transactional클래스나 메서드에 @Transactional 어노테이션을 붙이면 글로벌 트랜잭션을 정해줄 수 있다. 1234@Transactionalpublic void deleteById(final Long id) &#123; lineRepository.deleteById(id);&#125; 이렇게 메서드 위에 두면 메서드 실행 중 예외가 발생하면 롤백한다. 12345678@Service@Transactionalpublic class LineService &#123; public void deleteById(final Long id) &#123; lineRepository.deleteById(id); &#125;&#125; 클래스 위에 두면 클래스에 해당하는 메서드들을 @Transactional을 붙인 셈이 된다. @Transactional의 여러가지 속성트랜잭션에는 여러가지 속성을 설정해줄 수 있다. 예시코드를 통해 이해해보자. 일단 하나의 서비스에서 방을 DB에 저장하고 예외를 일으키는 메서드를 트랜잭션으로 처리하고자 한다. 1234567891011121314151617@Servicepublic class TransactionalService &#123; private final RoomRepository roomRepository; public TransactionalService(RoomRepository roomRepository) &#123; this.roomRepository = roomRepository; &#125; @Transactional public void throwSomething() &#123; roomRepository.createRoom(Room.fromPlainPassword(&quot;other&quot;, &quot;password&quot;)); throw new IllegalArgumentException(); &#125;&#125; 그리고 다른 서비스에서 아까 만든 서비스를 주입받아 예외를 만드는 메서드를 호출하는 메서드를 트랜잭션 처리해보자. 1234567891011121314151617181920212223@Servicepublic class OuterService &#123; private final TransactionalService transactionalService; private final RoomRepository roomRepository; public OuterService(TransactionalService transactionalService, RoomRepository roomRepository) &#123; this.transactionalService = transactionalService; this.roomRepository = roomRepository; &#125; @Transactional public void doSomething() &#123; roomRepository.createRoom(Room.fromPlainPassword(&quot;name&quot;, &quot;password&quot;)); try &#123; transactionalService.throwSomething(); &#125; catch (IllegalArgumentException e) &#123; System.out.println(&quot;catched!!&quot;); &#125; System.out.println(&quot;done!&quot;); &#125;&#125; 이제 OuterService의 메서드를 실행하기 위한 Runner 클래스를 만들었다. 123456789101112131415@Componentpublic class Runner implements ApplicationRunner &#123; private final OuterService outerService; public Runner(OuterService outerService) &#123; this.outerService = outerService; &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; outerService.doSomething(); &#125;&#125; 이제 어플리케이션을 실행하면 외부 트랜잭션 메서드가 실행될 것이다. 1. 전파 옵션트랜잭션 수행 중 다른 트랜잭션을 호출하는 상황에서 어떻게 처리하는지 다루는 옵션. REQUIRED : 트랜잭션 수행 중 다른 트랜잭션 호출되면 먼저 수행되던 거에 합쳐서 수행. propagation 기본 설정값. 12@Transactionalpublic void throwSomething() &#123; 다른 설정을 안하면 REQUIRED 옵션으로 설정된다.이 상태로 실행시키면 DB에는 아무 일도 일어나지 않는다. 1Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only UnexpectedRollbackException은 외부 트랜잭션이 내부 트랜잭션이 롤백됐음을 예상하지 못했다는 의미다. 외부 트랜잭션은 내부에서 다른 트랜잭션의 성공 여부 상관없이 커밋하려 한다.중간에 내부 트랜잭션이 실패해서 롤백됐으면 이를 외부 트랜잭션에게 알려줘야 해서 생긴 예외다. REQUIRED 옵션은 내부 트랜잭션과 외부 트랜잭션의 범위가 논리적으로는 분리되지만 물리적으로는 각 스코프가 같은 물리적 트랜잭션을 갖게 된다. 그래서 외부 트랜잭션은 내부의 트랜잭션의 rollback-only에 따라 영향을 받는다. SUPPORTS : 만약 트랜잭션이 진행되고 있는 상태에서 호출 시 해당 트랜잭션에 참여, 아닐 경우 트랜잭션 하지 않고 진행. 1234//외부 메서드가 트랜잭션이 아니면public void doSomething() &#123; ... &#125;@Transactional(propagation = Propagation.SUPPORTS)public void throwSomething() &#123; ... &#125; 이렇게 트랜잭션을 변경하고 실행하면 어떻게 될까? 그 결과 두 메서드의 DB 업데이트가 모두 이뤄진다.(예외를 일으켜도 DB 업데이트가 이뤄졌다.)사실 두 메서드 모두 트랜잭션 처리 되지 않았다. REQUIRED_NEW : 이미 진행 중인 트랜잭션이 있어도 새로운 트랜잭션 생성해서 진행. 서로 물리적으로 독립된 트랜잭션을 생성. 1234@Trasactionalpublic void doSomething() &#123; ... &#125;@Transactional(propagation = Propagation.REQUIRED_NEW)public void throwSomething() &#123; ... &#125; 이렇게 트랜잭션을 변경하고 실행하면 외부 트랜잭션만 커밋된다.내부 트랜잭션은 따로 트랜잭션으로 생성되서 예외 탐지하고 롤백됐고 외부 트랜잭션은 내부 트랜잭션의 실패 여부와 상관없이 트랜잭션을 진행해서 커밋했다. NESTED : 이미 진행 중인 트랜잭션의 중첩된 트랜잭션을 생성. 물리적으로는 하나의 트랜잭션인데 저장점을 추가하는 방식. 중첩된 트랜잭션은 외부 트랜잭션에 영향을 끼치지 못하지만 내부 트랜잭션은 외부 트랜잭션의 롤백에 영향 받는다. 1234@Trasactionalpublic void doSomething() &#123; ... &#125;@Transactional(propagation = Propagation.NESTED)public void throwSomething() &#123; ... &#125; 이러면 내부 트랜잭션은 롤백되지만 외부 트랜잭션은 잘 실행된다. 반면 내부 트랜잭션은 예외를 던지지 않는데 외부 트랜잭션에서 예외가 발생한 경우는 어떨까?모든 트랜잭션이 롤백된다! 내부가 성공해도 외부가 롤백되면 모두 롤백된다. 2. 롤백 조건 옵션트랜잭션이 롤백되는 조건을 다룬다.선언적 트랜잭션은 기본적으로 unchecked exception와 Error가 발생하면 롤백한다.Checked exception은 개발자가 반드시 처리한 예외이니 예상하지 못한 예외인 unchecked exception과 Error가 발생하면 롤백한다. @Transactional 어노테이션의 속성을 통해 롤백조건을 다르게 할 수 있다.관련 속성은 다음과 같다. rollbackFor : 추가로 롤백되어야 할 예외를 추가할 수 있다. rollbackForClassName : 추가로 롤백되어야 할 예외 클래스의 이름을 배열로 받아 추가할 수 있다. noRollbackFor : 롤백하지 않으려는 예외를 정할 수 있다. noRollbackForClassName : 롤백하지 않으려는 예외 클래스으 이름을 배열로 받아 정할 수 있다. 3. readOnly데이터를 수정하지 않는 트랜잭션을 데이터를 수정하려고 하는 경우를 막고 싶을 수 있다.이럴 때 사용되는게 readOnly 속성이다. readOnly는 읽기 전용일 경우 true로 세팅해주면 읽기 위한 트랜잭션임을 암시한다.다만 readOnly가 붙은 트랜잭션에서 데이터를 수정하려고 할 때 반드시 실패한다는 의미는 아니다.트랜잭션 매니저에 따라 readOnly를 지원하지 않는 경우 readOnly 설정은 무시된다. 4. 그 외 속성들트랜잭션의 격리 수준을 결정하는 isolation이나 트랜잭션의 제한 시간을 정하는 timeout 속성들도 존재한다. @Transation과 AOP선언적 트랜잭션은 AOP 프록시를 통해 활성화 된다.프록시로 구현되다보니 트랜잭션에 수행하는 프록시 객체와 진짜 객체가 서로 다를 수 있다.간략하게 표현하면 다음과 같다. 123456789101112131415161718@Servicepublic class OuterService &#123; private final TransactionalService transactionalService; private final RoomRepository roomRepository; public OuterService(TransactionalService transactionalService, RoomRepository roomRepository) &#123; this.transactionalService = transactionalService; this.roomRepository = roomRepository; &#125; @Transactional public void doSomething() &#123; roomRepository.createRoom(Room.fromPlainPassword(&quot;name&quot;, &quot;password&quot;)); transactionalService.throwSomething(); System.out.println(&quot;done! with throw&quot;); &#125;&#125; 위에서 예시로 사용했던 서비스는 사실 AOP 프록시를 사용하면 다음과 같이 된다.외부에서 doSomething 메서드를 호출 -&gt; (프록시)트랜잭션 시작! -&gt; (진짜) doSomething 수행! -&gt; (프록시)트랜잭션 끝! 12345678910public class 프록시객체 &#123; private final 진짜객체; public void 트랜잭션_붙은_메서드() &#123; 트랜잭션_시작; 진짜객체.트랜잭션_붙은_메서드(); 트랜잭션_끝; &#125;&#125; 그런데 다음과 같은 경우는 어떻게 될까?? 트랜잭션이 적용되지 않은 public 메서드를 통해서 트랜잭션 붙은 메서드를 호출해보자. 12345678910111213141516171819@Servicepublic class OuterService &#123; private final RoomRepository roomRepository; public OuterService(RoomRepository roomRepository) &#123; this.roomRepository = roomRepository; &#125; public void execute() &#123; doSomething(); &#125; @Transactional(readOnly = true) private void doSomething() &#123; roomRepository.createRoom(Room.fromPlainPassword(&quot;name&quot;, &quot;password&quot;)); throw new IllegalArgumentException(); &#125;&#125; 이렇게 하면 doSomething은 롤백될까? 답은 아니다!!!! 왜냐면 프록시 객체는 execute 메서드를 실행시킬 때 내부에서 어떤 메서드를 부르는지 모른다. 그래서 트랜잭션을 적용시켜주지 못한다. 그래서 private 메서드는 @Transactional을 붙이는 건 의미 없다. 트랜잭션 처리 해줄 프록시 객체가 해당 메서드에 접근할 수 없기 때문이다. 그리고 public이 붙었더라도 트랜잭션이 붙지 않은 메서드를 통해서 호출하면 트랜잭션이 적용되지 않는다!!!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"Bean Validation으로 검증하기","slug":"spring/validation","date":"2022-05-12T11:41:51.000Z","updated":"2022-05-19T07:07:23.114Z","comments":true,"path":"2022/05/12/spring/validation/","link":"","permalink":"https://yangdongjue5510.github.io/2022/05/12/spring/validation/","excerpt":"","text":"Bean Validation일반적인 유효성 검사 로직지켜져야 할 조건에 맞지 않은 상황에 로직을 진행하려는 경우 예외를 터트려서 의도하지 않은 진행을 막을 수 있다. 1234567891011public class Name &#123; private final String name; public Name(String name) &#123; if (name.isBlank()) &#123; throw new IllegalArgumentException(ExceptionMessage.BLANK_LINE_NAME.getContent()); &#125; this.name = name; &#125;&#125; 생성자로 전달받은 문자열이 빈값이면 예외를 터지도록 해서 Name 객체는 반드시 이름을 가지도록 만들 수 있다. 하지만 이런 로직이 비슷하게 여러 클래스에 흩어져 있다면 중복이 많아지고 관리하기도 힘들어진다. 이런 검증을 각 Bean Validation과 Hibernate Validator Bean Validation은 일종의 명세이지 실제 작동하는 코드는 아니다.이 명세를 구현한 것 중 하나가 Hibernate Validator이다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"Spring IoC 컨테이너, 컴포넌트 스캔, 빈 생명주기","slug":"spring/spring3","date":"2022-05-05T12:21:02.000Z","updated":"2022-05-06T04:54:05.433Z","comments":true,"path":"2022/05/05/spring/spring3/","link":"","permalink":"https://yangdongjue5510.github.io/2022/05/05/spring/spring3/","excerpt":"","text":"요약 (다음 질문의 정답을 안다면 이 포스트를 읽지 않아도 된다.) IoC 컨테이너와 ApplicationContext는 완전히 같은 개념인가? IoC 컨테이너를 구성하는 방법은 어떤 것이 있는가? BeanFactory와 ApplicationContext의 차이를 알고 있는가? IoC 컨테이너스프링의 IoC 컨테이너는 객체를 인스턴스화하고 구성 및 조합하고 수명주기를 관리하는 역할을 한다. 스프링이 제공하는 IoC 컨테이너스프링의 IoC 컨테이너는 두 가지 유형의 컨테이너를 제공한다. BeanFactory 기반 컨테이너 ApplicationContext 기반 컨테이너 우리가 가장 흔히 아는 ApplicationContext는 IoC 컨테이너 중 하나이다.\u0010 BeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.ApplicationContext는 BeanFactory의 기능을 확장한 버전이다. BeanFactoryBeanFactory는 IoC 컨테이너의 가장 기본적인 버전이다.BeanFactory는 메타데이터를 기반으로 빈 객체를 생성하고 구성한다. 이때 BeanFactory는 XML 기반으로 메타데이터를 사용한다.BeanFactory는 Lazy Loadaing으로 빈 객체를 등록한다. 코드로 이해하기User라는 POJO 클래스가 있다. 1234567public class User &#123; public static boolean IS_BEAN_INITIALIZED = false; public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125;&#125; 이 클래스를 XML을 통해 Bean 등록해보자. 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;nextstep.helloworld.core.User&quot; init-method=&quot;setIsBeanInitialized&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; config.xml에 user라는 이름으로 빈 등록을 해줬다.init-method를 통해 빈 객체가 생성될 때 User#setIsBeanInitialized를 실행하도록 했다. 만약 User가 빈 객체로 생성되면 IS_BEAN_INITIALIZED가 true가 될 것 이다. 테스트 코드로 확인해보자. 1234567891011121314151617181920class ContainerTest &#123; @Test @DisplayName(&quot;XML 기반으로 BeanFactory 레이지 로딩 확인하기&quot;) void beanFactoryLazyLoading() &#123; // given Resource res = new ClassPathResource(&quot;config.xml&quot;); BeanFactory factory = new XmlBeanFactory(res); // when boolean isCreated = User.IS_BEAN_INITIALIZED; User user = (User) factory.getBean(&quot;user&quot;); boolean isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED; // then assertThat(isCreated).isFalse(); assertThat(isCreatedAfterGetBean).isTrue(); &#125;&#125; 여기서 Lazy Loading을 확인할 수 있다.Lazy Loading은 BeanFactory에서 빈 객체를 가져올 때 해당 객체를 생성한다는 의미다. 그래서 User.IS_BEAN_INITIALIZED가 빈 객체를 가져올 때 true가 됨을 확인 할 수 있다. ApplicationContextApplicationContext는 BeanFactory의 하위 인터페이스다.따라서 BeanFactory의 모든 기능을 제공한다. 다만 ApplicationContext는 웹 어플리케이션, AOP에 필요한 더 많은 기능을 제공한다. ApplicationContext의 선언부를 통해 어떤 기능을 추가로 제공하는 지 보자. 123public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123; //...생략&#125; EnvironmentCapable 인터페이스 : 프로파일과 프로퍼티를 다루는 Environment를 접근할 수 있게 한다. ListableBeanFactory 인터페이스 : BeanFactory의 기능을 지원하기 위한 인터페이스. 빈 객체를 생성 관리한다. HierarachicalBeanFactory 인터페이스 : BeanFactory 구현체 사이의 계층 구조를 확인할 수 있게 한다. MessageSource 인터페이스 : 국제화(i18n)을 제공하는 인터페이스 ApplicationEventPublisher 인터페이스 : 이벤트를 발생시키는 기능을 제공한다. ResourcePatternResolver 인터페이스 : 리소스를 읽어오는 기능을 제공한다. ApplicationContext의 메타데이터 설정 방법들BeanFactory와 달리 ApplicationContext의 중요한 기능 중 하나는 메타데이터를 다양한 방식으로 할 수 있다. BeanFactory는 XML 외부 파일로 컨테이너를 설정해줘야 했다.ApplicationContext는 어노테이션 기반 설정도 지원한다! 아까 사용했던 User POJO 클래스를 다시 사용하자. 1234567public class User &#123; public static boolean IS_BEAN_INITIALIZED = false; public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125;&#125; 그리고 @Configuration 어노테이션을 붙인 설정 파일로 Bean 등록해보자. 12345678910@Configurationpublic class ConfigurationUserBean &#123; @Bean public User user() &#123; User user = new User(); user.setIsBeanInitialized(); return user; &#125;&#125; @Bean 어노테이션이 붙은 메서드가 실행되면 반환되는 객체를 빈 객체로 컨테이너에 등록한다.그리고 XML의 init-method 대신 메서드 안에 setIsBeanInitialized 메서드를 호출했다. 테스트로 확인해보자. 12345678910111213141516@Test @DisplayName(&quot;어노테이션 기반(설정 파일)로 빈 객체 생성 확인하기&quot;) void applicationContextBeanCreate() &#123; // given ApplicationContext applicationContext = new AnnotationConfigApplicationContext(ConfigurationUserBean.class); // when boolean isCreated = User.IS_BEAN_INITIALIZED; User user = (User) applicationContext.getBean(&quot;user&quot;); boolean isCreatedAfterGetBean = User.IS_BEAN_INITIALIZED; // then assertThat(isCreated).isTrue(); assertThat(isCreatedAfterGetBean).isTrue(); &#125; 설정 클래스를 전달해서 ApplicationContext를 생성했다.ApplicationContext는 eager-loading이라 컨테이너가 생성됐을 때 빈 객체를 생성한다! 그래서 빈 객체를 호출하기 전에도 이미 빈 객체가 생성되어 있다는 의미다!(결국 모든 빈객체를 eager-loading하기 때문에 ApplicationContext는 비교적 무거운 IoC container이다.) ComponentScanComponentScan은 특정 패키지에서 @Component가 붙은 클래스를 빈 객체 등록하는 방법이다.일일히 빈 객체를 메서드로 작성하지 않아도 된다는 장점이 있다. 이전에 @Bean 어노테이션으로 등록했던 방식 대신 ComponentScan을 활용해보자. 먼저 빈등록하고 싶은 클래스에 @Component 어노테이션을 달아주자. 12345678910111213@Componentpublic class User implements InitializingBean &#123; public static boolean IS_BEAN_INITIALIZED = false; public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125; @Override public void afterPropertiesSet() throws Exception &#123; setIsBeanInitialized(); &#125;&#125; InitializeBean 인터페이스로 해당 클래스가 빈 객체로 만들어지고 나서 setIsBeanInitialized()를 실행하도록 했다. 이제 설정 파일에 @ComponentScan 어노테이션을 붙여주자! 123456@Configuration@ComponentScan(basePackages = &#123;&quot;nextstep.helloworld.core.componentscan.user&quot;&#125;)public class ConfigurationUserBean &#123;&#125; @ComponentScan은 특정 패키지를 기준으로 해당 패키지와 하위 패키지의 @Component 어노테이션이 붙은 클래스를 빈등록한다. (위 예시는 User클래스가 있는 패키지를 기준으로 잡았다.) @Bean을 붙여서 빈객체를 생성해줬던 메서드를 제거할 수 있게됐다! 그렇다면 스프링 부트에서는 어떻게 ComponentScan을 하는 걸까?? 스프링 부트를 사용하면 @Configuration을 붙인 설정파일 없이도 @Component를 붙인 클래스를 빈등록 해준다.왜 그렇게 되는 건지 확인해보자. 123456@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 스프링 부트 프로젝트를 만들면 먼저 @SpringBootApplication이 붙은 클래스가 프로젝트 패키지에 생성된다.@SpringBootApplication에 들어가보면 다음과 같다. 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; //생략&#125; 즉 @SpringBootApplication 어노테이션에는 @ComponentScan 어노테이션이 포함되어 있다.basePackages가 따로 설정하지 않았으니 해당 클래스가 속한 패키지를 기준으로 컴포넌트 스캔을 진행하게 된다.그리고 @Filter 어노테이션으로 특정 클래스들을 컴포넌트 스캔에서 제외할 수 있다. Bean 생명주기Bean 객체의 생명 주기를 이해하기 위해서는 Bean을 생성하고 관리하는 스프링 컨테이너의 생명주기를 이해해야 한다. 스프링 컨테이너의 생명주기 컨테이너 초기화 컨테이너 종료 12345678910111213@Test @DisplayName(&quot;컨테이너 생명주기&quot;) void applicationContextLifeCycle() &#123; // 초기화 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ConfigurationUserBean.class); // 사용 User user = (User) applicationContext.getBean(&quot;user&quot;); // 종료 applicationContext.close(); &#125; 컨테이너 초기화1AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ConfigurationUserBean.class); AppliactionContext 객체를 생성하면 스프링 컨테이너를 초기화한다.이 과정에서 메타데이터를 읽어서 알맞은 빈 객체를 생성하고 각 빈을 연결(주입)하게 된다. 컨테이너 종료1applicationContext.close(); 컨테이너를 close 메서드를 통해 종료하면 컨테이너가 관리하던 빈 객체들도 모두 소멸된다.(이때 프로퍼티 스코프인 객체들은 소멸되지 않는다. ) 빈 객체의 생명 주기스프링 컨테이너의 생명주기를 보면 짐작할 수 있듯이 일반적인 빈 객체는 컨테이너의 통제에 따라 생명 주기를 진행한다. 객체 생성 -&gt; ApplicationContext가 생성되면서 빈 객체 생성 의존 설정 -&gt; ApplicationContext가 메타데이터를 기반으로 의존 주입 초기화 -&gt; 의존관계가 모두 설정하고 나면 빈 객체의 초기화에 해당하는 메서드를 수행 소멸 -&gt; ApplicationContext를 종료하면 빈 객체 소멸에 해당하는 메서드를 수행 초기화와 소멸의존관계까지 모두 주입되고 나면 빈 객체가 등록될 때 어떤 행위를 하도록 하고싶거나,특정 빈 객체가 소멸 될 때 어떤 행위를 하기 원할 때가 있다. 이런 의도를 빈 생명 주기 중 초기화와 소멸에서 수행할 수 있다. 초기화빈 객체가 생성되고 나서 어떤 메서드를 실행시키고 싶은 경우 초기화 단계에서 수행한다.이를 설정하기 위해서는 여러가지 방법이 있다. @PostConstruct InitializingBean 인터페이스 init-method 코드로 이해해보자.User 클래스가 빈 객체로 등록될 때 특정 메서드를 실행하게 만들자. 먼저 @PostConstruct 123456789@Componentpublic class User &#123; public static boolean IS_BEAN_INITIALIZED = false; @PostConstruct public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125;&#125; 이렇게 빈 객체가 등록되고 나서 수행됐으면 하는 메서드에 @PostConstruct를 붙여주면 된다. InitializingBean 인터페이스를 구현하는 방법도 있다. 12345678910111213@Componentpublic class User implements InitializingBean &#123; public static boolean IS_BEAN_INITIALIZED = false; public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125; @Override public void afterPropertiesSet() throws Exception &#123; setIsBeanInitialized(); &#125;&#125; afterPropertiesSet() 메서드 안에 빈 객체가 등록될 때 수행할 행동을 적어놓으면 된다. 마지막으로 xml init-method를 사용하는 방법이다. 1&lt;bean id=&quot;user&quot; class=&quot;nextstep.helloworld.core.User&quot; init-method=&quot;setIsBeanInitialized&quot;&gt; Bean 태그 안에 init-method 속성에 빈 객체 생성 될 때 수행될 메서드 이름을 적어주면 된다. 소멸빈 객체가 사라질 때 특정 행동을 하라고 설정할 수 있다.소멸을 구현하는 데에도 여러 방법이 있다. @PreDestroy DisposableBean 인터페이스 destroy-method 코드로 이해해보자.User 클래스의 빈 객체가 폐기될 때 특정 메서드를 실행하게 만들자. @PreDestory 123456789@Componentpublic class User &#123; public static boolean IS_BEAN_INITIALIZED = false; @PreDestroy public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125;&#125; DisposableBean 인터페이스 12345678910111213@Componentpublic class User implements DisposableBean &#123; public static boolean IS_BEAN_INITIALIZED = false; public void setIsBeanInitialized() &#123; IS_BEAN_INITIALIZED = true; &#125; @Override public void destroy() throws Exception &#123; IS_BEAN_INITIALIZED = false; &#125;&#125; XML destroy-method 1&lt;bean id=&quot;user&quot; class=&quot;nextstep.helloworld.core.componentscan.user.User&quot; destroy-method=&quot;setIsBeanInitialized&quot;&gt;&lt;/bean&gt; 이렇게 하면 빈 객체가 제거 될 때(컨테이너가 종료될 때) 해당 메서드를 실행시킬 수 있다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"왜 스프링을 쓰는 걸까??(IoC, DI)","slug":"spring/spring2","date":"2022-04-26T10:34:28.000Z","updated":"2022-05-05T12:21:39.328Z","comments":true,"path":"2022/04/26/spring/spring2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/04/26/spring/spring2/","excerpt":"","text":"요약 의존 역전과 유연함을 위해서 DI하도록 객체를 설계하는 경우,매번 해당 객체를 사용할 때마다 필요한 객체를 찾아서 주입해줘야 한다.스프링 프레임워크는 DI를 대신해주는 역할을 한다. 유연한 설계를 위해서객체지향 설계 원칙 중 SOLID 원칙이 있다.그 중 D에 해당하는 의존 역전 원칙은 상위 모듈이 하위 모듈의 구현에 의존하지 말고, 상위 모듈이 정한 추상 타입에 하위 모듈들이 의존해야 한다는 규칙이다. 쉽게 말하면 상위 기능에서 정한 인터페이스나 추상 클래스 타입으로 하위 클래스들이 협력해야 한다는 의미이다.이렇게 하면 상위 모듈은 하위 모듈의 내부 구현이 달라져도 상관하지 않게 되고 기능이 확장에 열리게 된다. 예시로 좀 더 알아보자.1234567public class FileReader &#123; public String readNames() &#123; //여기서 파일을 읽는 로직 작성됐음을 가정 return &quot;Read some Files&quot;; &#125;&#125; FileReader에서 파일을 읽어서 문자열을 반환하는 책임을 한다고 하자.이 클래스와 협력하는 NamePrinter를 보자. 1234567public class NamePrinter &#123; public void printNames() &#123; FileReader fileReader = new FileReader(); System.out.println(fileReader.readNames()); &#125;&#125; FileReader 객체를 만들어서 readName을 호출해서 출력한다! 그런데 이름을 읽어오는 방법이 파일만 있을까? 그렇다. 파일만 이름을 저장하라는 법은 없다.이번엔 DBReader를 만들어보자. 1234567public class DBReader &#123; public String readNames() &#123; //DB에서 이름을 읽어오는 로직이 존재한다고 가정 return &quot;Names From DB...&quot;; &#125;&#125; 이제 DBReader를 만들었어도 아직 DB에서 읽은 이름을 출력할 수 없다.왜냐면 NamePrinter는 FileReader에 의존하고 있어서 파일에서 읽어온 이름만 출력할 수 있다.그러면 NamePrinter의 FileReader를 DBReader로 바꾸면?읽는 방식이 바뀌었다고 상위 기능인 출력 기능을 담당하는 NamePrinter를 수정해야 되면 문제가 있다. 변경이 많은 곳을 추상화이름을 읽어오는 곳이 경우의 수가 다양하니까 인터페이스로 추상화하자. 1234public interface NameReader &#123; String readNames();&#125; 이제 FileReader와 DBReader가 해당 인터페이스를 구현해서 의존하도록 하자. 1234567public class FileReader implements NameReader &#123; public String readNames() &#123; //여기서 파일을 읽는 로직 작성됐음을 가정 return &quot;Read some Files&quot;; &#125;&#125; 1234567public class DBReader implements NameReader &#123; public String readNames() &#123; //DB에서 이름을 읽어오는 로직이 존재한다고 가정 return &quot;Names From DB...&quot;; &#125;&#125; 아직 할 일이 남았다.상위 모듈인 NamePrinter도 추상타입인 NameReader에 의존하도록 한다. 123456789101112public class NamePrinter &#123; private final NameReader nameReader; public NamePrinter(NameReader nameReader) &#123; this.nameReader = nameReader; &#125; public void printNames() &#123; System.out.println(nameReader.readNames()); &#125;&#125; 여기서는 생상자의 인자로 의존하도록 했다.인자로 구현체를 전달해주어서 원하는 방식으로 이름을 읽어들이면 된다! 물론 의존성 주입은 생성자로만 하는 건 아니다. Setter 메서드로도 할 수 있다. 123456789101112public class NamePrinter &#123; private NameReader nameReader; public void printNames() &#123; System.out.println(nameReader.readNames()); &#125; public void setNameReader(NameReader nameReader) &#123; this.nameReader = nameReader; &#125;&#125; 이제 실행해보자. 12345678void dependencyInjection() &#123; NamePrinter namePrinter = new NamePrinter(); namePrinter.setNameReader(new FileReader()); namePrinter.printNames(); //File에서 읽은 이름 출력 namePrinter.setNameReader(new DBReader()); namePrinter.printNames(); //DB에서 읽은 이름 출력&#125; 의존성을 주입하는 방식으로 변경하니, NamePrinter는 어떤 곳에서 이름을 읽어오던 이름을 출력할 수 있게 됐다! 좋은 설계를 쉽게 사용하기 위해서DI를 활용해서 유연하고 확장하기 좋은 설계를 만들었다.그런데 조금 걸리는게 있다. 클라이언트가 PrintName을 통해 이름을 출력하고 싶으면 의존성을 주입해줘야 한다.setter를 쓰던 생성자를 통해 주입을 해주던 매번 해줘야 된다는 의미다. 1234567//생성자 주입을 하는 경우NamePrinter namePrinter = new NamePrinter(new DBReader());namePrinter.readNames();//세터 주입을 하는 경우NamePrinter namePrinter = new NamePrinter();namePrinter.setNameReader(new FileReader());nameReader.readNames(); 흠. 꽤 번거롭다. 지금은 두개의 객체가 협력하는 책임이라 그나마 봐줄만 하지만,만약 추상화 수준이 높은 객체의 책임을 실행하려면 수많은 객체를 주입해줘야 할 것이다. 이 문제를 스프링이 해결해줄 수 있다.스프링은 객체를 생성하는 과정을 프로그래머가 아닌 자신이 한다.그리고 만들어진 객체를 스프링이 관리한다. 예제를 통해 확인하기스프링을 통해 객체를 관리하려면 스프링에게 어떤 객체를 관리할 것인지 알려줘야 한다.자세히보면 @Component 어노테이션을 붙였다.이 객체를 만들고 관리하는 일은 스프링이 해달라는 표시다. 1234567891011121314151617@Componentpublic class NamePrinter &#123; private NameReader nameReader; public NamePrinter(NameReader nameReader) &#123; this.nameReader = nameReader; &#125; public void printNames() &#123; System.out.println(nameReader.readNames()); &#125; public void setNameReader(NameReader nameReader) &#123; this.nameReader = nameReader; &#125;&#125; 근데 잠깐만, 스프링이 객체를 생성하려면 NameReader 객체가 필요하다.(생성자가 그것 뿐이니,,)그러면 NameReader 객체는 어디서 가져오는건가?! 12345678@Componentpublic class FileReader implements NameReader &#123; public String readNames() &#123; //여기서 파일을 읽는 로직 작성됐음을 가정 return &quot;Read some Files&quot;; &#125;&#125; 이렇게 필요했던 NameReader의 구현체에도 @Component 어노테이션을 붙여서 스프링이 이 객체를 생성해서 관리하게 하면 된다! 즉! 일단 스프링 어플리케이션을 실행하면 먼저 컴포넌트 스캔을 실행한다.컴포넌트 스캔은 @Component가 붙은 클래스를 객체로 만들어 IoC 컨테이너에 올려둔다.이때 중요한 건! 만약 DI 받는 객체가 있는 경우, 스프링이 IoC 컨테이너에 있는 객체일 경우 자동으로 주입해준다!! 반면 생성자로 주입받으려는 객체가 IoC 컨테이너에 없는 경우 컴파일에러를 일으킨다. 한 가지 궁금한 점! 아까 DI를 활용하면 유연하고 확장 가능한 구조를 얻을 수 있다고 했다.하지만 스프링을 통해 아까 예제에 있던 NameReader의 두 구현체 모두에게 @Component를 붙여 관리하도록 하면,컴파일 에러가 생긴다. 즉 NamePrinter가 어떤 구현체를 주입해서 객체를 생성해야 할 지 결정내리지 못하는 문제가 생긴다. 이 문제는 추후 더 알아보도록 하자!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"불필요한 객체 생성을 피해라","slug":"java/java-basic/effective-java/effective6","date":"2022-04-08T15:29:09.000Z","updated":"2022-04-08T16:25:13.689Z","comments":true,"path":"2022/04/09/java/java-basic/effective-java/effective6/","link":"","permalink":"https://yangdongjue5510.github.io/2022/04/09/java/java-basic/effective-java/effective6/","excerpt":"","text":"요약 변경되지 않는 객체를 사용할 때마다 새로운 객체를 만들지 말자. 불필요한 객체 생성을 하는 예시String12String bad = new String(&quot;bikini&quot;); //안좋은 예시String good = &quot;bikini&quot;; //무난한 예시 new String(“bikini”)로 문자열을 만드는 경우 불필요한 문자열 객체를 만든다.왜? “bikini”라는 코드 자체가 문자열 객체를 만들기 때문이다. 문자열 객체를 만들고 다시 새로운 객체로 만드는 코드인 셈이다. 반면 두번째 줄 코드는 가상 머신에서 문자열 리터럴을 하나 만들어서 재사용한다. 123for (int i = 0; i &lt; 100; i++) &#123; new String(&quot;bikini&quot;); //얼마나 많은 문자열 객체가 만들어질까?&#125; 반복문에 위처럼 문자열 객체를 만들면 불필요한 객체가 생기게 된다. 정적 팩터리 메서드로 불변 클래스 효율적으로 만들기12Boolean trueBoolean = new Boolean(&quot;true&quot;); //안좋은 예시Boolean falseBoolean = Boolean.of(&quot;false&quot;); //좋은 예시 Boolean 클래스는 객체 내부가 변경되지 않는 불변 객체이다.불변 객체는 굳이 사용할 때마다 객체를 만들어주지 않아도 된다. 새로운 객체를 만들기보다는 만들어진 객체를 반환하는 기능을 정적 팩터리 메서드로 할 수 있다. 1234567891011121314151617181920212223242526272829303132public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt;, Constable&#123; public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); @SuppressWarnings(&quot;unchecked&quot;) public static final Class&lt;Boolean&gt; TYPE = (Class&lt;Boolean&gt;) Class.getPrimitiveClass(&quot;boolean&quot;); private final boolean value; @java.io.Serial private static final long serialVersionUID = -3665804199014368530L; @Deprecated(since=&quot;9&quot;) public Boolean(boolean value) &#123; this.value = value; &#125; @Deprecated(since=&quot;9&quot;) public Boolean(String s) &#123; this(parseBoolean(s)); &#125; //생략 public static Boolean valueOf(String s) &#123; return parseBoolean(s) ? TRUE : FALSE; &#125;&#125; Boolean 객체 내부를 보면 자신의 인스턴스들을 내부에서 클래스 변수로 가지고 있다.정적 팩터리 메서드로 전달받은 인수에 맞는 인스턴스를 반환해주면 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"조합으로 체스 말 이동 범위 검사하기!","slug":"java/woowa-tech-course/composition-chess","date":"2022-04-08T00:31:53.000Z","updated":"2022-04-08T15:27:53.400Z","comments":true,"path":"2022/04/08/java/woowa-tech-course/composition-chess/","link":"","permalink":"https://yangdongjue5510.github.io/2022/04/08/java/woowa-tech-course/composition-chess/","excerpt":"","text":"요약 체스 말 객체들이 해당 위치로 이동할 수 있는지 검증하는 로직이 중복된 경우가 있었다.이를 따로 분리해서 중복을 제거하고자 했다. 도입 배경체스 말 종류 구현하기체스 말 객체(Piece)는 자신의 위치와 이동할 위치를 전달받아서 이동할 위치로 이동할 수 있는지 확인한다. 123456789101112131415161718192021public abstract class Piece &#123; private final Color color; private MovableStrategy strategy; public Piece(final Color color, final MovableStrategy strategy) &#123; this.color = color; this.strategy = strategy; &#125; public abstract double getPointValue(); public boolean movable(Square source, Square target, MoveType moveType) &#123; if (source.equals(target)) &#123; throw new IllegalArgumentException(&quot;같은 위치로는 이동 불가능합니다.&quot;); &#125; return this.strategy.movable(source, target, moveType); &#125; //...생략&#125; 체스 말 객체는 여러가지 종류가 있다. (퀸, 킹, 폰, 비숍, 룩, 나이트)Piece를 상속받아서 다양한 종류를 구현한다. 1public final class King extends Piece 체스 말 종류에 따라 달라지는 이동 범위체스 말 객체는 종류에 따라 이동 범위가 다르다. 문제는 각 클래스마다 이동 검증 로직이 중복되는 게 많다는 점이다! 중복되는 코드퀸 기물의 코드이다. 123456789101112131415public final class Queen extends Piece &#123; private static final List&lt;Direction&gt; QUEEN_DIRECTION = List.of(EAST, WEST, SOUTH, NORTH, SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST); public Queen(Color color) &#123; super(color); &#125; @Override public boolean movable(Square source, Square target, MoveType moveType) &#123; Direction direction = source.findDirection(target); return QUEEN_DIRECTION.contains(direction); &#125;&#125; 반면 이건 룩 기물의 코드이다. 1234567891011121314public final class Bishop extends Piece&#123; public static final List&lt;Direction&gt; BISHOP_DIRECTION = List.of(SOUTHEAST, NORTHEAST, SOUTHWEST, NORTHWEST); public Bishop(Color color) &#123; super(color); &#125; @Override public boolean movable(Square source, Square target, MoveType moveType) &#123; Direction direction = source.findDirection(target); return BISHOP_DIRECTION.contains(direction); &#125;&#125; 여기서 잘 보면 movable 메서드 안에 로직이 중복됨을 알 수 있다. 이를 해결해보자. 조합으로 중복 제거하기이때 체스 말 객체를 두가지로 나눠서 생각한다. 이동하는 거리가 제한 없는 경우 VS 이동하는 거리가 제한 있는 경우 전자는 퀸, 비숍, 룩이 해당한다.후자는 폰, 킹, 나이트가 해당한다. 그렇다면 거리 제한 없이 이동하는 전략과 거리 제한이 있는 전략을 구분해서 추상화할 수 있지 않을까? 인터페이스로 전략을 추상화해서 만들기모든 종류의 체스 말들이 자신의 이동여부를 확인할 수 있도록하는 인터페이스를 만들어보자. 1234public interface MovableStrategy &#123; boolean movable(Square source, Square target, MoveType moveType);&#125; 자신의 위치, 목표 위치, 움직임이 공격인지를 전달받아 해당 목표로 갈 수 있는지 판단한다. 이동하는 거리가 제한 없는 경우인터페이스를 구현해서 먼저 이동하는 거리가 제한이 없는 경우의 전략을 만들어보자. 1234567891011121314151617public class UnlimitedMovableStrategy implements MovableStrategy &#123; private final List&lt;Direction&gt; movableDirections; public UnlimitedMovableStrategy(List&lt;Direction&gt; movableDirections) &#123; this.movableDirections = movableDirections; &#125; public boolean movable(Square source, Square target, MoveType moveType) &#123; try &#123; Direction direction = source.findDirection(target); return movableDirections.contains(direction); &#125; catch (IllegalArgumentException e) &#123; return false; &#125; &#125;&#125; 이동하는 거리가 제한이 없는 전략은 가려는 목표지점의 방향이 내가 갈 수 있는 방향인지만 검사하면 된다. 즉 룩의 경우 상하좌우로 거리제한없이 이동할 수 있다.룩이 가려는 목표 지점이 상하좌우 방향 중 하나에 있다면, 룩은 그 목표로 갈 수 있다.(이동 경로에 다른 누군가 있는 경우나 목표 지점이 같은 편이 있는 경우는 다른 곳에서 검증한다.) 이동하는 거리가 제한된 경우이동하는 거리가 제한된 경우의 전략을 보자. 1234567891011121314151617181920public class LimitedMovableStrategy implements MovableStrategy &#123; private final List&lt;Direction&gt; movableDirections; private final int moveLimit; public LimitedMovableStrategy(List&lt;Direction&gt; movableDirections, int moveLimit) &#123; this.movableDirections = movableDirections; this.moveLimit = moveLimit; &#125; @Override public boolean movable(Square source, Square target, MoveType moveType) &#123; try &#123; Distance distance = source.getDistance(target); Direction direction = source.findDirection(target); return movableDirections.contains(direction) &amp;&amp; distance.isInRange(moveLimit); &#125; catch (IllegalArgumentException e) &#123; return false; &#125; &#125;&#125; 이동하려는 거리 제한이 있으면 두 위치간에 거리를 추가로 확인해주면 된다. 폰의 이동 전략폰의 이동 전략은 꽤 까다롭다. 첫 위치에서 움직이는 경우 전진을 두칸까지 할 수 있다.공격은 반드시 전진 방향 대각선으로 할 수 있다. 이를 위해서는 MoveType에 따라 다른 전략을 만들어서 실행해줘야 한다. 1234567891011121314151617181920212223242526272829303132public class PawnMovableStrategy implements MovableStrategy &#123; private static final int FIRST_MOVE_LIMIT = 2; private static final int NOT_FIRST_MOVE_LIMIT = 1; private static final int ATTACK_LIMIT = 1; private final List&lt;Direction&gt; nonAttackDirection; private final List&lt;Direction&gt; attackDirection; private final Rank startRank; public PawnMovableStrategy(List&lt;Direction&gt; nonAttackDirection, List&lt;Direction&gt; attackDirection, Rank startRank) &#123; this.nonAttackDirection = nonAttackDirection; this.attackDirection = attackDirection; this.startRank = startRank; &#125; @Override public boolean movable(Square source, Square target, MoveType moveType) &#123; if (moveType.isAttack()) &#123; return new LimitedMovableStrategy(attackDirection, ATTACK_LIMIT).movable(source, target, moveType); &#125; return nonAttackMovable(source, target); &#125; private boolean nonAttackMovable(Square source, Square target) &#123; if (source.isSameRank(startRank)) &#123; return new LimitedMovableStrategy(nonAttackDirection, FIRST_MOVE_LIMIT).movable(source, target, MoveType.MOVE); &#125; return new LimitedMovableStrategy(nonAttackDirection, NOT_FIRST_MOVE_LIMIT).movable(source, target, MoveType.MOVE); &#125;&#125; 폰의 이동전략을 수행하기 위해서는 자신의 첫 위치 시점(starkRank), 공격가능 방향(attckDirection), 이동 가능 방향(nonAttackDirection)을 주입받는다. 현재 이동하려는 것이 공격이면 공격에 맞는 방향과 거리로 검증한다.반면 그냥 이동하려는 경우는 이동에 맞는 방향과 거리로 검증한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"Java의 Call by Value","slug":"java/java-basic/java-call-by-value","date":"2022-04-02T09:11:48.000Z","updated":"2022-04-02T13:59:23.532Z","comments":true,"path":"2022/04/02/java/java-basic/java-call-by-value/","link":"","permalink":"https://yangdongjue5510.github.io/2022/04/02/java/java-basic/java-call-by-value/","excerpt":"","text":"요약 자바에는 Call by Value만 존재한다.Call by Value는 함수의 인자에 값을 전달하는 방식이고,Call by Reference는 함수의 인자에 주소를 전달하는 방식이다. Call by Value vs Call by Reference프로그래밍 언어에서 함수에 인자로 전달하는 방식에 따라 나뉜다. Call by ValueCall by Value는 함수 호출시 전달되는 변수의 값을 복사해서 전달한다.이렇게 전달된 인자는 외부에서 있었던 변수와는 달리 함수 내부의 지역 변수로 활용된다.즉 함수 안에서 인자를 변경해도 외부 변수 값은 변경되지 않는다. 12345678910111213141516public class CallByValueTest &#123; private void swap(int a, int b) &#123; int tmp = a; a = b; b = tmp; &#125; @Test public void swapTest() &#123; int a = 1; int b = 2; swap(1, 2); assertThat(a == 2 &amp;&amp; b == 1).isTrue(); &#125;&#125; 위 테스트 코드를 살펴보자.swap 함수는 두 int형 변수의 값을 바꾸는 함수다. 그런데 테스트 결과는 맞지 않게 나온다.원인은 swap 함수에서 변수를 가져오는 과정이 Call by Value이기 때문이다. 테스트 코드에서 전달한 a와 swap 내부에서의 a는 서로 영향을 주지 않는다.테스트 코드의 a에 저장된 1이라는 값을 복사해서 메서드의 a에 저장한 것일 뿐이다. Call by ReferenceCall by Reference는 함수 호출 시 전달되는 변수의 참조값을 전달하는 방식이다.함수가 인자로 주소값을 전달받고나서 이를 함수 내부에서 접근하여 수정하면,함수 외부의 변수도 변화가 생길 수 있다. Java의 Call by Value Java는 전달되는 인자의 타입에 따라 약간 다르게 보인다. 원시 타입자바는 8가지 원시 타입이 있다.(byte, short, int, long, float, double, char, boolean) 원시 타입 변수들은 스택 메모리에 그대로 저장된다.그래서 원시 타입이 인자로 전달될 때는 스택에 저장된 값 그대로 복사되어서 전달된다. 전달된 값은 원래 변수와는 다른 별개의 변수. 즉 Call by Value 방식으로 전달된다.전달된 갑쇼은 해당 메서드가 종료되면 스택에서 제거된다. 예시로 이해하기12345678910111213141516public class CallByValueTest &#123; @Test public void swapTest() &#123; int a = 1; int b = 2; //1단계 swap(1, 2); //2단계 assertThat(a == 2 &amp;&amp; b == 1).isTrue(); &#125; private void swap(int c, int d) &#123; int tmp = c; c = d; d = tmp; //3단계 &#125;&#125; 아까 본 예시로 다시 이해해보자. 1단계까지 실행하고 나면 스택에는 a &#x3D; 1, b &#x3D; 2 라는 정보를 저장하게 된다.2단계를 실행하고 나면 a &#x3D; 1, b &#x3D; 2 라는 정보에 새로운 스택 프레임이 생기고 그곳에 c &#x3D; 1, d &#x3D; 2가 생긴다.즉 (a &#x3D;1 , b &#x3D; 2), (c &#x3D; 1, d &#x3D; 2) 이런 식으로 스택에 저장된다. 이제 3단계까지 실행하면 스택은 (a &#x3D; 1, b &#x3D;2), (c &#x3D; 2, d &#x3D; 1, tmp &#x3D; 1) 이렇게 저장된다.swap 메서드가 종료되면 swap 메서드의 프레임이 종료되므로 결국 (a &#x3D; 1, b &#x3D; 2)만 스택에 남는다. 참조 타입참조 타입은 쉽게 말해서 객체의 주소를 저장하는 타입이다.보통 기본 타입을 제외한 모든 것을 의미한다. 참조 타입은 기본 타입과 다르게 값 그 자체를 저장하지 않는다.대신 그 값의 주소 값을 저장한다. 그렇다면 그 값의 주소는 어디의 주소를 의미하는 걸까?그 주소는 바로 힙 영역에 있는 인스턴스의 주소를 의미한다. 즉 참조 타입은 객체의 주소를 가지고 스택에 저장되고,그 주소는 힙 영역에 있는 인스턴스의 주소다. 앞서서 자바는 Call by Value라고 했다.참조 타입도 예외는 아니다. Call by Value다.다만 전달되는 Value가 주소값이라서 기본 타입과는 다르게 작동한다. 예시로 이해하기12345678910111213141516171819202122class UserAge &#123; int value;&#125;public class CallByValueTest &#123; @Test void callByValueObject() &#123; UserAge a = new UserAge(); a.value = 1; UserAge b = new UserAge(); b.value = 2; //1단계 swap(a, b); //2단계 assertThat(a.value == 2 &amp;&amp; b.value == 1).isTrue(); &#125; private void swap(UserAge c, UserAge d) &#123; int tmp = c.value; c.value = d.value; d.value = tmp; &#125;&#125; UserAge는 int 형 데이터를 저장하는 클래스다.이제 두개의 UserAge를 만들어서 값을 변경하는 swap 메서드에 전달해보자. 1단계까지 오면 스택에 a &#x3D; UserAge 주소값1, b &#x3D; UserAge 주소값2 이 오게된다.우리가 만든 실제 객체는 힙 영역에 있고 스택의 주소값은 힙 영역을 가르키는 값이다. 2단계까지 오면 이제 새로운 스택 프레임이 생긴다.c와 d에 a, b가 가진 값(즉 주소값)을 복사해서 넣어준다. 즉 Call by Value 방식으로 전달한다. 스택에는 (a &#x3D; UserAge주소1, b &#x3D; UserAge주소2), (c &#x3D; UserAge주소1, d &#x3D; UserAge주소2) 이렇게 저장된다. 이때 주목할 점은 a와 c가 같은 주소값을 저장하고 있고, b와 d가 같은 값을 저장하고 있다는 점이다.이제 c를 통해 힙에 있는 인스턴스를 변경하면 나중에 a를 통해 인스턴스에 접근했을 때 값이 변경되어 있게 된다.(b와 d도 같은 관계다.) 정리 자바는 모두 Call by Value이다.다만 원시 타입은 값 자체를 복사해서 전달하고,참조 타입은 참조하는 객체의 주소를 복사해서 전달한다. 참고 https://deveric.tistory.com/92https://www.baeldung.com/java-pass-by-value-or-pass-by-referencehttps://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-valuehttps://kingpodo.tistory.com/54https://johngrib.github.io/wiki/jvm-stack/#stack%EA%B3%BC-framehttps://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"상속과 조합","slug":"java/java-basic/object/post-3","date":"2022-03-12T04:28:30.000Z","updated":"2022-03-19T05:29:39.679Z","comments":true,"path":"2022/03/12/java/java-basic/object/post-3/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/12/java/java-basic/object/post-3/","excerpt":"","text":"상속의 위험성상속은 중복코드를 없애고 코드 재사용을 하기 위해 등장한 개념이다.내가 필요로 하는 클래스와 매우 유사한 클래스가 있다면 해당 클래스를 상속하면 같은 코드를 여러번 쓸 필요가 줄어든다. 상속은 코드 재사용을 위해 캡슐화를 희생시킨다. 부모 클래스의 코드를 재활용하기 위해 자식 클래스도 재활용할 코드를 모두 공개되기 때문이다. 경고 1. 자식 클래스 메서드 안에서 super 참조로 부모 클래스의 메서드를 직접 호출하면 두 클래스의 결합도가 높아진다. (super 참조를 제거하라.) 상속을 염두해두고 설계하지 않은 클래스를 상속하기 어렵다.기존의 코드를 다른 상황에 재사용하기 위해서는 개발자가 나름의 해석을 하고 가정한다.그러나 개발자의 가정을 이해해야 하는 코드는 읽기가 어려워진다. 실제 요구사항과 구현이 다르면 우리는 기존의 구현을 요구사항과 같은 결과를 나타내도록 많은 가정을 하게된다. 상속을 하려면 부모 클래스의 가정과 추론 과정을 정확하게 이해해야 한다.상속은 부모 클래스의 구체적인 구현을 이해해야 할 가능성이 높다. 그래서 결합도(다른 모듈에 대해 알고 있어야할 지식의 수준)가 높다. 자식 클래스가 부모 클래스의 변경이 취약해진다. 취약한 기반 클래스 문제.만약 부모 클래스의 변경된 부분이 자식 클래스에 파생되는 행동이라면, 자식 클래스의 행동이 예상과 다르게 작동 될 수 있다. 상속은 자식 클래스가 부모 클래스의 구현 세부 사항에 의존하도록 만든다.상속은 부모 클래스의 퍼블릭 인터페이스가 아닌 다른 곳을 고쳐도 영향을 받는다. 이게 캡슐화를 약화시킨다는 증거다. 경고 2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다. 코드 재활용을 하기 위해 부모 클래스를 상속 할 경우, 부모에서 공개 됐던 메서드들이 자식 클래스의 내부 규칙을 깨트릴 수 있다. 오브젝트에서 제시한 예시는 Vector를 상속받는 Stack이다.Stack은 push와 pop으로만 데이터를 수정할 수 있다. 그러나 Vector는 퍼블릭 인터페이스로 다양한 인덱스에 add할 수 있게한다. 이는 Stack의 규칙을 깨트리는 방식이다. 123456Stack&lt;String&gt; stack = new Stack&lt;&gt;();stack.push(&quot;1st&quot;);stack.push(&quot;2nd&quot;);stack.push(&quot;3rd&quot;);stack.add(0, &quot;4th&quot;); //이건 Vector의 퍼블릭 인터페이스. 스택의 규칙에 어긋난 행동 경고 3. 자식이 부모의 메서드를 오버라이딩하면 부모의 다른 메서드가 자식의 메서드를 결합하게 될 수 있다. 부모 클래스의 특정 메서드를 자식 클래스가 오버라이딩 하게 되면, 부모 클래스에서 해당 클래스를 원래의 메서드(즉 오버라이딩 되기 전 메서드)를 예상하고 사용했던 부분에서 예기치 못한 작동(오버라이딩 된 메서드)를 수행할 수 있다. 경고 4. 부모 클래스에 변화가 생기면 자식도 같이 변해야 되는 일이 생길 수 있다. 상속은 결합도가 높아서, 부모와 자식이 같이 변하거나, 자식과 부모를 변경하지 않거나 두가지 선택지 밖에 없다. 부모 클래스를 오버라이딩 하지 않고 불필요한 퍼블릭 인터페이스를 상속받지 않아도 부모의 중요한 부분이 변경되면 자식 클래스도 같이 변경될 수 밖에 없다. 상속을 보다 안전하게 사용하기추상화에 의존자식 클래스가 부모 클래스의 구현이 아닌 부모 클래스의 추상화에 의존해야 한다.더 정확하게 말하면 부모와 자식 모두 추상화에 의존해야 한다. 달라지는 부분을 찾아 메서드로 분리비슷해보이는 클래스 간에 서로 다른 부분을 메서드를 추출한다.그러면 다른 부분을 제외하면 나머지 메서드들은 동일하게 된다.그러면 이제 중복 코드를 부모 클래스로 올린다.그리고 달라지는 부분은 부모의 추상 메서드로, 각 클래스들이 구현하도록 하면 된다. 이제 자식 클래스들은 부모의 추상 메서드에만 의존하게 되므로 느슨하게 결합된다. 하지만 이런 추상 클래스를 활용한 추상화에 의존하는 방법도 문제가 있다.객체 행동만 변하면 각 클래스를 독립적으로 변경시키면 되겠지만, 인스턴스 변수가 추가되는 경우는 다르다.부모 클래스에 인스턴스 변수가 추가되어 객체 생성때 초기화해줘야 하는 경우, 상속되는 모든 클래스는 수정을 해줘야 한다. 합성을 활용하기상속은 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 방법.합성은 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다. 합성은 구현에 의존하지 않는다.합성은 내부 부분 객체의 퍼블릭 인터페이스에 의존한다. 즉 구현에 의존하는 것이 아닌 인터페이스에 의존하도록 할 수 있다.합성은 내부 부분 객체의 구현 방식이 변경되어도 전체 객체는 영향이 적다. 상속은 정적인 관계인데 합성은 동적인 관계이다.코드 작성 때 정해진 상속 관계를 실행 시점에서 변경이 불가능하다.반면 합성 관계는 코드 작성 때 정해진 관계를 실행 시점에서 변경이 가능하다. 상속을 합성으로 바꾸는 방법은 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다. 합성의 안전성불필요한 인터페이스 상속 문제부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,자식 클래스의 규칙에 맞게 인스턴스의 퍼블릭 인터페이스를 활용하면 된다. 메서드 오버라이딩 오작동 문제부모 클래스의 인스턴스를 외부에서 접근하지 못하도록 하고,자식 클래스의 메서드가 부모 인스턴스의 메서드를 오버라이딩해서 부모 인스턴스의 퍼블릭 인터페이스와 협력하면 된다.(이때 오버라이딩한 인스턴스 메서드가 인스턴스에게 동일한 메서드 호출을 전달하는 메서드를 포워딩 메서드라고 한다.) 부모 클래스와 자식 클래스의 동시 수정 문제합성이 이 문제를 완전히 해결하지는 못한다. 하지만 조합된 내부 인스턴스의 변경사항을 최대한 캡슐화 시킬 수 있다. 합성의 유연성하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함. 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 많이 늘어날 수 있다. 추상 메서드와 훅 메서드추상 메서드 : 개방 - 폐쇄 원칙을 만족하기 위한 설계. 하위 계층이 오버라이딩해서 구현훅 메서드 : 추상 메서드는 반드시 모두가 구현해야 해서 불편하다. 대부분의 하위 계층이 똑같이 구현하면 중복 코드가 많이 생기기 때문에 기본 구현을 해놓고 달라지는 경우에만 오버라이딩하는 메서드 기능 추가를 할 때 상속을 남용하면 필요 이상으로 클래스가 만들어진다.(클래스 폭발, 조합의 폭발)이런 문제는 자식 클래스와 부모 클래스의 다양한 조합이 필요한데 상속은 컴파일 타임에 관계가 결정되어 버려서 모든 조합을 미리 만들어놓으면서 생기는 문제다. 합성을 사용하면 컴파일 타임에서 정한 관계를 런타임에서 수정할 수 있다.상속은 조합의 결과를 개별의 클래스에 밀어넣는 방법이고, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 다음 런타임에서 인스턴스를 조립하는 방식이다. 그러면 상속은 언제 사용하는가코드 재활용을 목적으로 상속하면 변경하기 어렵고 유연하지 못하게 된다.만약 상속을 사용하려고 할 때 스스로에게 물어보자.내가 상속을 이용하는게 코드 재사용을 위한 것인가? 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위한 것인가? (코드 재사용을 위한 것이면 상속을 피해야 한다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"},{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"클린코드를 위한 함수","slug":"java/java-basic/clean-code/clean-code-2","date":"2022-03-04T08:37:59.000Z","updated":"2022-03-04T09:30:44.033Z","comments":true,"path":"2022/03/04/java/java-basic/clean-code/clean-code-2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/java-basic/clean-code/clean-code-2/","excerpt":"","text":"함수는 한 가지만 해라!함수에 적힌 코드들의 추상화 수준이 같은 단계로 통일시켜라는 의미다.혹은 함수 내에서 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 셈이다. 12345678910111213public Lotto createLotto(List&lt;String&gt; tokens) &#123; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (String token : tokens) &#123; numbers.add(Integer.parseInt(token)); &#125; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); for (int number : numbers) &#123; lottoNumbers.add(new LottoNumber(number)); &#125; return new Lotto(lottoNumbers);&#125; 위 코드는 크게 추상화 단계가 두가지이다. 문자열을 숫자로 바꾸는 단계 (추상화 단계 낮음) 숫자를 LottoNumber로 바꾸는 단계 (추상화 단계 중간) LottoNumber를 Lotto로 바꾸는 단계 (추상화 단계 높음) 이제 이 작업들을 나눠서 리팩토링 해보자.자연스럽게 내려가기 규칙이 적용되서 다음에 오는 함수는 추상화 단계가 하나씩 줄어드는 걸 볼 수 있다. 12345678910111213141516171819public Lotto createLotto(List&lt;String&gt; tokens) &#123; return new Lotto(createLottoNumbers(tokens));&#125;public List&lt;LottoNumber&gt; createLottoNumbers(List&lt;String&gt; tokens) &#123; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList(); for (int number : parseAll(tokens)) &#123; lottoNumbers.add(number); &#125; return lottoNumbers;&#125;public List&lt;Integer&gt; parseAll(List&lt;String&gt; tokens) &#123; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (String token : tokens) &#123; numbers.add(Integer.parse(token)); &#125; return numbers;&#125; 함수 인수함수에 전달되는 인수는 0개가 제일 좋다.3개 이상은 되도록 피해야 한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Clean Code","slug":"clean-code","permalink":"https://yangdongjue5510.github.io/tags/clean-code/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"클린코드를 위한 의미 있는 이름","slug":"java/java-basic/clean-code/clean-code-1","date":"2022-03-04T05:44:23.000Z","updated":"2022-03-04T08:37:55.679Z","comments":true,"path":"2022/03/04/java/java-basic/clean-code/clean-code-1/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/java-basic/clean-code/clean-code-1/","excerpt":"","text":"의도를 분명히 밝혀라 변수(혹은 함수나 클래스)의 존재 이유가 무엇인가? 어떤 일을 수행하는가? 어떻게 사용하는가? 이름으로 위 세가지가 표현이 안된다면 문제가 있다. 변수의 이름은 범위 크기에 비례해야 한다.123456int pricePerLotto = 1000;int Prizesum = 0;for (Lotto lotto : lottos) &#123; prizeSum += pricePerLotto * lotto.getPrize();&#125; 이름이 길수록 사용되는 범위가 넓다고 생각하자.예를 들면 for 문의 i는 해당 루프에서만 사용되서 짧아도 된다.이름이 길수록 검색도 용이하다. 맥락을 추가하라이름 그 자체로 의미를 분명히 보여주는 변수는 없다.함수나 클래스에서 맥락을 부여하면 이름을 더 자연스럽게 읽힐 수 있다.이마저도 힘들면 접두사를 붙일 수 있다. (stateName, 이런 식으로..) 123public void printNameAndPosition(String name, String position) &#123; System.out.println(name + position);&#125; name는 어떤 이름을 의미하고, positon는 어떤 위치를 표시하는 건지 도저히 알 수 없다. 이름과 포지션은 사실 자동차의 이름과 자동차의 위치를 말해주는 변수들이다.그럼 이를 더 잘 알려주기 위해 맥락을 추가해보자. 12345678public class Car &#123; private String name; private int position; public void printNameAndPosition() &#123; System.out.println(name + position); &#125;&#125; 이제 Car라는 맥락 안에서 이름과 위치를 파악하면 좀 더 의미있게 파악할 수 있다. 불필요한 맥락 제거그렇다고 불필요하게 맥락을 이름에 붙여주는건 불필요하다. 1234public class Car &#123; private String carName; private int carPosition; &#125; 이미 Car라는 맥락 안에서 쓰이는 이름에 굳이 car를 붙이지 않아도 되지않을까?","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Clean Code","slug":"clean-code","permalink":"https://yangdongjue5510.github.io/tags/clean-code/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","slug":"java/java-basic/effective-java/effective5","date":"2022-03-03T15:47:28.000Z","updated":"2022-03-03T16:37:16.427Z","comments":true,"path":"2022/03/04/java/java-basic/effective-java/effective5/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/java-basic/effective-java/effective5/","excerpt":"","text":"요약 클래스가 내부에 특정 자원에 의존하고, 그 클래스의 행동이 특정 자원에 따라 영향을 많이 받으면, 싱글톤과 정적 유틸리티 클래스로 구현하면 안된다.이런 영향력이 있는 자원을 클래스 내부에서 만들면 안된다.대신 이 자원(혹은 자원을 만드는 팩토리)을 해당 클래스를 인스턴스화 할 때 넘겨주자. 자원을 직접 명시하는 잘못된 예시 - 정적 유틸리티 &amp; 싱글턴맞춤법 검사기가 사전을 자원으로 가진다고 가정하자.만약 사전을 직접 명시한다는 건 어떤 얘기일까? 12345678//정적 유틸리티를 활용한 예제public class SpellChecker &#123; private static final Dictionary dictionary = new Dictionary(Language.ENGLISH); private SpellChecker() &#123;&#125; //객체 생성 방지 public static String changeSuggestions(String typo) &#123;...&#125;&#125; 12345678//싱글톤을 활용한 예제public class SpellChecker &#123; private final Dictionary dictionary = new Dictionary(Language.ENGLISH); private static SpellChecker INSTANCE = new SpellChecker(); private SpellChecker() &#123;&#125; public static String changeSuggestions(String typo) &#123;...&#125;&#125; 위 두 예시 모두 자원인 사전을 final로 직접 명시하고 있다. 나중에 다른 사전을 사용하고 싶을 때 변경이 힘들어진다. final을 제거하고 사전을 교체하는 메서드를 추가하는 방식은 멀티스레드 환경에 쓸 수 없음. 즉 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식을 사용하면 안된다! 의존 객체 주입 예시 - 생성할 때 필요한 자원 넘겨주기1234567public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Dictionary dictionary) &#123; this.dictionary = dictionary; &#125; //메서드..&#125; 자원이 많거나 의존 관계가 어떻든 잘 작동 불변성을 지원 생성자, 정적 팩터리, 빌더 모두에 적용 가능 자원 팩터리로 의존 객체 주입 - Supplier&lt;T&gt;1234567public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Supplier&lt;? extends Dictionary&gt; dictionaryFactory) &#123; this.dictionary = dictionaryFactory.get(); &#125; //메서드...&#125; 자원 팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.자바에서는 Supplier&lt;T&gt;가 해당한다. 위처럼 생성자(정적 팩토리 메서드나 빌더)에 팩토리를 넘겨받으면 다음같이 활용 가능하다. 12345public class Application &#123; public static void main(String[] args) &#123; SpellChecker englishChecker = new SpellChecker(() -&gt; new Dictionary(Language.ENGLISH)); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"인스턴스화를 막으려거든 private 생성자를 사용해라","slug":"java/java-basic/effective-java/effective4","date":"2022-03-03T15:04:59.000Z","updated":"2022-03-03T15:47:23.827Z","comments":true,"path":"2022/03/04/java/java-basic/effective-java/effective4/","link":"","permalink":"https://yangdongjue5510.github.io/2022/03/04/java/java-basic/effective-java/effective4/","excerpt":"","text":"인스턴스화하지 않으려는 클래스?객체지향적이지 않지만 필요할 때가 있다.java.lang.Math, java.util.Array 같이 기본 타입 값이나 배열 관련 메서드를 모아둔 곳java.util.Collections와 같이 특정 인터페이스를 구현한 객체를 생성하는 정적 메서드를 모아둔 곳.final 클래스와 관련된 메서드를 모아놓을 때. (final 클래스를 상속해서 하위 클래스에 메서드를 못넣음) 인스턴스화 하지 않으려면 private 생성자를 사용12345public class NotInstance &#123; private NotInstance() &#123; throw new AssertionError(); &#125;&#125; private로 기본 생성자를 해놓으면 외부에서 인스턴스화를 막을 수 있다.Private 기본 생성자를 해놓으면 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문이다. Private 기본 생성자는 상속도 못하게 만든다. 123456public class SomeClass extends Instance &#123; public SomeClass() &#123; //super(); 가 생략되어 있음. //부모 객체의 생성자가 private면 이 과정이 안되니 상속이 안된다. &#125;&#125; 추상 클래스의 위험성 추상 클래스 그 자체는 인스턴스화할 수 없다. 하지만, 추상 클래스는 상속한 클래스를 통해 인스턴스화 할 수 있다.게다가 사용자가 추상 클래스를 보면 인스턴스화 하지 말라고 이해하지 않고, 상속받아서 사용하라고 이해하기 때문에 더 위험하다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"자바 제네릭과 와일드카드 튜토리얼","slug":"java/java-basic/generic-tutorial","date":"2022-02-25T07:26:32.000Z","updated":"2022-04-02T13:57:26.954Z","comments":true,"path":"2022/02/25/java/java-basic/generic-tutorial/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/25/java/java-basic/generic-tutorial/","excerpt":"","text":"요약 본 포스트는 오라클 자바 튜토리얼 제네릭 부분을 공부한 내용을 적은 포스트이다.JDK 8 기반으로 작성됐다. https://docs.oracle.com/javase/tutorial/java/generics/why.html 제네릭은 왜 쓰는가제네릭은 클래스, 인터페이스, 메서드를 선언할 때 타입(클래스, 인터페이스)도 매개변수로 만들 수 있다.전통적인 매개변수와 마찬가지로 타입 매개변수도 다양한 인풋을 받을 수 있게한다. 타입 체크를 컴파일 타임에 한다. 12345678910//정수를 리스트에 담아서 사용하려고 했는데 실수로 문자열을 넣는 상황//제네릭이 아닌 경우List list = new ArrayList();list.add(&quot;hello&quot;); //컴파일 에러가 발생하지 않는다.int hello = (int) list.get(0); //나중에 실행하면 여기서 ClassCastException이 발생한다.//제네릭인 경우List&lt;Integer&gt; genericList = new ArrayList&lt;&gt;();genericList.add(&quot;hello&quot;); //컴파일 에러 캐스팅 할 필요 없어진다. 12345678//제네릭 없는 경우List list = new ArrayList();list.add(&quot;하이&quot;);String hi = (String) list.get(0); //제네릭을 전달하지 않으면 Object를 반환List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();stringList.add(&quot;하이&quot;);String hello = list.get(0); 제네릭 간단하게 사용해보자아무 타입이나 저장할 수 있는 Box 클래스를 구현하고자 한다.제네릭 없이 구현하자면 다음과 같을 것 이다. 1234567891011class ObjectBox &#123; Object content; public Object getContent() &#123; return content; &#125; public void setContent(Object content) &#123; this.content = content; &#125;&#125; 이런 경우, get할 때마다 casting을 해줘야 된다.그리고 담겨진 내용물을 잘못 파악해 casting해도 컴파일 타임에 알 수 없고 런타임 때 ClassCastException이 발생한다. 제네릭을 사용1234567891011class GenericBox&lt;T&gt; &#123; T content; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125;&#125; 제네릭을 사용하면 캐스팅이 필요없고 casting도 필요 없다. 타입 파라미터 네이밍 컨벤션위에서 T는 타입 파라미터라고 한다. E - Element K - Key N - Number T - Type V - Value S, U, V - 2, 3, 4번째 타입 이렇게 지칭한다. 제네릭 타입 인보킹과 인스턴스화제네릭 타입 인보킹은 위에서 적은 T와 같은 매개변수를 우리가 의도한 실제 타입으로 변환하는 행위를 말한다. 1Box&lt;Integer&gt; integerBox; 참조변수를 통해 타입 인보킹을 해줄 수 있다.이때 조심해야 할 것은 T는 타입 매개변수이고, Integer는 타입인자이다. 이 두가지는 다르다. 제네릭을 사용하는 클래스를 인스턴스화하려면 다음과 같다. 123Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();//타입 추론도 된다.Box&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"Enum에서 메서드 참조와 BiFunction 사용하기","slug":"java/woowa-tech-course/post-2","date":"2022-02-24T14:12:58.000Z","updated":"2022-02-24T15:21:11.218Z","comments":true,"path":"2022/02/24/java/woowa-tech-course/post-2/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/24/java/woowa-tech-course/post-2/","excerpt":"","text":"요약 int matchCount와 boolean bonusMatch를 BiFunction를 통해 해당 Enum 객체를 찾을 수 있다. 문제 배경 (안좋은 사례 모음) 로또 순위를 Enum LottoRank로 등수와 상금을 관리하고자 한다.LottoRank가 맞춘 번호 갯수와 보너스 번호 맞춤여부를 전달받아 등수를 판별해야 한다. LottoRank에 맞춘 번호 갯수와 보너스 번호 맞춤여부를 추가로 저장하면 된다? 123456789public enum LottoRank &#123; FIRST(new Money(2_000_000_000), 6, false), SECOND(new Money(30_000_000),5, true), THIRD(new Money(1_500_000), 5, false), FOURTH(new Money(50_000), 4, false), FIFTH(new Money(5_000), 3, false), NOTHING(Money.ZERO, 2, false); //이하 생략...&#125; 그런데 문제가 있다. 4등, 5등은 보너스 맞춤여부가 false이든 true이든 상관없이 맞춘 갯수만 중요하다.그리고 꽝인 경우, 맞춘 갯수가 2개 뿐만 아니라 1개, 0개여도 꽝이다. 그리고 꽝도 4등 5등의 경우와 마찬가지로 보너스 맞춤여부가 상관없다.이런 경우도 전부 알맞은 상금을 가진 열거형 객체를 반환해줘야 한다. 좀 더 순위가 나오는 경우를 구체화한다? 12345678910111213141516public enum LottoRank &#123; FIRST(new Money(2_000_000_000), 6, false), SECOND(new Money(30_000_000),5, true), THIRD(new Money(1_500_000), 5, false), FOURTH(new Money(50_000), 4, false), FOURTH_WITH_BONUS(new Money(50_000), 4, true), FIFTH(new Money(5_000), 3, false), FIFTH_WITH_BONUS(new Money(5_000), 3, true), NOTHING_TWO(Money.ZERO, 2, false); NOTHING_TWO_WITH_BONUS(Money.ZERO, 2, true); NOTHING_ONE(Money.ZERO, 1, false); NOTHING_ONE_WITH_BONUS(Money.ZERO, 1, true); NOTHING_(Money.ZERO, 0, false); NOTHING_WITH_BONUS(Money.ZERO, 0, true); //이하 생략...&#125; 음…이렇게 하면 당연히 안된다!!!!!!!물론 보너스 번호 일치여부를 또 다른 열거형으로 도입하면 보너스 맞춤여부가 상관없는 경우 BONUS_MATCH.NOT_NEED 이런 식으로 처리하면 되긴 할 것이다.그렇지만 NOTHING의 맞춘 갯수가 0 ~ 2개를 모두 적용되어야 된다. BiFunction 도입하기이제 생각을 좀 바꿔보자.열거형 객체가 순위를 정하는 기준을 메서드참조로 저장하고 있다면 어떨까? 1. 일단 등수를 구별하는 기준을 메서드로 만들어주자123456789101112131415161718192021222324252627public enum LottoRank &#123; //생략... private static boolean isFirstPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 6; &#125; private static boolean isSecondPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 5 &amp;&amp; bonusMatch; &#125; private static boolean isThirdPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 5 &amp;&amp; !bonusMatch; &#125; private static boolean isFourthPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 4; &#125; private static boolean isFifthPrize(Integer matchCount, boolean bonusMatch) &#123; return matchCount == 3; &#125; private static boolean isNothingPrize(Integer matchCount, boolean bonusMatch) &#123; return 0 &lt;= matchCount &amp;&amp; matchCount &lt; 3; &#125;&#125; 이렇게 각 등수를 구분하는 기준을 정해준다.물론 bonusMatch를 사용하지 않는 경우도 있다. 하지만 나중에 메서드 참조를 위해서 넣어줬다. 2. BiFunction을 메서드 참조를 통해 열거형의 필드로 보내준다.1234567891011121314151617public enum LottoRank &#123; FIRST(new Money(2_000_000_000), LottoRank::isFirstPrize), SECOND(new Money(30_000_000), LottoRank::isSecondPrize), THIRD(new Money(1_500_000), LottoRank::isThirdPrize), FOURTH(new Money(50_000), LottoRank::isFourthPrize), FIFTH(new Money(5_000), LottoRank::isFifthPrize), NOTHING(Money.ZERO, LottoRank::isNothingPrize); private final Money prize; private final BiFunction&lt;Integer, Boolean, Boolean&gt; predicate; LottoRank(Money prize, BiFunction&lt;Integer, Boolean, Boolean&gt; predicate) &#123; this.prize = prize; this.predicate = predicate; &#125; // 이하 생략&#125; 두가지 객체를 받아서 한가지로 결과를 반환하는 BiFunction 인터페이스를 필드로 가지고, 생성자로 초기화해주자.그리고 우리가 만들었던 메서드들이 메서드 참조로 BiFunction을 구현하게 된다!! 3. 각 객체의 BiFunction을 통해 적절한 순위 객체를 반환한다.12345678910111213141516public enum LottoRank &#123; //열거형의 필드와 생성자는 위에 나와있으니 생략. public static LottoRank of(Integer matchCount, boolean bonusMatch) &#123; return Stream.of(values()) .filter(rank -&gt; rank.isMatched(matchCount, bonusMatch)) .findFirst() .orElseThrow(InvalidMatchCountException::new); &#125; //등수 기준 구현 메서드는 위에 나와있으니 생략. private boolean isMatched(int matchCount, boolean bonusMatch) &#123; return predicate.apply(matchCount, bonusMatch); &#125;&#125; LottoRank의 모든 객체들을 순회하면서 그 객체의 BiFunction에 판별에 필요한 정보를 전달해줘서 적절한 순위를 찾아낸다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"Junit으로 parameterized test","slug":"java/woowa-tech-course/post-1","date":"2022-02-21T12:16:22.000Z","updated":"2022-03-12T04:17:21.320Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/post-1/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post-1/","excerpt":"","text":"요약 @ParameterizedTest 어노테이션과 함께 @MethodSorce나 @ValueSource를 통해 한 테스트 메서드에 여러번 파라미터를 넘길 수 있다. @MethodSource 도입 배경 자동차 이름의 글자 갯수가 5개 이하여야 하고, 자동차 이름이 빈 문자열이면 안되고 등등 다양한 제약 사항을 테스트해보고 싶다고 하자.근데 테스트 코드를 작성하다보니 다음과 같이 메서드가 비슷비슷하게 나올 때 이를 리팩토링해보자. 12345678910111213141516171819@SuppressWarnings(&quot;NonAsciiCharacters&quot;)public class CarNameTest &#123; @Test public void 자동차_이름_글자수_테스트() &#123; assertThatThrownBy(() -&gt; new CarName(&quot;다섯글자이상&quot;)) .isInstanceOf(RuntimeException.class) .hasMessageContaining(&quot;자동차 이름은 5자 이하여야 합니다.&quot;); &#125; @Test public void 자동차_이름이_존재하지_않는_경우_테스트() &#123; assertThatThrownBy(() -&gt; new CarName(&quot;&quot;)) .isInstanceOf(RuntimeException.class) .hasMessageContaining(&quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;); &#125; // 등등...&#125; 해결하기 주목할 점은 한 테스트 메서드에 여러개의 인자를 여러 케이스로 보낼 수 있다는 점이다!! 1234567891011121314151617181920public class CarNameTest &#123; private static Stream&lt;Arguments&gt; provideCarNameAndExceptionMessage() &#123; return Stream.of( Arguments.of(null, &quot;자동차 이름을 찾을 수 없습니다!&quot;), Arguments.of(&quot;다섯글자이상&quot;, &quot;자동차 이름은 5자 이하여야 합니다.&quot;), Arguments.of(&quot;&quot;, &quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;) ); &#125; @ParameterizedTest @MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;) public void 자동차_이름_예외_테스트(String carName, String message) &#123; assertThatThrownBy(() -&gt; new CarName(carName)) .isInstanceOf(CarNameException.class) .hasMessageContaining(message); &#125;&#125; 다음같이 @ParameterizedTest해서 @MethodSource로 해결할 수 있다! @ValueSource 도입 배경 한가지 메서드에 여러가지 경우의 수를 넣어 실험하고 싶은데 어떻게 할까?예를 들어 자동차 이름에 여러가지 이름을 넣어보고 실제로 들어갔는지 테스트해보고 싶으면 어떻게 할지 고민해보자. 1234567891011@Testpublic void 자동차_이름_테스트() &#123; Car klayCar = new Car(&quot;klay&quot;, 0); assertThat(klayCar.getName()).isEqualTo(&quot;klay&quot;); Car eveCar = new Car(&quot;eve&quot;, 0); assertThat(eveCar.getName()).isEqualTo(&quot;eve&quot;); Car pobiCar = new Car(&quot;pobi&quot;, 0); assertThat(pobiCar.getName()).isEqualTo(&quot;pobi&quot;);&#125; 이렇게 무식하게 하면 당연히 뚜들겨 맞는다. 해결하기 주목할점은 전달될 인자의 자료형에 따라 strings, ints 등 필드값을 바꿔주면 된다. 123456@ParameterizedTest@ValueSource(strings = &#123;&quot;클레이&quot;, &quot;이브&quot;, &quot;포비&quot;&#125;)public void 자동차_이름_테스트(String carName) &#123; Car car = new Car(carName, 0); assertThat(car.getName()).isEqualTo(carName);&#125; @EnumSource열거형도 파라미터로 전달해줄 수 있다. 123456@ParametherizedTest@EnumSource(value = CardFace.class)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore &gt; 0 &amp;&amp; cardScore &lt; 11).isTrue();&#125; names 필드를 통해 열거형에서 일부만 골라서 넘겨줄 수 있다. 123456@ParametherizedTest@EnumSource(value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore == 10).isTrue();&#125; mode 필드를 사용하면 일부를 제외하고 넘겨줄 수 있다. 123456789@ParametherizedTest@EnumSource( value = CardFace.class, names = &#123;&quot;TEN&quot;, &quot;KING&quot;, &quot;QUEEN&quot;, &quot;JACK&quot;&#125;, mode = EnumSource.Mode.EXCLUDE)void testAllSuit(CardFace face) &#123; int cardScore = face.getScore(); assertThat(cardScore != 10).isTrue();&#125; @CsvSourceCsvSource는 여러 값을 문자열로 작성해주면 알아서 맞는 매개변수로 바꿔서 가져온다. 123456789101112@ParameterizedTest@CsvSource(value = &#123;&quot;ACE,FIVE,true&quot;, &quot;ACE,SIX,false&quot;&#125;)void canReceiveCard(CardFace face1, CardFace face2, boolean expected) &#123; final Participator dealer = new Dealer(); final Card firstCard = new Card(SPADE, face1); final Card secondCard = new Card(SPADE, face2); dealer.receiveCard(firstCard); dealer.receiveCard(secondCard); assertThat(dealer.canReceiveCard()).isEqualTo(expected);&#125; 파라미터 테스트 이름 설정하기 @ParameterizedTest의 name 필드에 {매개변수인덱스}를 넘겨주면 해당 인자가 테스트 이름에 포함된다. {매개변수 인덱스} 말고도 다양한 템플릿을 사용할 수 있다.{displayName} : 테스트 메서드 이름{arguments} : 모든 인자를 쉼표로 구분해서 모두 표현{argumentsWithNames} : 모든 인자를 이름과 함께 보여줌. 123456789101112131415@ParameterizedTest(name = &quot;&#123;0&#125; vs &#123;1&#125; is &#123;2&#125;&quot;)@CsvSource(value = &#123;&quot;BLACKJACK,BUST,WIN&quot;, &quot;BLACKJACK,STAND,WIN&quot;, &quot;STAND,BUST,WIN&quot;, &quot;BLACKJACK,BLACKJACK,DRAW&quot;, &quot;STAND,STAND,DRAW&quot;, &quot;BUST,BUST,DRAW&quot;, &quot;BUST,STAND,LOSE&quot;, &quot;STAND,BLACKJACK,LOSE&quot;,&#125;)void getResultFromStatus(Status status1, Status status2, Result expected) &#123; Result actual = Result.of(status1, status2); assertThat(actual).isEqualTo(expected);&#125; 더 알아보기 https://www.baeldung.com/parameterized-tests-junit-5 https://www.arhohuttunen.com/junit-5-parameterized-tests/","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"우아한테크코스 자동차 경주 미션 회고","slug":"java/woowa-tech-course/post","date":"2022-02-21T09:37:50.000Z","updated":"2022-02-24T14:17:24.023Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/post/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/post/","excerpt":"","text":"아직도 내가 모르는 게 이렇게 많다니. 우테코 첫 미션을 하면서 배운 것도 많지만 그보다 더 많이 내가 모르고 있다는 걸 알게됐다.같이 공부하는 크루들도 출중한 사람이 엄청 많았다. 그에 비하면 내 코드는 뭐… 바보 같을 때가 많았다. 페어 프로그래밍으로 같이 하면서, 처음엔 나 혼자하는게 더 빠르지 않을까 싶기도 했었는데,같이하는 페어의 독특한 생각을 많이 느낄 수 있어서 나 혼자하는 것보다 더 괜찮은 결과물을 얻을 수 있었던 것 같다. 미션을 마무리한 날, 같은 데일리 미팅 크루들과 자신의 코드를 설명하는 시간을 가졌다.역시 각 크루들의 코드가 나와 다른 부분도 많았는데, 그 부분을 잘 설득하는 크루를 보며 감탄했다.반면 나는 아직 설명도 제대로 못하고, 내가 왜 그렇게 짰는지 설득도 잘 못하는 것 같아 아쉽다…! 부족한 게 많으면 나아질 부분도 많다는 뜻. 이제 더 열심히 공부해서 다른 크루에게 도움이 되는 크루가 되자.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"자바의 예외 Throwable, Error, Exception","slug":"java/java-basic/java-exception","date":"2022-02-21T01:34:05.000Z","updated":"2022-02-21T05:08:15.161Z","comments":true,"path":"2022/02/21/java/java-basic/java-exception/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/java-basic/java-exception/","excerpt":"","text":"요약 Throwable -&gt; Exception -&gt; RuntimeException 등 다양한 예외Throwable은 stackTrace 생성 등 예외에 필요한 다양한 일을 함Exception은 예외 메시지를 받아 초기화할 수 있다RuntimeException은 치명적이진 않은 예외를 뜻함.RuntimeException은 치명적일 수 있는 에외로 반드시 처리를 해줘야 함. Throwable모든 에러와 예외의 부모 클래스다.Throwable의 인스턴스만 JVM이나 throw 키워드를 통해 예외나 에러를 thrown 될 수 있다.마찬가지로 catch문에 Throwable의 인스턴스만 올 수 있다. Throwable 객체는 생성될 때 해당 예외가 발생하던 수행 스택의 스냅샷을 가지게 된다.또한 다른 Throwable에 의해 생성된 경우 cause를 통해 알 수 있다.cause는 상위 Exception가 throw 될 때 굳이 하위 레이어의 내용까지 전파하지 않기 위함이다. 사실 개발하는 입장에서는 자주 사용하진 않는다. ErrorThrowable을 상속받는 클래스로,Try catch로 처리되어선 안될 정도로 심각한 문제를 일으킬 수 있는 문제들을 Error 클래스로 표현한다.일반적으로 비정상적인 상태를 나타낼 때 주로 사용된다. ExceptionThrowable을 상속받는 클래스로,Try catch 되어야할 이유가 있는 문제들을 Exception으로 표현한다.이때 Checked Exception과 RuntimeException 두가지로 구분된다. Checked Exception은 반드시 try catch 되거나 throws 되어야 컴파일 되는 예외이다.RuntimeException은 try catch 되거나 throws 되지 않아도 되는 예외이다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"자바 사용자 정의 예외 만들기","slug":"java/woowa-tech-course/java-custom-exception","date":"2022-02-20T23:37:58.000Z","updated":"2022-02-24T14:16:59.712Z","comments":true,"path":"2022/02/21/java/woowa-tech-course/java-custom-exception/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/21/java/woowa-tech-course/java-custom-exception/","excerpt":"","text":"요약 예외를 상속하는 클래스를 통해 예외를 만들 수 있다.생성자를 통해 에러 메시지를 초기화 할 수 있다. 배경 12345public void checkCarNameEmpty(String carName) &#123; if (carName == null || carName.equals(&quot;&quot;)) &#123; throw new RuntimeException(&quot;자동차 이름이 입력되지 않았습니다!&quot;); &#125;&#125; 다음같이 작성하면 자동차 이름이 빈 문자열이거나 null인 경우 런타임예외를 발생시킨다. RuntimeException은 너무 포괄적인 의미이니 도메인에 적합한 예외를 만들어보자. 예외 클래스 만들기1. 생성자를 그대로 사용하기1234567891011121314public class EmptyCarNameException extends RuntimeExecption &#123; public EmptyCarNameException(String message) &#123; super(message); &#125; public EmptyCarNameException(Throwable cause) &#123; super(message); &#125; public EmptyCarNameException(String message, Throwable cause) &#123; super(message); &#125;&#125; 이런 식으로 예외를 상속한 클래스를 만들고, 생성자들을 만들면 커스텀 예외로 활용할 수 있다. 2. 좀 더 활용하기12345public class CarNameException extends RuntimeException &#123; public CarNameException(String message) &#123; super(message); &#125;&#125; 먼저 자동차 이름에 관련된 예외들이 모두 상속하는 수퍼클래스를 만들었다. 12345public class EmptyCarNameException extends CarNameException &#123; public EmptyCarNameException() &#123; super(&quot;빈 문자열을 자동차 이름으로 입력할 수 없습니다.&quot;); &#125;&#125; 자동차 이름 예외를 상속받도록 하였고,이미 특정 도메인 상황을 예외로 만들고 싶어서 사용자 정의 예외를 만들었기 때문에, 굳이 매번 에러메시지를 입력받아 생성할 필요가 없다고 생각했다.그래서 예외 클래스에 정해진 에러 메시지로 초기화하도록 만들었다. 실제 코드에 적용시켜보기123456789101112131415161718192021222324252627282930313233343536373839404142public class CarName &#123; private static int MAX_CAR_NAME_LENGTH = 5; private static String EMPTY_STRING = &quot;&quot;; private final String carName; public CarName(String carName) &#123; checkCarName(carName); this.carName = carName; &#125; private static void checkCarName(String input) &#123; checkCarNameNotNull(input); checkCarNameLength(input); checkCarNameExists(input); checkCarNameIsNotSpace(input); &#125; private static void checkCarNameNotNull(String carName) &#123; if (carName == null) &#123; throw new CarNameNullPointerException(); &#125; &#125; private static void checkCarNameLength(String carName) &#123; if (carName.length() &gt; MAX_CAR_NAME_LENGTH) &#123; throw new CarNameLengthOverException(carName.length()); &#125; &#125; private static void checkCarNameExists(String carName) &#123; if (carName.equals(EMPTY_STRING)) &#123; throw new CarNameNotExistsException(); &#125; &#125; private static void checkCarNameIsNotSpace(String carName) &#123; if (carName.trim().equals(EMPTY_STRING)) &#123; throw new CarNameSpaceException(); &#125; &#125;&#125; 이제 도메인에서 우리가 만든 사용자 예외를 검증해보자.도메인 객체가 만들어지기 전에 예외를 모두 검증한다. 테스트해보기1234567891011121314151617181920public class CarNameTest &#123; private static Stream&lt;Arguments&gt; provideCarNameAndExceptionMessage() &#123; return Stream.of( Arguments.of(null, &quot;자동차 이름을 찾을 수 없습니다!&quot;), Arguments.of(&quot;다섯글자이상&quot;, &quot;자동차 이름은 5자 이하여야 합니다.&quot;), Arguments.of(&quot;&quot;, &quot;모든 자동차 이름은 반드시 존재해야 합니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;), Arguments.of(&quot; &quot;, &quot;자동차 이름은 공백으로 설정할 수 없습니다.&quot;) ); &#125; @ParameterizedTest @MethodSource(value = &quot;provideCarNameAndExceptionMessage&quot;) public void 자동차_이릅_예외_테스트(String carName, String message) &#123; assertThatThrownBy(() -&gt; new CarName(carName)) .isInstanceOf(CarNameException.class) .hasMessageContaining(message); &#125;&#125; 다양한 예외 상황마다 예외 객체와 예외 메시지를 통해 테스트를 할 수 있다! 사용자 예외의 장단점장점 클래스의 이름으로 어떤 예외인지 가늠가능하다. CarNameEmtpyException이면 어떤 상황인지 바로 이해가능하다! 상세한 예외 정보를 제공할 수 있다. 자동차의 이름 길이가 5를 넘기면 예외를 발생시키고자 한다. 이때 사용자가 입력한 이름의 길이도 함께 알려주고 싶다면? 12345public class CarNameLengthOverException extends CarNameException &#123; public CarNameLengthOverException(int length) &#123; super(&quot;자동차 이름은 5자 이하여야 합니다. 입력된 글자 수 : &quot; + length); &#125;&#125; 예외 핸들링이 용이하다. 해당 예외 상황에 관련된 정보를 한 곳에 관리 가능하다. 단점 새로운 클래스를 작성해줘야 된다. 굳이 이미 있는 예외 클래스로도 처리 가능한데, 굳이 새로운 클래스를 작성해야 될 지 고민해야한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"자바 일급 컬렉션 활용해보기","slug":"java/woowa-tech-course/java-first-collection","date":"2022-02-16T12:10:39.000Z","updated":"2022-02-24T14:17:03.142Z","comments":true,"path":"2022/02/16/java/woowa-tech-course/java-first-collection/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/16/java/woowa-tech-course/java-first-collection/","excerpt":"","text":"요약 일급 컬렉션은 컬렉션 객체를 감싸는 객체를 말한다.일급 컬렉션은 객체를 만들 때 검증해야 할 로직을 모아 둘 수 있다.일급 컬렉션은 해당 컬렉션이 행해야 할 책임을 모아 둘 수 있다. 불변성을 지키기 위해서는 setter 금지. 일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당 getter 할 때 불변 객체 반환. 일급 컬렉션이란일급 컬렉션은 컬렉션 객체를 감싸는 객체다.일급 컬렉션은 멤버 변수로 감싸고자 하는 컬렉션만 갖는다. 12345678public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; //이하 생략... &#125; 일급 컬렉션의 강점1. 일급 컬렉션은 해당 컬렉션의 검증 로직을 한 곳에 모을 수 있다.예를 들어 자동차 경주에 참가할 자동차 리스트를 관리한다고 가정하자.이때 참가할 자동차들의 이름은 중복되면 안된다. 일급 컬렉션을 활용하면 참가할 자동차를 생성할 때 다음 같이 검증할 수 있다. 12345678910111213141516171819202122public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; private static void checkCarNameDuplicated(List&lt;String&gt; carNames) &#123; long count = carNames.stream().distinct().count(); if (count != carNames.size()) &#123; throw new CarNameDuplicationException(); &#125; &#125; //이하 생략...&#125; 이렇게 일급 컬렉션 객체의 생성자에 검증 로직을 넣어두면 참여중인 자동차 객체는 반드시 중복되지 않은 이름들을 가진다고 확신할 수 있다. 일급 컬렉션을 사용하지 않는다면 이런 검증 로직은 서비스 메서드로 처리하게 된다.그러면 매번 참여중 인 자동차를 만들 때 마다 서비스 메서드를 호출해줘야 되는 번거로움이 생긴다. 2. 상태와 행동을 한 곳에서 관리 할 수 있다.참여한 자동차들은 모두 레이싱을 시도하는 역할을 할 수 있다. 다음 같이 일급 컬렉션에 행동을 추가해서 관리할 수 있다. 12345678910111213141516171819202122public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; //생략... public void executeCarRacing(RandomNumberGenerator randomNumberGenerator) &#123; for (Car car : cars) &#123; car.tryToMoveBy(randomNumberGenerator); &#125; &#125;&#125; 일급 컬렉션을 통해 이 객체가 어떤 행동을 하는지도 한눈에 볼 수 있게됐다. 일급 컬렉션과 불변성일급 컬렉션이 불변하다는 특징을 가졌다고 알려졌는데, 사실 그렇지 않을 수 있다는 포스트도 있다. 관련 포스트 불변성을 지키고 싶다면 다음 세가지를 지켜주자 setter를 사용하지 않는다. 일급 컬렉션의 멤버 변수를 초기화할 때 가져온 인자를 새로운 주소값으로 재할당하자. getter를 할 때 불변한 콜렉션으로 반환하자. 1234567891011121314151617public class ParticipatedCars &#123; private static final int START_POSITION = 0; private final List&lt;Car&gt; cars; public ParticipatedCars(List&lt;String&gt; carNames) &#123; checkCarNameDuplicated(carNames); this.cars = new ArrayList&lt;&gt;(); // &lt;- 새로운 주소가 할당된다. for (String carName : carNames) &#123; cars.add(new Car(carName, START_POSITION)); &#125; &#125; public List&lt;Car&gt; getCars() &#123; return Collections.unmodifiableList(this.cars); //&lt;- getter할 때 불변된 리스트가 반환된다. &#125;&#125; 여전히 궁금한 것들 왜 일급 컬렉션은","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"자바에서 정규 표현식 잘 활용하기","slug":"java/woowa-tech-course/java-regex","date":"2022-02-09T14:45:29.000Z","updated":"2022-02-24T14:17:07.974Z","comments":true,"path":"2022/02/09/java/woowa-tech-course/java-regex/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/09/java/woowa-tech-course/java-regex/","excerpt":"","text":"요약 Pattern 클래스와 Matcher 클래스를 활용해서 자바 정규 표현식을 잘 표현한다. 특히 Matcher클래스에 정규 표현식을 compile(String)하고, matcher(String)으로 대상 문자열을 전달해준다.이때 find()메서드를 반드시 실행해줘야 정상적으로 Matcher 객체에 관련 내용이 할당된다!! Pattern 클래스로 정규 표현식 통과 여부 확인하기주어진 문자열이 input이고, 정규식이 REGEX라는 변수에 할당됐을 때,Pattern 클래스로 여부를 확인할 수 있다. 123private static boolean isMatches(String input) &#123; return Pattern.matches(REGEX, input);&#125; Matcher 클래스로 정규 표현식에 해당하는 문자열 부분 가져오기Pattern 클래스로 정규 표현식을 compile 메서드로 넘겨주고, 검사할 문자열을 matcher 메서드로 전달해주면 해당 문자열에 대한 Matcher 객체를 생성할 수 있다.이때 중요한 건! 해당 객체의 find 함수를 실행해야 group 메서드로 입력된 문자열 중 정규 표현식에 해당하는 부분을 가져올 수 있다. 12345private static String findRegexPart(String input) &#123; Matcher matcher = Pattern.compile(REGEX).matcher(input); matcher.find(); return matcher.group();&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"JPA에서 @Embedded로 복합키 매핑하기","slug":"spring/JPA/compositekey","date":"2022-02-03T08:11:16.000Z","updated":"2022-06-30T00:29:24.948Z","comments":true,"path":"2022/02/03/spring/JPA/compositekey/","link":"","permalink":"https://yangdongjue5510.github.io/2022/02/03/spring/JPA/compositekey/","excerpt":"","text":"요약 @Embeddable를 붙인 복합키 클래스를 만든다 엔티티 클래스에 @EmbeddedId를 통해 복합키 필드를 만든다. 이때 엔티티 클래스의 모든 매개변수를 받는 생성자를 만든다.이때 복합키 필드는 new로 객체를 초기화해준다. 문제 상황챌린지 테이블과 태그 테이블이 다대다 관계인 상황이다.이때 태그 테이블은 이름이 기본키이고, 챌린지 테이블은 챌린지 ID가 기본키로 가진다. 우리는 챌린지 테이블과 태그 테이블 사이에 매핑 테이블을 도입해서 다대일 관계 두 개로 분리해서 사용하기로 했다.챌린지 -(일대다)- 매핑 테이블 -(다대일)- 태그 이때 매핑 테이블은 기본키로 태그의 이름과 챌린지의 챌린지아이디를 가진다.(즉 복합키이다.)이를 어떻게 JPA로 표현할까? 관련 코드 해결방법 @EmbeddedId를 도입해서 복합키를 모은 클래스를 따로 만들어서 해결한다. ChallengeTag(매핑 테이블)12345678910111213141516171819202122232425@Builder@NoArgsConstructor@Setter@Getter@Entitypublic class ChallengeTag &#123; @EmbeddedId private ChallengeTagPK challengeTagPK; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;challenge_id&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT)) @MapsId(&quot;challengeId&quot;) private Challenge challenge; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;name&quot;, nullable = false, insertable = false, foreignKey = @ForeignKey(ConstraintMode.CONSTRAINT)) @MapsId(&quot;name&quot;) private Tag tag; public ChallengeTag(ChallengeTagPK challengeTagPK, Challenge challenge, Tag tag) &#123; this.challengeTagPK = new ChallengeTagPK(); this.challenge = challenge; this.tag = tag; &#125;&#125; ChallengeTagPK라는 필드를 만들어서 @EmbeddedId를 붙여줬다. 이러면 기본키를 복합키를 필드로 가지는 객체로 설정 할 수 있다. 이때 주의할 점 몇가지 알아보자. 1. 복합키에 따른 객체를 선언해줘야 한다. challengeId와 name을 복합키로 가지므로, Challenge 객체와 Tag 객체를 멤버로 가져야 한다. 각 객체는 @MapsId(“필드명”)으로 연결해줘야 한다. (괄호 안 이름은 ChallengeTagPK의 필드명이다.) 2. 모든 필드를 매개변수로 받는 생성자를 선언해야 한다. 이때 기본키를 담당하는 객체는 new로 초기화 한다! @AllArgsConstructor로 하지 않는다. ChallengeTagPK(기본키 클래스)12345678910111213@EqualsAndHashCode@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Embeddablepublic class ChallengeTagPK implements Serializable &#123; private Long challengeId; private String name;&#125; @Embeddable을 붙이면 복합키를 표현하는 클래스이다. 몇 가지 중요한 점을 살펴보자. 1. Setter 메서드를 선언해줘야 한다. 나중에 이 클래스의 필드를 challenge와 tag의 기본키를 가져와 초기화한다. 2. Serializable을 구현해야 한다. Serializable은 직렬화가 가능하다는 의미이다. 자바 객체를 외부 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는게 직렬화이다.(자바 객체를 바이트로 만들면 다른 자바 시스템에서 Reader로 읽어들일 수 있다.) 3. equals와 hashcode를 오버라이딩 해줘야 한다. 기본키는 식별할 수 있도록 해주는 역할이다. @Embeddable이 붙은 객체는 각 객체들과 구분되는 기준이 명확해야 한다.이 기준을 equals와 hashcode를 오버라이딩해서 해결한다. 롬복으로 @EqualsAndHashCode 를 붙여주면 쉽게 해결 가능하다.","categories":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}],"tags":[{"name":"sable project","slug":"sable-project","permalink":"https://yangdongjue5510.github.io/tags/sable-project/"}],"keywords":[{"name":"JPA","slug":"jpa","permalink":"https://yangdongjue5510.github.io/categories/jpa/"}]},{"title":"데이터베이스 설계 프로세스","slug":"cs/database/powerofdatabase01","date":"2022-01-06T13:35:42.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2022/01/06/cs/database/powerofdatabase01/","link":"","permalink":"https://yangdongjue5510.github.io/2022/01/06/cs/database/powerofdatabase01/","excerpt":"","text":"요약 데이터베이스 설계 과정을 배운다. 실전 예제로는 패캠 부트캠프 파이널 프로젝트(Sable 함께모으기 서비스) 예시로 한다. 임무 목표와 임무 명세 정의임무 명세 : 이 데이터베이스의 존재 이유나 목적을 단순한 한 문장으로 정리 임무 목표 : 이 데이터베이스가 수행해야 할 작업을 정리. 이렇게 작성된 목표와 임무 명세는 사용자와 관리자에게 타당해야 한다.각 임무 목표는 하나의 작업을 너무 디테일하지 않을 정도로 기술한다. 예시 임무 명세 : 함께 모으기 데이터베이스는 Sable의 함께모으기(저축 챌린지)에 필요한 데이터를 관리한다. 임무 1. 챌린지의 정보를 완전히 관리한다.임무 2. 사용자의 정보를 완전히 관리한다.임무 3. 챌린지마다 사용자가 작성한 리뷰를 관리한다.임무 4. 사용자의 계좌를 관리한다.임무 5. 챌린지의 계좌를 관리한다. 기존 데이터베이스 분석해당 데이터베이스의 사용자와 관리자의 요구사항을 인터뷰. 기존의 데이터베이스 분석. 인터뷰를 통해 대상과 사건을 특정할 수 있다.(사용자는 챌린지에 참여해서 규칙에 따라 저축 을 한다.)여기서 대상은 사용자, 챌린지, 규칙, 저축이다. 대상을 정리했으면, 각 대상에 대한 특징을 찾아낼 수 있다. 이 과정에서 예상되는 필드를 구성할 수 있다. 어떤 대상이, 어떤 특징을 가지는 지 분석 특정 대상의 특징을 설명하는게 필드다. 값 목록(특별한 값의 집합을 나타내는 특성)은 따로 표시한다. 계산된 필드는 따로 정리한다. 중복된 특성은 하나의 필드로 정리한다.(혹은 여러개로 나눠야 할 특성은 분해한다.) 예시 일단 우리 서비스에 요구사항을 정리해본다.사용자는 이름, 이메일, 생년월일, 닉네임, 성별, 비밀번호, 하나의 사용자 계좌와 여러 개의 챌린지 계좌를 가진다.챌린지는 챌린지 호스트, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표 금액, 챌린지 성공한 사람들의 리뷰를 가진다.챌린지는 챌린지 모드와 자유 모드가 있다.챌린지 모드는 패널티 금액을 가진다.자유 모드는 패널티 금액이 없다.챌린지는 정해진 시간 전에 모집을 시작해서 시작일이 되면 모집을 마감한다.사용자는 각 챌린지에서 자신이 원할 때 원하는 금액을 사용자 계좌에서 빼서 챌린지 계좌에 저축할 수 있다.각 챌린지 계좌에 사용자가 저금한 내용은 저장된다.…. 이제 대상을 정리해본다. (대상은 사람, 장소, 물건, 사건 등…)사용자, 챌린지, 호스트, 리뷰, 사용자 계좌, 챌린지 계좌 이제 대상마다 특징을 정리해본다.(계산된 필드와 값 목록 필드를 구분한다.) 특징(필드) : 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부, 챌린지 이름, 챌린지 시작일, 챌린지 종료일, 챌린지 내용, 챌린지 주기, 챌린지 목표금액, 챌린지 패널티 금액, 챌린지 공식 여부, 챌린지 모드 값 목록 필드 : 사용자가 가지는 챌린지 계좌들, 챌린지에 참여한 사용자들, 사용자가 한 챌린지에 저금한 내용들, 사용자가 참여한 챌린지들, 사용자가 만든 챌린지들 계산된 필드 : 사용자의 미션 달성율, 사용자의 챌린지 예금 합, 사용자의 챌린지 저축액 &#x2F; 챌린지 목표 금액, 챌린지의 참여 사용자 합 데이터 구조 생성 예비 필드 목록이 존재하면 이를 기반으로 대상에 할당해본다.(대상을 잘 설명하는 것 같은 필드를 할당) 예비 필드 목록을 검토하는 중 새로운 대상이 필요하면 추가한다. 앞 단계들을 통해 표현할 다양한 대상를 선정하여 테이블들에 할당한다.(처음 테이블을 만들면 모든 테이블은 데이터 테이블이 된다.) 데이터 테이블 : 조직에 중요한 주제를 나타냄 연결 테이블 : 다대다 관계의 두테이블의 연결 설정 부분 집합 테이블 : 특정 데이터 테이블과 관계. 특정 주제를 구체적으로 설명.부분 집합 테이블은 데이터들이 해당 필드를 모두 사용하지 않은 경우가 많은 경우를 말한다.(재고 테이블은 책 테이블과 장비 테이블을 하위 테이블로 만들 수 있다. (이는 서로 1대1 관계를 가진다.)) 검증 테이블 : 데이터 무결성을 제공하는 중요한 테이블 각 테이블의 필드들 할당하고 검토 좋은 필드의 조건을 따르는지 확인 필드들이 단독 값을 저장. 다중 구조나 다중값 필드는 개선 부분 집합 테이블을 구성한다. 각 테이블 키 설정 각 키는 데이터베이스에서 유일하게 식별할 수 있는 값이어야 한다.(부분 집합 테이블을 제외하면 동일한 기본키를 가지면 안된다.) 만약 마땅한 키가 없는 경우, 인위적인 키를 만들어줄 수 있다. 데이터베이스 각 필드의 필드 명세 설정 일반적 요소 : 필드 이름, 소속 테이블 등… 물리적 요소 : 데이터 타입, 길이, 문자 지원 등.. 논리적 요소 : 키 종류, 유일성, 널 지원, 기본값 등.. 좋은 필드의 조건 테이블의 대상의 특성을 잘 설명하는 필드가 되도록 한다. 필드는 단 하나의 값을 포함한다 더 작은 구성요소로 해체 될 수 없다. 계산되거나 연결된 값은 포함하지 않는다. 전체 데이터베이스에서 해당 필드는 유일하다.(연결되는 필드 외에..) 다중 부분 필드는 여러 필드로 나눠준다. (이름 -&gt; 성 , 이름) 다중값 필드는 새로운 테이블로 분리해서 사용한다. 예시 예비 필드 목록을 대상에 할당사용자 - 이메일, 생년월일, 닉네임, 성별, 비밀번호, 사용자 공식 여부 챌린지 - 챌린지 식별아이디, 챌린지 이름, 시작일, 종료일, 내용, 주기, 목표금액, 패널티 금액, 챌린지 공식여부, 챌린지 모드, 챌린지 유효 여부 사용자 계좌 - 계좌 소유자, 계좌 잔고 챌린지 계좌 - 계좌 소유자, 계좌 잔고, 소속 챌린지 아이디 리뷰 - 리뷰 작성자 이메일, 리뷰 내용, 리뷰 작성 날짜, 리뷰의 챌린지 아이디 값 목록 필드는 다른 테이블로 분리하고, 종속되는 주제는 부분 집합 테이블로 만든다챌린지의 태그는 따로 일대다 관계를 가지는 태그 테이블로 따로 빼서 만들고, 계좌 - 사용자 입출금 계좌 &amp; 챌린지 계좌 구조는 종속되는 주제인 사용자 계좌와 챌린지 계좌를 따로 부분집합 테이블로 만든다. 테이블 관계 연결 및 결정테이블은 1대1, 1대다, 다대다 관계가 있다.다만 다대다 관계는 주의해야 한다. 다대다 관계의 문제다대다 관계로 외래키를 도입하면 그 외래키가 중복 데이터가 많이 발생한다.그리고 만약 하나만 관계를 맺는 튜플을 삭제하면, 그 관계를 맺는 다른 테이블의 해당 튜플이 삭제될 수 있다. 학생과 수업 테이블이 다대다이고 서로 id을 외래키로 연결한다고 하면,학생 테이블의 수업id가 중복되는 데이터가 많아진다.한 학생만 듣는 수업이 있다고 했을 때, 그 학생을 삭제하면 그 수업이 삭제될 수 있다. 테이블 관계와 관계의 특징을 확인 기본 키나 연결 테이블을 통해 각 관계에 있는 테이블 간의 논리적인 연결 설정. 각 테이블에 대한 참여의 유형과 정도를 결정 업무 규칙 정의 및 결정 데이터베이스의 다양한 측면에서 제약사항 확인 업무 규칙 설정 검증 테이블을 정의, 구현 뷰의 정의 및 결정 데이터로 작업하는 다양한 방법을 확인 (상세 정보 조회, 요약 조회 등..) 적당한 테이블과 필드를 활용해서 뷰를 정의(뷰의 표준을 정할 수 있음.) 데이터 무결성 재확인 설계된 테이블이 잘 설계된 테이블인지 확인 필드가 적절한 구조인지 확인 테이블 수준 무결성 확인 필드 명세 점검, 무결성 점검 관계 유효성 점검, 각 테이블 참여 특징 명확히 결정. 데이터베이스의 다양한 측면에 있는 제약사항 결정","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}]},{"title":"우아한테크코스 4기 최종 코딩테스트 후기","slug":"java/woowa-tech-course/utecoprecourse4","date":"2021-12-19T12:39:13.000Z","updated":"2022-02-24T14:17:55.860Z","comments":true,"path":"2021/12/19/java/woowa-tech-course/utecoprecourse4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/19/java/woowa-tech-course/utecoprecourse4/","excerpt":"","text":"최종 코딩테스트 문제 링크https://github.com/woowacourse/java-pairmatching-precourse 아쉬운 점검증 로직 중복과정, 레벨, 미션을 입력받을 때, 해당 과정, 레벨, 미션이 존재하는지 검증해야 된다.나는 이를 검사하는 메서드를 각 열거형 객체가 가지고 있도록 하고 findByName메서드로 이름에 맞는 객체를 가져오도록 했다. 과정을 예를 들면 다음과 같다. 123456789101112131415161718192021public enum Course &#123; BACKEND(&quot;백엔드&quot;), FRONTEND(&quot;프론트엔드&quot;); private String name; Course(String name) &#123; this.name = name; &#125; public static Course findByName(String input) &#123; exceptionNotContain(input); return Arrays.stream(Course.values()).filter(course -&gt; course.name.equals(input)).findFirst().get(); &#125; private static void exceptionNotContain(String input) &#123; if (!Arrays.stream(Course.values()).anyMatch(course -&gt; course.name.equals(input))) &#123; throw new IllegalArgumentException(NO_EXIST_COURSE); &#125; &#125;&#125; 여기서 exceptionNotContain(String input)이 입력값이 존재하는 지 검증하고 예외를 출력한다.만약 외부에서 과정 객체를 가져오고 싶다면, findByName(String input)을 호출하면 된다.없는 경우는 예외를 일으키고, 있는 경우 해당 객체를 반환할 것이다. 1234567891011121314151617181920public class MatchingInformation &#123; private Course course; private Level level; private Mission mission; private MatchingInformation(Course course, Level level, Mission mission) &#123; this.course = course; this.level = level; this.mission = mission; &#125; public static MatchingInformation of(String line) &#123; List&lt;String&gt; information = split(line); Course course = Course.findByName(information.get(COURSE_INDEX)); Level level = Level.findByName(information.get(LEVEL_INDEX)); Mission mission = Mission.findByName(information.get(MISSION_INDEX)); return new MatchingInformation(course, level, mission); &#125; ...&#125; 매칭 정보 일급컬렉션을 생성할 때, 입력받은 이름을 토대로 findByName메서드를 호출하는 것을 볼 수 있다. 문제는 과정, 레벨, 미션 이 세가지 열거형 모두 이 메서드를 가지고 있는데, 모두 중복되는 코드로 작성했다.인터페이스를 도입하자니 검증 메서드가 static이라서 힘들었다. 과정, 레벨 출력과정, 레벨, 미션을 도입하기 전에 항상 과정, 레벨, 미션을 출력해야 한다. 나는 마음이 급해서 그냥 바로 문자열로 만들어서 매번 출력하도록 처리했다.근데 다른 PR을 보니, 과정, 레벨, 미션을 저장하고, 저장된 정보를 토대로 출력하는 사람들이 많았다.(대단..) 묻지 말고 시키기객체가 가진 데이터를 가져오지 말고, 객체에게 책임을 전달해야 되는데, 기능 구현에 급급하다보니, getter 메서드로 객체에게 묻는 로직이 상당히 많았다.프리코스에서 가장 인상깊게 생각한 피드백이고, 지키기 위해서 노력했는데 막상 시험에서 지키지 못하니 아쉽다. 구현하지 못한 기능페어를 만들 수 없는 상황을 예외 처리해줘야 했는데, 시험을 풀 당시 페어를 만들 수 없는 상황이 뭔지 몰라서 구현을 못했다… 알고보니 크루가 2명보다 적으면 페어를 못만드는 상황이 생긴다는 것……생각해보니 쉬운 로직인데 너무 긴장해서 구현하지 못한 거 같다. 시간이 부족하기도 했고. 후기돌이켜보면 믿기지 않는 한달이었다.설마 되겠냐는 생각으로 서류 지원했는데 덜컥 붙어서 정신없이 프리코스를 진행한 것 같다.다른 지원자들의 PR을 보니 내가 우물 속 개구리 인걸 깨달았다. 3주 동안 정말 많은 걸 배웠다.의식있는 노력을 통해 익숙함을 벗어나서 더 좋은 코드를 추구하는 마음가짐을 배웠다.평소 잘 모르는 걸 알면서 방치했던 git 사용법도 이번 기회로 정리해서 배웠다.하드코딩을 제거해서 다른 사람들이 봐도 이해할 수 있는 코드를 작성할 수 있음을 배웠다.한 메서드가 한 역할을 수행하라는 원칙도 알고는 있었는데, 실천을 통해 더 자세히 체화했다.예외가 발생하는 상황을 처리해서 프로그램이 다시 입력할 수 있도록 하는 방법을 배웠다.객체지향 설계를 직접 실천해보고 객체 지향의 기본 개념들을 배웠다. 프리코스를 해보니, 우아한 테크코스에 가고 싶은 생각이 더 깊어졌다.혹시 내가 자격이 있을까 고민하는 개발 지망생들이 있다면, 꼭 지원해서 프리코스까지 체험해보길 적극 추천한다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"메시지와 인터페이스","slug":"java/java-basic/object/object4","date":"2021-12-16T11:13:44.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/12/16/java/java-basic/object/object4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/16/java/java-basic/object/object4/","excerpt":"","text":"메시지, 인터페이스메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.메시지는 오퍼레이션 이름과 인자로 구성된다. receiver.message(argument); 이렇게 메시지를 구성할 수 있다. 메시지와 메서드그렇지만 메시지가 한 메서드를 가르키는 건 아니다.메서드는 메시지를 수신하는 객체, 인자에 따라 달라진다.메서드는 메시지를 수신했을 때 실행되는 함수를 의미한다. 이렇게 메시지와 메서드를 구분하면,메시지 전송자와 수신자가 느슨하게 결합된다.전송자는 그냥 내가 어떤 메시지를 보낼 지만 생각하면된다.수신자는 그냥 메시지에 따라 메서드를 실행하기만 하면된다. 전송자는 수신자가 어떻게 메시지를 처리하는 지 감춰지게 된다. 퍼블릭 인터페이스퍼블릭 인터페이스는 객체가 의사소통을 위해 공개하는 메시지의 집합이다.퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.(오퍼레이션은 어떤 행동에 대한 추상화된 것이라고 보자.) 시그니처는 오퍼레이션 이름과 파라미터 목록을 합친 것이다.시그니처에 구현을 더하면 메서드가 된다! 좋은 인터페이스를 위해서인터페이스는 최소한으로, 추상적이어야 한다. 이런 원칙을 지키기 위해서는 책임주도 설계가 하는게 좋다.메시지를 먼저 선택해서 협력에 상관없는 오퍼레이션을 제거할 수 있다.메시지가 객체를 선택하도록 해서 객체의 의도를 메시지에 표현 할 수 있다. 다음 규칙을 통해 좋은 인터페이스 규칙을 알아보자. 디미터 법칙 : 협력 경로를 제한하라낯선 객체와 협력하지 말고 이웃과 협력하라.객체가 특정 조건을 만족하는 대상에게 메시지를 전송하도록 제한. 한 객체는 다음 대상들에게 메시지를 전송하도록 제한하자. this 객체 메서드 매개변수 this의 속성 this의 속성인 컬렉션의 요소 메서드 내에서 생성된 지역 객체 이런 식의 코드는 디미터 법칙을 위반하는 예시다. 1234567public Reservation reserve(Screening screening) &#123; ... screening.getMovie.getDiscountConditions(); //위반!! screening.calculateFee(audienceCount); //준수!! ...&#125; 위반코드는 Movie 객체에게 메시지를 전달하고 있다.Movie 객체는 위 다섯가지에 속하지 않는다!!연쇄적으로 메시지를 전달하는 코드를 기차 충돌 코드라고 한다. 준수코드는 screening에게 메시지를 전달하므로 디미터 법칙을 준수했다. 하지만 디미터 법칙은 객체의 응집도가 낮아질 수 있다. 묻지 말고 시켜라메시지 전송자는 메시지 수신자의 상태를 기반으로 결정 내리고 수신자의 상태를 바꾸면 안된다!!!전송자가 수신자의 상태를 기반으로 결정하는 건 캡슐화 위반이다! 묻지 말고 시켜라는 객체의 상태와 행동이 서로 밀첩하도록 설계하게 한다. 의도를 드러내는 인터페이스인터페이스의 메서드는 어떻게가 아닌 무엇을 하는지 드러내도록 하라.무엇을 하는지 드러낸다는 것은, 그 인터페이스의 메서드가가 어떤 책임을 지는지를 표현하는 것이다.절대 내부 구현을 메서드의 이름으로 표현하지 않는다. 1234567public class PeriodCondition &#123; public boolean isSatisfiedByPeriod(Screening screening) &#123; ... &#125;&#125;public class SequenceCondition &#123; public boolean isSatisfiedBySequence(Screening screening) &#123; ... &#125;&#125; 위 코드는 상영 정보를 받아서 해당 할인 조건에 맞는 지 검증한다.그러나 위 코드의 메서드들은 클라이언트 입장에서 동일한 일을 한다. 그런데 이 두 메서드가 연관있음을 알 수 없다.또한 판단 기준이 약간 수정된다면 메서드 명을 변경해줘야 되는 일이 생긴다.(캡슐화가 안된다는 소리.) 다음 코드로 바꿔주는게 적절하다. 1234567891011public interface DiscountCondition &#123; boolean isSatisfiedBy(Screening screening);&#125;public class PeriodCondtion implements DiscountCondition &#123; public boolean isSatisfiedBy(Screening screening) &#123;...&#125;&#125;public class SequenceCondition implements DiscountCondition &#123; public boolean isSatisfiedBy(Screening screening) &#123;...&#125;&#125; 결론 객체에게 묻지 말고 시키되, 구현 방법이 아닌 클라이언트의 의도를 드러내는 메시지를 전달하자.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"우아한테크코스 4기 프리코스 3주차 회고","slug":"java/woowa-tech-course/utecoprecourse3","date":"2021-12-10T11:56:16.000Z","updated":"2022-02-24T14:17:41.318Z","comments":true,"path":"2021/12/10/java/woowa-tech-course/utecoprecourse3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/10/java/woowa-tech-course/utecoprecourse3/","excerpt":"","text":"우아한 테크코스 4기 프리코스 3주차 회고3주차 문제 및 내 답안 링크https://github.com/woowacourse/java-vendingmachine-precourse 마주한 문제들MVC 패턴 적용MVC 패턴은 Model, View, Controller를 기준으로 객체들을 분류해서 프로그램을 만드는 패턴이다.2주차 피드백에 비즈니스 로직에 출력 관련 로직을 같이 두지 말라는 피드백이 있었다.3주차에는 MVC 패턴을 도입해서 View 관련 로직을 분리하고자 했다. Model은 데이터를 저장하고, 일관성 있게 처리하는 역할,Controller는 사용자의 입력을 받고, view를 생성하거나 수정하고, model에 접근하여 데이터를 가져오는 역할,View는 사용자에게 보여지는 부분을 구현하는 역할. 컨트롤러 예시12345678910public class InputMoneyController &#123; public void inputMoneyControl() &#123; InputMoneyView.messageInputMoney(); inputMachineMoney(); &#125; private void inputMachineMoney() &#123; MoneyRepository.initializeMachineMoney(); &#125;&#125; 내 답안에 쓰인 컨트롤러 중 일부다.이 객체는 자판기에 돈을 입금해야 하는 상황을 책임진다.자판기는 사용자에게 돈을 입금하라는 메시지를 출력해줘야 한다. 출력은 InputMoneyView의 책임이다.InputMoneyView.messageInputMoney()는 입금할 때 필요한 메시지를 출력하라는 의미다. 뷰 예시12345public class InputMoneyView &#123; public static void messageInputMoney() &#123; System.out.println(MESSAGE_INPUT_MONEY); &#125;&#125; 뷰가 메시지를 받으면 적절한 메시지를 출력하게 된다. 모델 예시위 컨트롤러를 보면, MoneyRepository.initializeMachineMoney(); 코드가 보일 것이다.컨트롤러가 모델에게 메시지를 전달하고 있다.기계에 돈을 초기화해서 저장해달라는 메시지를 전달한다. 1234567public class MoneyRepository &#123; private static Money vendingMachineMoney; public static void initializeMachineMoney() &#123; vendingMachineMoney = new Money(); &#125;&#125; MoneyRepository는 내가 만든 코드에서 모델에 해당하는 객체다.자판기에 저장되는 돈을 관리하는 책임을 진다.initializeMachineMoney()를 통해 기계가 가진 돈을 초기화해서 저장할 수 있다. 일급 컬렉션 도입하기일급 컬렉션은, 컬렉션을 감싸는 클래스를 만들어서 사용하는 방법이다.\u0010다음과 같이 컬렉션을 그냥 쓰지 말고, 멤버 변수가 컬렉션 하나뿐인 일급 컬렉션을 도입하면 이익이 있다. 123456789public class MachineCoins &#123; private Map&lt;Coin, Integer&gt; machineCoins = new LinkedHashMap&lt;&gt;(); MachineCoins() &#123; initializeChangeCoins(); setMachineCoins(MoneyRepository.getMachineMoney()); &#125; ...&#125; 위 코드는 자판기 기계에 동전을 담당하는 객체다.이 객체가 생성되려면, initializeChangeCoins()와 setMachineCoins(MoneyRepository.getMachineMoney())를 실행한다. map에 각 동전과 그 갯수를 0개로 초기화하고,기계가 가진 돈만큼 동전을 만들어서 객체가 보관한다.즉 MachineCoins는 자판기 기계가 가진 돈만큼 동전으로 만들어서 Map에 저장하는 자료구조이다. 만약 MachineCoins라는 객체가 아닌 그냥 Map&lt;Coin, Integer&gt; 객체로 자판기의 동전을 관리하면 문제가 있다.위에서 얘기했듯이, 동전 갯수는 기계가 가진 돈만큼만 만들어야 한다. 일반 Map을 사용하면 해당 객체가 그런 조건을 달성했는지 알 수 없다.혹은 다른 사람이 코드를 봤을 때, 조건이 필요한지 알 수 없다. (그냥 Map일 뿐…) 이때 MachineCoins같이 일급 컬렉션을 사용하면 조건을 달성했음을 보장할 수 있다.그리고 조건을 검증하고, 상태와 행동을 한 클래스에서 확인 할 수 있어서 다른 사람이 파악하기도 편하다. 그리고 객체에 값을 수정하는 메소드를 만들지 않으면, 그 객체의 값을 불변으로 보장할 수 있기도 하다. 참고 https://jojoldu.tistory.com/412 맵 순회하는 방법 (Map Entry, Iterator)동전 정보를 Map에 저장했었는데, 동전을 출력하는 로직에서 Map을 순회해야 했었다. 그냥 for문을 쓰면 될 줄 알았는데, 잘 되지 않았다.다음은 내가 찾은 방법이다. 123456Map&lt;Coin, Integer&gt; map = new LinkedHashMap&lt;Coin, Integer&gt;();for (Map.Entry&lt;Coin, Integer&gt; entry : map.entrySet()) &#123; int key = entry.getKey(); int value = entry.getValue(); //map.remove(key); 이건 될까?&#125; 위 코드는 순회는 잘된다. map의 원소를 수정하면 concurrentmodificationexception가 발생한다.그럴 땐 iterator를 도입한다. 12345Iterator&lt;Coin&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) &#123; iterator.next(); iterator.remove();&#125; 이런 식으로 구현하면 순회와 동시에 삭제가 가능하다! 후기긴장감 속에 치뤄진 프리코스가 끝을 향하고 있다.사실 서류 통과가 될 지도 긴가민가했었는데, 어느새 프리코스를 마치고 최종 코딩테스트만 남기고 있다.프리코스를 하기 전에는 내가 자바를 해본 경험이 꽤 있어서 무난하게 프리코스를 통과하지 않을까 싶었는데 오산이었다. 매 미션마다 다른 분들이 제출한 PR을 보면 엄청난 고수들이 많았다.그럴 때마다 많은 좌절감을 느끼기도 했지만, 오히려 만약 이런 분들에게 피드백 받고 같이 공부하면정말 소중한 기회일 것이고, 그래서 더 프리코스 과제에 더 집중하고자 했다. 프리코스는 매 주마다 미션을 하나씩 주고, 미션을 구현할 때 지켜야할 규칙을 제시한다.정말 놀라운 건, 이 규칙들이 몇가지 안되는데, 이 규칙들을 지키기가 굉장히 까다롭다는 사실이다. 메서드 길이 15줄을 넘어가면 안되고, 메서드의 들여쓰기가 2를 넘으면 안된다.이 두가지만 지키려고 해봐도 굉장히 까다롭고, 코드가 완전히 새로워진다. 그리고 클래스에게 책임을 나눠주고 여러 클래스들이 협력하도록 설계하는 게 재밌었다.사실 스프링을 쓰다보면, 요구사항이 비슷한 경우가 많아서 설계도 비슷하게 반복되는 경우가 많았다.그래서 설계를 크게 고민하지 않았던 적이 많은데 이번 프리코스는 스스로 설계를 고민해야 되는 부분이 많아서 흥미로웠다. 코딩 실력을 향상시키기에는 3주는 짧다고 볼 수 있지만,프리코스를 하면서 정말 극적으로 코드 보는 시선이 넓어지고, 코드 짜는 좋은 습관도 생긴 것 같다. 프리코스의 모든 과정은 인터넷에 공개되어 있다.이번 프리코스를 하면서 왜 진작 이런 자료를 찾아서 공부하지 않았는지 생각이 날 정도로 정말 귀한 경험이었다. 우아한 테크 코스 지원 여부를 떠나서, 프리코스는 초보 자바 개발자라면 반드시 참고하길 바란다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"우아한테크코스 4기 프리코스 2주차 회고","slug":"java/woowa-tech-course/utecoprecourse2","date":"2021-12-04T15:40:27.000Z","updated":"2022-02-24T14:17:36.293Z","comments":true,"path":"2021/12/05/java/woowa-tech-course/utecoprecourse2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/05/java/woowa-tech-course/utecoprecourse2/","excerpt":"","text":"우아한 테크코스 4기 프리코스 2주차 회고2주차 문제 &amp; 내 제출 답안https://github.com/woowacourse/java-racingcar-precourse https://github.com/yangdongjue5510/java-racingcar-precourse 마주한 문제들책임을 클래스들에게 분배하기이번 문제는 메서드를 분리하는 것에 더해, 클래스를 분리해서 책임을 분배해야 한다는 미션을 받았다. 문제에는 Car 객체가 제시되어 활용하는 요구사항이 추가됐다. 일단 나눠주여 할 책임을 보면, 사용자에게 입력을 받는 책임 입력된 값을 검증하는 책임 \u0010자동차를 만드는 책임 자동차의 게임을 진행하는 책임 레이싱 결과를 분별하는 책임 결과를 출력하는 책임 이렇게 나눌 수 있었다. 나는 다음과 같이 클래스들에게 책임을 나눠줬다. 입력을 담당하는 InputManager 입력값 검증하는 ValidChecker 자동차를 만들어 게임을 진행하는 RacingPlayer 자동차의 운행 여부를 판단하여 운행하는 Car 자동차 위치에 따라 우승자를 찾는 RacingReferee 이렇게 역할을 나눠줬는데, 역할을 나눠주고 나니 각 객체의 인스턴스 변수를 다른 객체가 활용해야 하는 경우가 있었다. 패키지 분리 후 default 접근 지시자나는 이 문제를 해결하기 위해 도매인과 관련된 Car, RacingPlayer, RacingReferee는 같은 패키지로 분리해줬다. 그리고 getter 메서드를 default로 추가해 도매인 관련된 객체들만 해당 인스턴스 변수를 이용할 수 있게 했다. 예시로 RacingReferee는 우승자들을 분류해서 리스트로 가지고, 우승자의 이름을 출력하는 책임을 지고 있다.그런데 우승자(Car 객체)는 이름이 private로 되어 있다. 이럴 경우 default getter로 캡슐화를 최대한 준수하고자 했다. 1234567public class Car implements Comparable&lt;Car&gt; &#123; private final String name; ... String getName() &#123; //default 접근지시자를 활용했다. return this.name; &#125;&#125; 123456789101112public class RacingReferee &#123; private List&lt;Car&gt; winners; ... private void printWinners() &#123; StringBuilder builder = new StringBuilder(); ... for (int i = 0; i &lt; winners.size(); i++) &#123; //getName 메서드를 활용하고 있다. builder.append(winners.get(i).getName()).append(MESSAGE_COMMA_WITH_SPACE); &#125; ... &#125;&#125; 우승자 알아내기Car의 우승 여부를 알려면 각 Car의 위치를 알아야 한다. 그런데 나는 앞서 말했듯이 우승여부를 다른 객체(RacingReferee)가 한다고 했다.이미 Car 객체의 위치값은 private인데 어떻게 RacingReferee가 이를 계산해서 처리할 것인가? 가장 편한 대답은 아까처럼 default getter를 만드는 방법이다.하지만 검색을 좀 해봤더니 다른 방식을 알아냈다. 바로 Comparable로 정렬하기 이다. Car를 Comparable로 정렬 기준을 만들자. 1234567891011public class Car implements Comparable&lt;Car&gt; &#123; private final String name; private int position = 0; ... @Override public int compareTo(Car otherCar) &#123; return otherCar.position - this.position; &#125; ...&#125; 이렇게 해놓으면 외부에서 자동차 위치를 알지 못해도 compareTo로 자동차들의 위치를 비교한다! 123456789101112public class RacingReferee &#123; private List&lt;Car&gt; winners; ... private void findWinner(List&lt;Car&gt; participantCars) &#123; Collections.sort(participantCars); // Car winner = participantCars.get(WINNER_INDEX); this.winners = participantCars.stream() .filter(car -&gt; car.compareTo(winner) == COMPARE_WINNER_RESULT) .collect(Collectors.toList()); &#125; ...&#125; RacingReferee는 Car가 어떤 식으로 정렬하는지 알지 못해도 일단 Collections.sort() 하면 우승자 순으로 정렬된다는거만 안다. 나름 캡슐화를 지킨 방식이라서 재밌었다. 후기이번 주차는 비교적 수월하게 했다. 지난주에 설계를 못한다는 생각에 충격을 먹어서, 급하게 객체지향 관련 책을 찾아 본 게 큰 도움이 된거 같다. 지난 야구 게임을 구현할 때는 한 클래스가 거의 모든 데이터를 독점하고, 여러 일을 책임지고 있는 좋지 않은 설계로 구현했었다. 이번 문제는 강제로 Car 객체를 사용해야되서 자연스럽게 여러 객체들을 협력에 동참시켜야 했다.특히 이번엔 한 클래스가 데이터를 독점하지 못하도록 어떤 부분에 다른 클래스로 대체할 것인지 고민을 많이 했다.그 고민을 통해 등장시킨게 RacingReferee였다. 이 객체는 우승자를 가지고, 스스로 관리하게 설계했다는 점에서 만족스러웠다. 그리고 Comparator와 Comparable에 대해 공부할 수 있는 기회였다.최대한 캡슐화를 지키면서 우승 자동차를 구하는 방법을 찾다보니 평소에 잘 이해하지 못했던 개념을 제대로 이해할 수 있었다.이런 아이디어를 내가 직접 생각해낸게 아니라서, 만약 실제 코딩테스트 상황에서 이런 문제를 만나면 어찌해야 될 지 고민이 되긴한다. 하지만 아직 부족한 부분이 많다.대표적으로 README 작성. 살아있는 문서를 작성하라는데, 이게 좀 힘들다.의외라고 생각할 수 있는데, 나는 문제를 풀 때, 구현에 집중하다 보면, README는 안중에도 없게 된다.(…)그래서 이번엔 비교적 좀 더 신경을 썼는데, 아직 부족한 거 같기도 하다… 그리고 테스트 코드 작성도 많이 부족하다.나는 사실 이 문제를 여러번 풀어보고 제출한다.이번 주 문제인 레이싱 문제도 대충 3번정도 풀어보고 제출하는 거다.그래서 제출 코드에는 굳이 테스트 코드가 필요없다. 이미 많이 시도해본 코드들이기 때문이다. 근데 실전에서는 그럴 시간이 없다. 5시간안에 여러번 푼다는건 말도 안된다 ㅋㅋ.그래서 테스트 코드를 작성하는 법을 배워야 한다는 걸 느꼈다.JUnit와 TDD에 대해 공부하려고 한다. 아직 많이 부족하다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"13. Comparable과 Comparator의 차이!","slug":"java/java-basic/java13","date":"2021-12-03T01:29:20.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/12/03/java/java-basic/java13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/03/java/java-basic/java13/","excerpt":"","text":"Comparable과 Comparator의 차이결론둘 다 객체의 비교 기준을 마련하는 인터페이스. Comparable은 **compareTo(T t)**로 자기 자신과 다른 객체의 비교.Comparator은 compare(T t, T u) 자기 자신이 아닌 다른 두 객체 간의 비교. Comparable은 Arrays.sort()나 Collections.sort()를 했을 경우 비교 기준을 제공한다.Comparator는 새로운 비교기준이 필요할 때 익명 클래스로 활용 가능. 실험실험에 필요한 Student12345678910111213141516171819202122public class Student &#123; private int age; private int score; public Student(int age, int score) &#123; this.age = age; this.score = score; &#125; @Override public String toString() &#123; return &quot;age = &quot;+age+&quot; score = &quot;+score; &#125; public int getAge() &#123; return age; &#125; public int getScore() &#123; return score; &#125;&#125; 일단 정렬 실험에 사용될 객체를 만들어봤다. 이제 age나 score에 따라 다르게 구현해보자. Comparable와 Comparator를 클래스에 적용하기1234567public class Student implements Comparable&lt;Student&gt; &#123; ... @Override public int compareTo(Student o) &#123; return this.age - o.age; &#125;&#125; Comparable을 활용하려면 compareTo메서드를 구현해야 한다. 이 메서드는 자기 자신과 다른 객체를 비교한다. (return 값이 양수면 자기 자신 우선, 음수면 다른 객체 우선) 1234567public class Student implements Comparator&lt;Student&gt; &#123; ... @Override public int compare(Student o1, Student o2) &#123; return o1.age - o2.age; &#125;&#125; Comparator는 compare메서드를 구현해야 한다. 이 메서드는 서로 다른 객체 두개를 비교한다. 정렬 실험해보기문제는 Comparable을 구현한 경우와 Comparator를 구현한 경우가 정렬을 할 때 다르다는 점이다!! 1234567//implements Comparable&lt;Student&gt; 한 경우Arrays.sort(arr); //성공!Collections.sort(list); //성공!//implements Comparator&lt;Student&gt; 한 경우Arrays.sort(arr); //컴파일 에러!!Collections.sort(list); //컴파일 에러!! 실험해보니, Comparable을 구현했을 때만 정렬이 가능했다!!Comparator를 구현한 경우 Comparable이 구현되지 않았다며 컴파일 에러를 일으켰다! 그러면 Comparator는 왜 있는거에요?Student 클래스가 Comparable을 구현하고, 정렬을 age 기준으로 오름차순으로 정렬됐다고 하자. 근데 프로그래밍하다가 Student를 score 기준으로 오름차 정렬해야 되는 요구사항이 생겼다면?이미 age로 정렬하여 사용하고 있는 곳이 있으면, Comparable을 바꿀수도 없다. 그럴 때 익명클래스를 활용한 Comparator를 통해 해결한다. 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getScore() - o2.getScore(); &#125;&#125;);","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"REST Api 프로젝트에서 만난 소소한 문제들","slug":"spring/restproject1","date":"2021-12-02T02:44:58.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/12/02/spring/restproject1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/12/02/spring/restproject1/","excerpt":"","text":"Rest api 프로젝트를 하면서 배운 것들을 정리하고자 한다. JPA entity에서 배운 것들12345678910111213141516171819202122232425@Entity@Getter @Setterpublic class Investments &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(nullable = false) private Long investId; @Column(nullable = false) private Long userId; @ManyToOne //다대일 관계 @JoinColumn(name=&quot;id&quot;) private Products product; @Column(nullable = false) private Long investmentAmount; @Temporal(TemporalType.DATE) private Date investmentDate = new Date(); //기본값을 현재로?? @Enumerated(EnumType.STRING) private InvestmentStatus investmentStatus = InvestmentStatus.VALID; //기본값을 유효로 ?&#125; JPA와 디비에는 사용하고 싶지 않지만, VO 클래스 멤버 변수로 사용하고 싶은 변수는 @Transient를 붙인다. 이번 프로젝트에서는 h2 디비를 썼다. h2에서는 기본키 자동증가기능을 사용하려면 @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY) 를 써야 잘 작동했다. 칼럼의 NOT NULL은 @Column(nullable &#x3D; false) 로 처리했다. (@NotNull은 안됐다.) @Temporal(TemporalType.DATE) 는 날짜시간 데이터 중 날짜 데이터를 저장한다는 의미다.시분초는 0으로 처리되어 저장된다. **@Enumerated(EnumType.STRING)**은 열거형 데이터를 저장할 때 쓰인다.이번 프로젝트는 열거형 이름 그 자체를 도입했다. 헤더 값 읽기1234@GetMapping(&quot;/product&quot;)public ResponseDto&lt;List&lt;Products&gt;&gt; productGet(@RequestHeader(&quot;X-USER-ID&quot;) long userId) &#123; ...&#125; @RequestHeader안에 헤더의 키값을 넣어주면 가져올 수 있다! SpringBoot Could not find acceptable representation(Error: Request failed with status code 406)12345678910@Getter @Setterpublic class ResponseDto&lt;T&gt; &#123; public ResponseDto(T data, HttpStatus status) &#123; this.status = status; this.data = data; &#125; HttpStatus status; T data;&#125; 406에러는 return된 객체에 setter getter가 없어서 일어났었다. stream으로 합구하기!1234List&lt;Long&gt; numbers = Arrays.asList(1L, 2L, 3L, 4L, 5L);// Stream의 reduce 이용Long sum1 = numbers.stream().reduce(0L, Long::sum); reduce를 이용하면 구할 수 있었다!! JSON으로 통신할 때 Object Mapper로 케이스 변환하기1234567@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)public class User &#123; private phoneNumber; //json에는 phone_number로 보임 @JsonProperty(&quot;user_name&quot;) //특정 변수에만 적용할 경우. private userName&#125; JSON을 반환할 때 ResponseEntity나는 커스텀해서 ResponseDto를 만들었는데 자바에서는 이미 ResponseEntity가 있더라 크흠… SQL INIT어플리케이션을 시작할 때 SQL을 실행해서 스키마를 만들고 데이터를 입력할 수 있다. 12345spring: sql: init: platform: h2 mode: always application.yml에 다음같이 적으면, 항상 어플리케이션을 시작할 때 SQL을 초기화해준다. Resources 폴더에 schema-플랫폼이름.sql , data-플랫폼이름.sql 을 실행한다. 위 예시는 플랫폼을 h2로 했으니, schema-h2.sql, data-h2.sql이라고 하면된다!! 이때 ddl-auto는 꺼줘여야 잘 작동하게 된다!! JPA Method이름으로 쿼리 만들기1234567891011121314public interface InvestmentsRepository extends JpaRepository&lt;Investments, Long&gt; &#123; default Investments updateInvestStatus(Investments invest, InvestmentStatus status) &#123; invest.setStatus(status); save(invest); return invest; &#125; List&lt;Investments&gt; findInvestmentsByIdAndStatusEquals(long productId, InvestmentStatus investmentStatus); List&lt;Investments&gt; findInvestmentsByUserId(long userId); Investments findInvestmentsByUserIdAndIdAndStatusEquals(long UserId, long productId, InvestmentStatus status);&#125; 레퍼지토리에 우리가 원하는 쿼리의 역할을 메서드 이름으로 만들면 그에 해당하는 쿼리를 실행하는 메서드가 만들어진다. 전역 예외 핸들러12345678@ControllerAdvice@RestControllerpublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) public ResponseDto&lt;String&gt; handleException(Exception e) &#123; return new ResponseDto&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); &#125;&#125; 예외 핸들러를 따로 만들면, 모든 예외 발생을 다음 메서드로 처리한다. 생성자 주입1234567891011@RestController@RequestMapping(&quot;/api&quot;)@RequiredArgsConstructorpublic class ApiController &#123; private final ProductsService productsService; private final InvestmentsService investmentsService; ...&#125; @Autowired 키워드를 쓰는 것보다 @RequiredArgsConstructor와 private final 키워드를 활용한 생성자 주입이 스프링에서 더 권장하는 방법이다. 나도 이 방법을 사용하기 전까지 순환 참조를 하고 있는 줄 모르고 있었는데, 생성자 주입으로 변경하는 과정에서 실수를 확인 할 수 있었다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[{"name":"reshapi project","slug":"reshapi-project","permalink":"https://yangdongjue5510.github.io/tags/reshapi-project/"},{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"책임 할당을 위한 GRASP 패턴","slug":"java/java-basic/object/object3","date":"2021-11-29T11:12:30.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/29/java/java-basic/object/object3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/java/java-basic/object/object3/","excerpt":"","text":"GRASP 패턴일반적인 책임 할당을 위한 소프트웨어 패턴. 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들. 영화 예매 시스템을 통해 GRASP 패턴을 익혀보자. 도메인 개념에서 출발하기어떤 책임을 할당해야 할 지 고민해야 될 때 가장 먼저 고려해야 할 게 도메인이다. 영화에는 금액 할인 영화, 비용 할인 영화가 있다. 할인 조건에는 순번 조건, 기간 조건이 있다. 하나의 영화는 여러번 상영될 수 있고,하나의 상영에는 여러 예매가 있을 수 있다. 그리고 한 영화에는 여러 할인 조건이 사용될 수 있다. ![](&#x2F;Users&#x2F;MUHN2-031&#x2F;Documents&#x2F;dev&#x2F;ghblog&#x2F;source&#x2F;img&#x2F;스크린샷 2021-11-29 오후 8.40.39.png) 도메인 설계는 완벽할 수 없다.다만 앞으로의 설계와 구현에 출발점일 뿐이다. 정보 전문가에게 책임을 할당하라(information expert pattern)애플리케이션이 제공해야 되는 기능을 애플리케이션의 책임으로 생각하라. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고, 메시지를 책임질 첫번째 객체를 선택하는 것으로 시작하자. 영화 예매시스템은 영화 예매를 책임져야한다. 이제 이 책임을 수행하는 메시지를 결정해야 한다.이때 메시지는 수신할 객체 중심이 아닌 발신한 객체의 의도를 반영해서 결정해야 한다. 메시지를 전송할 객체는 무엇을 원할까? 우리가 던져야 할 첫 질문이다.누구와 협력할지는 몰라도 그 객체가 협력에서 원하는 건 분명해보인다.영화 예매의 예시에선 영화를 예매하는 것을 원한다. 그렇다면 메시지는 예매하라가 된다. 메시지를 결정하고 나면 메시지에 적합한 객체를 선택해야 한다. 메시지를 수신할 적합한 객체는 누구인가? 이때 객체는 상태와 행동을 가진 캡슐화의 단위다.객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.(무지성 getter, setter는 안된다!) 객체는 자신의 책임과 책임에 필요한 상태를 가져야 한다.객체의 책임과 책임을 수행하는데 필요한 정보를 잘 아는 객체에게 책임을 할당한다.GRASP는 이 패턴을 정보 전문가 패턴이라고 한다. 이때 정보를 알고 있다는 건 데이터를 저장하고 있다는 의미와는 살짝 다르다.정보를 저장하지 않아도, 어떤 객체를 알고 있거나, 필요한 정보를 계산을 제공하는 방식 등 다양하다. 정보 전문가가 정보를 알고 있다는 것은 반드시 정보를 저장한다는 의미는 아니다! 영화 예매 시스템의 예시에서는 어떨까? 예매하라는 메시지를 잘 수행할 객체를 찾아보면 된다. 도메인 개념에서 아마 상영 객체가 잘 수행할 것 같다.왜냐면 예매하는 책임에는 상영 시간, 상영 순번, 상영 영화 등 정보가 필요한데, 이런 정보는 상영 객체가 가지는게 자연스럽다.따라서 영화 예매 정보 전문가는 상영이다. 정보 전문가가 메시지를 처리하는 흐름을 생각하라.메시지와 메시지를 처리할 객체를 정했다면 이제 그 정보 전문가가 내부에서 어떻게 책임을 다할지 생각해보자. 이 흐름은 외부로 공개되지 않으며, 개략적인 수준에서 책임에 필요한 작업을 생각해보고, 혼자서 못하는 작업인지 분별할 정도로 생각한다.혼자서 처리할 수 없는 작업은 또다시 외부로 보내는 메시지가 되고, 이 메시지에 맞는 정보 전문가를 찾는 과정을 반복한다. 영화 시스템의 예시에서는 상영 객체가 예매하라는 메시지를 처리할 때, 예매 가격을 처리하는 과정이 필요하다.그러나 상영 객체는 각 영화의 가격이나, 할인 정책을 알지 못한다. 그래서 외부의 도움이 필요하다. 이제 가격을 계산하라는 새로운 메시지가 생기고, 이 메시지를 책임질 새로운 객체를 선정하면 된다. 낮은 결합도를 추구해라(low coupling pattern)설계의 전체적인 결합도가 낮도록 책임을 할당하라. 위에서 만든 도메인 모델을 보면 연결되있는 개념들이 있다.영화 예매 시스템에서, 영화 객체와 영화 할인 기준 개념은 서로 연관있다. 반면 상영과 영화 할인 기준 개념은 연결되어 있지않다.만약 이 둘을 연결하려면, 새로운 결합도가 생기는 거고 추천하지 않는다. 차라리 이미 연관된 개념인 영화 객체와 영화 할인 기준 개념을 서로 연결하는게 맞다. 높은 응집도를 추구해라(high cohesion pattern)영화 예매 시스템에서 상영이 영화 할인과 결합되면 응집도가 낮아지는 문제가 생긴다. 상영은 이제 영화 할인 계산을 직접할 수 있지만,근데 만약에 영화 할인 관련 객체를 교환하는 경우를 생각해보자.그러면 상영 객체도 같이 변경되어야 하는 거다.(서로 다른 이유로 변경되는 책임을 지게된다.) 상영 정보가 바뀌면 할인 객체도 변경되어야 하고,할인 객체가 바뀌면 상영 객체도 변경되어야 한다. 이 둘은 그런 수고를 감수할 정도로 같이 결합해야할 객체인지 의심해보아야 한다.한 클래스는 한 가지의 변경사항만 책임지도록 하자.변경되는 이유가 여러가지면 이 클래스가 변경되는 시점도 제각각이고, 연관성도 떨어진다. 차라리 영화 객체와 할인 객체가 연결되는게 맞고, 상영은 영화 객체와만 결합하는게 낫다.그러면 상영은 할인 관련 책임은 신경을 전혀 쓰지 않아도 된다. 변경의 이유가 지나치게 많은 클래스의 징후 인스턴스 변수가 초기화되는 시점을 살펴보자 인스턴스 변수가 초기화 될 때 일부만 초기화되면 응집도가 낮다고 봐야한다. 그렇지 않다면 함께 초기화 되는 기준으로 코드를 분리하라. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보자 모든 메서드가 모든 변수를 사용하면 응집도가 높은 것. 일부 메서드들은 특정 변수만 사용하는 경우, 코드를 분리하라. 창조자에게 객체 생성 책임을 할당하라(creator pattern)객체를 생성할 책임을 어떤 객체에게 할당할 것인가? Creator pattern은 다음 조건을 가장 만족시키는 객체가 생성해야 한다고 주장한다.객체 A를 생성해야 한다면… A 객체를 포함하거나 참조하는 객체 A 객체를 기록하는 객체 A 객체를 긴밀하게 사용하는 객체 A 객체를 초기화 하는데 필요한 데이터를 가진 객체 즉 조건들을 보면, A객체와 결합되있는 객체를 찾고 있는 걸 알 수 있다.즉 이미 결합된 관계에서 객체를 만드는게 결합도를 낮추는데 도움이 된다. 인터페이스로 변화에 대응하라(polymorphism, protected variations)코드를 작성하다보면, 특정 객체 타입에 따라 다르게 반응해야 하는 경우가 있다. 예를 들면 할인 기준에 따라 할인 적용을 다르게 해야 하면 if, else if로 객체의 타입을 검사해서 할인을 적용해줘야 한다.하지만, 이때 기준이 추가되면, 매번 else if를 추가해줘야 된다. 그래서 인터페이스를 도입해서 원하는 기준으로 초기화해주면, 검사하지 않고 할인 적용 메시지를 보내주면 된다. 인터페이스를 도입해서 캡슐화하면, 구현 클래스들의 세세한 변경을 외부에서는 신경 안써도 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"REDIRECT와 FORWARD의 차이!!","slug":"spring/boot/boot13","date":"2021-11-29T06:09:24.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/11/29/spring/boot/boot13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/spring/boot/boot13/","excerpt":"","text":"REDIRECT와 FORWARD의 차이REDIRECT리다이렉트는 “서버가 클라이언트에게 해당 URL로 다시 요청하라고 명령하는 것”이다. 클라이언트가 서버의 URL에 요청 (get이던 post던 상관없이) 서버의 컨트롤러가 해당 URL에 매핑된 메서드 실행 해당 메서드가 다른 URL로 리다이렉트 시킬 경우, 클라이언트는 그 URL로 GET 요청을 새로 실행! REDIRECT의 특징리다이렉트는 클라이언트에게 새로운 GET 요청을 하도록 명령하는 것이다. 따라서 새로운 요청이 만들어져서, 스프링의 모델 같은 값이 모두 초기화 된다!! 대신 GET 요청을 새롭게 실행한 것이라서 브라우저의 GET 요청한 URL로 달라지고,새로고침할 경우 GET 요청이 반복되서 실행되는 것이므로,반복된 POST를 방지 할 수 있다.(이건 포워드에서 더 잘 알아보자.) REDIRECT하는 컨트롤러 예시12345678910111213141516171819... @GetMapping(&quot;/redirect&quot;) public String getRedirect() &#123; return &quot;redirect:/result&quot;; &#125; @PostMapping(&quot;/redirect&quot;) public String postRedirect() &#123; list.add(++i); return &quot;redirect:/result&quot;; &#125; //리다이렉트하면 다음 메서드로 get요청이 간다 @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125;... FORWARD포워드는 “서버가 포워딩한 URL이 매핑된 메서드를 실행하고 그 결과값을 클라이언트에게 보여준다.” 즉 서버가 클라이언트에게 해당 URL을 GET 요청으로 다시 하라고 하는 것이 아닌,자기가 해당 URL 매핑된 메서드를 찾아서 실행한다!! 이때 중요한 건 처음 클라이언트가 보낸 요청 그대로 유지한다는 점이다.리다이렉트는 처음 클라이언트가 보낸 요청은 종료하고, 보내고 싶은 URL로 새로운 GET 요청을 통해 접근했지만,포워드는 처음 클라이언트가 보낸 요청을 끝내지 않고 서버가 보내고 싶은 URL로 처음 요청을 유지한 상태로 접근한다. FORWARD의 특징포워드는 새로운 요청을 생성하지 않는다.다만 다른 URL에 매핑된 메서드에 접근할 뿐이다. 그래서 POST요청이 온 상황에서 포워드하면,포워드한 URL로 POST method로 매핑된 메서드에 접근하려고 한다.즉 기존 요청의 HTTP method를 유지한 상황에서 접근한다. 기존의 요청이 보존된 상황이므로, 스프링의 모델 같은 값이 다른 URL로 포워딩되도 유지된다. 이때 중요한 건 클라이언트 요청 처리 과정에 포워드가 포함된다는 사실이다.(리다이렉트는 클라이언트의 처음 요청을 종료시키고 새로운 GET 요청을 만들었다. 즉 분리된다.)그래서 포워딩하고 나서도 클라이언트의 URL은 처음 요청했던 URL과 동일하다. 그 상태로 새로고침을 하면, 맨 처음 클라이언트의 요청을 다시 시작하는 것이다.즉 POST를 클라이언트가 요청하고, 서버가 view 관련 URL로 포워딩 시킨다고 했을 때, 클라이언트는 view를 볼 수 있지만, URL은 클라이언트가 POST 요청하던 그대로이다.이 상태에서 새로고침을 하면 다시 클라이언트의 POST 요청 -&gt; 서버가 veiw 관련 URL 포워딩 과정을 다시하게 된다. 즉 POST를 반복해서 하게 된다!!!! FORWARD하는 컨트롤러 예시12345678910111213141516171819202122232425... @GetMapping(&quot;/forward&quot;) public String getForward() &#123; return &quot;forward:/result&quot;; &#125; @PostMapping(&quot;/forward&quot;) public String postForward() &#123; list.add(++i); return &quot;forward:/result&quot;; &#125;//이전 요청에 따라 매핑된다. @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125; @PostMapping(&quot;/result&quot;) @ResponseBody public String postResult() &#123; return &quot;post method&quot; +getListString(); &#125;... 직접 테스트 해보기컨트롤러 클래스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Controllerpublic class RedirectController &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = 0; public String getListString() &#123; StringBuilder sb = new StringBuilder(); list.stream().forEach(integer -&gt; sb.append(integer)); return sb.toString(); &#125; @GetMapping(&quot;/result&quot;) @ResponseBody public String getResult() &#123; return &quot;get method&quot; +getListString(); &#125; @PostMapping(&quot;/result&quot;) @ResponseBody public String postResult() &#123; return &quot;post method&quot; +getListString(); &#125; @GetMapping(&quot;/test&quot;) public String test() &#123; return &quot;test&quot;; &#125; @GetMapping(&quot;/redirect&quot;) public String getRedirect() &#123; return &quot;redirect:/result&quot;; &#125; @PostMapping(&quot;/redirect&quot;) public String postRedirect() &#123; list.add(++i); return &quot;redirect:/result&quot;; &#125; @GetMapping(&quot;/forward&quot;) public String getForward() &#123; return &quot;forward:/result&quot;; &#125; @PostMapping(&quot;/forward&quot;) public String postForward() &#123; list.add(++i); return &quot;forward:/result&quot;; &#125;&#125; JSP 화면123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;/redirect&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;리다이렉트&quot;&gt;&lt;/form&gt;&lt;form method=&quot;post&quot; action=&quot;/forward&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;포워드&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"응집도와 결합도","slug":"java/java-basic/object/object2","date":"2021-11-28T15:45:28.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/29/java/java-basic/object/object2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/29/java/java-basic/object/object2/","excerpt":"","text":"응집도와 결합도응집도모듈 내부 요소가 연관된 정도.모듈의 내부 요소가 한 목적을 위해 긴밀하게 협력하는 정도. 높을 수록 좋다. 좀더 구체적으로 설명하면, 하나의 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도하나 바꾸려고 할 때, 모듈 전체를 바꿔야 되면 응집도가 높은 것. 하나의 변경이 일어날 때, 모듈 하나만 바꿔서 해결 가능하면, 응집도가 높은 것. 즉 특정 요구 사항을 변경하려고 한다면,그 요구 사항과 관련된 코드는 하나의 모듈에 모여있어야 한다. 그 요구 사항과 관련된 코드를 찾기 위해 소스 코드 전체를 구석구석 찾으면 안된다!! 결합도한 모듈이 다른 모듈에 대해 얼마나 많은 정보를 갖고 있는지.의존성 정도를 나타냄. 다른 모듈에 대해서는 최소한의 정보만 가지고 있는게 좋다.낮을 수록 좋다. 좀더 구체적으로 설명하면, 한 모듈이 변경하려 할 때 다른 모듈도 바뀌어야 하는 정도.하나 바꾸려고 하는데 다른 애들도 다 바꿔줘야되면 결합도가 높은거다.(구현된 클래스에 의존하지 말고 인터페이스에 의존하라는 말도 결합도를 낮추기 위해서 등장한다.) 물론 바꿀 일이 거의 없는 객체는 결합도가 높아도 괜찮다. 캡슐화와 관계캡슐화는 변할 수 있는 내용은 외부에서 알 수 없게 감추는 것이다. 일반적으로 응집도와 결합도의 문제는 캡슐화를 잘 설계하면 동시에 해결된다. 캡슐화가 잘된 걸까? (public Getter, setter)1234567891011public class Movie &#123; private Money free; public Money getFee() &#123; return fee; &#125; public void setFree(Money fee) &#123; this.fee = fee; &#125;&#125; 이렇게 private 매개변수를 해놓고, getter, setter를 해놓으면 캡슐화가 잘 된걸까? 답은 아니다!!! 게터 세터는 객체 내부 상태에 어떤 정보도 캡슐화하지 못한다. 사실상 그냥 public으로 열어둔거나 다름없다.외부에서 Movie 객체를 접근할 때 이미 Money 객체가 있다는 걸 알게된다. 이런 경우는 객체가 가지는 데이터에 중점적으로 설계해서 이런 일이 생긴다.객체는 문맥을 고려한 책임을 기반으로 설계되어야 한다. 높은 결합도결합도는 하나의 모듈을 변경하려 할 때 다른 모듈도 다 바뀌어야 하는 정도이다. 캡슐화를 지키지 못해서 결합도가 높아지는 경우를 보자. 12345678910public class ReservationAgency &#123; public Reservation reserve(Screening screening, Customer customer, int audienceCount) &#123; ... Money fee; //Money에 의존 if (discountable) &#123; fee = movie.getFee().minus(discountAmount).times(audienceCount); &#125; ... &#125;&#125; 다음 예시에선 Money타입의 fee에 요금 정보를 저장하고 있다.근데 만약 Money가 아닌 다른 타입에 fee를 저장하고 싶으면 어떻게 되는가? Money 대신 다른 타입을 수행할 수 있도록,getFee()를 수정하고 -&gt; minus()를 수정하고 -&gt; times()를 수정해야 한다 Money를 바꿀 뿐인데 다른 객체의 메서드들이 다 변해줘야 한다. 이는 movie의 getFee()가 사실상 객체에 fee와 관련된 내용이 있음을 알리는, 즉 캡슐화 하지 못해서 생긴 사례다. 낮은 응집도변경되는 이유가 각자 다른 코드들을 하나의 모듈 안에 뭉쳐 놓으면, 변경과 관련없는 코드도 영향을 받을 수 있다. 할인 정책을 선택하는 코드와 할인 조건을 검증하는 코드가 한 모듈에 있다고 하자.할인 정책을 추가하려고 하면, 할인 조건을 검증하는 코드는 변경과 큰 상관은 없지만 영향을 받는다. 응집도가 낮으면 변경 하나를 하려고 할 때 코드 구석구석을 고쳐야 할 수 있다. 응집도가 낮다는 건 자신과 관련있는 코드가 다른 엉뚱한 곳에 있을 수 있다는 의미이기도 하기 때문이다. 단일 책임 원칙 한 클래스가 변경되려면, 하나의 이유여야 한다는 것이다.즉 응집도 있게 설계해서 그 클래스가 엉뚱한 일에도 영향 받지 않도록 설계되어야 함을 의미한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"12. 자바의 상속 내부 원리 (부모의 private 변수는 자식이 직접 접근 가능할까)","slug":"java/java-basic/java12","date":"2021-11-28T14:27:33.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/11/28/java/java-basic/java12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/28/java/java-basic/java12/","excerpt":"","text":"부모의 private 멤버 변수는 자식이 직접 접근할 수 있을까?답은 No다. 자식 객체가 생성되면, 부모 객체는 생성 될까? 답은 Yes다 이를 검증하기 위해 코드를 짜보자. 예시코드부모 클래스123456789public class Parent &#123; public Parent() &#123; System.out.println(&quot;Parent!&quot;); &#125; private String privateString = &quot;private&quot;; protected String protectedString = &quot;protected&quot;; String defaultString = &quot;default&quot;; public String publicString = &quot;public&quot;;&#125; 부모 객체가 생성되면, 부모 생성 문구를 출력하도록 했다.그리고 접근 지시자 별 문자열을 멤버로 가지고 있다. 자식 클래스123456public class Sub extends Parent&#123; public Sub() &#123; //super(); 부모의 기본 생성자가 생략되어 있다. System.out.println(&quot;SUb class!&quot;); &#125;&#125; 자식 객체는 생성자만 가지고 있다. 이때 자식클래스는 부모의 private 멤버 변수와 생성자를 상속받지 않는다.즉 privateString을 제외한 멤버변수를 자식 클래스도 직접 접근 가능하다.자식 객체를 생성하면, 자식의 생성자가 실행된다. (이때, super()에 의해 부모 생성자 먼저 실행된다!) 그렇다고 자식 객체를 만들 때, 부모 객체와 자식 객체가 각각 생기는 게 아니다.자식 객체를 만들어도 하나의 객체를 가진다. 다만 자식 객체가 생성 되기 전에 부모 객체가 생성되고, 부모 객체의 멤버가 초기화된다.그 다음 자식 생성자가 실행되면서 부모 객체가 생성된 것에 자식 객체가 추가로 씌여진다. 쉽게말하면 (Object 객체 생성자 실행 -&gt; 부모 객체 생성자 실행 -&gt; 자식 객체 생성자 실행) 이런 식으로 실행되고,이 세가지 클래스에 있는 멤버들은 한 객체(자식)에 초기화된다. 그렇다면 다음 코드를 실행하면?1234567public class Application &#123; public static void main(String[] args) &#123; Parent first = new Parent(); Parent second = new Sub(); Sub third = new Sub(); &#125;&#125; 다음과 같다! 12345Parent!Parent!SUb class!Parent!SUb class! 참고 사이트 https://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"9. 템플릿 메서드 패턴","slug":"java/java-basic/design-pattern/dp9","date":"2021-11-27T12:14:40.000Z","updated":"2023-02-06T11:26:30.243Z","comments":true,"path":"2021/11/27/java/java-basic/design-pattern/dp9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/27/java/java-basic/design-pattern/dp9/","excerpt":"","text":"템플릿 메서드 패턴템플릿 메서드 패턴은 특정 역할의 책임을 한 메서드에 여러 메서드를 조합*(이게 템플릿!)*으로 정해놓는 패턴이다. 템플릿 메서드를 구성하는 메서드들은 역할에 속하는 객체마다 다르게 구현될 수 있다. 활용 예시우리는 여러 DB에 연결해야 한다. 우리가 연결한 DB는 모두 다음과 같은 절차를 따른다고 하자.해당 DB드라이버 찾기 - DB에 로그인 - DB에 연결 이때 DB마다 사용하는 드라이버가 다르다. 이 상황에서 템플릿 메서드 패턴을 활용해서 문제를 해결해보자. 템플릿 메서드를 포함한 추상 클래스일단 추상 클래스 안에 주어진 템플릿을 구현한 메서드를 만들어보자!이때 각 DB마다 달라지는 부분은 추상 메서드로 다형성을 확보한다. 123456789101112131415public abstract class DataConnection &#123; //템플릿 메서드 public final void process() &#123; findDriver(); login(); connectDB(); &#125; public abstract void findDriver(); public abstract void connectDB(); public final void login() &#123; System.out.println(&quot;로그인을 실행합니다...&quot;); &#125;&#125; 추상 클래스를 상속하는 자식 클래스이제 DB마다 클래스를 상속해서 구현하자.추상 메서드를 DB 요구 조건에 맞게 구현하면 된다. 우리는 MySQL과 H2를 예시로 구현해보자 1234567891011public class MySQLConnection extends DataConnection&#123; @Override public void findDriver() &#123; System.out.println(&quot;MySQL 드라이버를 찾습니다.&quot;); &#125; @Override public void connectDB() &#123; System.out.println(&quot;MySQL과 연결합니다.&quot;); &#125;&#125; 1234567891011public class H2Connection extends DataConnection&#123; @Override public void findDriver() &#123; System.out.println(&quot;H2 드라이버를 찾습니다.&quot;); &#125; @Override public void connectDB() &#123; System.out.println(&quot;H2 드라이버를 연결합니다.&quot;); &#125;&#125; 결과 확인이제 적용해보자. 123456789public class Application &#123; public static void main(String[] args) &#123; DataConnection dataConnection = new MySQLConnection(); dataConnection.process(); dataConnection = new H2Connection(); dataConnection.process(); &#125;&#125; 123456MySQL 드라이버를 찾습니다.로그인을 실행합니다...MySQL과 연결합니다.H2 드라이버를 찾습니다.로그인을 실행합니다...H2 드라이버를 연결합니다. 템플릿 메서드 패턴의 문제템플릿 메서드 패턴은 확장이 필요할 때마다 새로운 클래스를 상속해서 추가해줘야 한다. 그리고 상속이 가지는 단점을 그대로 가져온다. 컴파일 타임에 고정된 관계가 정해진다. 전략 패턴은 더 유연하게 확장할 수 있다. 템플릿 메서드 패턴은 DIP 원칙을 일부 어길 수 있다. DIP는 상위 모듈은 하위 모듈에 의존을 금지하고 서로 추상화된 인터페이스에 의존하라는 원칙이다.그런데 템플릿 메서드 패턴은 만약 추상 클래스가 상위 모듈(즉 사용하는 측)이고 구현체가 특정 로직을 구현한 하위 모듈인 방식으로 구현하면 구현체가 상위 모듈을 의존하게 된다. 스프링의 템플릿 콜백과의 차이점?둘 다 템플릿을 사용해서 변경 주기가 다른 코드를 분리하지만, 템플릿 콜백은 템플릿에서 메서드를 실행할 때 인자로 콜백 함수를 받아서 수행하는 일종의 전략 패턴이다. 즉 상속으로 확장하는 템플릿 메서드보다 더 유연하다. 템플릿 콜백은 JdbcTemplate와 같은 스프링의 여러 곳에서 사용된다. 템플릿 콜백은 템플릿과 콜백 사이의 경계를 어떻게 지을 것인지, 그리고 만들어지는 콜백들이 또 특정한 패턴이 생기면 그 코드를 템플릿에 모아둘 수 있는지 점검해봐야 한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"객체지향의 역할, 책임, 협력","slug":"java/java-basic/object/object1","date":"2021-11-26T11:36:16.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/11/26/java/java-basic/object/object1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/26/java/java-basic/object/object1/","excerpt":"","text":"역할, 책임, 협력하나의 프로그램을 만들기 위해서는 다양한 객체가 자신의 로직을 실행해서 전체 기능을 완성한다. 중요한 건, 다양한 객체가 한 기능을 만들기 위해 메시지 를 주고 받으며 상호작용한다는 사실이다. 이처럼 어플리케이션의 기능을 완성하기 위해 여러 객체가 상호작용하는 것을 협력이라고 한다. 각 객체들이 수행하는 자신의 로직을 책임이라고 하고, 객체들이 협력 안에서 수행하는 책임이 모여 객체가 수행하는 역할을 구성한다. 협력두 객체 사이의 협력은 한 객체가 다른 객체에 도움을 요청하면서 시작된다.메시지 전송은 객체 사이의 협력을 만드는 유일한 커뮤니케이션 수단이다. 즉 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 행위다.협력은 역할을 수행하기 위한 특정 책임을 잘 수행할 수 있는 다른 객체에게 위임하는 행위다. 협력과 자율성메시지를 수신한 객체는 메서드를 실행해 요청을 실행한다.이때 협력을 요청한 객체는 응답하는 객체가 어떤 방식으로 메시지를 처리할지 알지 못한다.요청하는 객체가 해당 책임에 대해 지나치게 개입하면 안된다! (다른 객체의 내부구현에 손대지말라.)(ex. 협력에 참여하는 객체의 인스턴스 변수에 직접 접근하는 경우는 해당 객체의 자율성을 훼손 -&gt; private 키워드로 캡슐화) 객체의 행동과 상태객체는 어떤 협력에 참여할 지에 따라 상태와 행동이 정의되어야 한다.즉 협력이 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.협력이 달라지면 객체의 행동도 달라질 수 있다. 협력없는 행동은 아무 의미 없다! 그렇다면 상태는 왜 존재하는가?상태는 행동에 사용되기 때문에 존재한다. 즉 협력은 객체의 행동을 정의하고객체의 행동이 필요한 정보에 따라 객체의 상태가 결정된다. 결국 협력은 객체의 모든 것을 설계하는 문맥을 제공한다. 책임책임은 협력에 참여하기 위해 객체가 수행하는 행동이다. 책임을 지는 객체는 책임을 완수하기 위해 필요한 정보를 알고 있어야 한다.혹은 그 책임을 할 수 없는 객체가 그 책임이 필요한 경우, 그 책임을 할 수 있는 객체를 알고 있어야 한다. 즉 책임은 단순한 행동을 해야 하는 것 뿐만 아니라, 그 행동에 필요한 정보도 알고 있어야 하는 것을 의미한다. 객체지향에서 제일 중요한 것이 객체에게 적절한 책임을 지게 하는 것이다. 책임 할당책임 할당을 위한 기본적인 방법은 그 책임을 수행하기 위해 필요한 정보를 가장 잘 아는 전문가에게 책임을 주는 것이다. 이제 이 책임을 할당하는 과정을 살펴보자. 하나의 큰 메시지를 정의한다.(시스템이 사용자에게 제공하는 큰 기능을 하나의 책임으로 본다) 메시지를 정의했으면 그 메시지를 처리할 객체를 고른다.(이때 메시지가 크기 때문에 그 객체 혼자서 처리 못한다.) 그 객체가 처리하지 못하는 책임은 다른 전문가(!)를 찾아서 메시지를 전달한다. 이 과정을 2번과 3번을 반복한다. 책임 주도 개발위 과정을 책임 주도 개발로 표현하면 다음과 같다 일단 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 본다.(시스템의 책임을 파악) 이제 하나의 큰 책임을 더 작은 책임으로 잘게 분해한다. 분해된 책임들을 객체들에게 할당한다. 책임을 수행하던 객체가 다른 객체의 도움이 필요하면 적절한 객체 혹은 역할을 찾는다. 해당 객체가 참여하게 되면서 두 객체는 협력하게 된다. 역할역할은 특정한 협력 안에서 수행하는 책임의 집합.실제로 협력에서 객체에게 책임을 할당한다기 보다는 역할에 책임을 할당한다고 보는 게 좋다. 역할은 유연하고 재사용 가능한 협력을 얻을 수 있게 한다.역할은 다른 것으로 교체할 수 있는 책임의 집합이다. 즉 동일한 책임을 가진 여러 객체가 있다면, 그것을 추상화 한 것이 역할이다. 영화 예매를 예시로 들면,영화 요금을 할인 하는 두 가지 방식이 있다고 하자.하나는 요금의 퍼센트로 할인하는 방식이고,(10퍼센트 할인..)다른 하나는 예매 표 중 일부 값을 할인하는 방식이 있다.(두 표사면 한 표는 할인..) 이 두 방식 모두 객체로 표현된다면, 이 두 객체는 요금을 할인한다는 동일한 책임을 가진다.그렇다면 우리는 이 같은 책임을 하나의 역할로 추상화하여 표현할 수 있다.이렇게 하면 할인 방식에 따라 협력을 일일히 만들지 않고, 역할이 할인 정책을 추상화하여 담당하게 된다. (자바에서 역할을 구현하는 방식은 추상 클래스와 인터페이스를 사용한다.) 객체냐 역할이냐그렇다면 동일 책임을 지는 다른 객체가 없는,즉 하나의 객체만이 해당 책임을 지는 경우에도 그 객체를 역할로 추상화 해줘야 할 까? 답은 아니다. 책임 수행하는 대상이 한 종류면, 간단하게 객체로 간주해도 좋다.다만 책임 수행하는 객체가 여러 종류면, 역할로 간주하라. 사실 설계 초반에는 객체와 역할을 명확히 하긴 힘들다.다양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작해라.애매하고 확실하지 않은 경우는 객체로 시작하자. (진행하면서 역할로 대체하면 된다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"오브젝트","slug":"오브젝트","permalink":"https://yangdongjue5510.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"우아한테크코스 4기 프리코스 1주차 회고","slug":"java/woowa-tech-course/utecoprecourse1","date":"2021-11-26T05:48:15.000Z","updated":"2022-02-24T14:17:30.669Z","comments":true,"path":"2021/11/26/java/woowa-tech-course/utecoprecourse1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/26/java/woowa-tech-course/utecoprecourse1/","excerpt":"","text":"우아한 테크코스 4기 프리코스 1주차1주차 문제 깃허브 링크https://github.com/woowacourse/java-baseball-precourse 문제 간단 요약우리가 흔히 아는 야구게임을 자바로 구현하는 게 1주차 문제다.세개의 수를 입력받고 해당 자릿수에 맞는 숫자를 입력한 경우 스트라이크 추가,자릿수는 맞지 않지만 맞는 숫자를 포함한 경우 볼 추가해서 결과를 반환한다. 3 스트라이크. 즉 정확히 맞출 경우 게임을 종료하고,다시 게임을 시작을 할 수 있도록 해야한다. 마주한 문제들요구사항 작성하기일단 우테코 프리코스는 가장 먼저 요구사항을 작성해야 한다.요구 사항을 기능 중점으로 정리해서 README.md를 작성해야 하는게 첫 단계다. 처음에 필자는 그냥 우테코에서 작성된 요구사항을 마구잡이로 요구사항을 만들었는데,나중에 코드를 작성하려고 했더니, 어떤 요구사항 먼저 해결해야 할 지 막막했다. 그래서 내가 고민하고 고안해낸 요구사항 분석하는 방법은 다음과 같다. 가장 먼저 전체적인 프로그램의 흐름을 이해한다. 요구사항은 기능 관점에서 작성한다. 요구사항은 의존 관계가 가장 느슨한 것 먼저 우선순위로 작성한다. 1주차 프리코스의 문제에서는 목표 숫자를 난수로 만드는게 가장 의존 관계가 느슨하다. 이게 무슨 말이냐면, 목표 숫자를 난수로 만드는 기능은 다른 기능의 힘을 필요로 하지 않는다는 의미다. 최대한 각 기능들이 서로의 역할을 간섭하지 않도록 하라. 일단 한 기능에서 예외처리를 담당하면, 다른 기능에서는 예외처리 책임을 질 필요 없다. 예외처리를 해야 될 경우 예외처리를 담당하는 기능과 협력하도록 하자. 이렇게 요구사항 목록을 작성하고 나면, 프로그래밍을 하는 과정에서 빼먹는 요구사항을 최소한으로 줄일 수 있다.또한 요구사항 구현 순서를 어느정도 정리하고 작성하기 때문에 구현을 더 원활하게 할 수 있다. 깃 사용우테코 프리코스는 깃 커밋을 신중하게 작성해야 한다.그래서 깃을 어떻게 사용하는지가 굉장히 중요하다. 기능은 따로 브랜치를 만들어서 격리된 상황에서 구현하라. 기능을 만들다가 되돌리기 쉽다. 커밋 메시지를 잘 지켜서 작성한다. 다른 사람이 쉽게 이해할 수 있도록 하기 위함이다. 커밋은 기능 관점에서 작성해야 한다. 지나치게 세세하게 하지도 않고, 지나치게 적게 하지 않기 위함이다. 코드 작성우아한 테크코스에서는 최대한 간략하게 코드를 작성하도록 한다.일단 메서드가 한 역할을 잘하도록하고, 그 메서드가 15줄이 넘지 않도록 하는게 중요하다. 필자의 경우, 전체적인 기능을 정리하고 나서,이 기능들을 어떤 클래스가 책임질 지,혹은 메서드를 어떻게 나눌 것인지가 정말 어려웠다. 후기프리코스에 참여해보니, 내가 그동안 얼마나 코드를 대충 짰는지 체감하는 경험이 됐다.혼자 코드를 짜다보면 의식의 흐름대로 코드를 짜게 되는 경우가 많다.그러다보면 한 메서드에 수많은 기능이 의존하게 되고, 유지보수도 극악에 향하게 된다. 프리코스의 요구사항을 만족하는 방식으로 프로그래밍 하다보니 자연스럽게 책임을 나누게 되고,그 책임을 수행하는 여러 객체들의 협동으로 기능을 완성했다.평소 코딩할 때는 생각해보지 못했던 부분을 경험할 수 있어 재밌었다. 프리코스는 코딩하는 법을 알려주지 않는다. 다만 무엇을 만들라 한다.그런데 하다보면 알게 된다. 아무도 알려주지 않지만 스스로 알게 된다. 내가 모르는 건 스스로 찾아서 해결하게 된다. 그리고 그 정보를 체득하기 위해 노력하게 된다. 프리코스를 시작하기 전, 교육을 기획한 자바지기님은 프리코스를 우아한 테크코스를 통과하기 위한 것으로 생각하지 말고,더 좋은 개발자가 되기 위한 과정으로 여겨줬으면 좋겠다고 하셨는데, 이번 프리코스를 통해 더 좋은 개발자가 될 수 있을 거 같다.다음 프리코스도 더 기대가 된다.","categories":[],"tags":[{"name":"우아한테크코스","slug":"우아한테크코스","permalink":"https://yangdongjue5510.github.io/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/"}],"keywords":[]},{"title":"자바 코딩 규칙(Java Code Conventions)","slug":"java/java-basic/java11","date":"2021-11-20T14:23:18.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/11/20/java/java-basic/java11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/20/java/java-basic/java11/","excerpt":"","text":"자바 소스 파일 구조시작 주석 package 문 import 문 Class 혹은 Interface 선언 시작 주석모든 소스 파일은 다음과 같은 시작 주석을 써줘야 한다. 123456789/* *클래스 이름 * *버전 정보 * *날짜 * *저작권 주의 */ package문 import문일반적으로 패키지문을 먼저 쓰고, 임포트문을 다음에 써준다. 두 문 사이에는 공백을 써준다. 123package com.yangdongjue;import java.util.*; class와 interface 선언클래스와 인터페이스 선언 순서를 알아보자 문서화 주석(&#x2F;** … *&#x2F;) 클래스&#x2F;인터페이스 문(public class …) 구현 주석(&#x2F;* … *&#x2F;) 클래스(static) 변수public - protected - default - private 순으로 나열 일반 변수클래스 변수와 동일하게 나열 생성자 메서드접근자가 아닌 기능에 의해 구성되어야 함. 한줄의 길이 한줄의 길이는 최대 80자다. 만약 하나의 식이 한 줄에 안들어가면? 줄 나누기를 해주자. 줄나누기 콤마 후에 두 줄로 나눈다. 12someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2, VeryLong veryLongExpress3); 연산자 앞에 두 줄로 나눈다.이때 연산자 레벨이 맞도록 나눠 줘야 한다. (괄호의 경우…) 12VeryLong veryLong = veryLong1+(veryLong2+veryLong3) +veryLong4; 메서드 선언에서 줄 나누기를 할 때는 한번 더 들여써준다.메서드 구현부와 헷갈리면 안되기 때문이다. 1234someMethod(VeryLong veryLongExpress1, VeryLong veryLongExpress2, VeryLong veryLongExpress3) &#123; ...(메소드 구현부) &#125; 주석주석은 코드 개요와 코드 자체로는 알 수 없는 추가 정보를 제공하기 위해서 쓰인다.주석은 프로그램을 이해하기 위한 내용을 다뤄야 한다.코드 상에 이미 표현된 중복 정보는 다루지 말아야 한다. 자바 주석은 구현 주석과 문서화 주석으로 나뉜다. 구현 주석 블록 주석파일, 메서드, 클래스 등에 설명 할 때 사용.클래스나 인터페이스 속에서 파일이나 메서드가 시작되기 전에 써줘야 하고,해당 메서드나 파일의 들여쓰기를 반영해야 한다. 123/* *블록 주석을 작성하자~ */ 한 줄 주석짧은 주석은 뒤에 따라오는 코드를 설명.뒤 코드와 동일한 들여쓰기 적용.윗 코드와 한칸 띄어서 사용 12345if (condition) &#123; /* 한 줄 주석 */ int a = 1;&#125; 꼬리 주석아주 짧은 주석이 필요한 경우 설명하는 코드와 같은 줄에 작성. 12345if (condition) &#123; return true; /* condition에 해당 */&#125; else &#123; return false /* condition에 해당히지 않음 */&#125; 줄 끝 주석한 줄을 통째로 주석 처리하거나, 일부를 주석 처리 할때 사용.코드를 주석처리 할 때 여러줄을 주석하는 건 가능하지만, 그외는 여러줄 주석을 금한다. 1234567891011if (condition) &#123; //줄 끝 주석은 이렇게 쓸 수 있다. int a = 1;&#125; else &#123; return false; //줄 끝 주석을 여기에도 쓸 수 있다.&#125;//if (condition) &#123;// int a = 2;//&#125; 문서화 주석문서화 주석은 다음 다섯가지를 분석한다. 자바 클래스 인터페이스 생성자 메서드 필드 다만 문서화 주석이 어울리지 않으면, 클래스 선언 후에 블록 주석 혹은 한줄 주석으로 표현한다. 123456/** * 이 클래스는 어떤 역할을 합니다. */public class Example &#123; ...&#125; 변수변수 선언123456/* 옳은 예시 */int a;int b;/* 괜찮지만 불편한 방식 */int a, b; 이때 중요한 건 한 클래스에 필요한 변수를 선언은 가장 처음에 하는게 좋다!!!!!그리고 지역 변수를 전역 변수와 같은 이름으로 선언하지 말자!!!! 1234567class Example &#123; int a = 1; if (condition)&#123; int a = 2; // 이렇게 쓰지 말라는 거다!!! &#125;&#125; 클래스 &amp; 인터페이스 선언 메서드 이름과 파라미터를 감싸는 괄호 시작 사이에는 빈 공간이 없어야 한다. 12345678public class Main &#123; int a; int b; int method() &#123; int c; &#125;&#125; 여는 중괄호는 클래스&amp;인터페이스&amp;메서드의 선언부 문장 끝에 위치한다. 닫는 중괄호는 구현부가 없는 경우가 아니면 여는 문장과 동일한 들여쓰기로 새로운 줄로 사용하자. 12345678class Main &#123; int a; int b;&#125;class Okay &#123;&#125;class Wrong &#123; int c; &#125; 클래스나 인터페이스 내부의 메서드는 분리되기 위해서 한 줄씩 띄어놔야 한다. 12345678class Main &#123; int a; int b; void firstMethod()&#123;&#125; void secondMethod()&#123;&#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"스프링 부트의 특징","slug":"spring/boot/boot12","date":"2021-11-19T02:56:33.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/11/19/spring/boot/boot12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/19/spring/boot/boot12/","excerpt":"","text":"스프링 부트의 특징스프링 부트는 스프링의 복잡한 xml 간편화와 빠른 개발을 위해 등장했다.부트는 웹을 위해 필요한 필수 라이브러리를 내장하고 있다.(톰캣 등) 스타터(starter) : 특정 모듈을 사용할 수 있도록 필요한 라이브러리를 모아놓은 라이브러리 모음 자동설정(AutoConfiguration) : 추가된 라이브러리나 모듈을 사용할 수 있도록 자동으로 빈 등록이나 프로퍼티 설정을 하는 것.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"12. 링크 계층","slug":"cs/network/network12","date":"2021-11-17T11:27:55.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network12/","excerpt":"","text":"a. 링크a-1. 링크 계층 소개 링크 계층(2계층) 프로토콜을 실행하는 장치를 노드라 함. 통신 경로상의 인접한 노드들을 연결하는 통신 채널은 링크 한 링크에서 전송 노드는 데이터그램을 링크 계층 프레임으로 캡슐화해서 링크로 전송한다. a-2. 링크 계층의 서비스 프레임화 : 네트워크 계층 데이터그램을 링크상으로 전송하기 전에 링크 계층 프래임에 캡슐화.header payload trailer 형식으로 캡슐화 링크 접속 : 매체 접속 제어(MAC) 프로토콜은 링크상으로 프레임을 전송하는 규칙에 대해서 명시함 신뢰적 전달(RDT) : 링크 계층의 신뢰적 전달 서비스도 확인 응답과 재전송 방식으로 가능*트랜스포트 계층이나 애플리케이션 계층과 달리 데이터를 재전송하는 방식과 달리*링크 계층 프로토콜은 오류가 발생한 링크에서 오류를 정정.왜 수송 계층과 링크 계층 모두 RDT가 필요하지? 링크 계층에서 잘 되도, IP에서 best-effort로 인한 손실이 발생가능. 그래서 수송 계층에서 RDT를 하는 것. 오류 검출과 정정 : 오류 검출은 송신 노드에서 프레임의 오류 검출 비트를 설정하고 수신 노드에서 오류 검사를 수행하게 하는 방식. 오류 정정은 프레임 안의 오류 검출, 프레임의 어느 곳에서 오류가 발생했는지를 찾아내는 것.(오류 검출과 비슷하게 구현) a-3. 링크 계층이 구현되는 위치링크 계층은 네트워크 인터페이스 카드로 알려진 네트워크 어댑터로 구현된다. 링크 계층 제어기로 링크 계층 서비스들의 대다수가 구현한다. 일부 링크 계층 기능은 호스트 cpu에 실행되는 소프트웨어에 구현되어 있다. 링크 계층은 하드웨어와 소프트웨어의 조합. 프로토콜 스택상에서 소프트웨어와 하드웨어가 만나는 부분에 위치. 송신 측의 제어기는 상위 계층에 의해 생성되어 호스트 메모리에 저장된 데이터그램을 링크 계층 프레임을 캡슐화한 후, 링크 접속 프로토콜에 따라 이 프레임을 통신 링크로 전송한다. 수신 측의 제어기는 프레임을 수신한 후 네트워크 계층 데이터그램을 추출한다. b. 오류 검출 및 정정 기술 비트 오류를 방지하기 위해 송신 노드에서 데이터 D에 오류 검출 및 정정 비트들(EDC)을 첨가한다. 수신자는 자신이 수신한 D’와 EDC’만으로 원래의 D가 D’와 동일한지 결정한다. 오류 검출 비트를 사용하더라도 여진히 미검출된 비트 오류가 있을 수 있다. b-1. 패리티 검사b-1-1. 단일 패리티 비트 데이터 D가 d개의 비트를 가지고 있다고 할 때, 패리티 비트를 하나 추가. 이 비트들에서 1의 개수가 짝수(혹은 홀수)가 되도록 설정한다. 수신자는 받은 데이터의 1 갯수가 홀수(혹은 짝수)이면 오류가 있음을 알게 된다. 그러나 짝수 개의 비트 오류가 발생하면 오류를 검출하지 못할 수도 있다. b-1-2. 2차원 단일 비트 패리티데이터 D를 i개의 행과 j개의 열로 나눠서 각 가로줄과 세로줄의 1 갯수가 짝수(혹은 홀수)가 되도록 패리티를 설정한다. 이 방식은 수신자가 단일 비트 오류의 발생을 검출할 수 있을 뿐 아니라, 열과 행의 인덱스 값을 사용해 잘못된 비트를 실제로 식별해 오류를 정정할 수 있다. b-2. 체크섬데이터 바이트를 16비트 정수 단위로 취해서, 더한 값의 1의 보수가 인터넷 체크섭이 되며, 이를 세그먼트 헤더에 넣어준다. 오버헤드가 적지만 오류 면에서 상대적으로 취약하다. b-3. 순환중복검사(CRC) 데이터 D가 비트 d로 이뤄져 있을 때, G로 표현하는 생성자로 알려진 r+1 비트 패턴에 대해서 합의한다. 송신자는 r개의 추가비트 R을 선택해서 D 뒤에 덧붙이며, d+r 비트 패턴은 모듈 -2연산(XOR 연산)을 이용하면 G로 정확히 나누어진다. 수신자는 d+r개의 수신 비트를 G로 나눈다. 나머지가 0이 아니면 오류가 존재하는 것. 예시로 해보자 일단 생성자 G를 1001로 약속하고,101110인 데이터 D에 2^r을 곱한 것을 G로 나눈 나머지를 R로 정한다. 그 이후 D*2^R XOR R을 수신자에게 보낸다 XOR 연산은 같은 자리 같은 숫자이면 0인 연산이다. 간단히 생각하면 D뒤에 R을 그냥 덧붙인 결과라 생각하자. 예시에 따르면 101110011이 된다. c. 다중 접속 링크와 프로토콜다수의 송수신 노드들의 공유되는 브로드캐스트 채널로의 접속을 조정하는 문제. 즉 다중 접속 문제에 의한 충돌을 해결해야 한다. 이런 전송을 조정하기 위한 것이 다중 접속 프로토콜. #out of band channel &amp; in band channel out of band &#x3D; control과 data가 다른 채널로 전달 in band &#x3D; control 과 data가 같은 채널로 전달 무선랜은 in-band channel c-1. 이상적인 다중 접속 프로토콜의 조건 단 하나의 노드가 전송하려 할 때, 그 노드가 R bps의 처리율을 갖는다. M개의 노드가 전송하려 할 때, 각 노드가 R&#x2F;M bps의 처리율(평균적 의미)을 갖는다. 프로토콜이 분산되어 있어, 고장으로 시스템이 정지될 수 없다. 비용이 적게 든다. c-2. 채널 분할 프로토콜c-2-1. 시분할 다중화(TDM) TDM은 시간을 시간 프레임으로 나누고 또한 각 시간 프레임을 N개의 시간 슬롯으로 나눈다. 각 시간 슬롯은 N개의 노드에게 할당된다. 노드는 전송할 패킷이 있을 때마다 TDM 프레임에서 자신에게 할당된 시간 슬롯 동안 패킷 비트를 전송. 참가자들에게 고정된 시간을 주고, 말할 게 없어도 시간을 준다. 전송하고픈 노드가 하나라도 노드 전송률은 평균 R&#x2F;N으로 제한. 노드가 전송 순서상 자신의 차례를 기다려야함. c-2-2. 주파수분할 다중화(FDM) FDM은 R bps의 채널을 다른 주파수로 나눠서 각 주파수를 N개 노드 중 하나에게 할당한다. TDM과 비슷한 장단점을 가짐. c-3. 랜덤 접속 프로토콜항상 채널의 최대 전송률인 R bps로 전송한다. 충돌이 생기면 충돌과 관련된 각 노드는 프레임이 충돌없이 전송될 때까지 자신의 프레임을 계속해서 재전송. 대신 그 프레임을 재전송하기 전에 랜덤 지연 시간 동안 기다린다. c-3-1. 슬롯 알로하 가정 모든 프레임은 정확히 L비트로 구성 시간은 L&#x2F;R초의 슬롯들로 구성(즉 한 슬롯은 한 프레임 전송에 걸리는 시간과 같음) 노드는 슬롯의 시작점에서만 프레임을 전송하기 시작 각 노드는 언제 슬롯이 시작하는지 알 수 있게끔 동기화되어 있음 한 슬롯에서 2개 이상의 프레임이 충돌 시, 모든 노드는 그 슬롯이 끝나기 전에 충돌 발생을 알게 됨 작동 방식 노드는 전송할 새 프레임이 있으면 다음 슬롯까지 기다렸다가 전체 프레임을 전송 충돌이 없으면, 노드는 성공적으로 자신의 프레임을 전송한 것따라서 보낸 프레임을 다시 보낼 필요 없음 충돌하면, 노드는 그 슬롯이 끝나기 전 충돌을 검출, 노드는 그 프레임이 충돌 없이 전송 될 때까지 확률 p로 해당 프레임을 다음 스롯들에서 재전송한다.각 노드들은 자신의 동전을 던지며, 재전송할지 다음 슬롯에서 동전을 다시 던질지를 결정한다. 장점 활성노드가 채녈의 전속력 R로 계속해서 프레임을 전송할 수 있돌록 허용 상당히 분산(노드는 슬롯을 동기화시켜야) 매우 단순 활성 노드가 하나일 때 잘 동작 단점 여러 노드가 참여하면 충돌이 생겨 낭비가 생긴다. 모두가 전송을 자제해 슬롯이 비는 상황이 생길 수 있다. 효율성(여러개의 활성 노드가 있을 때 충돌없이 전송되는 시간 비율) N개의 노드가 확률 p로 슬롯 알로하로 패킷을 보낼 때 임의의 노드가 성공 확률은? Np(1-p)^(N-1) 최대 효율은 효율성의 극대화인데, 이 프로토콜의 최대 효율은 0.37.(겨우 37%의 슬롯만 낭비되지 않는다…) c-3-2. 알로하슬롯 알로하는 모든 노드가 슬롯의 시작점에서 전송을 시작할 수 있도록 동기화되어 있기를 요구 하지만 알로하 프로토콜은 슬롯이 없고 완전히 분산된 프로토콜 전송된 프레임이 하나 이상의 다른 전송과 충돌하면, 노드는 확률 p로 즉시 프레임을 전송한다. 주어진 노드가 성공적인 전송을 할 확률은 p(1-p)^2(N-1) 순수 알로하 프로토콜의 최대 효율은 1&#x2F;2e 즉 슬롯 알로하의 절반… c-3-3. CSMA 말하기 전에 들어라 : 다른 사람이 말하고 있으면 말이 끝날 때까지 기다려라.네트워크에서는 이를 캐리어 감지 라고 한다. 다름 사람이 동시에 말하기 시작하면 말을 중단하라 : 네트워크에서 이것을 충돌 검출이라 함(송신 노드는 전송하면서 동시에 채널을 듣는다.)멈춘 후 랜덤 시간 동안 기다린 후 유휴 시 감지 및 전송 과정을 반복 하지만 브로드캐스트 채널의 종단간의 채널 전파 지연이 CSMA의 성능을 결정하는 데 중요함. 전파 지연이 길 수록 네트워크의 다른 노드에서 이미 시작된 전송을 캐리어 감지 노드가 감지 할 수 없는 경우 증가. c-3-4. CSMA&#x2F;CD다중접속 프로토콜에 충돌 검출을 추가한 것. 쓸모 없는 프레임(충돌이 발생한 프레임)을 모두 전송하지 않게 됨. 링크 계층 프레임을 만든 후에 그 프레임을 어댑터의 버퍼에 저장 채널이 유휴한 것을 감지하면(채널로부터 어댑터로 들어오는 신호 에너지가 없으면) 프레임 전송을 시작한다.채널이 바쁜 것을 감지하면, 신호 에너지가 감지되지 않을 때까지 기다렸다가 프레임을 전송한다. 전송하는 동안 어댑터는 다른 어댑터로부터 신호가 있는지 감시한다. 전송 도중 다른 어댑터로부터 신호 에너지를 감지하면, 자신의 프레임 전송을 취소한다. 임의의 랜덤 시간(이진지수적 백오프)만큼 기다린 후 2단계로 돌아간다 #이진지수적 백오프 충돌을 n번 경험한 프레임을 전송할 때, {0,1,2…,2^n-1} 중 랜덤하게 선택한다. 새 프레임을 준비할 때 최근 발생했던 충돌을 고려하지 않는다. 효율성 prop : 신호 에너지가 임의의 두 어댑터 사이에서 전파되는 데 걸리는 최대 시간 trans : 최대 크기의 이더넷 프레임을 전송하는 데 걸리는 시간(10Mbps 이더넷에서 대략 1.2msec) c-4. 순번 프로토콜다중 접속 프로토콜의 두가지 특성 단 하나의 노드만이 활성화 되면 그 노드가 R bps의 처리율을 가져야 한다 M개의 노드가 활성이면 각 노드가 거의 R&#x2F;M bps의 처리율을 가진다. 알로하와 CSMA는 첫번째 특성을 가지나 두 번째 특성은 없다. 순번 프로토콜을 개발하게 된 계기이다. 채널 나누기 MAC protocol : high load 일 때 효율적 공정, low load일 때 비효율(무조건 1&#x2F;N을 분배) 랜덤 access MAC protocol : low load 일 때 효율, high load일 때 비효율(충돌 overhead) c-4-1. 폴링 프로토콜 노드 중 하나를 마스터 노드로 지정. 각 노드를 라운드 로빈 형식으로 폴링. 마스터가 노드1에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다. 노드 1이 모두 보내고 나면 노드 2에게 최대로 보낼 수 있는 프레임 수에 대한 메시지를 보내준다. 단점 폴링 지연(노드가 전송할 수 있음을 알리는데 걸리는 시간)으로 인해 활성 노드는 R bps보다 작은 전송률을 가진다. 마스터 노드가 고장 나면 전체가 작동 안하게 됨 c-4-2. 토큰 전달 프로토콜 토큰이라고 알려진 작은 특수 목적 프레임이 정해진 순서대로 노드 간에 전달된다. 토큰이 노드1-&gt;노드2-&gt;노드3 순으로 토큰을 전달한다. 노드는 토큰을 수신하면, 보낼 데이터가 있을 때만 토큰을 잡는다. 보낼 게 있으면 최대 개수 만큼 프레임을 보낸다. 노드하나가 실패하면 전체가 동작하지 않는다. d. 스위치 근거리 네트워크스위치 네트워크에서는 링크 계층 프레임을 전달하기 위해 IP 주소가 아닌 링크 계층 주소를 사용 d-1. 링크 계층 주소체계와 ARPd-1-1. MAC 주소호스트의 어댑터 혹은 라우터의 어댑터가 링크 계층 주소를 가진다. 다수의 어댑터를 가지고 있는 호스트나 라우터는 여러개의 링크 계층 주소를 가진다. MAC 주소는 6바이트(48비트) 길이이고, 16진수 표기법으로, 각 바이트는 2개의 16진수로 표현. 어떤 어댑터도 동일한 주소를 가지지 않는다!(IEEE에서 주소 할당) MAC 주소는 평면 구조를 가지며, 어댑터의 위치에 따라 변경되지 않음 마치 사람의 주민등록번호와 같다(ip는 위치에 따라 변하는 것처럼, 주소와 비슷하다) d-1-2. ARP 네트워크 계층 주소(ip)와 링크 계층 주소(MAC 주소) 사이의 변환(ARP는 링크 계층과 네트워크 계층의 경계에 있다고 봐야한다.) ARP는 동일한 서브넷상에 있는 호스트나 라우터 인터페이스의 IP 주소만을 해결한다. 호스터와 라우터는 자신의 메모리에 ARP 테이블을 가지고 있다. 테이블엔 &lt;IP 주소, MAC 주소, TTL&gt;이 있다. ARP 테이블을 보고 노드를 찾아 간다. 만약 송신 노드의 ARP 테이블에 목적지 노드에 대한 엔트리가 없다면? 먼저 송신 노드 ARP 패킷이라는 특수 패킷을 구성한다.ip주소와 mac 주소를 포함하는 필드를 갖고 있다. ARP 질의 패킷의 목적은 해결하려는 ip주소에 대응하는 mac 주소를 결정하기 위해모든 호스트와 라우터에게 질의하는 것. 송신 노드는 어댑터에게 ARP 패킷을 전달하여,브로드캐스트 주소(FF-FF-FF-FF-FF-FF)로 패킷을 전송하도록 지시서울시 xx구 xx동 xx아파트 101호에 사는 사람 주민번호가 뭔지 아는사람? 각 노드의 어댑터는 ARP 패킷을 자신의 ARP 모듈로 전달,모듈이 자신의 ip와 패킷 속 ip와 비교하여 일치할 경우 요구 정보를 반환. 질의를 한 호스트는 답변을 듣고, 자신의 ARP 테이블을 갱신 질의 메시지는 브로드캐스트로 전달되지만 응답 메시지는 표준 프레임으로 전송된다. ARP의 플러그 앤 플레이, 즉 노드의 ARP 테이블이 자동으로 구축된다. d-1-2-1. 서브넷에 없는 노드로 데이터그램 전송 라우터는 각 인터페이스 당 하나의 IP 주소를 가진다. 각 라우터 인터페이스는 ARP 모듈(라우터 안)과 어댑터를 가진다. 물론 각 인터페이스 별로 MAC 주소를 가진다. ARP로 라우터의 MAC 주소를 알아내 원래 목적지를 담은 데이터그램을 포함한 프레임을 전달한다 라우터의 어댑터의 링크 계층 프레임이 자신을 목적지로 했는지 확인 후 라우터의 네트워크 계층으로 보낸다. 라우터는 포워딩 테이블을 참조해 정확한 인터페이스를 결정한다 데이터그램을 새 프레임에 캡슐화해 서브넷 2로 전송한다. ARP로부터 목적지의 MAC 주소를 알아내 보낸다. d-2. 이더넷최초의 이더냇 랜은 노드를 연결하기 위해 동축 버스를 사용. 버스 토폴로지의 이더넷은 브로드캐스트 랜으로, 전송되는 모든 프레임은 버스에 연결된 모든 어댑터를 거치며 처리됨 이후 랜을 허브 기반의 스타 토폴로지를 사용하는 이더넷으로 대체했다. 허브는 프레임이 아닌 각각의 비트에 대한 처리를 하는 물리 계층 장치이다. 허브도 브로드캐스트 랜이므로, 여러 프레임이 수신되면 충돌이 발생해 재전송 해야한다. 허브 이후 중앙의 허브가 충돌이 없는 스위치로 대체되었다. d-2-1. 이더넷 구조 데이터 필드(46~1500바이트) : IP 데이터그램을 운반(다른 네트워크 계층도 가능), 46보다 작으면 채워서라도 보내야 하고, 1500바이트보다 많으면 데이터그램을 단편화해야함. 목적지 주소(6바이트) : 목적지 어댑터의 MAC주소 출발지 주소(6바이트) : 전송하는 어댑터의 MAC주소 타입 필드(2바이트) : 이더넷으로 하여금 네트워크 게층 프로토콜을 다중화(연계). IP 외의 다른 네트워크 계층 프로토콜을 사용할 수 있음을 의미 순환중복검사(CRC, 4바이트) 프리앰블(8바이트) : 첫 7바이트는 10101010값을 가짐. 마지막 바이트는 10101011이다. 첫 7개의 바이트는 수신 어댑터를 깨우고, 수신자의 클록을 송신자의 클록에 동기화시키는 역할을 한다. 8번째 바이트의 마지막 두 비트(연속으로 오는 1)는 어댑터로 하여금 중요한 것이 오고 있음을 알려준다. d-2-2. 이더넷 특징 비연결형 서비스핸드셰이킹하지 않고 이더넷 프레임에 데이터그램을 캡슐화해서 그 프레임을 랜으로 전송 비신뢰적인 서비스CRC를 통과해도 응답이 없고, 실패해도 응답이 없다. CRC를 실패하면 그냥 수신자가 폐기한다.CRC를 통과했는지 알 방법이 없다.(TCP가 이 역할을 대신한다.) d-3. 링크 계층 스위치스위치는 그 자체가 서브넷의 호스트와 라우터들에게 투명함. 호스트&#x2F;라우터는 프레임을 스위치가 아닌 다른 호스트&#x2F;라우터를 목적지로 해서 랜상으로 보내며,중간에 스위치가 프레임을 받아서 다른 노드에게 전달하는 것을 알지 못한다. d-3-1. 스위치의 전달 및 여과여과 : 프레임을 전달할지 혹은 폐기할 지 결정. 전달 : 전송될 인터페이스를 결정하고 해당 인터페이스로 내보내는 것. 여과와 전달은 스위치 테이블을 이용. &lt;MAC 주소, 그 MAC 주소로 가게 하는 스위치 인터페이스, 해당 엔트리가 만들어진 시점&gt; d-3-2. 스위치의 작동 방식목적지 주소 DD-DD-DD-DD-DD-DD를 가진 프레임이 스위치의 인터페이스 X에 도착했다고 가정 목적지 주소에 대한 엔트리가 스위치 테이블에 없을 경우 : 인터페이스 X를 제외한 모든 인터페이스에 프레임 복사본을 보낸다.(브로드캐스트) 목적지 주소가 인터페이스 X에 대한 엔트리가 있는 경우 : 이 경우, 다른 인터페이스를 전달할 필요가 없으며, 프레임을 여과를 실행하여 제거(DD-DD-DD-DD-DD-DD로 보내려면 인터페이스 X를 사용해야 될 경우 잘못된 상황이다.) 목적지 주소가 인터페이스 Y에 대한 엔트리가 있는 경우 : Y에 접속된 랜 세그먼트로 전달 d-3-3. 스위치의 자가학습*플러그앤플레이* 스위치 테이블을 자동으로 동적으로 자치적으로 구축하는 기능 스위치 테이블은 초기에 비어있다. 인터페이스로 수신한 각 프레임에 대해서 다음 정보를 저장한다.a. 프레임의 출발지 주소필드에 있는 MAC 주소b. 프레임이 도착한 인터페이스c. 현재시간 일정시간이 지난 후에도 스위치가 해당 주소를 출발지 주소로 하는 프레임을 수신하지 못하면 테이블에서 삭제한다. d-3-4. 스위치 vs 라우터 라우터 : 네트워크 계층 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 3계층까지 프레임 처리해야함 스위치 : MAC 주소를 사용해서 패킷 전달, 저장 후 전달 패킷 스위치, 플러그앤 플레이, 2계층까지만 패킷 처리 d-4. 가상 근거리 네트워크(VLAN)트래픽 격리 부족, 사용자 관리, 스위치의 비효율적인 사용을 해결하기 위한 기술. VLAN을 지원하는 스위치는 하나의 물리적 근거리 네트워크 기반 구조상에서 여러 개의 가상 근거리 네트워크들을 정의할 수 있게 한다. d-4-1. VLAN 트렁킹 트렁크 포트를 지정해 트렁크 링크를 통해 다른 스위치로 전달해준다. 프레임이 속한 VLAN을 식별해주는 4바이트 VLAN 태그를 헤더에 덧붙여 어떤 VLAN의 요청인지를 파악한다.(802.1Q) d-4-2. 802.1Q","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"11. 네트워크 계층 제어 평면(ICMP, SNMP)","slug":"cs/network/network11","date":"2021-11-17T11:27:48.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network11/","excerpt":"","text":"a. 인터넷 제어 메시지 프로토콜(ICMP)호스트와 라웉터가 서로 간에 네트워크 계층 정보를 주고받기 위해 사용된다. 대표적으로 인터넷 문제 식별을 할 수 있다. ICMP는 구조적으로 IP 바로 위에 있고 IP 페이로드에 담겨 전송된다. TYPE과 CODE값으로 상태를 구분해 인식한다. a-1. ICMP 메시지 타입 b. 네트워크 관리와 SNMP적절한 비용으로 요규사항을 만족시키기 위해, 네트워크와 구성요소 자원들을 감시, 테스트, 폴링, 설정, 분석, 평가, 제어하는 하드웨어, 소프트웨어, 인간요소 등을 배치하고 통합, 조정하는 것. 관리 서버는 네트워크 관리 활동이 일어나는 장소. 네트워크 관리 정보의 수집, 처리, 분석, 게시를 제어. 피관리 장치는 관리 대상 네트워크에 존재하는 네트워크 장치들. 피관리 장치 내부에는 피관리 객체들이 있다. 피관리 객체는 하드웨어 일부, 소프트웨어 요소에 대한 설정 매개변수들이다. 피관리 장치 내의 피관리 객체들에 관련된 정보들은 MIB에 저장된다. 피관리 장치에는 네트워크 관리 에이전트가 있어 관리 서버와 통신하며, 피관리 장치에 대한 행동을 취하는 프로세스이다. 네트워크 관리 프로토콜은 관리 서버와 피관리 장치들 사이에서 연결. c. SNMP관리 서버와 그 관리 서버를 대표하여 실행되고 있는 에이전트 사이에서 네트워크 관리 제어 및 정보 메시지를 전달하기 위해 사용 SNMP 관리 서버는 에이전트에게 요청을 수신하고 SNMP 에이전트는 이를 수행한 후 요청에 대한 응답을 보냄 에이전트가 요구받지 않았더라도 트랩 메시지를 관리 서버에게 전송. 트랩 메시지는 MIB 객체 값들을 변화시킨 예외 상황의 발생을 통지하기 위해 이용. 출처: https://nongue.tistory.com/165?category=866237 [가자미의 개발이야기]","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"10. 네트워크 계층 제어 평면 (소프트웨어 정의 네트워크(SDN) 제어 평면)","slug":"cs/network/network10","date":"2021-11-17T11:27:39.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/11/17/cs/network/network10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network10/","excerpt":"","text":"a. SDN a-1. SDN 구조의 특징 플로우 기반 포워딩 : 스위치들에서 패킷 포워딩은 전송 계층, 네트워크 계층, 링크 계층 헤더의 어떤 값을 기반으로도 가능하다.IP 데이터그램의 포워딩이 온전히 목적지 주소만으로 이뤄지는 전통적 라우터 기반과는 매우 대조적. 데이터 평면과 제어 평면의 분리 : 데이터 평면은 네트워크 스위치로 구성. 이들은 자신의 플로우 테이블의 내용을 기반으로 비교와 실행을 수행. 제어 평면은 서버와 스위치의 플로우 테이블을 결정, 관리하는 소프트웨어로 이뤄진다. SDN의 제어 평면은 SDN 컨트롤러와 네트워크 제어 응용들의 집합으로 이뤄짐 데이터 평면 스위치, 컨트롤러, 네트워크 제어 응용들이 서로 다른 제조사나 기관에서 제공하는 분리된 개체이다. a-2. SDN 컨트롤러와 SDN 네트워크 제어 응용컨트롤러는 크게 세개의 계층으로 구성된다. 통신 계층 : SDN 컨트롤러와 제어받는 네트워크 장치들 사이의 통신컨트롤러와 장치들 사이에 정보를 전달하는 프로토콜.사우스바운드라는 컨트롤러 인터페이스(API)를 넘나는다. 네트워크 전역 상태 관리 계층 : SDN 제어 평면의 궁극적인 제어 결정제어 장치들의 플로우 테이블을 결정. 네트워크 제어 응용 계층과의 인터페이스 : 컨트롤러와 네트워크 제어 응용들과의 상호 작용노스바운드라는 인터페이스를 통해 네트워크 제어 응용들이 네트워크 상태 정보와 플로우테이블을 읽도록 함 논리적으로는 중앙 집중화된 것으로 보이지만, 실제로는 분산된 서버의 집합으로 구현된다. a-2-1. 오픈플로우 프로토콜통신 계층에서 동작하는 프로토콜. 컨트롤러와 스위치(혹은 오픈플로우 api를 구현한 다른 장치)와의 사이에서 동작. TPC 상에서 포트번호 6653을 사용. a-2-1-1. 오픈플로우에서 자주 사용되는 메시지컨트롤러에서 스위치로 전달 되는 주요 메시지 설정 : 스위치의 설정 파라미터를 문의하거나 설정 상태 수정 : 스위치 플로우 테이블의 엔트리를 추가&#x2F;제거&#x2F;수정 하거나 스위치 포트의 특성을 설정 상태 읽기 : 스위치 플로우 테이블과 포트로부터 통계 정보와 카운터 값을 요청 패킷 전송 : 스위치의 지정된 포트에서 특정 패킷을 내보내기 위해 사용 스위치에서 컨트롤러로 전달 되는 주요 메시지 플로우 제거 : 어떤 플로우 테이블 엔트리가 시간이 만료 되었거나, 상태 수정 메시지에 대한 결과로 삭제됨을 알림 포트 상태 : 포트의 상태 변화를 알리기 위해 사용 패킷 전달 : 플로우 테이블의 어떤 엔트리와도 일치하지 않는 패킷이나, 작업을 위해 컨트롤러로 패킷을 전달. a-3. 데이터 평면과 제어 평면의 상호 작용 예제 위 예제는 다익스트라 알고리즘이 최단 경로를 위해 사용되는 SDN 예시이다. 라우터별 제어 시나리오와는 두가지 차이점을 가진다. 다익스트라 알고리즘이 패킷 스위치 외부에서 별도의 어플리케이션으로 실행 링크 업데이트 정보를 서로 간이 아닌 SDN 컨트롤러에게 전송한다. 본 예시에서 s1, s2 사이의 링크가 단절되어 플로우 테이블을 수정해야 하는 상황이다. 링크 단절을 감지한 s1이 오픈 플로우의 포트 상태 메시지를 통해 SDN 컨트롤러에 링크 상태 변화를 알린다. SDN 컨트롤러는 링크 상태 관리자에게 알려 링크 상태 데이터베이스를 갱신한다. 다익스트라 링크 상태 라우틍을 담당하는 네트워크 제어 응용은 링크 상태 변화가 있을 경우 알려받도록 이전에 등록해두었다. 이 응용은 링크 상태의 변화를 알게 된다. 링크 상태 라우팅 응용이 링크 상태 관리자와 접촉해 갱신된 링크 상태를 가져와 새로운 최소 비용 경로를 계산한다. 컨트롤러의 플로우 테이블 관리자가 오픈플로우 프로토콜을 사용해 링크 상태 변화에 영향을 받는 스위치들의 플로우 테이블을 갱신한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"9. 네트워크 계층 제어 평면(OSPF, BGP)","slug":"cs/network/network9","date":"2021-11-17T11:27:30.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network9/","excerpt":"","text":"a. OSPFa-1. 자율 시스템 (AS)확장 문제 : 수억개의 라우터가 있는데, 각 라우터의 목적지 라우팅 정볼르 저장하려면 어마어마한 메모리가 필요하다 관리 자치 문제 : ISP는 자신의 네트워크를 원하는대로 운용하거나, 네트워크 내부 구성을 외부에 감추길 원한다. 이를 자율 시스템 (AS)로 해결한다. AS는 동일한 괄리 제어하에 있는 라우터의 그룹으로 구성된다. 이 AS들은 고유한 AS넘버로 구별된다.(ASN) 한 AS안에는 동일한 라우팅 알고리즘을 사용하게 되고, 이를 AS 내부 라우팅 프로토콜이라고 부른다. Intra-AS : AS 내부 프로토콜 Inter-AS : AS 외부 프로토콜 gateway router : 다른 AS와 연결되는 라우터 Inter-AS는 어떤 AS에 갔을 경우 도달할 수 있는 라우터를 자신의 AS 내 라우터들에게 알려주야 한다. a-2. 개방형 최단 경로 우선 프로토콜 (OSPF)intra AS 라우팅 프로토콜의 일종. 다익스트라 알고리즘을 사용하는 링크 상태 알고리즘. 라우터는 링크 상태를 AS 내부 모든 라우터에게 flood. 각 라우터는 전체 AS에 대한 완벽한 토폴로지 지도(즉 그래프)를 얻는다. OSPF는 링크의 가중치 설정 방법에 특정하지 않고, 주어진 링크 가중치에 대해 최소 비용 경로를 결정하는 방법을 제공 모든 링크 가중치를 1로 하여 최소 홉 라우팅을 하거나, 링크 용량에 반비례하는 가중치를 주어 적은 대역폭의 링크 사용을 최소화하는 라우팅을 할 수 있다. 보안 : 인증을 통해 신뢰할 수 있는라우터들만이 AS 내부의 OSPF 프로토콜에 참여 복수 동일 비용 경로 : 한 목적지에 동일한 비용을 가진 여러 경로가 존재할 경우, 이 경로들을 사용할 수 있음 ip 헤더의 Tos 필드를 사용해서 각 링크마다 다양한 cost를 사용할 수 있다. (hop갯수, 대역폭…) 멀티캐스트 라우팅과 유니캐스트 라우팅의 통합 지원 단일 AS 내에서 계층 지원 로컬 area, backbone으로 two-level hierarchy구조. link-state advertisement를 해당 area 안에서 진행. area border router가 area 외부의 라우팅을 책임짐 OSPF 영역은 backbone에 한정됨. boundary router가 외부 AS와 연결 b. ISP간의 라우팅 : BGP(Border Gateway Protocol, 경게 게이트웨이 프로토콜)패킷이 여러 AS를 지나야 할 때 어떻게 처리할 것인가? 모든 AS들은 BGP라고 불리는 Inter AS 라우팅 프로토콜을 사용함. BGP는 CIDR형식으로 표현된 주소의 앞쪽 접두부를 향해 포워딩한다. b-1. BGP의 역할\\1. 이웃 AS로부터 도달 가능한 서브넷 접두부 정보를 얻는다. -나는 존재하고 여기 있습니다. by 서브넷. -BGP는 인터넷의 모든 라우터들이 이 서브넷에 대해 알도록 한다. \\2. 서브넷 주소 접두부로의 가장 좋은 경로를 결정 -BGP의 경로 결정 절차에 따라 좋은 경로를 결정한다. b-2. BGP 경로 정보 알리기BGP의 추상적 연결 그래프 eBGP &#x3D; 외부 BGP연결 iBGP &#x3D; 내부 BGP연결 iBGP는 물리적인 링크와 항상 일치하지 않음 이때 x에 대한 도달 가능성 정보를 모든 라우터에게 알리는 작업을 가정해보자. 먼저 AS3이 AS2에게 BGP 메시지를 보내 x가 존재하고 AS3 안에 있음을 알린다. 그 다음 AS2는 AS1에게 “x는 존재하고 x로 가려면, AS2를 거쳐 AS3로 가야함”을 알린다. 이 과정에서 iBGP와 eBGP가 모두 사용된다. b-3. 최고의 경로 설정라우터가 BGP 연결을 통해 주소 접두부를 알릴 때 BGP 속성을 함께 보낸다. 접두부 + BGP 속성 &#x3D; 경로 (BGP에서는 경로를 이렇게 정의) AS-PATH : 알림 메시지가 통과하는 AS들의 리스트. 메시지의루프를감지하고 방지. NEXT-HOP : AS-PATH를 시작하는 라우터 인테페이스의 IP 주소 이 두가지가 주로 사용. AS1의 라우터들이 라우터 X로 가는 경로가 있다고 할 때, NEXT-HOP은 2a로 향하는 인터페이스 IP 주소이고, AS-PATH는 AS3,X 와 AS2,AS3,X 이렇게 두가지를 광고로 받는다. 여기서 경로 선택은 정책에 따라 달라진다. b-3-1. 뜨거운 감자 라우팅가능한 모든 경로 중, 경로의 시작점인 NEXT-HOP 경로 비용이 최소가 되는 경로가 선택된다. 2d에서 x로 데이터를 보내려 할 때, 2d는 AS1,AS3,X 경로와 AS3,X 경로 두가지를 받는다. AS2 내부 프로토콜을 통해 얻은 라우팅 정보로 가장 적은 비용의 게이트웨이인 2a를 선택한다. 2a로 가는 인터페이스 i를 결정한 이후, 포워딩 테이블에 (i,x) 경로를 추가한다. 위 예시에 따르면 2d는 AS1,AS3,X 경로로 데이터를 전송한다. b-3-2. 경로 선택 알고리즘AS-PATH와 NEXT-HOP 뿐만 아니라 지역 선호도를 BGP 속성에 추가해 경로를 선택하는 라우팅 알고리즘 이때 지역 선호도는 네트워크 관리자의 정책에 따른다. 가장 높은 지역 선호값을 가진 경로를 선택하는데, 여러 개라면 이중 최단 AS-PATH를 가진 경로로 선택한다. 이러고도 여러 경로가 존재하면, 뜨거운 감자 라우팅을 실행해 경로를 선택한다. b-4. 라우팅 정책 A,B,C &#x3D; 백본 제공자 네트워크 W,X,Y &#x3D; 액세스 ISP ISP액세스 네트워크로 들어오는 모든 트래픽은 그 네트워크를 목적지로 해야만 한다 ISP액세스 네트워크에서 나가는 트래픽은 그 네트워크 안에서 생성된 것이어야만한다. 이때 X는 두 백본 제공자 네트워크와 연결되어 있는 다중 홈 액세스 ISP이다. X는 과연 어떻게 B와 C간의 트래픽을 포워딩하는것을 방지할 수 있을까? BGP 경로의 알림 방식을 제어함으로 해결된다. X는 B와 C에게 자기 자신을 제외하고는 어떤 다른 목적지로도 경로가 없다고 알림으로써 방지할 수 있다. A, B, C는 당연히 자신이 해도 되지 않을 트래픽(B-C를 지나는 트래픽에 A는 자신의 망을 내놓지 않을 것이다.)을 부담하지 않을 것이다. 이를 위한 규칙은 ISP 백본 네트워크를 통해 흐르는 트래픽은 해당 고객 네트워크를 출발지로 하거나 목적지로 해야한다는 것이다. 이는 iBGP 정책을 활용해 구현될 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"8. 네트워크 계층 :제어 평면(라우팅 알고리즘)","slug":"cs/network/network8","date":"2021-11-17T11:24:54.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network8/","excerpt":"","text":"a. 라우팅 알고리즘라우팅이 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것. 여기서 좋은 경로란 최소 비용 경로를 의미.(비용은 금전적, 시간적, 혼잡 등을 폭넓게 의미) a-1. 라우팅 알고리즘 그래프 라우팅을 표현하는 데 쓰이는 도식. 일반적으로 G&#x3D;(N, E) 나타냄 N : 노드의 집합, E : 엣지의 집합. 노드는 패킷 포워딩 결정이 이뤄지는 지점인 라우터 엣지는 노드들을 연결하는 물리 링크 c(x, y) 는 노드 x, y간의 비용을 의미한다. 이 값이 무한대면 x와 y가 이웃하지 않는다는 것을 의미 에지 (x, y)가 E에 속하면 노드 y는 노드 x의 이웃 a-2. 중앙 집중형 라우팅 알고리즘(링크 상태 알고리즘)네트워크 전체에 대한 완전한 정보를 가지고 경로의 최소 비용을 계산 라우터들이 이웃에 대한 정보만 알고, 이를 네트워크 내부 라우터들에게 브로드캐스트해서 정보 전달 #브로드캐스트 vs 유니캐스트 유니캐스트는 한 곳에서 출발해서 한 목적지로 도착. 브로드캐스트는 한 곳에서 출발해서 여러 목적지로 도착. a-2-1. 다익스트라 알고리즘.링크 상태 알고리즘(모든 노드의 링크 cost를 알고 있음) D(v) : 목적지 v까지의 최소 비용 경로의 비용 p(v) : v까지 현재 최소 비용 경로에서 v의 직전 노드(v의 이웃) N’: 노드 집합. 어떤 v까지 최소비용 경로가 알려져있으면 v는 N’에 포함 12345678910111213Initialization : #초기화 N&#x27;=&#123;u&#125; #출발지 u for all nodes v: if v is a neighbor of u: then D(v) = c(u,v) else : D(v) = 무한대Loop find w not in N&#x27; such that D(w) is a minimum #N&#x27;에 포함되지 않은 노드 중 최소 경로인 w add w to N&#x27; update D(v) for each neighbor v of w and not in N&#x27;: D(v)=min(D(v), D(w)+c(w,v))until N&#x27; = N 이 방식은 각 노드에 대해서 최소 비용 경로상의 직전 노드를 알게됨. 직전 노드를 반복해서 구하다보면 최소 비용 경로를 구축가능. 이 방식에서 최악의 경우 얼마나 많은 계산이 필요한가? 첫번째 루프에서 출발지 제외 n개를 검사하여 하나를 골라 수행. 두번째 루프에서 n-1개를 검사해 하나를 골라 수행… 이런 식으로 총 n(n+1)&#x2F;2개를 검사해야 함. 즉 **O(n^2)**의 복잡성을 가짐 하지만 이 방식은 혼잡에 따른 경로 진동이 발생가능. 경로에 골고루 분배되는게 아닌 한쪽에 쏠려서 진행. 1. 초기에 D가 A로 1을 보내려 하고, B가 A로 1을 보내려 하고, C가 A로 e만큼의 트래픽을 보내려 할 때, 경로의 cost가 계산되었다. 2. 1의 결과를 토대로 최소 경로를 다시 찾으면, C-D-A 쪽 링크에 트래픽이 쏠리게 된다. 3. 2의 결과를 토대로 최소 경로를 다시 찾으면, C-B-A 쪽 링크에 트래픽이 쏠리게 된다. 4. 3의 결과를 토대로 최소 경로를 다시 찾으면, C-D-A 쪽 링크에 트래픽이 쏠리게 된다…..이후 무한 반복하게 되겠지? a-3. 분산 라우팅 알고리즘자신과 이웃한 링크에 대한 정보만 가지고 시작. 반복된 계산과 이웃 노드와의 정보 교환을 통해 점차적으로 목적지까지의 최소 비용 경로 계산 a-3-1. 벨만-포트 식x부터 y까지 최소 비용 경로 비용 dx(y) x의 모든 가능한 모든 이웃 v 일때 벨만-포트 식 : **dx(y)&#x3D; minv{c(x,v) + dv(y)}**이다. 이 식은 라우터들의 엔트리 설정에 도움이 된다. (어떤 지역의 라우터로 가려면 특정 라우터를 사용하는 것이 유리함을 알려줌) a-3-2. 거리 벡터 알고리즘(DV 알고리즘)Dx&#x3D;[Dx(y): y in N] 노드 x에서 N에 속한 모든 다른 노드 y까지의 비용 추정값의 벡터. DV알고리즘에 의해 노드 x는 다음 정보를 얻게 됨 1. 모든 이웃 노드 v의 비용 c(x,y) 2. 노드 x의 거리 벡터 Dx 3. 이웃 노드들의 거리 벡터. Dv 노드 x가 이웃 w의 거리 벡터를 받으면, 벨만-포트 식을 사용해 자신의 거리 벡터를 수정 비동기적으로 거리 벡터를 교환하다보면, 비용 추정값 Dx(y)가 실제 최소 비용 경로의 비용 dx(y)에 수렴! 1234567891011121314151617Initialization: for all destination y in N: Dx(y) = c(x,y) #y과 이웃이 아니면 c(x,y)는 무한대 for each neighbor w: Dw(y)= ? for all destination y in N for each neighbor w send distance vector Dx = to wLoop wait util I see a link cost change to some neighbor w or until i receive a distance vector from some neigbor w for each y in N: Dx(y)= minv&#123;c(x,v) + Dv(y)&#125;if Dx(y) changed for any destination y: send distance vector Dx to all neighbors forever 링크 비용 변경 시-&gt;자신의 거리 벡터 갱신-&gt;최소 비용거리 비용에 변화시 이웃에 거리 벡터 보냄 a-3-3 링크 비용이 증감에 따른 전파속도의 차이가 존재한다. 감소하는 경우 \\1. y가 가진 정보는 Dy(x)&#x3D;4, Dy(z)&#x3D;1, Dz(y)&#x3D;1, Dz(x)&#x3D;5이다. \\2. x-y의 링크가 1로 감소함을 y가 인지해 Dy(x)&#x3D;1 로 수정해 이를 이웃에게 알림 \\3. z는 변경된 벡터를 기반으로 Dz(x)를 5에서 2로 변경 \\4. y는 z로부터 변경된 벡터를 받지만 y의 최소비용은 변화하지 않음. 증가하는 경우 \\1. y가 가진 정보는 Dy(x)&#x3D;4, Dy(z)&#x3D;1, Dz(y)&#x3D;1, Dz(x)&#x3D;5이다. \\2. x-y의 링크가 60으로 증가함을 y가 인식했을 때, Dy(x)&#x3D;Dy(z)+Dz(x)&#x3D;1+5&#x3D;6이 된다.(여기서 Dz(x)가 5로 설정한건 당연히 잘못된 것이다. 하지만 y는 현 시점에 그를 알아차리지 못한다.) \\3. z는 변경된 벡터를 기반으로 Dz(x)&#x3D;min{c(z,x), Dz(y)+Dy(x)}를 5에서 7으로 바꾼다. \\4. y는 z로부터 변경된 벡터를 받아 Dy(x)를 6에서 8로 바꾼다.(z가 Dz(x)를 바꿨으니, Dy(x)&#x3D;Dy(z)+Dz(x)의 값이 변한 것) 다시 z는 y로부터 변경된 벡터를 받아… zyzyzyz…..의 cost가 50&#x3D;c(z,x)보다 커질 때까지 1~4를 반복한다.(44번 반복되어야 된다.)*(이렇게 테이블이 설정되면 y에서 x로 데이터를 보낼 경우 y는 z로 보내고 z는 y로 보내는 라우팅 루프가 발생한다.!!!!)* a-3-4. 포이즌 리버스(3개 이상의 노드가 참여하는 loop에는 적용 불가)라우팅 루프를 방지하는 방법. 만약 z가 y를 통해서 목적지 x로 가는 경로를 설정 시, z는 y에게 x까지의 거리가 무한대라고 알림. (상대방을 활용하여 특정 목적지로 가는 경우, 상대방이 나에게 특정 목적지에 대한 최소경로를 물으면 무한대라고 알려주기) \\1. y가 가진 정보는 Dy(x)&#x3D;4, Dy(z)&#x3D;1, Dz(y)&#x3D;1, Dz(x)&#x3D;5이다. \\2. x-y의 링크가 60으로 증가함을 y가 인식하여 Dy(x)를 구할 때, Dy(z)+Dz(x)&#x3D;1+5무한대 c(y,x)인 60이 Dy(x)가 된다. \\3. z는 변경된 벡터를 기반으로 Dz(x)&#x3D;min{c(z,x), Dz(y)+Dy(x)}를 50으로 바꾼다. \\4. y는 z로부터 변경된 벡터를 받아 Dy(x)를 60에서 c(y,z)+Dz(x)&#x3D;1+50&#x3D;51로 바꾼다. a-4. 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교 링크 상태 알고리즘 거리 벡터 라우팅 알고리즘 메시지 복잡성 n개의 노드, E개의 링크가 있을 때, O(nE)번 메시지를 전송 이웃 노드와 교환함. 여러 요인이 영향을 끼침 수렴 속도 O(nE)개의 메시지가 필요한 O(n^2) 알고리즘 라우팅 루프나 무한 계수 문제가 발생할 수 있음 견고성 경로 계산이 분산되어 진행, 나름 견고함 한 노드의 잘못된 계산이 전체로 확산 가능 a-5. 정적 라우팅 알고리즘, 동적 라우팅 알고리즘정적 : 고정된 기준에 따라 경로 계산(홉 갯수 등) 동적 : 변동하는 가치에 따라 경로 계산(혼잡도)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"7. 네트워크 계층(IP)","slug":"cs/network/network7","date":"2021-11-17T11:21:40.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/network7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/network7/","excerpt":"","text":"a. IPv4 데이터그램 헤더 버전 번호 : 4비트. 데이터그램의 ip 프로토콜 버전 명시. 헤더 길이 : ip 데이터그램에서 실제 페이로드가 시작되는 곳을 결정.(데체로 헤더는 20바이트) 서비스 타입 : IPv4의 서비스 타입을 구별(실시간 데이터그램인가 아닌가 등) 데이터그램 길이 : 헤더를 포함한 전체 데이터그램 길이 식별자 , 플래그, 단편화 오프셋 : 단편화에 사용됨. TTL : 라우터가 데이터그램을 처리할 때마다 감소. TTL 필드 값이 0이 되면 라우터가 데이터그램을 폐기 프로토콜 : 데이터 부분이 전달될 목적지의 전송 계층의 특정 프로토콜을 명시 헤더 체크섬 : 비트 오류를 탐지. 출발지와 목적지 IP 주소 옵션 데이터(페이로드) b. IPv4 데이터그램 단편화MTU : 링크 계층 프레임이 전달할 수 있는 최대 데이터 양 문제 : 송신지와 목적지 간의 경로를 따르는 각 링크가 다른 링크 계층 프로토콜을 사용할 수 있고 각 프로토콜이 서로 다른 MTU를 가질 수 있게 됨. 해결 : IP 데이터그램의 페이로드를 두 개 이상의 더 작은 IP 데이터그램으로 분할하고 각자 링크 계층 프레임으로 캡슐화. 이렇게 나눠진 데이터그램을 조각(fragment)라고 부른다. 그렇다면 이렇게 나눠진 조각들을 언제 재결합 하는가? &#x3D;&gt; end system에서 데이터그램 재결합! 목적지 호스트가 받은 데이터그램이 어떤 조각인지 파악하려면? &#x3D;&gt; 헤더에 식별자, 플래그, 단편화 오프셋을 활용! b-1 식별자, 플래그, 단편화 오프셋식별자는 단편화된 데이터그램끼리는 같은 값을 지닌다. 플래그는 목적지 호스트가 데이터그램의 마지각 조각을 수신했음을 알리기 위한 장치. 마지막 조각은 0을, 아닌 조각은 1을 가짐. 단편화 오프셋는 조각의 분실방지와 순서대로 재결합을 위한 장치. 원본 데이터그램 내에 조각의 시작 위치를 나타냄.(예시에서는 8비트이므로 원본 위치에서 8을 나눈 값을 입력.) c. IPv4 주소체계(서브넷) 인터페이스 &#x3D; 호스트와 물리적 링크 사이의 경계 십진 표기법 &#x3D; 32비트 ip주소를 각 바이트를 십진수로 표현하고 각 바이트를 점으로 구별. 모든 호스트와 라우터는 IP 데이터그램을 송수신할 수 있으므로 각 호스트와 라우터 인터페이스가 IP 주소를 갖도록 함. 서브넷 &#x3D; 인터페이들과 하나의 라우터 인터페이스로 연결된 네트워크 서브넷 마스크 &#x3D; 32비트 주소 중 서브넷 주소를 가르키는 부분(&#x2F;24일 경우 왼쪽 24비트가 서브넷 주소임) 네트워크 마스크 &#x3D; 255.255.255.0 (이 네트워크 마스크와 and 연산을 하게 되어 나타나게 되는 주소가 서브넷) 하지만 서브넷은 여러 호스트를 라우터 인터페이스에 연결하는 것만을 의미하진 않음. 각 서브넷은 호스트나 라우터에서 각 인터페이스를 분리하여 생긴 고립된 네트워크를 의미. d. 클래스 주소체계클래스 주소체계 : ip 주소의 네트워크 부분을 8, 16, 24비트로 제한. 해당 서브넷 주소를 갖는 서브넷을 A, B, C 클래스 네트워크로 분류. 하지만 서브넷의 주소넷 부족 현상. 호스트 id 낭비 발생. e. CIDRip가 십진수 형태의 a.b.c.d&#x2F;x로 표현. 이때 x는 ip주소의 네트워크 부분을 표시하며 프리픽스라 함. 따라서 x는 네트워크 id 32-x는 호스트 id를 담당. 라우터가 CIDR을 찾아갈때 포워드 테이블의 네트워크 마스크와 and 연산을 하여 목적지와 일치하는 prefix가 가장 길게 일치하는 것과 연결. e-1 CIDR 경로 집약여러 네트워크를 알리기 위해 하나의 네트워크 접두사를 사용하는 것. ex)32비트의 ip 주소를 할당하는 과정을 지켜보자. 먼저 8개의 조직을 가진 곳에 ip를 할당해야 된다고 가정하자. 이때 a라는 ISP가 큰 인터넷 연결을 위해 할당받는다. 현재 예시에서는 20비트를 할당받는다 하자. 그러면 우리는 자체 서브넷을 x.y.z.0&#x2F;20으로 표현 가능하다. 그렇다면 이 조직들이 어떤 ip를 할당 받았는지를 알려야한다. 근데 이를 굳이 일일히 굳이 이 서브넷의 조직이 8개임을 굳이 알릴 필요가 없개된다. 그냥 x.y.z.0&#x2F;20으로 표현해도 일맥상통한다. 즉 주소가 더 간편해졌다.(경로 집약되었다.) Fly-By-Night-ISP가 200.23.16.0&#x2F;20만 알려도 된다. 이때 만약 어떤 조직이 다른 ISP로 연결되야 되는 경우는 어떻게 될까? 다른 ISP는 이제 자신의 서브넷 뿐만 아니라 자신에게 옮겨온 조직의 ip도 알려야한다. f. 특별한 IP주소0.0.0.0 &#x3D; 새로운 호스트가 DHCP 서버에 주소 할당 요청할 때 255.255.255.255&#x3D; 해당 네트워크의 모든 호스트가 수신. 해당 서브넷에서는 사용. 외부로는 전달 x 127.x.y.z &#x3D; 네트워크 계층에서 하위로 전달하지 말고 다시 상위 계층으로 보내라는 의미. 사설아이피 : 해당 서브넷에서만 사용되는 아이피 directed broadcast adress : 라우터가 broadcast 해야할 때. 라우터의 네트워크 마지막 주소로 x.y.z.255 network address : 네트워크 블록에서 맨 처음 주소로. x.y.z.0 g. 동적 호스트 구성 프로토콜 (DHCP)자동으로 호스트에 IP 주소를 할당하는 기능. 각 서브넷은 DHCP 서버를 갖는다. DHCP 서버가 없는 서브넷은 DHCP 연결 에이전트(라우터)가 DHCP 서버 주소를 알려줘 DHCP를 이용할 수 있게한다. UDP 포트넘버 67을 사용 DHCP discover : DHCP 서버가 있나요? -DHCP 발견 메시지를 포함하는 IP 데이터그램을 서브넷에 연결된 모든 노드로 브로드캐스팅 -목적지 IP 주소를 255.255.255.255, 출발지 IP 주소를 0.0.0.0로 설정해서 브로드캐스팅 DHCP offer : 제가 DHCP서버입니다! 당신이 쓸 수 있는 IP주소를 드립니다. -DHCP 제공 메시지를 ip브로드캐스트 주소(255.255.255.255)로 서브넷에 모든 노드로 브로드캐스팅 -메시지에는 발견 메시지의 트랜잭션 ID, 클라이언트에 제공된 IP 주소, 네트워크 마스크, IP 주소 임대 기간을 포함 -여러 DHCP 서버가 ip를 제공할 경우 최적의 위치에 있는 서버를 선택 DHCP request : 좋아요 이 주소로 할게요! -받은 ip주소와 임대 기간을 확인차 전송 DHCP ack : 좋아요 이 주소 쓰시면 돼요! -요청된 파라미터를 확인차 전송 h. 네트워크 주소 변환 (NAT)ip 주소 할당량이 부족해지는 상황이 발생하면 어떻게 해결해야될까? NAT를 활용하여 사설 ip를 할당하는 것. NAT 가능한 라우터에 의해 public ip와 사설 ip가 나눠져 있는 걸 알 수 있다. 이때 NAT을 활용하는 라우터는 외부에서는 라우터가 아닌 하나의 IP 주소를 가지는 하나의 장비로 인식된다. 홈 네트워크의 여러 ip주소들은 DHCP로 할당받는다. 홈 네트워크 내부에 있는 장비들은 포트번호로 구별한다. 포트번호는 홈네트워크에서 전송할 때 NAT 변환 테이블로 할당한다. 하지만 외부의 클라가 NAT 안에 있는 서버에 접근할 수 없게 된다.(NAT 변환테이블은 NAT에서 데이터 보낼 때 할당되므로) \\1. NAT 변환 테이블에 필요한 포트를 미리 써놓기? &#x3D;&gt; 유지보수가 힘들어진다. \\2. NAT 변환 테이블에 장치를 자동으로 등록 \\3. relay방식. 중간에 전달 서버를 만들어 중간 서버가 NAT 내부 IP와 포트번호 전달. i. IPv6IPv4의 32비트 주소 공간이 빠르게 고갈되어 등장한 128비트 프로토콜 간소한 헤더를 사용해 더 빨리 처리하도록 했다. 트래픽 클래스 : 특정 응용 프로그램의 우선 순위 부여 흐름 라벨 : 데이터그램 흐름을 인식 다음 헤더 : 전송 프로토콜을 구분 TCP, UDP 홉 제한 : 라우터가 데이터그램을 전달할 때마다 1씩 감소. 0보다 작아지면 데이터그램을 버림 IPv4에서 IPv6으로 전환하는 터널링. IPv6 사이에 있는 IPv4 라우터들을 터널로 칭함. IPv6의 데이터그램을 IPv4 데이터그램의 필드에 넣는다. j. 소프트웨어 기반 네트워크 SDN각 패킷 스위치의 검색 추가 작업 테이블을 보여주며 테이블은 원격 컨트롤을 통해 계산, 설치 및 업데이트 각 라우터마다 가지고 있는 플로우 테이블을 통해 다양한 행동을 취한다. 헤더세트와 일치하는 패캣을 카운터 세트에 업데이트하고 플로우 테이블 요소와 일치하면 행동을 처리 match+action : 서로 다른 종류의 장비를 통일 라우터 match &#x3D; longest IP prefix + action &#x3D; forward out a link 스위치 match &#x3D; 목적지 MAC 주소 + action &#x3D; forward or flood 방화벽 match &#x3D; ip 주소와 TCP UDP 포트번호 + action &#x3D; 수용 혹은 거부 NAT match &#x3D; IP 주소와 포트 + action &#x3D; 주소와 포트를 재작성","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"네트워크 면접 대비 스터디","slug":"cs/network/networkinterview","date":"2021-11-17T11:01:24.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/11/17/cs/network/networkinterview/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/17/cs/network/networkinterview/","excerpt":"","text":"1주차 1주차TCP&#x2F;IP를 4계층으로 분석하라링크 계층OSI 7 계층에서 물리계층과 데이터링크 계층링크 계층은 기본적으로 프로토콜을 정의하고, 물리적 영역을 표준화.매체 접속 제어(MAC) 프로토콜이 링크상의 프레임 전송 규칙을 제어한다.(링크 접속 제어) 특히 RDT(신뢰적 전달)을 제공하는데, 전송 계층에도 RDT를 제공하지만 링크 계층에서도 제공하는 이유는,네트워크 계층인 IP에서 best effort로 인해 데이터 손실이 일어날 수 있기 때문. ARP (ip주소로 mac주소를 알아오는 거) -&gt; 홉단위로 ARP 인터넷 계층(네트워크 계층) (IP)IP는 경로를 알려주는 역할을 한다. IP는 비연결 지향이고 신뢰할 수 없는 프로토콜.그래서 링크 계층이나 전송 계층에서 RDT 를 확보해야 한다. 8비트 씩 4개로 32비트 주소체계를 가짐.255.255.255.255 이런 식으로 십진수로 표기함. CIDR 주소체계x.y.z.0&#x2F;a 이렇게 뒤에 prefix를 표기하는데, 앞에서 프리픽스까지는 네트워크 id를 의미함.32-a는 호스트 id가 됨. NATip 주소가 부족해 지는 상황에서 로컬 네트워크는 사설 ip를 할당하는 것.외부에서는 포트 번호를 활용하여 각 ip에 접근 가능하다. IP, ARP, RARP, ICMP, OSPF※ ICMP : 패킷정보 실패시 ERROR를 알리거나 해결 가능한 힌트를 제공하며, 주로 ping, traceroute를 할때 사용됩니다. 전송 계층(TCP&#x2F;UDP)데이터를 실제 송수신하는 역할. 네트워크 계층은 어떤 경로로 메시지를 전달하지를 결정전송 계층은 도착한 메시지를 어떻게 처리 할 것인지 결정(엔드시스템에 존재.) UDP는 비교적 간단하지만, 비연결 지향이고, 신뢰성없고, 순서가 뒤죽박죽으로 전달된다.핸드쉐이킹도 하지 않고, 상대편이 어떤 상태인지 관심없다.비트 손상이 일어날 수 있으나, 딜레이는 비교적 적은 편.(비디오, 오디오 서비스에서 활용.) TCP는 신뢰성있고 순서대로 전송을 지원하지만, 비교적 복잡한 과정을 거침(그래서 IP와 함께 사용.)한 연결에 한 리시버와 한 센더가 참여하고, 양방향 데이터 흐름을 가진다.연결 지향이라 핸드쉐이킹을 가지고(3way) 센더와 리시버의 상태 정보를 기억한다.센드 버퍼와 리시브 버퍼가 있어서 처리 속도가 전송 속도보다 느릴 경우 속도 조절(흐름제어). TCP 혼잡제어 방식 : AIMD(최소단위로 시작해서 하나씩 늘려서 보냄. 혼잡 발생시 기존 전송량의 절반을 보냄)와 slow start(최소단위부터 시작해서 2^n씩 늘려서 보냄. 혼잡 발생시 AIMD방식으로 제어) 소켓은 두 프로그램(프로세스)이 통신하기 위해 양 쪽에 생성되는 링크 단자(인터페이스)소켓은 어플리케이션 계층과 전송 계층 사이의 인터페이스.UDP, TCP 여부에 따라 소켓에 필요한 정보가 달라진다. 소켓 API 흐름클라이언트 : 소켓 열기(socket) -&gt; 서버에 연결 요청(connect) -&gt; 데이터 송수신(send, recv) -&gt; 연결 종료(close)서버 : 소켓 열기(socket) -&gt; IP주소와 포트 번호를 소켓에 결합(bind) -&gt; 연결 요청 대기(listen) -&gt; 요청이 오면 수락한 후 소켓 연결(accept) -&gt; 데이터 송수신(send, recv) -&gt; 연결 종료(close) 어플리케이션 계층서버와 클라이언트를 구현하는 계층(?)이 과정에서 데이터 송수신의 규칙이 만들어짐.(네트워크서비스, 메일서비스, 웹서비스 등 표준적인 인터페이스)OSI 7계층에서 세션, 프레젠테이션, 애플리케이션 계층에 해당HTTP, FTP, Telnet, DNS, SMTP 서버는 항상 연결되어 있고 고정적인 IP 주소를 가짐. 클라이언트의 요청에 대한 응답을 하는 곳.클라이언트는 간헐적으로 연결하고, 동적인 IP 주소를 가진다.(이동하는 경우), 통신의 시작점. TCP의 3(4) way handshaking에 대해 설명하라TCP 연결에서 데이터를 주고받기 이전에 서로가 준비 됐음을 확인하는 절차. SYN : 연결요청 플래그FIN : 연결중단 플래그ACK : 요청확인 플래그Seq : 시퀀스 통신을 시작할 때(3 way handshaking) 클라이언트가 자신의 seq를 x로 설정하고, SYN &#x3D; 1, Seq&#x3D;x를 헤더에 담아 서버에 보낸다.(저는 x부터 시작할 거고요, 연결을 원합니다.) LISTEN중이던 서버는 요청을 받으면, 자신의 seq를 y로 정하고,SYN &#x3D;1 , Seq &#x3D; y, ACK &#x3D; 1, ACKnum &#x3D; x+1을 헤더에 담아 보낸다.(잘 받았습니다. 저는 y부터 시작할 거고요, 저도 연결을 원합니다. ) 클라이언트는 서버의 응답을 듣고,ACK &#x3D; 1, ACKnum &#x3D; y+1를 헤더에 담아 서버의 응답을 확인했다고 전한다.(확인했습니다.) 통신을 끝낼 때(4 way handshaking) 클라이언트가 소켓을 닫고, FIN &#x3D; 1, seq &#x3D; x를 담아 전달 (제 x번째 요청은 통신을 끝내는 거에요.) 이제 클라이언트가 더는 데이터를 보낼 순 없지만 받을 순 있다.그리고 서버는 아직 연결을 종료하지 않았다. 서버는 ACK &#x3D;1, ACKnum &#x3D; x+1을 담아 보낸다.(서버는 여전히 데이터를 보낼 수 있다.)(일단 알겠습니다. 제가 보내야할 일을 끝내면 저도 통신 끝낼게요.) 클라이언트는 서버의 ACK를 통해 자신의 종료 요청을 전달된 것을 알게되고,이제 서버가 남은 일을 모두 끝낼 때까지 기다린다. 서버는 데이터를 모두 보내고 나면, FIN &#x3D; 1, seq &#x3D; y를 보낸다.(저도 이제 남은 일 다 끝났습니다. 이제 연결을 끝내죠.)이제 서버도 데이터를 보낼 수 없게 된다. 클라이언트는 서버의 종료 요청을 듣고, ACK &#x3D;1 , ACKnum&#x3D;y+1을 보낸다.(알겠습니다. 연결을 종료합니다.) 이때 중요한건, 자신의 ACK요청이 잘 전달됐는지를 확인하기 위해서 잠시동안 대기한다.ACK 요청이 전달되지 않으면 재전송해야 될 수 있기 때문이다.대기 후 연결을 종료한다. 난수인 seq를 보내는 이유 서버 측에서 패킷의 seq를 보고 패킷을 구분.난수로 보내야 패킷을 혼동없이 구분할 수 있음.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"스프링 프레임워크의 기본 개념 정리 (POJO, Ioc/DI, AOP)","slug":"spring/spring1","date":"2021-11-15T02:44:25.000Z","updated":"2023-01-25T09:49:28.003Z","comments":true,"path":"2021/11/15/spring/spring1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/15/spring/spring1/","excerpt":"","text":"스프링 프레임워크의 기본 개념 정리 (POJO, Ioc&#x2F;DI, AOP)POJO포조는 plane old java object란 의미인데, 필자도 처음에 이게 뭔 소린지 잘 이해가 안갔다.쉽게 말하면, 기본 자바의 기능 외에 다른 클래스를 사용하지 말자는 뜻이다.클래스나 메소드 시그니처를 개발자가 필요한 대로 만들어서 사용하자는 의미다. 서블릿으로 자바 웹 애플리케이션을 만들면, 서블릿의 구조를 따라서 만들어야 한다.예를 들면 이런 식이다. POJO가 아닌 경우123456789101112131415161718public class DeleteBoardServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String seq = request.getParameter(&quot;seq&quot;); BoardVO vo = new BoardVO(); vo.setSeq(Integer.parseInt(seq)); BoardDAO boardDAO = new BoardDAO(); boardDAO.deleteBoard(vo); RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;getBoardList.do&quot;); dispatcher.forward(request, response); &#125;&#125; 자세히 보면 HttpServlet이라는 클래스를 상속하고,service 메소드를 오버라이딩해서 그 안에 비즈니스 로직을 작성하고 있다. 이때 비즈니스 로직에는 response 객체가 사용되지 않는다.(포워딩할 때만 사용된다.)그럼에도 불구하고 service 메소드의 고정적인 구조로 인해 response를 인수로 가져와야 한다. POJO는 이런 불필요한 구조를 탈피해서,개발자가 본인에게 필요한 비즈니스 로직을 구현할 때 필요한 만큼의 기본 자바 객체만 사용하도록 한다. POJO를 지키면 이런 식이 될 것이다. POJO인 경우12345678910111213@Controllerpublic class Cont&#123; @RequestMapping(&quot;/hello/&#123;seq&#125;&quot;) public String helloController(@PathVariable int seq)&#123; BoardVO vo = new BoardVO(); vo.setSeq(seq); BoardDAO boardDAO = new BoardDAO(); boardDAO.deleteBoard(vo); return &quot;getBoardList.do&quot;; &#125;&#125; IoC&#x2F;DI 제어의 역전&#x2F;의존성 주입IoC 제어의 역전IoC는 프로그램의 흐름을 직접 제어하는 것이 아니라 외부요소가 제어한다는 의미이다.여기서 외부 요소는 일반적으로 프레임워크나 컨테이너를 의미한다. 프로그램의 흐름을 직접 제어한다는 의미는 특정 객체가 협력할 대상을 직접 선택해서 생성하여 사용한다는 의미이다.이보다는 외부에서 결정한 객체를 통해 흐름을 실행한다면 흐름을 바꾸고 싶을 때마다 외부에서 적절한 객체를 사용하도록 설계하면 된다. 123456789101112131415161718192021@Controllerpublic class UserController &#123; @Autowired private UserService userService; @Autowired private AuthenticationManager authenticationManager; @GetMapping(&quot;/auth/joinForm&quot;) public String joinForm()&#123; return &quot;/user/joinForm&quot;; &#125; @GetMapping(&quot;/auth/loginForm&quot;) public String loginForm()&#123; return &quot;/user/loginForm&quot;; &#125; .... &#125; 스프링으로 작성된 컨트롤러의 일부 예시다.보면 @Autowired라는 어노테이션을 볼 수 있다. 이는 해당 변수에 스프링 컨테이너가 관리하고 있는 객체 중 적절한 것을 할당해달라는 의미이다.(좀 어려운 말로는 의존성을 주입한다고도 말한다.) 개발자가 일일히 객체를 싱글톤으로 만들어서 그 싱글톤 객체를 직접 불러와서 변수에 할당할 필요 없다는 의미다.스프링 컨테이너가 알아서 객체를 싱글톤으로 메모리에 로딩시켜놓고, 개발자가 요청하면 스프링 컨테이너가 알아서 할당해줄 것이다. DI 의존성 주입 일단 이 어려운 용어를 이해하기 전에 의존성이 뭔지 좀 알아보자. 검색을 해보면 “A가 동작하기 위해서 B가 반드시 필요한 경우, A는 B에 의존한다.” 라는 의미인데,우리가 바로 위에 썼던 예시를 보면, UserService, AuthenticalManager라는 객체 두 개가 UserController 객체에 사용된다. 즉 UserController 객체는 이 두 객체에 의존한다는 의미다. 보통 어플리케이션은 여러 컴포넌트를 조합해서 요청을 처리한다. 이때 특정 컴포넌트가 다른 컴포넌트를 의존해서 사용해야 되는 상황이 반드시 생긴다.의존하는 상황에서 사용하는 쪽에서 직접 사용하려는 객체를 사용하려면, 직접 new해서 객체를 만들거나, 메모리 상에 있는 해당 객체를 직접 가져와야 할 텐데, 스프링에서는 스프링 컨테이너가 메모리 상에 있는 객체를 가져와서,해당 레퍼런스 변수에 할당해, 의존 관계를 만들어 준다는 의미다. 즉, 클래스 외부에서 적절한 객체를 찾아와서 해당 클래스와 의존성을 갖도록 주입한다는 의미다!! 왜 외부에서 주입해주는 게 내부에서 직접 생성하는 것보다 나은가? 내부에서 직접 객체를 생성하면 해당 객체와 강하게 결합된다. 즉 생성한 객체를 다른 객체로 변경하려면 생성한 코드를 바꿔줘야 한다.반면 인터페이스에 의존하도록 하고 구현체를 외부에서 주입하는 방식으로 설계하면 주입하는 코드만 변경해주면 된다. 반면 내부 코드는 변경되지 않고, 확장성도 더 좋다. 스프링에서 의존성 주입하는 여러가지 방법 스프링에서는 주입하려는 컴포넌트를 개발자가 직접 생성해서 주입하지 않는다. 스프링 컨테이너가 정해진 클래스를 객체로 만들어서 필요할 때 주입해준다.특히 어플리케이션이 복잡해질 수록 조립해야 할 컴포넌트도 복잡해지는 데, 이런 컴포넌트 조립도 스프링에서는 스프링 컨테이너가 해줘서 간편하다. 어노테이션 활용하기 @Autowired 레퍼런스 변수 위에 @Autowired 어노테이션을 붙이면 알아서 의존성이 주입된다.다만, 주입을 하기 전에 컴포넌트 스캔을 해야 한다. 12&lt;!-- 해당 패키지 하위에 있는 모든 어노테이션을 검사 --&gt;&lt;context:component-scan base-package=&quot;com.fastcampus.biz&quot;/&gt; xml 태그 활용하기 다음과 같이 xml에 빈등록 되어 있다고 하자.(web.xml이나 컨텍스트 xml) 123&lt;bean id=&quot;indexService&quot; class=&quot;com.baeldung.di.spring.IndexService&quot; /&gt; IndexService라는 클래스를 스프링이 관리하는 객체(빈)로 등록했다.이제 이 객체를 IndexApp이라는 클래스에서 사용하고자 한다고 가정해보자. a. 생성자로 의존성 주입하기 12345&lt;bean id=&quot;indexApp&quot; class=&quot;com.baeldung.di.spring.IndexApp&quot;&gt; &lt;constructor-arg ref=&quot;indexService&quot; /&gt;&lt;/bean&gt; 생성자로 레퍼런스 변수를 초기화 할 수 있다.IndexApp이 빈으로 등록 될 때, 설정한 대로 객체를 주입시켜서 객체 생성될 것이다. b. 프로퍼티로 의존성 주입하기 12345&lt;bean id=&quot;indexApp&quot; class=&quot;com.baeldung.di.spring.IndexApp&quot; &gt; &lt;property name=&quot;service&quot; ref=&quot;indexService&quot; /&gt;&lt;/bean&gt; 프로퍼티 태그로 해당 레퍼런스 변수에 의존성 주입할 수 있다.다만 setter메소드가 정의되어 있어야 한다. AOP 관점 지향 프로그래밍AOP를 이해하기 위해서는 일단 관점(Aspect)를 이해해야 한다. 요청을 처리할 때, 핵심 비즈니스 로직외에도 필요한 여러가지 공통된 처리가 있다.사용자가 권한이 있는지… 요청이 제대로 된 경우 사후처리 등… 이제 비즈니스 로직에 해당하는 메서드와 이런 공통된 처리들을 따로 분리해서 관리하자는게 시작이다.(관심 분리)그래야 개발자가 비즈니스 로직에 집중할 수 있고, 중복된 코드 작성도 줄어들 것이다. 개발자가 호출한 모든 핵심 비즈니스 로직 메서드를 조인 포인트 라고 한다. 조인 포인트 중 개발자가 필터링한 비즈니스 로직 메서드를 포인트 컷이라고 한다. 일괄적으로 적용해줘야하는 공통 처리는 어드바이스라고 한다.(어드바이스는 적용시기나 종류에 따라 다섯가지로 나뉜다.) 모듈들의 공통 처리를 담당하는 어드바이스 와 특정 모듈의 핵심 비즈니스 로직인 포인트컷 을 결합(위빙)한 것을 Aspect 라고 한다. AOP 구현 하기AOP 구현도 어노테이션 방법과 xml 태그 방법 두가지로 구현 가능하다. xml 태그로 AOP 구현 일단 어드바이스가 구현된 클래스를 먼저 구현하자(어라운드어드바이스를 예시이다.) 12345678910111213141516public class AroundAdvice &#123; public Object aroundLog(ProceedingJoinPoint jp) throws Throwable &#123; // JoinPoint를 상속한 ProceedingJoinPoint를 이용하면 클라이언트가 호출한 비즈니스 메소드 정보를 알 수 있다. String method = jp.getSignature().getName(); Object returnObj = null; StopWatch watch = new StopWatch(); watch.start(); // 실제 클라이언트가 호출한 비즈니스 메소드가 실행되는 시점 returnObj = jp.proceed(); watch.stop(); System.out.println(method + &quot;() 메소드 수행에 소요된 시간 : &quot; + watch.getTotalTimeSeconds() + &quot;(초)&quot;); return returnObj; &#125;&#125; 이때 주목할 점은 ProceedingJoinPoint jp를 매개변수로 받는다는 점이다.(이는 Around 어드바이스만의 특징이다. 다른 종류의 어드바이스는 JointPoint 객체를 매개변수로 받는다.) 그리고 어드바이스를 빈 등록한다. 123&lt;!-- 횡단관심(어드바이스)에 해당하는 클래스를 bean 등록한다 --&gt;&lt;bean id=&quot;AroundAdvice&quot; class=&quot;com.fastcampus.biz.common.BeforeAdvice&quot;/&gt;&lt;bean id=&quot;afterThrowing&quot; class=&quot;com.fastcampus.biz.common.AfterThrowingAdvice&quot;&gt;&lt;/bean&gt; 그리고 AOP 설정을 해준다. 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id=&quot;allPointcut&quot; expression=&quot;execution(* com.fastcampus.biz..*Impl.*(..))&quot;/&gt; &lt;aop:aspect ref=&quot;beforeAfter&quot;&gt; &lt;aop:before pointcut-ref=&quot;allPointcut&quot; method=&quot;beforeLog&quot;/&gt; &lt;aop:after-returning pointcut-ref=&quot;getPointcut&quot; method=&quot;afterLog&quot; returning=&quot;returnObj&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;afterThrowing&quot;&gt; &lt;aop:after-throwing pointcut-ref=&quot;allPointcut&quot; method=&quot;exceptionLog&quot; throwing=&quot;exceptionObj&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;around&quot;&gt; &lt;aop:around pointcut-ref=&quot;allPointcut&quot; method=&quot;aroundLog&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 이때 주목할 점은, 포인트컷을 정의하고, 애스펙트를 어드바이스와 포인트컷을 연결해준다. 어노테이션으로 AOP 구현하기 일단 어노테이션으로 하려면 다음 태그를 추가해야한다. 1&lt;aop:aspectj-autoproxy/&gt; 이제 포인트컷을 설정해보자(@Aspect를 붙여주자.)어노테이션 기반에서는 클래스를 만들어서 포인트컷을 설정할 수 있다. 1234567891011121314@Aspectpublic class BoardPointcut &#123; @Pointcut(&quot;execution(* com.fastcampus.biz..*Impl.*(..))&quot;) public void allPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz..*Impl.get*(..))&quot;) public void getPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz.board.*Impl.*(..))&quot;) public void boardPointcut() &#123;&#125; @Pointcut(&quot;execution(* com.fastcampus.biz.user.*Impl.*(..))&quot;) public void userPointcut() &#123;&#125;&#125; 그러면 어드바이스를 다음과 같이 작성할 수 있다.@Service로 빈등록을 처리하고, @Aspect로 애스팩트 등록을 할 수 있다.자세히보면, 어노테이션으로 어드바이스 종류를 선언하고 포인트컷을 매개변수로 넣어준다. 123456789101112131415161718192021@Service@Aspect // Aspect = Pointcut(핵심 관심) + Advice(횡단 관심)public class AroundAdvice &#123; @Around(&quot;BoardPointcut.allPointcut()&quot;) public Object aroundLog(ProceedingJoinPoint jp) throws Throwable &#123; // JoinPoint를 상속한 ProceedingJoinPoint를 이용하면 클라이언트가 호출한 비즈니스 메소드 정보를 알 수 있다. String method = jp.getSignature().getName(); Object returnObj = null; StopWatch watch = new StopWatch(); watch.start(); // 실제 클라이언트가 호출한 비즈니스 메소드가 실행되는 시점 returnObj = jp.proceed(); watch.stop(); System.out.println(method + &quot;() 메소드 수행에 소요된 시간 : &quot; + watch.getTotalTimeSeconds() + &quot;(초)&quot;); return returnObj; &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"}]},{"title":"8. 상태 패턴","slug":"java/java-basic/design-pattern/dp8","date":"2021-11-13T06:34:25.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/11/13/java/java-basic/design-pattern/dp8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/13/java/java-basic/design-pattern/dp8/","excerpt":"","text":"상태 패턴객체의 특정 상태에 따라 객체의 행동이 달라지는 상황에서,객체의 상태를 본인이 체크해서 행동을 달리하는 것이 아니라,상태를 객체화해서 상태가 행동을 책임지도록 위임하는 패턴. 특정 상태를 캡슐화하는 인터페이스를 선언하고,원래 객체에서 해당 인터페이스를 구성하도록 설계한다. 상태 인터페이스를 구현한 여러 상태 객체들을 만들어서 활용한다. 활용 예시자동차에는 여러 주행 모드가 있다.우리가 설계하는 자동차 객체는 일반모드와 터보모드가 있다. 123456//자동차의 역할을 캡슐화하는 자동차 인터페이스public interface Car &#123; void drive(); void stop(); void setState(BasicCarState state);&#125; 이제 자동차 인터페이스를 구현해보자.이때 중요한건 자동차의 상태를 구성하는 방식으로 구현체를 설계해야 한다. 12345678910111213141516171819202122//자동차 인터페이스를 구현한 기본자동차 구현체public class BasicCar implements Car&#123; private BasicCarState state; public BasicCar()&#123; state = NormalState.getInstance(); &#125; @Override public void drive() &#123; state.driveState(this); &#125; @Override public void stop() &#123; state.stopState(this); &#125; @Override public void setState(BasicCarState state) &#123; this.state = state; &#125;&#125; 이제 자동차의 모드(상태)를 객체로 만들어보자.일단 자동차의 모드와 관련된 행동을 캡슐화하자. 12345//기본 자동차의 상태를 캡슐화하는 인터페이스public interface BasicCarState &#123; void driveState(Car car); void stopState(Car car);&#125; 캡슐화한 인터페이스를 구현해서 모드들을 만들어보자.필자는 상태 객체를 싱글톤으로 처리했다. 12345678910111213141516171819202122public class NormalState implements BasicCarState&#123; private static NormalState normalState; private NormalState()&#123;&#125;; public static BasicCarState getInstance()&#123; if(normalState==null)&#123; normalState = new NormalState(); &#125; return normalState; &#125; @Override public void driveState(Car car) &#123; System.out.println(&quot;Start Normal process...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Normal process...&quot;); &#125;&#125; 123456789101112131415161718192021public class TurboState implements BasicCarState&#123; private static TurboState turboState; private TurboState()&#123;&#125; public static BasicCarState getInstance()&#123; if(turboState==null)&#123; turboState= new TurboState(); &#125; return turboState; &#125; @Override public void driveState(Car car) &#123; System.out.println(&quot;Start Turbo process...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Turbo process...&quot;); &#125;&#125; 이제 우리가 설계한 자동차 객체를 실험해보자. 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Car avante = new BasicCar(); avante.drive(); avante.stop(); avante.setState(TurboState.getInstance()); avante.drive(); avante.stop(); &#125;&#125;/*Start Normal process...Stop Normal process...Start Turbo process...Stop Turbo process...*/ avante의 상태를 바꾸니 아반떼의 행동이 달라졌다. 상태 패턴과 전략 패턴의 차이점? 상태 패턴은 객체의 상태를 캡슐화해서 객체로 관리하는 패턴이다.이 상태는 원래 객체의 다른 행동에 영항을 미친다. 전략 패턴은 객체의 특정 행동(특히 행동을 수행하는 방식이 달리질 가능성이 많은 행동)을독립적으로 구성하는 패턴이다. 사실 실사용에서는 매우 비슷하게 보이지만,상태는 원래 객체의 다른 행동에도 큰 영향을 미치지만,전략은 변하기 쉬운 행동을 독립적으로 구성하는 것이라고 파악하자. 더 나아가기이번엔 활용 예시를 더 발전시켜보자. 자동차 객체에 연료 필드를 추가해 연료에 따라 자동차의 주행모드를 동적으로 변환시켜서 운행시켜보자. 먼저 자동차 추상 클래스를 만들어보자. 12345678910public abstract class Car &#123; public int fuel; public CarState carState; public abstract void drive(); public void setCarState(CarState carState)&#123; this.carState = carState; &#125;&#125; 자동차에 남은 연료를 표시하는 fuel필드가 추가됐고, setter 메서드를 구현해놨다. 이제 자동차의 다양한 주행 모드를 추상화하는 인터페이스를 만들어보자. 1234public interface CarState &#123; void driveState(Car car); void stopState(Car car);&#125; 주행모드로 주행하고 주행모드를 멈추는 역할 두가지를 수행한다.이제 다양한 주행모드를 구현해서 만들어보자. 1234567891011121314public class NormalState implements CarState&#123; final int fuelPerHour = 10; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive NormalState...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop NormalState...&quot;); &#125;&#125; 1234567891011121314public class TurboState implements CarState&#123; final int fuelPerHour = 40; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive Turbo state...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Turbo state...&quot;); &#125;&#125; 1234567891011121314public class EcoState implements CarState &#123; final int fuelPerHour = 3; @Override public void driveState(Car car) &#123; car.fuel-=fuelPerHour; System.out.println(&quot;Drive EcoState...&quot;); &#125; @Override public void stopState(Car car) &#123; System.out.println(&quot;Stop Eco State...&quot;); &#125;&#125; 이 상태는 연료소비량을 나타내는 fuelPerHour를 상수로 가지고 있고,각 메서드를 구현했다. 이제 자동차 추상 클래스를 상속받은 클래스를 만들어서,drive 메소드를 구현해보자. 우리는 자동차 객체에 남은 연료량에 따라 동적으로 주행모드를 변화시키고 싶다. 1234567891011121314151617181920public class BasicCar extends Car&#123; public BasicCar()&#123; this.fuel = 100; this.carState = new NormalState(); &#125; @Override public void drive() &#123; if(fuel&lt;15&amp;&amp; ! (carState instanceof EcoState))&#123; carState.stopState(this); this.setCarState(new EcoState()); &#125; else if(fuel&gt;15 &amp;&amp; fuel&lt;80&amp;&amp; ! (carState instanceof NormalState))&#123; carState.stopState(this); this.setCarState(new NormalState()); &#125; else if(fuel &gt; 80 &amp;&amp;! (carState instanceof TurboState))&#123; carState.stopState(this); this.setCarState(new TurboState()); &#125; carState.driveState(this); &#125;&#125; 이제 마지막으로 테스트를 해보자. 123456789public class Test &#123; public static void main(String[] args) &#123; Car avante = new BasicCar(); avante.setCarState(new TurboState()); while(avante.fuel&gt;0)&#123; avante.drive(); &#125; &#125;&#125; 12345678910111213//실행결과Drive Turbo state...Stop Turbo state...Drive NormalState...Drive NormalState...Drive NormalState...Drive NormalState...Drive NormalState...Stop NormalState...Drive EcoState...Drive EcoState...Drive EcoState...Drive EcoState... 실행결과를 보면 자연스럽게 자동차 주행 모드를 변화시키는 것을 알 수 있다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"인터페이스와 추상클래스의 차이(feat. 데코레이터 패턴)","slug":"java/java-basic/javainterface","date":"2021-11-07T10:02:30.000Z","updated":"2022-02-20T23:39:04.656Z","comments":true,"path":"2021/11/07/java/java-basic/javainterface/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/07/java/java-basic/javainterface/","excerpt":"","text":"인터페이스와 추상 클래스의 차이를 잘 느낄 수 있는 예제를 가져왔다. 데코레이터를 인터페이스로 구현해본다고 하자. 인터페이스로 데코레이터를 구현한다면?패션 모델에게 각종 의류를 데코레이터로 적용하는 예시를 인터페이스로 구현해보자. 12345//모델의 역할은 런웨이를 하는 것.public interface Model &#123; void runway();&#125; 1234567//모델인터페이스를 구현한 한국모델 구현체(클래스)public class KoreanModel implements Model&#123; @Override public void runway() &#123; System.out.println(&quot;한국 모델이 런웨이를 시작합니다.&quot;); &#125;&#125; 모델과 구현체를 만들었다. 이제 데코레이터 인터페이스를 도입해보자.데코레이터는 모델을 포함하고 있으며 모델을 대신할 것이다. 12345//의류데코레이터는 모델이 옷을 입도록 한다.public interface ClotheDecorator extends Model&#123; void wearClothes();&#125; 12345678910111213141516171819//의류 데코레이터를 구현한 의류 클래스public class Shirts implements ClotheDecorator&#123; Model model; public Shirts(Model model)&#123; this.model = model; &#125; //우리가 원하는 추가 기능이다. @Override public void wearClothes() &#123; System.out.println(&quot;셔츠를 입었습니다!&quot;); &#125; //모델을 대신해야 하기 때문에 이 메소드가 구현되어야 한다. @Override public void runway() &#123; model.runway(); wearClothes(); &#125;&#125; 1234567891011121314151617//이번엔 바지를 구현해보자! 전체적인 방식은 비슷하다.public class Pants implements ClotheDecorator&#123; Model model; public Pants(Model model)&#123; this.model = model; &#125; @Override public void wearClothes() &#123; System.out.println(&quot;바지를 입었습니다!!&quot;); &#125; @Override public void runway() &#123; model.runway(); wearClothes(); &#125;&#125; 123456public class Test &#123; public static void main(String[] args) &#123; Model yang = new Pants(new Shirts(new KoreanModel())); yang.runway(); &#125;&#125; 근데 자세히 보면 Shirts와 Pants에 중복된 부분이 있다…! 1234Model model;public Pants(Model model)&#123; this.model = model;&#125; 이 부분이 중복된다. Model model을 인터페이스에 넣으려면 반드시 상수가 되어버리니 우리가 원래 사용하려던 방식과 안맞는다…그리고 생성자를 인터페이스에 추가해줄 수도 없다…. 추상클래스로 중복된 부분을 제거해보자.데코레이터 인터페이스를 데코레이터 추상 클래스로 바꿔보자. 1234567891011121314public abstract class ClothDecorator implements Model &#123; Model model; public ClothDecorator(Model model)&#123; this.model = model; &#125; public abstract void wearCloth(); @Override public void runway()&#123; model.runway(); wearCloth(); &#125;&#125; 이 추상클래스를 자세히보면, 두가지 역할을 한다. 멤버 변수 모델을 생성자로 초기화 runway메소드의 로직을 구현 그래서 설계가 뻣뻣해지는 경향이 있다. 하지만 추상 클래스로 데코레이터를 작성하면 구현 클래스들이 좀 더 간략해지긴 한다. 123456public class Hat extends ClothDecorator&#123; public Hat(Model model) &#123; super(model); &#125; @Override public void wearCloth() &#123; System.out.println(&quot;모자를 썼습니다!!!&quot;); &#125;&#125; 123456public class Shoes extends ClothDecorator&#123; public Shoes(Model model) &#123; super(model); &#125; @Override public void wearCloth() &#123; System.out.println(&quot;신발을 신었습니다!!!&quot;); &#125;&#125; 멤버 변수 선언과 로직 구현을 추상클래스가 해주니 구현 클래스가 간략해졌다. 하지만 추상 클래스가 너무 많은 역할을 하는 건 아닌지 생각해봐야 한다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"405 Not Allowed 해결하기","slug":"cs/web/http405error","date":"2021-11-01T05:25:13.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/11/01/cs/web/http405error/","link":"","permalink":"https://yangdongjue5510.github.io/2021/11/01/cs/web/http405error/","excerpt":"","text":"405 Not AllowedHttp status code 중 405는 특정 Http method가 혀용되지 않는다는 의미다. 문제 배경서블릿 프로젝트에서 입력 페이지에서 데이터를 입력받아 post로 데이터를 넘겨주고해당 데이터가 유효하면 다른 url로 리다이렉트 하고,그렇지 않으면 다시 입력 페이지에서 데이터를 입력받도록 구성했는데 405 문제가 생겼다. 문제가 발생하는 이유와 증상들1. 데이터 유효에 따라 다르게 발생일단 유효한 데이터를 입력해서 post 요청하면 문제가 발생하지 않는데,유효하지 않은 데이터를 입력하는 경우 이런 문제가 발생했다. 2. 무한 반복되는 로그post대신 get으로 로직을 짜도 문제가 발생했다. 유효하지 않은 데이터를 입력받으면 리다이렉션이 너무 많이 일어나는 에러가 발생했다. 로그를 살펴보니 끝없이 데이터의 유효성 검사를 하고 있었다.분명, 다시 데이터를 입력받아야 정상 로직인데, 입력을 받지도 않고 유효성 검사를 무한 반복하고 있었다. 3. 같은 URL로 요청 두 개가 전달.또한 브라우저에서 개발자 모드로 살펴보니, 내가 의도한 url로 post 요청과 get 요청 두개가 요청되고 있었다.post는 내가 의도한 게 맞는데, get은 내가 의도하지 않은 요청이다. 문제 원인데이터의 유효값을 체크하여 리다이렉트 하는 곳에서 문제가 있었다. 12345678910111213@WebServlet(name = &quot;LoginServlet&quot;, value = &quot;/login.do&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; .... //데이터 유효성 확인 후 리다이렉트 if(user!= null) &#123; response.sendRedirect(&quot;/ServletProject2_war_exploded/board.do/list&quot;); &#125;else&#123; response.sendRedirect(&quot;login.do&quot;); &#125; &#125;&#125; 이게 문제가 되는 코드다. 데이터가 유효하지 않으면 login.do로 리다이렉트하고 있다.이러면 login.do로 get요청을 하게된다. 그런데 나는 login.do를 처리하는 LoginServelt 클래스에 post만 처리 할 수 있도록 했다.405 code는 이런 상황에서 발생한 것이다. 그리고 get으로 로직을 다시 짰을 때 무한 리다이렉션이 일어나는 이유는login.do로 유효하지 않은 데이터 받음 -&gt; 유효하지 않으니 login.do get요청 -&gt; login.do로 빈 쿼리파라미터 받음-&gt; 유효하지 않으니 login.do get 요청… 이렇게 무한 반복되서 그랬다. 문제 해결다음과 같이 코드를 고치면 된다. 12345678910111213@WebServlet(name = &quot;LoginServlet&quot;, value = &quot;/login.do&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; .... //데이터 유효성 확인 후 리다이렉트 if(user!= null) &#123; response.sendRedirect(&quot;/ServletProject2_war_exploded/board.do/list&quot;); &#125;else&#123; response.sendRedirect(&quot;login.html&quot;); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"private 생성자나 열거 타입으로 싱글턴임을 보증하라","slug":"java/java-basic/effective-java/effective3","date":"2021-10-21T15:54:57.000Z","updated":"2022-03-03T15:32:26.357Z","comments":true,"path":"2021/10/22/java/java-basic/effective-java/effective3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/22/java/java-basic/effective-java/effective3/","excerpt":"","text":"싱글턴의 단점싱글턴은 인스턴스를 하나만 생성할 수 있는 클래스를 말한다.그런데 이 싱글턴 클래스를 사용하는 클라이언트를 테스트하기 어렵다.특히 인터페이스를 구현하는 방식으로 만들어진 싱글턴이 아니면 mock 객체로 테스트 하기 어렵다. mock객체? 테스트하고 싶은 객체의 핵심 책임만 검증할 수 있도록 만들어진 객체이다.원래 객체가 수많은 협력을 하고 있는데 반해, mock객체는 단순히 자신의 역할만 가지고 있을 뿐이다.싱글톤은 자기 자신이 다른 수많은 객체와 협력해야 한다.(하나뿐이므로) 그래서 협력을 제외한 mock객체 테스트가 불가능하다는 의미다. public static final 방식123456public class Yang&#123; public static final Yang INSTANCE = new YANG(); private Yang()&#123;...&#125; ....&#125; private 생성자는 맨 처음 public static final 인스턴스를 생성할 때 한번만 호출된다. 리플렉션 API의 AccessibleObject.setAccessible을 사용해서 private 생성자를 호출하는 경우가 있을 순 있는데,그런 경우를 대비하면 생성자를 수정해서 예외처리를 하면된다. 간결하게 싱글턴임을 알 수 있다.(static final이면 절대 다른 객체를 참조할 수 없으니..!) 정적 팩터리 메서드1234567public class Yang&#123; public static final Yang INSTANCE = new Yang(); private Yang()&#123;...&#125; public static Yang getInstance()&#123;return INSTANCE;&#125; ....&#125; 위와 비슷하지만, 정적 팩터리 메서드를 추가했다. 이로 얻는 장점은 싱글턴이 아니게 바꿀 수 있다. 정적 팩터리 메서드 내용을 바꾸면 언제든지 싱글턴이 아니게 만들 수 있다. 정적 팩터리 메서드를 제네릭 싱글턴 팩터리로 만들 수 있다! 정적 팩터리 메서드 참조를 공급자로 사용할 수 있다! Yang::getInstance 를 Supplier&lt;Yang&gt;으로 사용할 수 있다! 다만 위의 장점이 필요한게 아니면 public field 방식을 써라! 싱글턴 클래스 직렬화의 문제Public static final 필드나 정적 팩터리 메서드를 사용해서 싱글턴 클래스를 직렬화하려고 Serializable을 구현하면 문제가 생긴다.직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 생긴다. 이걸 막기 위해서는 모든 인스턴스 필드를 일시적(transient)라고 선언하고 readResolve 메서드를 추가해야 한다. 123private Object readResolve() &#123; return INSTANCE; //진짜 객체를 반환하고 가짜 객체는 가비지 컬렉터에 맡긴다.&#125; 열거 타입 활용하기직렬화 상황이나 리플렉션 공격에서 자유로운 방법은 열거 타입을 활용하는 거다.그래서 대부분의 상황에서는 열겨 타입으로 싱글턴을 만드는게 가장 좋다.다만, 상속을 활용해야 되는 경우 사용할 수 없다. (인터페이스 구현은 가능하다.) 1234public enum Yang &#123; INSTANCE; //기타 메서드...&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"mysql PID에러(The server quit without updating PID file)","slug":"cs/database/mysqlpid에러","date":"2021-10-21T14:29:08.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/10/21/cs/database/mysqlpid에러/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/21/cs/database/mysqlpid%EC%97%90%EB%9F%AC/","excerpt":"","text":"mysql이 갑자기 에러가 났다…주요 증상은 다음과 같다. 123mysql.server startStarting MySQL.. ERROR! The server quit without updating PID file (/usr/local/var/mysql/MUHN2-031.local.pid). 12345mysqld start2021-10-21T13:40:56.896075Z 0 [ERROR] [MY-010273] [Server] Could not create unix socket lock file /var/lib/mysql/mysql.sock.lock.2021-10-21T13:40:56.896105Z 0 [ERROR] [MY-010268] [Server] Unable to setup unix socket lock file.2021-10-21T13:40:56.896439Z 0 [ERROR] [MY-010119] [Server] Aborting2021-10-21T13:40:57.857715Z 0 [System] [MY-010910] [Server] /usr/local/Cellar/mysql/8.0.27/bin/mysqld: Shutdown complete (mysqld 8.0.27) Homebrew. PID에러가 발생해서 별의 별 짓을 다해봤다. 프로세스 인스턴스 종료하기 애초에 프로세스가 실행되지도 않았음 디렉토리 권한 설정하기 효과 없음 필요한 디렉토리를 직접 만들어주기 효과 없음 재설치 효과 없음 이렇게 난항을 겪는 와중 재설치 했을 때 로그를 읽어보니 해답이 보였다. 12A &quot;/etc/my.cnf&quot; from another install may interfere with a Homebrew-builtserver starting up correctly. 즉 예전에 설치했을 때 생긴 cnf가 있으면 서버 구동에 문제를 일으킬 수 있다는 안내문이다. 그래서 sudo rm &#x2F;etc&#x2F;my.cnf 해줬더니 작동됐다….","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}]},{"title":"생성자에 매개변수가 많으면 빌더를 고려하자","slug":"java/java-basic/effective-java/effective2","date":"2021-10-16T13:08:41.000Z","updated":"2022-03-03T15:35:49.660Z","comments":true,"path":"2021/10/16/java/java-basic/effective-java/effective2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/16/java/java-basic/effective-java/effective2/","excerpt":"","text":"점층적 생성자 패턴자바빈즈 패턴빌더 패턴 점층적 생성자 패턴클래스에 멤버 변수가 많다면, 수많은 생성자(점층적 생성자 패턴)가 가능하다. 12345678910class Clazz&#123; int a; double b; String c; .... public Clazz(int a)&#123;&#125; public Clazz(int a, double b)&#123;&#125; public Clazz(int a, double b, String c)&#123;&#125; ...&#125; 근데 이런 방식은 굳이 초기화 하고 싶지 않은 변수도 입력해줘야 된다.입력해야 될 매개변수가 적으면 나쁘지 않지만, 매개변수가 많아지면 코드 가독성을 해친다. 자바빈즈 패턴매개변수가 없는 생성자로 객체를 만들고, 세터 메서드를 호출해 원하는 매개변수 값을 설정하는 방식. 123456789class Clazz&#123; private int a; private double b; private String c; public void setA(int a)&#123;this.a = a;&#125; public void setB(double b)&#123;this.b = b;&#125; public void setC(String c)&#123;this.c = c;&#125;&#125; 단점 이 방식은 한 객체를 만들 때 메소드를 여러개 사용해야 되고, 완전히 초기화가 되기 전엔 일관성이 무너지게 된다.또한 클래스를 불변으로 만들 수 없다. (만들고 나서 인스턴스 멤버에 접근해서 수정할 수 있어야 하므로..) 12345Clazz clazz = new Clazz();clazz.setA(1);clazz.setB(3.5);clazz.setC(&quot;hi.&quot;);//이제 객체 초기화 끝...! 빌더 패턴점층적 생성자 패턴과 자바빈즈 패턴의 장점만 취한 방식이다. 원하는 클래스 안에 정적 클래시로 빌더를 만들고, 빌더 기본 생성자(혹은 정적 팩토리 메서드)에 필수 매개변수를 받고, 나머지 선택 매개변수들은 빌더가 제공하는 세터 메서드로 초기화 해준다. 원하는 멤버들을 모두 초기화했을 경우, 불변객체를 반환하는 build 메서드로 완성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Employee&#123; //가능한 모든 멤버 변수들. private final int age; private final int wage; private final String name; private final String company; private final String role; public Employee(Builder builder)&#123; age = builder.age; wage = builder.wage; name = builder.name; company = builder.company; role = builder.role; &#125; public static class Builder &#123; //멤버 변수 중 필수로 들어가야 할 변수. private final String name; private final String role; //선택 매개변수 기본값으로 초기화 한다. private int age = 0; private int wage = 0; private String company =&quot;&quot;; //빌더의 기본 생성자. 필수 매개변수를 받아야 객체 생성이 가능하다는 의미다. public Builder(String name, String role)&#123; this.name = name; this.role = role; &#125; //선택 매개변수 setter 메서드 public Builder age(int age)&#123; this.age = age; return this; &#125; public Builder wage(int wage)&#123; this.wage = wage; return this; &#125; public Builder company(String company)&#123; this.company = company; return this; &#125; //build메서드 public Employee build()&#123; return new Employee(this); &#125; &#125;&#125; 이 코드를 기반으로 코드를 짜면 다음과 같다. 1Employee kim = new Employee.Builder(&quot;kim&quot;, &quot;backend&quot;).age(12).company(&quot;naver&quot;).build();","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"생성자 대신 정적 팩터리 메서드를 고려하라.","slug":"java/java-basic/effective-java/effective1","date":"2021-10-15T13:38:49.000Z","updated":"2022-02-20T23:26:57.555Z","comments":true,"path":"2021/10/15/java/java-basic/effective-java/effective1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/15/java/java-basic/effective-java/effective1/","excerpt":"","text":"정적 팩터리 메서드란 무엇인가정적 팩터리 메서드의 장점은 무엇인가정적 팩터리 메서드의 단점은 무엇인가정적 팩터리 메서드 네이밍 컨벤션 일반적으로 public 생성자를 통해 클래스의 인스턴스를 만든다.하지만 정적 팩터리 메서드를 통해 만들면 여러 이점이 있다. 정적 팩터리 메서드란 무엇인가?static으로 선언되었고, 객체를 반환하는 메서드를 말한다. 책에 나온 예시인 valueOf를 보자 123public static Boolean valueOf(boolean b)&#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 이렇게 정적으로(static) 선언되어서 다음같이 사용할 수 있다. 12boolean bool = true;Boolean boolWrapper = Boolean.valueOf(bool); 정적 팩터리 메서드의 장점은 무엇인가? 이름을 가질 수 있다. 생성자는 여러 매개변수를 가질 수 있지만 이름은 클래스명이 전부라 구분이 어렵다. 정적팩터리는 메소드의 이름을 다양하게 할 수 있어서 구분을 쉽게 할 수 있다. 1234567891011121314151617181920212223242526class Student&#123; int age; double score; //정적 팩토리 메서드 static Student ageOf(int age)&#123; return new Student(age); &#125; static Student scoreOf(double score)&#123; return new Student(score) &#125; //생성자 public Student(int age)&#123; this.age =age;&#125; public Student(double score)&#123; this.score = score;&#125;&#125;//아래 매개변수로 판단하기는 헷갈린다!Student a = new Student(30);Studnet b = new Student(4.5);//메소드 명을 보니 분명하게 판별할 수 있다!Student c = Student.ageOf(30);Student d = Student.scoreOf(4.5); 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다. 위 valueOf 메소드는 미리 만들어진 static Boolean 객체를 반환한다. 정적 팩토리 메서드는 객체를 요청할 때 굳이 객체를 만들어 주지 않아도 된다.(싱글톤처럼 활용도 가능하다.) 12345678910class Boolean&#123; //정적 상수 객체들 public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); //static final 객체를 반환하는 정적 팩터리 메서드 public static Boolean valueOf(boolean b)&#123; return b ? Boolean.TRUE : Boolean.FALSE; &#125;&#125; 반환 타입의 하위 타입 객체를 반환할 수 있다. 인터페이스에 정적 메서드를 선언하면 구현 클래스에 대한 내용을 공개 안해도 그 객체를 반환 할 수 있다. 12345678public interface Person&#123; public static Person whoTeaches()&#123; return new Teacher(); &#125; public static Person whoLearns()&#123; return new Student(); &#125;&#125; 12public class Student implements Person&#123;...&#125;public class Teacher implements Person&#123;...&#125; 123//Teacher 클래스나 Student 클래스를 몰라도 해당 클래스 객체들을 사용할 수 있다!!Person kim = Person.whoTeaches();Person lee = Person.whoLearns(); 매개변수에 따라 매번 다른 객체를 반환할 수 있다. 인터페이스의 정적 팩터리 메서드의 반환 객체가 인터페이스를 구현하기만 하면 어떻게 되든 상관없다.(캡슐화.) 인터페이스를 구현한 구현체를 반환하는 규칙만 지킨다면, 추후에 수정하기도 용이하다. 123456public interface Person&#123; public static Person isOld(int age)&#123; if (age&gt;65) return new OldPerson(int age); else return new YoungPerson(int age); &#125;&#125; 12345678public class OldPerson implements Person&#123; int age; public OldPerson(int age)&#123;this.age = age;&#125;&#125;public class YoungPerson implements Person&#123; int age; public YoungPerson(int age)&#123;this.age = age;&#125;&#125; 123//사용자는 어떤 객체가 만들어지는지 알 필요가 없다.Person kim = Person.isOld(75); //OldPerson객체Person lee = Person.isOld(23); //YoungPerson객체 정적 팩터리 메서드의 단점은 무엇인가? public이나 protected 생성자 대신 정적 팩터리 메서드를 사용하면, 상속이 불가능해진다. 상속 관계를 만들려면 public, protected 생성자가 있어야 한다. 개발자가 이해하기 어렵다. 정적 팩터리 메서드는 클래스나 인터페이스에 있어서 생성자보다는 알기 어렵다. 정적 팩터리 메서드 네이밍 컨벤션 from : 매개변수 하나 받아서 해당 타입의 인스턴스 반환 of : 여러 매개변수 받아 적합한 타입의 인스턴스 반환 valueOf : from, of의 더 자세한 버전 getInstance : (매개변수를 받아 매개변수를 가진) 인스턴스를 반환한다. create &#x2F; newInstance : 새로운 인스턴스를 만들어 반환한다. instance 대신 다른 클래스의 이름을 적으면 다른 클래스의 인스턴스를 반환한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://yangdongjue5510.github.io/tags/effective-java/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"완전탐색","slug":"cs/algorithm/theory/완전탐색","date":"2021-10-15T01:54:02.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/10/15/cs/algorithm/theory/완전탐색/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/15/cs/algorithm/theory/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/","excerpt":"","text":"완전탐색이란문제 유형복잡도 파악 완전탐색이란모든 경우를 탐색하는 방법.부분점수를 얻기 좋으나 시간 복잡도가 일반적으로 높은 편. 완전탐색 문제를 접근할 땐 고를 수 있는 값의 종류 파악 중복을 허용하는지 순서를 중요시 하는지 위 세가지를 파악해자. 문제 유형완전탐색 문제는 크게 4가지로 나눌 수 있다. N개에서 중복 허용해서 M개를 순서 있게 나열하기 N개에서 중복 허용하지 않고 M개를 순서 있게 나열하기 N개에서 중복 허용해서 M개를 순서 없이 고르기 N개에서 중복 허용하지 않고 M개를 순서 없이 고르기. 즉 완전탐색 문제는 두 개의 양의 정수를 구하고, 배열이나 리스트에 나열하는 방법의 개수를 묻는 방식으로 푼다. 복잡도 파악완전 탐색은위 유형마다 시간 복잡도 &#x2F; 공간 복잡도를 정리해보자 중복허용, 순서중요 : O(N^M) , O(M) 중복불허, 순서중요 :O(N!&#x2F;(N-M)!), O(M) 중복허용, 순서불허 : O(N^M), O(M) 중복불허, 순서불허 : O(N!&#x2F;M!(N-M)!), O(M) 대체로, 순서를 신경쓰는 경우가 더 복잡하다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"운영체제 면접대비 스터디","slug":"cs/os/운영체제면접대비","date":"2021-10-14T05:53:10.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/10/14/cs/os/운영체제면접대비/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/14/cs/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84/","excerpt":"","text":"목차1주차프로세스와 스레드의 차이쓰레드의 동기화 이슈교착 상태와 기아 상태메모리 계층 2주차메모리 할당 방식메모리 단편화메모리 할당 알고리즘가상 메모리요구 페이징페이지 교체 알고리즘 3주차페이징세그멘테이션상호배제 방식뮤텍스세마포어 4주차PCB와 프로세스 컨텍스트컨텍스트 스위칭사용자 수준 스레드 vs 커널 수준 스레드fork와 vfork의 차이점 5주차RaceCondition시스템콜vs서브루틴 1주차프로세스와 스레드의 차이정의 프로세스 : 메모리에 올려져 실행 중인 프로그램쓰레드 : 프로세스 안에서 실행되는 흐름 단위 공유자원 차이 프로세스 : 프로세스들 끼리는 IPC를 제외하면 공유를 허용하지 않음쓰레드 : code, data, heap은 서로 공유. stack은 서로 독립적.(각자의 흐름을 가져야 함) *프로세스 구조* code : 컴파일된 코드가 저장(프로그램 끝날 때 해제) Data : 선언된 변수가 저장되는 영역 (전역변수, static, 프로그램 끝날 때 해제) BSS(초기화 안된 전역변수) &#x2F; DATA(초기화 된 전역변수) heap : 동적으로 할당된 메모리가 저장 stack : 함수와 관련된 인자나 변수 저장 (다양한 레지스터 사용!) *IPC* 프로세스 간 상태 확인 및 데이터 송수신할 때 사용. 프로세서마다 공유하는 커널 공간을 통해 데이터를 쓰고 읽음. IPC 비용이 커서 멀티 프로세스보다 멀티 스레드를 활용하기도 함. *Context Switching* 프로세스의 상태 정보를 저장하고 복원하는 과정 PCB : 프로세스의 상태를 저장한 구조체(program counter와 stack pointer 등 다양한 레지스터 저장)스위칭 될 때마다 PCB를 저장하고 로드.서로 자원이 공유되지 않으니, 스위칭 연산이 비싸다. 쓰레드보다 프로세스 바꿀 때가 더 든다. 왜 ? 쓰레드는 공유 자원이라 바꿀게 스레드보다 더 적다. 약점 프로세스 : 서로 자원 공유가 제한됨 IPC 연산 비용 일일히 자원 할당하는 시스템콜 비용 쓰레드 : 하나만 잘못되도 프로세스 전체에 악영향 동기화 이슈 *멀티 프로세스 vs 멀티 쓰레드* 멀티 프로세스 여러 cpu가 동시에 여러개의 프로세스 처리 메모리 침범 막아서 안전성 높음 작업량이 많으면 컨텍스트 스위칭으로 인해 성능이 저하 멀티 스레드 하나의 프로세스에서 여러 스레드가 각자 하나의 작업을 처리 자원 공유로 빠른 작업 가능 스레드 하나가 망하면 한 프로세스가 다같이 망함 쓰레드의 동기화 이슈상호배재(mutex) 한 스레드가 공유 자원에 접근하면 다른 스레드가 접근 못하게 하기 임계 자원(crtical resource) : 접근 제한 자원 임계 영역(critical section) : 접근 제한 코드. 영역 세마포어(semaphore) 공유 자원에 정해진 수의 사용자만 접근 허락 교착 상태와 기아 상태교착 상태(dead lock) 여러 쓰레드가 서로 상대방의 작업이 끝나길 기다리느라 다음 작업을 못하는 상황 기아 상태 우선순위가 낮은 프로세스가 계속 경쟁에 뒤쳐져 원하는 자원을 계속 못받는 상태. 이슈 해결 방법 교착 상태 예방 : 원인을 제거 회피 : 발생하지 않도록 알고리즘 도입 은행원 알고리즘 &#x2F; 자원할당 알고리즘 회복 : 문제가 발생한 프로세스를 중단, 메모리 해제 무시 : 해결할 때 생기는 비용이 너무 비싸면 무시 예방이 가장 낭비가 심하다. 기아 상태 우선순위 수시로 바꿈 FIFO 기반 스케줄러로 바꿈 *교착 상태의 원인* 상호배제 : 다른 프로세스도 갖고 싶은 걸 자기만 가지려함 점유대기 : 자원을 가지고 있으면서 다른 자원을 대기 비선점 : 자원을 가진 프로세스의 자원을 못 뺏음 순환대기 : 다음 프로세스가 원하는 걸 가지고 있음. 메모리 계층레지스터 - 캐시 - 메모리 - 하드디스크 메모리를 필요에 따라 나눈 계층(오른쪽으로 갈 수록 CPU가 느리게 접근) 레지스터CPU 요청 처리에 필요한 정보를 임시 저장하는 기억장치 캐시데이터나 값을 미리 복사해놓는 임시 저장소. 메인 메모리RAM, ROM으로 구성된 명령, 자료를 기억하는 장치.cpu에서 직접 접근가능 하다는게 하드디스크와 다름 하드디스크비휘발성 순차적 데이터 저장소. 느리지만 저렴.직접 사용하지 못하고 시스템콜로 메모리에 옮겨서 사용. 계층이 필요한 이유 디코딩 속도 큰 메모리 용량은 디코딩하는데 많은 시간 소요. 메모리가 작으면 빠르게 디코딩해서 접근 가능 참조의 지역성 자주 쓰이는 데이터는 계속 더 자주 쓰임 경제성 빠를 수록 비싸서 저렴한 메모리를 효율적으로 활용해야함. 2주차메모리 할당 방식**연속 할당 방식 **프로그램 전체를 한 공간에 연속적으로 할당. 정적 분할과 동적 분할 정적 분할 : 메모리 영역을 고정된 크기로 미리 나눠놓고 맞는 프로세스를 집어넣는 방식. 내외부단편화 모두 일어남.동적 분할 : 프로세스에 맞게 메모리 영역을 할당함. 외부단편화가 생길 수 있음. 비연속 할당 방식프로그램을 페이지로 나눈 후, 여러 곳에 흩어져서 할당. 메모리 단편화프로세스를 메모리에 올릴 때 생기는 메모리 낭비 현상.대표적으로 외부 단편화와 내부 단편화가 있다. 외부 단편화 어떤 프로세스보다 전체 물리 메모리의 남은 공간이 더 많아도,물리 메모리의 남은 공간들이 연속적이지 못해서 프로세스를 메모리에 올리지 못하는 상황 내부 단편화 물리 메모리의 남은 공간에 어떤 프로세스를 할당하고 남은 공간이다른 프로세스를 받아들이지 못해 낭비되는 상황 메모리 단편화 해결하기 COMPACTION 압축 비어있는 공간을 연속적인 공간으로 재배치.현재 프로세스들을 다른 곳(하드디스크 등)에 복사했다가 다시 메모리에 올려야 함병목현상이나, IO 문제가 발생 가능하다. -&gt; 외부 Coalescing holes( 공간 통합) 프로세스가 끝나고 메모리에서 사라지면, 새로 생긴 빈 공간을 주위 빈공간과 합침.좀 더 큰 프로세스가 올 수 있게 만들고 오버헤드가 낮음 메모리 할당 알고리즘멀티 프로세스 환경에서 여러 프로세스가 동시에 실행된다.단편화 문제를 줄이기 위해 메모리를 할당하는 알고리즘. BEST FIT : 현재 물리 메모리의 빈 공간을 모두 탐색해서 가장 낭비가 적은 공간에 프로세스 올림 FIRST FIT : 현재 물리 메모리에서 프로세스를 올릴 수 있는 빈 공간 중 가장 먼저 찾은 공간에 프로세스 올림 WORST FIT : 현재 물리 메모리 남은 공간들 중 프로세스를 할당하고도 남은 공간이 가장 큰 공간에 프로세스 올림(남은 공간에 다음에 올 프로세스가 들어올 가능성을 생각한 것.) 평가 효율성 : BEST FIT, FIRST FIT &gt; WORST FIT복잡도 : FIRST FIT &gt; BEST FIT , WORST FIT FIRST FIT의 50퍼센트 규칙 전체 메모리에 N개의 블록이 할당되었다고 했을 때 0.5N개의 블록이 외부 단편화되어 사용할 수 없음.총 (1.5N 중 0.5N, 즉 1&#x2F;3만큼 사용할 수 없게 된다.) 가상 메모리메모리에 로드되어 실행 중인 프로세스가 가상의 메모리 공간을 참조해 거대한 물리 메모리를 사용하는 것처럼 보이게 하는 방식. 프로세스를 모두 메모리에 할당하기엔 한계가 있다.(리눅스의 프로세스 크기가 4기가.)CPU가 프로세스의 모든 공간을 사용하지는 않는다. 자주 사용하지 않는 부분은 하드디스크에 저장가상 주소로 통해 메모리에 접근. 프레임 : 물리 메모리를 구성하는 가장 작은 단위페이지 : 가상 메모리를 구성하는 가장 작은 단위 MMU : CPU가 가상 메모리에 접근하고 싶을 때 가상 주소를 실제 물리 주소로 바꾸어 접근 페이지 폴트 : 프로세스의 페이지 중 일부가 RAM에 올려지지 않은 상황. 요구 페이징페이지 폴트가 발생하면, 가상 메모리에서 해당 페이지를 찾아야 함.(요구페이징)CPU는 프로세스 페이지의 주소를 페이지 테이블에 기록했음. 페이지 테이블의 가상 주소를 보고 요청하면, MMU가 실제 물리 주소로 변환해서하드디스크에 있는 페이지를 물리 메모리에 올려야 한다. 페이지 교체 알고리즘가상 메모리에서 페이지를 가져왔는데, 메모리에 남는 프레임이 없어서 올리지 못하는 경우,메모리의 다른 페이지를 빼서 가상 메모리에 넣고, 가져온 페이지를 물리 메모리에 넣어야 한다. OPT : 앞으로 안쓸거 같은 페이지를 교체 FIFO : 가장 먼저 할당된 페이지를 교체 LRU least recently used : 오랫동안 덜 쓴 페이지 교체 - 지역성(로컬리티) LFU least fre: 사용 빈도가 적은 페이지 교체 NUR : 최근에 사용안한 페이지 교체 3주차페이징비연속할당 방식, 고정 분할 기법의 일종으로 프로세스를 여러 개의 페이지로 나눠 메모리에 흩어져서 할당됨외부 단편화를 막을 수 있지만, 페이지 크기가 커질 수록 내부 단편화도 커짐.(필요한 메모리보다 할당된 메모리가 더 큰 경우) 페이징을 하기 위해서는 mmu와 페이지테이블이 필요하다. 세그멘테이션페이징은 물리적으로 동일한 크기로 분할하는 기법이지만세그멘테이션은 논리적인 기준으로 분할하는 기법이다.세그멘테이션은 각 세그멘트가 크기가 달라서 메모리에 할당하고 해제하는 과정에서 외부 단편화가 날 수 있다. 외부 단편화를 방지하기 위해 세그멘트를 페이징하는 paged segmentation 기법을 사용한다. 상호배제 방식공유 자원 접근을 제한하는 방식. 뮤텍스여러 프로세스&#x2F;스레드가 공유 자원에 접근하는 상황을 막는 상호 배제 락 매커니즘.임계 구역(공유 자원)에 하나의 프로세스&#x2F;스레드만 접근 가능함 세마포어여러 프로세스&#x2F;스레드 중 정해진 프로세스&#x2F;스레드 갯수만큼만 접근을 허락하는 매커니즘.대기 중인 프로세스&#x2F;스레드가 공유 자원을 사용할 수 있는 지 계속 검사하는 과정이 발생 가능(바쁜 대기) 세마포어는 뮤텍스가 될 수 있는데, 뮤텍스는 세마포어가 될 수 없다!!!세마포어는 소유가 불가능한데, 뮤텍스가 소유가 가능하다. 4주차PCB와 프로세스 컨텍스트프로세스 메타데이터CPU는 프로세스 메타데이터로 프로세스를 식별.Process ID, Process State, Program Counter, Process Context 등…Program Counter &#x3D; 다음에 실행될 명령어의 주소를 저장. PCB(Process Control Block)프로세스 관리를 위한 메타데이터를 저장하는 자료구조. 커널이 관리 프로세스 컨텍스트CPU가 해당 프로세스를 실행하기 위한 프로세스 데이터 모음.CPU는 레지스터를 기반으로 코드를 실행하므로,프로세서의 상태와 관련된 레지스터 집합을 프로세스 컨텍스트라고 이해. 컨텍스트 스위칭하나의 프로세스가 CPU를 사용하고 있을 때,하던 프로세스 작업을 중단하고 다른 프로세스 작업을 하기 위해,진행 중이던 프로세스의 컨텍스트를 PCB에 저장하고,다음 프로세스를 진행하기 위해 PCB에서 해당 컨텍스트를 가져와 작업을 진행한다. 프로세스와 쓰레드 컨텍스트 스위칭프로세스 : PCB에 프로세스 컨텍스트를 저장.쓰레드 : 프로세스 내부의 TCB에 컨텍스트를 저장. 컨텍스트 스위칭이 일어나는 경우 인터럽트 발생 CPU 사용 허가 시간 모두 소모 입출력 대기해야 하는 경우 사용자 수준 스레드 vs 커널 수준 스레드커널 수준 스레드커널이 생성해서 관리하는 스레드.커널이 직접 관리하므로 권한이 많지만, 그만큼 오버헤드가 일어남 한 프로세스에 여러 쓰레드를 할당하면, 한 스레드가 블락되도 다른 스레드로 대신하면 됨. 커널에서 관리하다 보니, 컨텍스트 스위칭도 발생. 오버헤드가 일어남 사용자 수준 스레드사용자 모드에서 동작하는 스레드.사용자 레벨에서 스레드 전용 라이브러리를 이용해서 여러 스레드를 생성.(자바에서 스레드 함수 이용하던지..) 스케줄링을 커널이 하지 않고 스레드 라이브러리에 따라 스케줄링. 이 스레드들은 커널의 기능을 사용하지 못하고,커널도 이들의 존재를 모른다. fork와 vfork의 차이점.forkUNIX 계열에서 새로운 프로세스 만드는 함수자식 프로세스가 부모 프로세스를 복제하는 방식 vfork부모 프로세스와 자식 프로세스가 페이지 테이블 공유.복사하지 않고 공유하므로 생성 속도가 빠르지만,공유된 자원을 두고 경쟁할 수 있다. -&gt; 부모 프로세스는 자식이 exit하거나 execute할 때까지 block 5주차Race Condition공유 자원에 여러 프로세스가 동시에 접근하려고 경쟁하는 상황결과의 순서를 기대할 수 없다 Race Condition attackSetuid(소유자 권한으로 실행)으로 설정된 파일이 실행 중일 때,생성된 임시파일과 같은 이름의 파일에 심볼릭링크를 만들어서 원본 파일을 지우고새로운 임시 파일이 생성될 때, 심볼릭 링크를 통해 파일 내용을 변경. 시스템은 변경된 파일을 새롭게 생성된 파일로 착각하고 프로세스 진행. 레이스컨디션 대응 가능하면 임시파일 생성 금지 파일 생성 시, 동일 파일 존재 시, 파일 생성 혹은 쓰기를 금지 만들려는 파일에 링크가 걸려있으면 실행중단 임시파일이 공격자에 의해 삭제되지 않도록 함(umask를 최하 022정도로 유지. 쓰기 권한 제거) 시스템콜 vs 서브루틴커널은 하드웨어를 제어하는 일종의 API.시스템콜은 커널의 서비스를 호출하는 명령어.서브루틴은 프로그래밍 할때 사용하는 대부분의 API. 서브루틴이 시스템콜을 호출하고 -&gt; 시스템콜이 커널을 호출.-&gt;커널의 수행 결과를 시스템콜로 전달-&gt;시스템콜이 다시 서브루틴에게 보냄","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"10. 객체 지향의 사실과 오해 마인드맵 정리","slug":"java/java-basic/java10","date":"2021-10-11T07:54:26.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/10/11/java/java-basic/java10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/11/java/java-basic/java10/","excerpt":"","text":"클릭하면 크게 보실 수 있습니다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"7. 어댑터 패턴","slug":"java/java-basic/design-pattern/dp7","date":"2021-10-09T09:33:00.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/10/09/java/java-basic/design-pattern/dp7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/09/java/java-basic/design-pattern/dp7/","excerpt":"","text":"어댑터 패턴한 클래스의 인터페이스를 사용하고자 한 다른 인터페이스로 변환한다.쓰고자 하는 인터페이스를 구현한 클래스에 바꾸고 싶은 클래스의 객체를 구성한다. 닭과 오리를 만들어서 날고 울 수 있게 하고 싶다.그러나 두 객체의 행동이 약간 다르다. 1234public interface Chicken &#123; void kokkio(); void fly();&#125; 1234public interface Duck &#123; void quak(); void fly();&#125; 이 두 인터페이스를 구현하는 두 클래스가 있다. 1234567891011public class KoreanChicken implements Chicken&#123; @Override public void kokkio() &#123; System.out.println(&quot;꼬끼오!!!&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;푸득...&quot;); &#125;&#125; 1234567891011public class KoreanDuck implements Duck&#123; @Override public void quak() &#123; System.out.println(&quot;꽥!!&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;푸드득~!&quot;); &#125;&#125; 이제 닭을 오리처럼 행동을 요구하고 싶다.오리 인터페이스를 구현하는 어댑터를 만들어보자이 어댑터는 치킨 객체를 구성하고 있다. 12345678910111213141516public class ChickenAdapter implements Duck&#123; Chicken chicken; public ChickenAdapter(Chicken chicken)&#123; this.chicken = chicken; &#125; @Override public void quak() &#123; chicken.kokkio(); &#125; @Override public void fly() &#123; chicken.fly(); &#125;&#125; 이제 어댑터를 사용해서 오리와 닭을 둘다 동일한 메소드로 요청하자! 123456789101112public class Test &#123; public static void main(String[] args) &#123; Duck koreanDuck = new KoreanDuck(); koreanDuck.quak(); koreanDuck.fly(); Chicken koreanChicken = new KoreanChicken(); Duck adaptedChicken = new ChickenAdapter(koreanChicken); adaptedChicken.quak(); adaptedChicken.fly(); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"6. 싱글톤 패턴","slug":"java/java-basic/design-pattern/dp6","date":"2021-10-01T04:21:35.000Z","updated":"2022-12-24T19:06:51.060Z","comments":true,"path":"2021/10/01/java/java-basic/design-pattern/dp6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/10/01/java/java-basic/design-pattern/dp6/","excerpt":"","text":"싱글톤 패턴인스턴스가 하나 뿐인 객체를 만드는 패턴!어디서든 그 인스턴스에 접근할 수 있게하는 패턴! 왜 쓰는가?굳이 여러개가 필요 없는 클래스의 객체가 여러개 생기면 메모리를 불필요하게 차지하게 된다.이런 클래스들의 객체를 하나로 유지하도록 설계해서 메모리를 효율적으로 사용하게 한다. 혹은 설정이나 보안같이 중요한 내용을 담는 클래스는 여러개의 객체를 만들면 안정성을 해친다. 전역변수 쓰면 되잖아요 전역변수는 시작하면서 생성(JVM마다 다름). 필요하지 않을 때 생성될 수 있음. 고전적인 싱글톤 패턴12345678910public class Singleton &#123; private static Singleton uniqueObject; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(uniqueObject == null)&#123; uniqueObject =new Singleton(); &#125; return uniqueObject; &#125;&#125; 유일한 객체는 private static으로 정적으로 만들자. 객체에 대한 접근은 public static한 메소드로 하자. 메소드가 현 객체의 유무를 파악해서 객체를 만들어 반환. 멀티 스레드 문제 만약 여러개의 스레드가 getInstance메소드에 접근하면 어떻게 될까? (1번 스레드와 2번 스레드가 getInstace를 호출한 상황…)1번 getInstance -&gt; 2번 getInstance -&gt;1번 객체 유무 판별(없다고 판단) -&gt; 2번 객체 유무 판별(없다고 판단) -&gt;1번 객체 생성 -&gt; 2번 객체 생성(문제 발생!!!!!!) -&gt;1번 객체 반환(1번 객체 반환) -&gt; 2번 객체 반환(2번 객체 반환) 즉 두 스레드가 반환한 객체는 서로 다른 객체다!!!! 스레드 문제 해결하기 getInstance를 synchronized하기. getInstance 호출 시 끝날 때까지 다른 스레드 정지. 하지만 매번 객체에 접근할 때마다 동기화하는건 속도 문제 발생 가능 getInstance의 속도가 중요하지 않은 경우 사용. 인스턴스를 필요할 때 만들지 말고 처음부터 만들기 123456public class Singleton &#123; private static Singleton uniqueInstance = new Singleton(); private Singleton(); public static Singleton getInstance()&#123;return uniqueInstance;&#125;&#125; 이 방법은 JVM에서 클래스가 로딩될 때 인스턴스를 생성! 게으른 홀더 방식내부 클래스를 따로 선언해서 그 안에 객체를 저장하는 방식이다.클래스 로더가 이 클래스를 읽을 때 객체 생성된다. 1234567public class Singleton2 &#123; private Singleton2()&#123;&#125; public static class LazyHolder&#123; private static final Singleton2 uniqueInstance = new Singleton2(); &#125; public static Singleton2 getInstance()&#123;return LazyHolder.uniqueInstance;&#125;&#125; synchronized를 사용하지 않아 성능도 좋고, 다른 키워드를 사용하지 않아도 되서 직관적이다. 주의 할 점 만약 여러개의 클래스 로더를 사용할 경우 여러개의 객체가 생성될 수 있다!구체 클래스에 의존하여 인스턴스를 찾게 되므로, DIP, OCP를 위반할 가능성이 있다. 싱글톤의 비용 소멸이 정의되어 있지 않음 : 싱글톤을 없애거나 중지하는 좋은 방법이 없다. 인스턴스를 저장하는 레퍼런스 변수를 Null로 바꾸는 메서드를 추가해도 다른 모듈의 그 싱글톤 인스턴스에 대한 참조값을 계속 유지할 수 있음. 상속 불가 : 싱글톤에서 파생된 클래스는 싱글톤이 아니다. 효율성 : 인스턴스 호출 때마다 if 문 실행한다. 대부분의 경우는 이 if문이 필요없긴 하다. 비투명성 : 싱글톤 사용자는 getInstance 메서드를 사용해야 한다. 이는 사용자가 해당 객체가 싱글톤임을 알아야 한다는 의미다. 모노스테이트 패턴모노스테이트 패턴은 하나의 객체만 만들도록 유도하는 또 다른 패턴이다. 여러 인스턴스가 하나인 것처럼 작동한다. 123456789@Testvoid testInstancesBehaveAsOne() &#123; final MonoState m1 = new MonoState(); final MonoState m2 = new MonoState(); for (int x = 0; x &lt; 10; x++) &#123; m1.setX(x); assertThat(x).isEqualTo(m2.getX()); &#125;&#125; 왜냐면 2개의 객체가 같은 변수를 공유하기 때문이다. 모든 변수를 정적으로 만들어서 쉽게 구현할 수 있다. 그리고 어떤 메서드도 정적이어서는 안된다. 1234567891011121314public class MonoState &#123; private static int itsX = 0; public MonoState() &#123; &#125; public void setX(final int x) &#123; itsX = x; &#125; public int getX() &#123; return itsX; &#125;&#125; 모노스테이트와 싱글톤의 차이싱글톤은 단일 객체 구조를 강요한다. 싱글톤은 둘 이상의 인스턴스를 생성하지 못하게 한다.모노스테이트는 단일 객체 행동을 강요한다. 모노스테이트는 여러 인스턴스를 만들 수 있되, 그 인스턴스들이 단일 객체처럼 행동을 한다. 모노스테이트의 이점 투명성 : 모노스테이트 사용자는 일반 객체처럼 사용해도 상관없다. 파생 가능성 : 모노스테이트의 파생 클래스는 모노스테이트다. 다형성 : 모노스테이트의 메서드가 정적이지 않기 때문에 파생 클래스에서 오버라이딩해서 서로 다르게 구현할 수 있다. 잘 정의된 생성과 소멸 : 정적인 모노스테이트의 변수는 생성과 소멸 시기가 잘 정의되어있다. 모노스테이트의 비용 변환 불가 : 보통 클래스를 모노스테이트로 변환하기 힘들다. 효율성 : 하나의 모노스테이트는 실체 객체이기 때문에 많은 생성과 소멸을 겪을 수 있다. 실재함 : 모노스테이트 변수는 모노스테이트가 사용되지 않아도 공간을 차지한다. (정적) 플랫폼 한정 : 한 모노스테이트가 여러 JVM 인스턴스나 여러 개의 플랫폼에서 동작하게 만들 수 없다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"5. SOLID 원칙","slug":"java/java-basic/design-pattern/dp5","date":"2021-09-30T04:23:53.000Z","updated":"2022-01-22T16:20:00.033Z","comments":true,"path":"2021/09/30/java/java-basic/design-pattern/dp5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/30/java/java-basic/design-pattern/dp5/","excerpt":"","text":"SOLID확장과 유지보수를 쉽게 만드는 객체지향 프로그래밍 설계의 다섯가지 원칙. S : 단일 책임 원칙(SRP)한 설계 부품(클래스, 함수..)는 하나의 책임만 가져야 한다.약은 약사에게 진료는 의사에게…한 부품에 여러 기능이 있으면, 내부 메소드들이 의지하는 부분이 많아진다.즉 결합도가 높아지고, 그 부품에 대한 책임 높아진다. -&gt; 유지보수가 힘들어진다. 123456789101112131415161718class ICanDoEverything&#123; public void plus(int a, int b)&#123; System.out.println(a+b); &#125;; public void display(Displayable file)&#123;file.play();&#125; public void singASong(Singable singer)&#123;singer.sing();&#125;&#125;public class SRPTest &#123; public static void main(String[] args) &#123; ICanDoEverything hero = new ICanDoEverything(); Displayable file = new Jpg(); Singable singer = new RealSinger(); int a1 = 1; int a2 =2; hero.display(file); //책임 1 hero.singASong(singer); //책임 2 hero.plus(a1, a2);//책임 3 &#125;&#125; 숫자 두개를 더하고, 파일을 받아 실행하고, 가수를 불러 노래도 시킬 수 있는 ICanDoEverything 클래스가 있다!이 클래스의 객체 hero는 main메서드에서 3가지 책임을 하고 있다.근데 만약 이 클래스의 한 메서드에서 문제가 생기면 어떨까?객체 hero의 3가지 책임이 모두 실행할 수 없게 된다!!!(그 책임이 문제와 큰 관련이 없어도 말이다) O : 개방-폐쇄 원칙(OCP)기존의 코드를 변경하지 않고(close) 기능을 수정하거나 추가 할 수 있어야 한다.(open)자주 변경되는 내용은 따로 분리하고, 자주 변경되지 않는 부분은 다른 부분이 변경 되더라도 영향을 덜 받아야 한다. 123456789101112131415161718192021222324252627282930313233343536373839package SOLID;interface Displayable &#123; public void play();&#125;class Jpg implements Displayable&#123; @Override public void play()&#123; System.out.println(&quot;jpg displayed&quot;); &#125;&#125;class Gif implements Displayable&#123; @Override public void play()&#123; System.out.println(&quot;gif displayed&quot;); &#125;&#125;class FileDisplayer&#123; Displayable file; public void setFile(Displayable file)&#123; this.file = file; &#125; public void play()&#123; file.play(); &#125;&#125;public class ImageDisplay &#123; public static void main(String[] args) &#123; FileDisplayer fileDisplayer = new FileDisplayer(); Displayable file = new Jpg(); fileDisplayer.setFile(file); fileDisplayer.play(); file = new Gif(); fileDisplayer.setFile(file); fileDisplayer.play(); &#125;&#125; 여기서 변화할 내용은 play메소드이다.인터페이스로 play 메소드를 인터페이스로 추상화했다. L : 리스코프 치환 원칙자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.즉, 부모의 자리에 자식이 와도 문제 없어야 한다!또한 자식이 부모의 기능을 재정의 하지 않고 확장하는 것이 좋다. 12345678910111213141516171819202122class Account &#123; int accountNum = 123456; String owner= &quot;yang&quot;; int balance = 1000; int getBalance()&#123; return this.balance; &#125;&#125;class SavingAccount extends Account&#123; int interestRate = 2; int getBalance()&#123; return this.balance * this.interestRate; &#125;&#125;class Bank&#123; Account account = new Account(); account.getBalance(); //1000반환 account = new SavingAccount(); account.getBalance(); //2000반환!&#125; 자식 클래스가 메소드를 재정의해서 같은 코드더라도 다른 결과를 일으키는 문제가 있다. I : 인터페이스 분리 원칙자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.(영향 받지 않아야 한다.)하나의 큰 인터페이스보다 구체적인 여러 인터페이스가 낫다. 123456789101112131415161718192021interface Everything&#123; void run(); void sing(); void swim();&#125;class Singer implements Everything&#123; @Override public void run() &#123; System.out.println(&quot;Singer can run?&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;Singer can sing a song!!&quot;); &#125; @Override public void swim() &#123; System.out.println(&quot;Singer can swim....?&quot;); &#125;&#125; 노래를 하는 Singer클래스는 여러 기능을 포함하는 큰 인터페이스를 구현하고 있다.이에 대한 부작용으로 Singer클래스는 자신이 해야할 역할 외에도 다른 기능을 구현해야 하게 된다. 123456789101112131415interface Singable&#123; void sing();&#125;interface Runnable&#123; void run();&#125;interface Swimable&#123; void swim();&#125;class RealSinger implements Singable&#123; @Override public void sing() &#123; System.out.println(&quot;Singer can sing a song~!&quot;); &#125;&#125; 인터페이스를 구체적으로 나눴더니, Singer클래스가 필요한 역할만 구현할 수 있게 됐다! D : 의존 역전 원칙(DIP)의존 관계를 맺을 때, 변하기 쉬운 것보다 변화하기 어려운 것에 의존해라!변화하기 쉬운 것 -&gt; 구체적으로 구현된 것변화하기 어려운 것 -&gt; 추상화 된 것(인터페이스, 추상 클래스) 즉 의존관계를 맺을 때, 실제 구현된 클래스가 아닌 인터페이스나 추상 클래스과 맺으라는 뜻!! 역전? 즉 원래 변하기 쉬운 것에 상위 모듈이 의존하면 : 변화할때마다 상위 모듈도 따라 변화해야 함!그러나 인터페이스 같이 변하기 어려운 것에 상위 모듈이 의존하면?하위 모듈은 인터페이스에 의존하도록 하여(역전!),수정을 아무리 해도 상위 모듈이 인터페이스를 의존하는 한 문제는 없다! 12345678910111213public class ImageDisplay &#123; public static void main(String[] args) &#123; FileDisplayer fileDisplayer = new FileDisplayer(); Displayable file = new Jpg(); fileDisplayer.setFile(file); fileDisplayer.play(); file = new Gif(); fileDisplayer.setFile(file); fileDisplayer.play(); &#125;&#125; 아까 사용했던 예시에서 보면, 실제 구현된 Jpg 클래스의 메소드를 부르는게 아닌,Diplayable 인터페이스의 메소드를 호출하는 방식으로 의존관계를 만든다!!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"29. 백준 1080번 행렬(그리디)","slug":"cs/algorithm/problem/al29","date":"2021-09-27T04:33:09.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/27/cs/algorithm/problem/al29/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/27/cs/algorithm/problem/al29/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1080 이 문제는 그리디로 접근해야 한다.그리디는 현재 상황에서 최선을 고르는 과정을 반복해서 답을 찾아가는 것 근데 나는 개인적으로 저 정의보다 다음과 같이 이해하는게 빨랐다.그리디는 뒷 일을 생각하지 않는 거다!! 풀이법 이 문제에서도 풀이법은“처음부터 답안과 비교해 다른 원소를 만나면 그 원소를 바꾼다.” -&gt; 현재 상황의 최선그리고 문제 조건에 따라 뒤에 따라오는 원소들(3x3배열 만큼)도 바꾼다. -&gt; 이건 어찌되던 지금 신경 안씀 검증 자 이게 진짜 작동하는지 검증해보자!!!그리디 검증은 최적해를 구하는 임의의 알고리즘을 가정하고, 이 것이 우리 방법보다 좋지 않음을 보이면 된다. 임의의 배열 arr이 있다고 할 때우리의 풀이로 3번 연산하면 목표 배열을 만들 수 있다고 하자.(이 세 값을 a1, a2, a3라 하자.) 임의의 알고리즘의 최소 연산 2개라고 가정하고, 연산이 일으키는 위치 b1, b2가 있다고 하자. 이때 주어진 배열이 목표 배열과 다른 가장 처음 위치는 a1이다.연산을 통해 a1의 위치를 바꿀 수 있는 원소는 a1 자신과, a1보다 왼쪽에 있거나, 위에 있거나, 왼쪽 대각선에 있는 원소일 것이다.그러나 a1 이전에 있는 원소들은 이미 목표 값과 맞는 원소들이다. 즉 하나의 값을 맞추기 위해 이미 맞는 원소들 바꾸게 되어, 더 연산하게 된다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344package week4;import java.util.*;import java.io.*;public class No1080&#123; static int N; static int M; static char [][] arr1; static char [][] arr2; public static void change(int a, int b)&#123; for(int i = 0 ; i &lt; 3 ; i++)&#123; for(int j = 0 ; j &lt; 3 ; j++)&#123; if(arr1[a+i][b+j] == &#x27;0&#x27;) arr1[a+i][b+j] = &#x27;1&#x27;; else arr1[a+i][b+j] = &#x27;0&#x27;; &#125; &#125; &#125; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader( new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); N = Integer.parseInt(st.nextToken()); M = Integer.parseInt(st.nextToken()); arr1=new char[N][M]; arr2=new char[N][M]; int result = 0; for(int i = 0 ; i &lt; N ; i++)&#123; arr1[i] = bf.readLine().toCharArray(); &#125; for(int i = 0 ; i &lt; N ; i++)&#123; arr2[i] = bf.readLine().toCharArray(); &#125; for(int i = 0 ; i &lt; N-2 ; i++)&#123; for(int j = 0 ; j &lt; M-2 ; j++)&#123; if(arr1[i][j]!= arr2[i][j])&#123; change(i,j); result++; &#125; &#125; &#125; if (!Arrays.deepEquals(arr1,arr2)) System.out.println(-1); else System.out.println(result); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"https://yangdongjue5510.github.io/tags/greedy/"}],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"11. 카카오 로그인 OAuth2.0 개념","slug":"spring/boot/boot11","date":"2021-09-24T05:25:56.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/24/spring/boot/boot11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/24/spring/boot/boot11/","excerpt":"","text":"실제에는 나라는 사람은 한명인데, 수만은 웹사이트마다 회원가입하면, 인터넷 속 나는 엄청 많아진다…그래서 네이버, 카카오 계정으로 다른 사이트를 사용할 수 있게하자! 장단점 장점 : 인증처리를 우리가 안해도 됨단점 : 각 사이트에서 필요한 정보가 네이버나 카카오 정보에 없을 수도 있음… OAuth (Open Auth)인증 처리를 대신해주는 기능. 인증 처리 과정사용자가 웹서버에서 카카오 로그인 요청을 카카오 API서버로 보낸다.정상 요청이면, 웹서버에 특정 코드를 담아서 콜백한다.웹서버는 해당 코드를 받으면, 해당 사용자가 카카오 로그인에 성공했음을 알게된다. 정보 접근 위임 과정특정 사용자가 카카오 로그인을 통해 인증 됐음을 전제웹 서버에서 카카오로 특정 사용자의 코드를 보내면서 권한을 요청하면,카카오 API서버는 코드를 검사해서 카카오 자원서버로 접근할 수 있는 토큰을 웹서버에 준다.이 토큰은 웹서버가 특정 사용자의 정보로 접근할 수 있도록 한다. 이 과정에서 용어를 정리해야 한다.요청하는 사용자 -&gt; 리소스 오너웹 서버 -&gt; 클라이언트카카오 API서버 -&gt; 인증 서버카카오 자원 서버 -&gt; 리소스 서버 스프링에서 OAuth2.0 스프링에서는 facebook, google을 공식적으로 OAuth를 제공한다.OAuth2 client 라이브러리를 사용하면 쉽게 사용할 수 있다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"21.[블로그 프로젝트] 글 삭제, 수정 구현하기","slug":"spring/blog/blog21","date":"2021-09-21T08:15:36.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/21/spring/blog/blog21/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/21/spring/blog/blog21/","excerpt":"","text":"삭제하기BoardService에 메소드 추가1234@Transactionalpublic void deletePost(int id)&#123; boardRepository.deleteById(id);&#125; ApiController에 메소드 추가하기12345@DeleteMapping(&quot;api/board/&#123;id&#125;&quot;)public ResponseDto&lt;Integer&gt; deleteById(@PathVariable int id)&#123; boardService.deletePost(id); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림&#125; board.js로 버튼 눌렸을 때 요청하기.12345678910111213141516deleteById : function()&#123; //ajax 호출 시 비동기 호출 var id = $(&quot;#id&quot;).text(); $.ajax(&#123; type : &quot;DELETE&quot;, url : &quot;/api/board/&quot;+id, dataType: &quot;json&quot; &#125;).done(function (resp) &#123; alert(&quot;글삭제 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);&#125; detail.js에서 세션 검증 추가123&lt;c:if test = &quot;$&#123;board.user.id == principal.user.id&#125;&quot;&gt; &lt;button id=&quot;btn-delete&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt;&lt;/c:if&gt; principal에 저장된 세션 정보와 게시물의 작성자가 동일할 때만 버튼 생성. 수정일단 버튼을 눌렀을 때 입력받을 수 있는 페이지로 넘어가도록 하자 컨트롤러에 메소드 추가12345@GetMapping(&quot;/board/&#123;id&#125;/updateForm&quot;)public String updateForm(@PathVariable int id , Model model)&#123; model.addAttribute(&quot;board&quot;, boardService.postDetail(id)); return &quot;board/updateForm&quot;;&#125; 모델에 우리가 고칠 포스트의 내용을 넣고, updateForm 페이지를 띄움 updateForm.jsp 구현123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;input type=&quot;hidden&quot; id=&quot;id&quot; value=&quot;$&#123;board.id&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input value=&quot;$&#123;board.title&#125;&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter title&quot; id=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;textarea class=&quot;form-control summernote&quot; rows=&quot;5&quot; id=&quot;content&quot;&gt;$&#123;board.content&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-update&quot; class=&quot;btn btn-primary&quot;&gt;글수정 완료&lt;/button&gt;&lt;/div&gt;&lt;%--summernote--%&gt;&lt;script&gt; $(&#x27;.summernote&#x27;).summernote(&#123; tabsize: 2, height: 300 &#125;);&lt;/script&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 여기서 버튼을 눌렀을 때 작동할 내용을 스크립트에 적자. board.js에 추가하기12345678910111213141516171819202122232425262728293031323334353637383940414243let index = &#123; init : function()&#123; $(&quot;#btn-update&quot;).on(&quot;click&quot;,()=&gt;&#123; this.update(); &#125;); &#125;, update : function()&#123; let id = $(&quot;#id&quot;).val(); let data = &#123; title: $(&quot;#title&quot;).val(), content: $(&quot;#content&quot;).val(), &#125;; $.ajax(&#123; type : &quot;PUT&quot;, url : &quot;/api/board/&quot;+id, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;글수정 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 2개의 데이터를 json으로 변경해 insert요청! &#125;,``` ### 서비스에 메소드 추가```java @Transactional public void updatePost(int id, Board requestBoard)&#123; Board board = boardRepository.findById(id) .orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;글 수정 실패 : id를 찾지 못함&quot;); &#125;); //영속성 로드 board.setTitle(requestBoard.getTitle()); board.setContent(requestBoard.getContent()); &#125; REST 컨트롤러에 메소드 추가12345@PutMapping(&quot;/api/board/&#123;id&#125;&quot;) public ResponseDto&lt;Integer&gt; update(@PathVariable int id , @RequestBody Board board)&#123; boardService.updatePost(id, board); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"20.[블로그 프로젝트] 게시물 상세보기","slug":"spring/blog/blog20","date":"2021-09-21T07:22:05.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/21/spring/blog/blog20/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/21/spring/blog/blog20/","excerpt":"","text":"BoardService에 postDetail 추가하기123456public Board postDetail(int id)&#123; return boardRepository.findById(id) .orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;글 상세보기 실패 : id를 찾지 못함&quot;); &#125;);&#125; findById를 사용하면 쉽게 처리할 수 있다~ 컨트롤러에 메소드 추가123456@GetMapping(&quot;/board/&#123;id&#125;&quot;)public String findById(@PathVariable int id, Model model)&#123; model.addAttribute(&quot;board&quot;, boardService.postDetail(id)); return &quot;board/detail&quot;;&#125; borad&#x2F;detail.jsp 파일을 반환해야 한다. index.jsp 수정하기123456789&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards.content&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;/board/$&#123;board.id&#125;&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; 상세보기를 하이퍼링크로 연결하도록 하자. detail.jsp 만들기12345678910111213141516171819202122&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;button class=&quot;btn btn-secondary&quot; onclick=&quot;history.back()&quot;&gt;돌아가기&lt;/button&gt; &lt;button id=&quot;btn-update&quot; class=&quot;btn btn-warning&quot;&gt;수정&lt;/button&gt; &lt;button id=&quot;btn-delete&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt; &lt;br /&gt; &lt;div&gt; &lt;h3&gt;$&#123;board.title&#125;&lt;/h3&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div&gt; &lt;div&gt;$&#123;board.content&#125;&lt;/div&gt; &lt;/div&gt; &lt;hr/&gt;&lt;/div&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 돌아가기, 수정, 삭제 버튼을 만들고, 모델의 글 제목과 글 내용을 가져온다.(아직 수정과 삭제를 구현하지 않았다. 추후에 해보자.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"19.[블로그 프로젝트] 인덱스 글목록 페이징","slug":"spring/blog/blog19","date":"2021-09-17T04:40:45.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/17/spring/blog/blog19/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/17/spring/blog/blog19/","excerpt":"","text":"서비스 구현 - 컨트롤러 연결 - jsp 수정 BoardService 수정하기123456789101112import java.util.List;//스프링이 컴포넌트 스캔을 통해서 Bean에 자동 등록. IoC를 해줌@Servicepublic class BoardService &#123; @Autowired private BoardRepository boardRepository; @Transactional(readOnly = true) public Page&lt;Board&gt; postList(Pageable pageable) &#123; return boardRepository.findAll(pageable); &#125; //찾아서 페이지에 맞도록 분류하고 페이지 객체로 반환&#125; 페이지 설정을 담은 객체인 Pageable을 인수로 받아, Pageable에 맞도록 데이터를 분류한 Page객체를 반환. BoardController 수정하기123456789101112@Controllerpublic class BoardController &#123; @Autowired private BoardService boardService; @GetMapping(&#123;&quot;/&quot;, &quot;&quot;&#125;) public String index(Model model, @PageableDefault(size=3, sort = &quot;id&quot;, direction = Sort.Direction.DESC)Pageable pageable)&#123; model.addAttribute(&quot;boards&quot;, boardService.postList(pageable)); return &quot;index&quot;; &#125;&#125; 스프링에서 html로 데이터를 가져올 때는 Model이 필요하다.그리고, Pageable에 페이지 설정을 저장해서 인수로 전달한다. model에 서비스에서 수정한 postList를 boards와 함께 속성을 추가한다.그리고 index를 반환해서 뷰리졸버가 index.jsp를 찾아 출력하도록한다. index.jsp 수정12345678910111213141516171819202122232425262728293031323334&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards.content&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt;&lt;%-- 플렉스 성질을 가진 객체를 가운대로 모으기.--%&gt;&lt;%-- 버튼 누를때마다 페이지 이동 --%&gt; &lt;c:choose&gt; &lt;c:when test = &quot;$&#123;boards.first&#125;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number-1&#125;&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number-1&#125;&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test = &quot;$&#123;boards.last&#125;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number+1&#125;&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;?page=$&#123;boards.number+1&#125;&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/ul&gt;&lt;/div&gt;&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; page객체는 해당 페이지가 처음인지를 알리는 first, 마지막을 알리는 last, 내용인 content가 있다.첫 페이지면, previous 버튼을 비활성화하고 마지막 페이지는 next 버튼을 비활성화 한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"6. 네트워크 계층(라우터)","slug":"cs/network/network6","date":"2021-09-17T04:06:01.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/17/cs/network/network6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/17/cs/network/network6/","excerpt":"","text":"a. 네트워크 계층의 목적.세그먼트를 받아서 데이터그램으로 만들고, 각 라우터들이 헤더필드를 검사하여 알맞은 곳으로 데이터를 전달.forwarding : 라우터의 입력부터 출력까지 필요한 기능들routing: 소스로부터 목적지까지의 경로를 결정(routing algorithms) b. Data Plane과 control planedata plane : 라우터가 자신이 가진 정보(routing table, forwarding table)를 활용해 경로 결정하는 기능(routing, forwarding)control plane : 소스-목적지에서 어떤 라우터를 만나게 할 것인가를 결정.(traditional routing algorithms과 software defined networking(sdn)방식 존재) b-1. traditional routing algorithms방식각 라우터마다 가지고 잇는 라우팅 알고리즘이 control plane에서 상호작용하여routing table을 각 라우터마다 만들어낸다.데이터가 각 라우터에 올 때마다, 라우터는 라우팅테이블을 활용해 경로를 결정한다.(data plane) b-2. SDN 방식따로 만들어진 remote controller(control plane에 속함)가 각 라우터(data plane)에 있는 control agents(ca)를 제어. 각 라우터들은 서로 상호작용하지 않음.(중앙집중 방식)flow of datagram : datagram의 집합. 라우터a. 라우터 라우터를 간단하게 도식화한 그림이다.녹색, 청색, 적색 네모가 묶인 것을 네트워크 인터페이스라고 부른다.들어오는 통로를 input ports, 나가는 통로를 output ports라고 부른다.라우팅 프로세서에 의해 스위칭패브릭이 아웃풋 포트를 지정해 보낸다.(포워딩) b. input port fucntions line termination : 라우터의 물리 계층. 전자기 신호를 비트로 바꿔주는 역할data link layer : 데이터들을 모아 한 프레임으로 만듬(프레이밍), 그 외에도 많은 역할.(이더넷도 여기에 포함)ip (빨간색 박스) : lookup, (포워딩 테이블을 보고 포워딩 해야할 곳을 찾는 행위), forwarding, queueing(보낼 정보들을 저장.) *이때 lookup&amp;forwarding은 목적지만 활용하는 경우(destination-based), 헤더의 다른 필드를 활용하는 경우(generalized. sdn) b-1 matching : 현재 내가 전달해야되는 패캣의 헤더에 있는 목적지 주소와 포워딩 테이블을 매칭Longest prefix matching : ip주소를 2진수로 표현하여, 앞부터 하나씩 비교하여, 더 길게 일치하는 것을 선정. b-2. Switching fabric메모리 방식 : 입력값을 메모리에 저장하여 출력 하는 곳에서 읽어들임.버스 방식 : 복도처럼 길을 뚫어놓은 상황. 동시에 여러 곳에서 전송할 수 없음. 대기시간이 길어짐.크로스바 방식 : 스위치를 사용하여 사용할 경우에만 해당 경로에 스위치를 켜서 작동시킴. b-3. input port queuing입력 쪽에서 큐잉을 사용하면 효과적이긴 하지만..Head of the Line(HOL) 블로킹 문제가 생김. 세번째 입력포트에서 초록색 데이터는 자기 앞의 빨간색 때문에 쓸데없이 기다리고 있다.만약 세번째 입력포트에서 초록색과 빨간색을 서로 바꾸면 그런 딜레이는 사라질 것. c. output ports input port랑 거꾸로 작동한다고 생각하자.output queuing은 congestion을 일으킬 수 있고 delay나 lost가 생길 수 있다.queuing은 저장한 데이터를 순서를 정해 내보낼 수 있다.(스케줄링) c-1 Scheduling mechanisms, priority버퍼가 얼마나 찼을때 어떤 걸 버릴 것인가, 어떤걸 언제 보낼 것인가를 정함priority scheduling :우선순위에 따라 버퍼를 여러개 운영하여 우선순위를 먼저 보냄. Round Robin scheduling : 온 순서대로 하되, 한쪽 데이터만 보내지 않고 골고루 보내는 방식 Weighted Fair Queuing : Round Robin을 기반으로 하되, 데이터들을 가중치를 부여하여 차이를 두는 방식","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"5. 수송계층","slug":"cs/network/network5","date":"2021-09-16T13:03:49.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/16/cs/network/network5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network5/","excerpt":"","text":"a. 수송 계층 ex. TCP, UDP일반적으로 교환 노드에는 존재하지 않음.(방화벽 같은 예외가 있다.)엔드 시스템에만 존재 보낼 때 조각으로 나눠서 각 조각마다 헤더를 붙여서 보낸다.받을 때는 순서대로 받지는 않는다. 받는 쪽이 수송 계층을 통해 순서를 파악한다. b. 수송 계층 vs 네트워크 계층네트워크 계층 : 어떤 경로로 메시지를 전달할 것인가수송 계층 : 도착한 메시지를 어떤 프로세스로 처리할 것인가.(프로세스들은 포트번호로 구분한다.) c. 인터넷 수송 계층 프로토콜순서대로 전달, 높은 신뢰성(오류 제어)(TCP)-순서 없이 오거나, 잘못된 메시지가 오거나(비트오류),-아예 도중에 메시지가 잃어버리거나, 같은 메시지를 여러번 받거나…=&gt;TCP는 이를 해결할 능력이 있음.순서 없이 전달, 낮은 신뢰성(UDP)두 기능 모두 속도나 딜레이를 보장하지 못한다. d. 멀티플렉싱&#x2F;디멀티플렉싱 프로세스가 소켓을 통해 요청을 전달하는데,요청들을 하나로 적절한 헤드로 담아 전달한다. 이를 멀티플렉싱이라 한다.이렇게 전달된 헤더를 해석하여 적절한 행동을 하는 것을 디멀티플렉싱이라 한다.디멀티플렉싱은 목적지 수송지 포트 넘버를 통해 어떤 프로세스에 전달해야할지를 파악한다. UDP의 경우(disconnection demux) : 목적지의 포트넘버를 파악해서 포트와 연결된 소켓으로 UDP세그먼트를 전달TCP의 경우(connection-oriented demux) : 소스 ip, 소스 포트넘버, 목적지 ip, 목적지 포트넘버가 모두 일치해야 전달 e. UDP중간 손실이나 순서가 달라져도 특별한 액션을 취하지 않는다.connectionless의 특징.받는 쪽의 프로세스가 작동 중인지 확인하지 않음(no handshaking)(연결설정을 위한 초기지연이 없다)UDP 세그먼트들은 각자 독립적으로 다뤄진다.(세그먼트들이 같이 온 세그먼트인지 관심x)ex. DNS, SNMP 비트 손상에 민감하지 않지만 딜레이에 민감한 어플리케이션에 자주 활용(비디오, 오디오 스트림)신뢰성 향상을 위해서는 어플리케이션 계층에서 해결해야 한다.헤더가 단순한 구조. 사이즈가 작고 구현이 쉬움 f. UDP 헤더32비트 2개이므로 8바이트.length는 헤더를 포함한 UDP 세그먼트의 바이트 길이.checksum는 오류 발생을 확인sender는 자기가 보낸 메시지를 특정 알고리즘의 결과값과 같이 보내고,receiver는 자기가 받은 메시지를 특정 알고리즘에 넣은 결과값과 같이 온 결과값을 비교하여 오류를 검증1의 보수 연산을 통해 메세지의 합과 알고리즘 결과값의 합이 0이 되는 결과값을 반환.1,2,3,-6 &#x3D;&gt; 0,3,3,-6으로 오는 경우 오류가 발생했지만 checksum으로는 못잡아낼 수 있다. RDTa. 신뢰성있는 데이터 전송의 원칙패켓에 있는 헤더의 특정 정보를 해석을 통해 정보가 제대로 왔는지 확인한다.먼저 어플리케이션 계층에서 수송계층의 RDT의 rdt_send()를 요청하면RDT에서는 정보를 패캣으로 나눠 담고이를 네트워크 계층의 unreliable channel에게 udt_send() 요청을 하게 된다.네트워크를 거쳐 정보가 수송계층에 도착하게 되면 rdt_rcv()요청이 이뤄지고,패캣의 헤더 부분을 실행하고 문제가 없으면 데이터만 꺼내서 deliver_data()요청으로 어플리케이션에게 전달한다. b. FSM (Finite State Machines)로 rdt 프로토콜 기술state : 프로그램이 실행되는 단계화살표 : 프로그램의 상태 변화event : 언제 상태변화가 이뤄지는가action : 상태변화에 따라 프로그램이 수행할 동작 c. rdt 1.0 (오류 없는 상황 가정)비트오류도 없고, 패캣 손실도 없고, out of order(순서오류)도 없다고 가정.수송 계층의 부분만 표현. d. rdt 2.0 (비트오류가 발생할 수 있는 경우)receiver가 재전송을 요구하거나(ARQ), 원본을 추측하여 수정해 사용한다.(FEC)ARQ방식이 일반적.리시버는 ACKs나 NAKs를 센더에게 반환한다.acknowledgements(ACKs) : 문제없음.negative acknowlegements(NAKs) : receiver가 특정 패캣에서 문제 확인&#x3D;&gt;재전송요구. e. rdt 2.1하지만 데이터가 아닌 컨트롤 메시지(ack, nak)에 문제가 생기면??센더는 이런 문제를 알아차리지 못함. 이를 막기 위해 센더가 각각의 패캣에 시퀀스 번호를 붙여서 보낸다.(짝수번일땐 0, 홀수번일땐 1)리시버는 동일한 번호로 오는 패캣을 버리는 방식으로 운용하게 된다.이를 stop and wait(보내고 응답기다리고 응답오면 보내기이라 한다. f. rdt 2.2rdt 2.1에서 NAK를 안쓰고 ACK만 쓰는 것(기능적으로는 동일)ACK를 보낼때 시퀀스번호를 같이 보내는 방식으로 운용 g. rdt 3.0 (패캣 손실이나 오류 발생할 경우)센더가 패캣을 보내고 타이머를 통해 ACK가 오지 않을 경우 재전송.rdt 3.0은 오류 처리에는 탁월하지만, 성능이 문제다. 리시버의 신호를 기다리는 동안 회선을 낭비하는 셈.따라서 이런 낭비를 막기위해서는 pipelined protocol. 즉 ack를 받지 않고 데이터를 여러번 보내는 프로토콜이 필요하다. h. Pipelined protocolACK를 받지 않고도 다음 패캣을 보냄 n개의 패캣을 ACK없이도 보내되, ACK가 안오면 다시 재전송해야되므로,센더는 ACK가 모두 올 때까지 패캣을 send buffer에 저장하고 있어야한다. h-1. Go-back-NACK를 반환할 때 ACK의 시퀀스 끝번호에 해당하는 ACK만 보냄(3개의 패캣을 받으면 3번 ACK만 보냄)(그렇다면 3번까지의 패캣은 잘 전송됐음을 의미) 센드버퍼(윈도우 사이즈)에 ack없이도 보낼 수 있는 패캣들이 존재하고,보냈지만 ack를 아직 받지 않은 패캣 중 가장 오래된 패캣의 순서 번호를 send_base.아직 보내지 않고 대기 중인 패캣 중 가장 빠른 패캣의 순서 번호를 nextseqnum.센더는 ACK를 받지못한 패캣 중 가장 오래된 패캣(send_base)을 기준으로 타이머를 설정함타이머가 만료되면(오랫동안 ACK가 안오면,) ACK를 받지못한 패캣 모두를 재전송한다. 리시버는 오류 없이 순차적으로 받은 패캣 중 시퀀스 넘버가 가장 큰 값을 ACK로 보낸다.expectedseqnum만 변수로 저장.순서에 맞지 않은 패캣은 그냥 버려버리고 ack를 다시 보내줌(버퍼 없음) h-2. Selective RepeatGBN의 불필요한 패캣 버림을 줄이고, 필요한 경우만 재전송하는 방식으로 효율성을 높임 GBN과 다른점은 리시버도 윈도우사이즈(버퍼)를 갖는다는 점.ACK를 반환할 때 개별적으로 반환.센더는 ACK를 받지 못한 개별적인 패캣으로 타이머를 설정.리시버는 전달받지 못한 패캣 시퀀스를 기억하고 있고 센더는 각 패캣의 타이머에 따라 패캣을 다시 보낸다. h-2-1 Selective repeat dilemma(GBN에서도 발생) 만약 시퀀스 넘버를 0,1,2,3으로 채택해 사용한다고 가정.(2비트일때 표현 가능한 수가 0123)윈도우 사이즈는 자연스럽게 3 마지막에 센더가 재전송한 pkt0을 리시버가 4번째 패캣으로 받아들일 문제가 생긴다!!!이것을 해결하려면 윈도우 사이즈를 줄여야한다.=&gt;시퀀스 넘버에 쓰이는 비트 수 &#x3D; n일때, 윈도우 사이즈는 2^(n-1)=&gt;2비트인 경우, 윈도우 사이즈는 2로 해야함=&gt;GBN의 경우 2^n-1 TCPa. TCP의 특징 간단요약point to point : 한 리시버와 한 센더가 참여.신뢰성(rdt지원), in order 지원pipelined 형식(버전에 따라 gbn, selective 형식 지원)센드 버퍼와 리시브 버퍼 존재한 연결에서 양방향 데이터 흐름connection oriented(handshaking) 센더와 리시버의 상태정보를 기억.flow controlled 처리 속도보다 전송 속도가 빠를 경우 속도를 조절. b. TCH 헤더 sequence number, ack &#x3D;&gt; rdt에 사용되는 기능시퀀스 번호와 ack는 바이트 단위당 1씩 늘어간다.head len(head length) : 디폴트 헤드 20바이트 + option의 길이를 확인. option의 존재 유무 파악UAPRSF &#x3D;&gt;모두 1비트(0과 1 값만 가질 수 있음)U 잘 안쓰임.A ack가 유효한가?P 잘 안쓰임.R reset. 연결리셋 연결강제종료S sync. 연결F final. 연결종료recieve window : 리시버가 현재 받을 수 있는 데이터 량. 플로우컨트롤에 활용check sum : udt에서 check sum과 동일한 기능urg data pointer : 잘 안쓰임option : 있을 수 있고 없을 수도 있는 가변기능(특별한 경우 아니면 잘 안쓰임) c. TCP timerTCP는 데이터에 대한 ack가 정해진 시간내에 오지 않으면 보낸 패캣을 재전송한다. 이때 정해진 시간을 재는 타이머를 너무 길게, 너무 짧게 설정하면 피해를 본다길게 하면, rtt(데이터가 전송되고, ack가 오는 데 걸리는 시간)이 끝나도 다른 패캣을 보내지 않기 때문에 시간적인 손해를 본다.짧게 하면, 정상적으로 ack가 오고 있는데 패캣을 재전송하는 불필요한 작업을 하게 될 수 있다. TCP는 timer를 여유있게 하는편.SampleRTT(측정값)를 다 모아 정규분포 95%의 신뢰도로 타이머를 설정. 하지만 매번 SampleRTT는 매번 달라져 정규 분포 모양이 달라짐.&#x3D;&gt;SampleRTT 수집방식은 사용할 수 없음.대신 exponential weighted moving average를 사용 EstimatedRTT (특정 시점에서의 RTT의 가중평균)를 통해 대략적인 평균 RTT를 예상. 이를 활용해서 타이머는 EstimatedRTT에 약간의 여유를 줘서 준다.여기서 약간의 여유는 DevRTT(분산값)을 이용한다.즉 TimeoutInterval &#x3D; EstimatedRTT + 4*DevRTT로 한다. a. TCP의 rdt(신뢰성 있는 데이터 전송)TCP는 ip의 위에서 rdt 서비스를 제공한다.(ip는 신뢰성 없음)​-pipelined 방식 사용(gbn selective 선택 사용)-cumulative ack(누적 ack 방식 사용)-보냈는데 ack를 받지 못한 패캣에 해당하는 타이머 하나를 운용​ b. TCP sender​초기에 NextSeqNum과 SendBase를 초기화.상위 계층이 데이터 전송을 요구할 때, nextseqnum에 해당 되는 데이터를 세그먼트 생성하고,nextseqnum을 생성된 데이터 만큼 뒤로 보내고 타이머 실행. 타이머가 다 되면,​보냈는데 ack를 못받은 데이터 중 시퀀스 넘버가 가장 작은 놈을 다시 보내고 타이머 재시작.ack를 받으면 sendbase를 ack까지 옮김만약 아직 받지 못한 ack가 있다면 타이머를 시작하고 그렇지 않으면 타이머 종료​ c. TCP ack generation event at receiver TCP receiver action 예상한 패캣이 오고 해당 패캣 이전까지는 ack 보냈음 혹시 다른 패캣이 올지 모르니 500ms 기다린 후 안오면 해당 ack를 보냄. 예상한 패캣이 왔는데 해당 패캣 이전에 ack를 안보낸 패캣이 있음 즉시 cumulative ack(누적ack)를 보냄 예상한 패캣보다 시퀀스 번호가 큰 패캣이 온 경우(gap detected) 바로 중복된 ack를 보냄.(지금까지 잘 받은 ack, 리시버가 기다리는 시퀀스 넘버이기도.) 갭을 채우는 패캣이 왔을때 바로 해당 ack를 보냄 ​ d. TCP fast retransmit타이머가 커질 수록 재전송할 때까지 기다리는 시간이 길어지게 된다.=&gt;이런 시간을 줄이려는게 fast retransmit 센더가 여러 세그먼트를 계속해서 보낼 때, 만약 어떤 세그먼트가 없을 경우 리시버는 동일한 ack를 중복해서 계속 보내게 된다.​이럴 경우 센더가 세번의 중복 ack를 받을 경우​타이머를 기다리지 않고 ack를 받지 못한 시퀀스번호가 가장 작은 세그먼트를 바로 재전송한다.​ e. TCP flow control센더가 보내는 양이 리시버가 처리하는 양보다 너무 많으면 이를 조절하는 기능​리시버는 헤더의 receiver window라는 곳에 현재 TCP 리시버 버퍼(RcvBuffer)에남은 공간(rwnd)이 얼마나 있는지를 작성해서 ack에 담아 전송함.​​ e. TCP connection management리시버와 센더가 서로간의 상태정보(초기 시퀀스넘버, 센더버퍼 사이즈, 리시버버퍼 사이즈)를 연결을 시작할 때 서로 교환하지만 TCP는 2way handshaking을 사용하지 않음=&gt; 응답을 보내고 대답을 듣는 시간이 가변적임.​리시버의 재전송시간이 센더의 타이머보다 늦다보니, 센더가 연결 요청을 다시보내게 되고,다시 보내게 된 연결에 따라 data를 전송하게 된다.(x를 보내야 되는데 x+1을 보내게 됨)이렇게 데이터를 전송한 이후 연결을 닫으면 재전송한 연결요청의 답을 들을 수 없게 된다.그래서 TCP는 3way handshaking을 함​​헤더에 있는 syn을 통해 연결 유무를 판단하고, 양방향 연결을 함.(x,y는 임의의 값)이때 acknum&#x3D;x+1은 비록 연결요청에는 데이터 값이 없지만, 요청 자체가 1비트라고 여겨서 acknum에 +1된것.3 way handshaking은 연결을 닫을 때도 특이하다.​​클라이언트가 먼저 연결을 종료한다고 가정한 상황이다.헤더에 있는 fin을 활용해 연결 종료 의사를 밝힌다.이것이 전달되면 서버도 ack를 통해 클라이언트의 연결 종료 의사를 확인한다.(이때 중요한 건 서버 쪽은 연결을 종료하지 않았다는 것이다. 단지 클라이언트가 연결, 즉 전송을 종료했을 뿐이다.)​그리고 마지막으로 서버도 종료 의사를 전달하여 클라이언트가 받았을 때 클라이언트는 잠시동안 대기한다.왜냐면 클라이언트가 보낸 종료ack가 서버에 잘 전달 안됐을 수 있기 때문이다.(잘 전달되지 않으면 서버는 종료의사를 다시 재전송하게 된다.) TCP 혼잡제어a. 혼잡혼잡의 원인 : 라우터에 들어오는 양이 처리량보다 더 커서. 딜레이가 길어지고, 패켓을 잃을 수 있음.라우터의 버퍼가 무제한이라고 가정하면. 데이터 전송이 계속 커질 수록, 데이터 전송 능력(throughput)능력은 같이 오르다가 한계 이후는 정체된다.하지만 현실엔 다름(라우터 버퍼가 유한함)실제로 유효하게 받은 데이터 처리량을 goodput이라고 한다. 혼잡이 발생하면 라우터에서 로스가 발생-수신자가 재전송-이럴 경우 재전송 데이터는 goodput에는 포함되지 않음.즉 혼잡이 발생하면 goodput과 throughput이 차이가 나게 된다! 여러 센더가 라우터들을 공유하면서 정보를 전송할 때g호스트 D가 B를 향해 데이터를 주고, A가 C를 향해 데이터를 전송한다고 가정.이때 R1라우터를 같이 사용하게 된다. 이때 A가 데이터 전송량을 늘리게 되면? B가 받는 정보량이 줄어들게 된다. 그리고 R1에서 생긴 패캣로스를 다시 재전송하게 되면 R4는 억울하게 정상적으로 했던 일을 다시 또 하게된다.이를 upstream trasmission cpacity의 낭비라고 한다. b. 혼잡 제어TCP의 혼잡제어는 해당 라우터를 사용하는 모든 참가자가 다같이 속도를 내리는 방식. b-1. additive increase multiplicative decrease AIMD방식congestion avoidance 상태에서 적용(전송이 어느정도 진행되고 있을 때 너무 많은 데이터전송을 막음)센더는 네트워크의 혼잡도를 잘 모르니 작은 데이터 먼저 한번 보내보고, 잘 보내졌음을 알게되면, 더 많은 데이터를 보내보고,이 또한 잘 보내졌으면, 더욱 많은 데이터를 보내고…(딜레이나 로스가 발생하게 되면 전송률을 낮춰서 다시 반복) 센더는 cwnd(혼잡제어 방식에 있어서 보낼 수 있는 데이터량), rwnd(플로우컨트롤에 의해 보낼 수 있는 양)), sender widow(rdt에서 보낼수 있는 데이터량) 중 가장 작은 값만큼 데이터를 보내기로 정한다. TCP sending rate &#x3D; cwnd&#x2F;RTT(대략적으로) b-2. TCP slow startslow start는 센더가 맨 처음 데이터를 한 세그먼트만 보내보는 것을 의미.잘 보내졌으면 두 세그먼 트를, 그 다음엔 네 세그먼트를… 이런식으로 2^n를 하며 전송 데이터를 늘려감.이렇게 데이터를 늘려가다가 혼잡하게 되면, AIMD로 제어. 초기엔 cwnd&#x3D; 1 mss(최대로 보낼 수 있는 세그먼트량)매 RTT마다 두배로 늘림. c. 데이터 전송 줄이기timeout이 발생하거나, 중복된 ack가 세번오면 로스로 간주한다.timeout이 발생 시(TCP Tahoe, 구버전), 전송량(cwnd)를 1mss로 재설정함. 다시 slow start 과정을 진행시킴.slow start 이후로 어떠한 임계값(threshold, 정해진 변수)보다 전송량이 커지게 되면, 선형적으로 증가함.TCP Tahoe는 항상 cwnd를 1mss로 만듬(다른 방식을 지원 안하니..)중복 ack가 세번 온 경우(TCP RENO , 신버전), 전송량(cwnd)를 절반으로 낮춤. 그리고 나서 선형적으로 증가(slow start)아님. 상태 이벤트 TCP 센더 대응 비고 Slow Start(SS) 전에 보낸 데이터의 ack를 정상적으로 받음 cwrd가 threshold보다 큰 경우 CA로 변환 매 RTT마다 cwrd를 두배로 Congestion Avoidacne(CA) 전에 보낸 데이터의 ack를 정상적으로 받음 매 RTT마다 cwrd를 1 mss씩 증가(additive increase) SS or CA 중복된 ack를 세번 받음 (로스 감지) threshold를 cwrd의 절반으로 cwrd를 threshold로 하고 CA로 변환 Fast Recovery(threshold부터 증가) SS or CA timeout(로스 감지) threshold를 cwrd의 절반으로 cwrd를 1mss로 하고 slow start 상태로 전환 slow start 진행 SS or CA 중복된 ack duplicate ack 카운트만 증가 cwrd나 threshold는 변경 안함 d. TCP throughputthroughput &#x3D; 시간당 전송률TCP의 throughput은 복잡하므로 간단한 가정이 필요. slow start 상태는 제외, 항상 보낼 데이터가 존재함을 가정. w&#x3D;로스가 발생할때 cwrd평균 cwrd는 3&#x2F;4w평균 throughput은 3w&#x2F;4rtt이때 가정을 제외하고 현실적인 Throughput은 이때 L은 로스 발생 확률이다. e. TCP Fairness TCP는 여러 사용자가 라우터를 이용하면 결과적으로는 동일한 양의 리소스를 사용하게 된다.두 TCP사용자가 한 라우터를 이용하고, 라우터의 처리양이 100이라고 할 때,(60,20)-전송량 증가-(80,30)-로스발생(값 절반으로 나눔)-(40,15)….이런식으로 가면 결국 (50,50)이됨. e-1 TCP Fairness의 한계UDP와 라우터를 공유하는 경우-UDP가 자원을 더 가져갈 수 있음! TCP를 여러개 사용할 때(여러 프로세스 사용)-여러 TCP를 운용하는 호스트가 자원을 더 가져갈 수 있음! e-2 Explicit Congestion Notification혼잡이 아닌 다른 경우에 ack를 받지 못하는 경우도 존재한다.근데 이런 경우에도 속도를 줄이는 것은 비효율적! 이를 해결하기 위해 네트워크에서 혼잡을 일으킨 호스트에게 혼잡임을 알리게 하자.IP헤더의 Tos필드에 혼잡여부를 기록해서 센더에게 전달! 하지만 많이 사용되지 않음(모든 라우터가 이 기능을 갖춰야하기때문에..)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"4. 어플리케이션(쿠키, 캐쉬, DNS, CDN, 이메일)","slug":"cs/network/network4","date":"2021-09-16T12:44:47.000Z","updated":"2022-01-22T16:20:00.030Z","comments":true,"path":"2021/09/16/cs/network/network4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network4/","excerpt":"","text":"a. 쿠키 User-server state : cookies서버가 유저의 상태를 기억하기 위한 쿠키(주문내역 등)맨 처음 유저가 브라우저로 사이트를 방문할 경우 생성이후 해당 브라우저로 사이트 방문시 쿠키를 통해 특정 액션을 취함. b. 쿠키의 네가지 구성요소1. HTTP 응답메시지에 있는 쿠키 헤더라인2. 다음 HTTP 요청 메시지에 있는 쿠키 헤더라인3. 사용자의 브라우저가 관리하는 쿠키파일4. 웹사이트의 백엔드 데이터베이스하지만 보안 상의 위험이 존재. c. 웹 캐쉬(프록시 서버)목적 : 클라이언트의 요구가 근본 서버에 관여하지 않고 안정화하자.(origin server가 클라이언트와 거리가 멀 경우..)프록시 서버(캐쉬)에 주변 클라이언트가 자주 사용하는 데이터를 저장해놓음만약 프록시 서버에 없는 내용을 클라이언트가 요구할 경우,프록시 서버는 origin서버에 해당 데이터를 요구캐쉬는 클라이언트와 서버의 역할을 모두 수행캐쉬 사용 시 응답 시간을 줄이고, 액세스 링크의 트래픽을 줄임 d. Conditional GET캐쉬나 클라이언트에 컨텐츠가 있는 상황에서오리진 서버의 컨텐츠가 변경되었을 경우 동기화를 하기 위한 기능if-modified-since 로 request해서 변경된 데이터를 요구할 수 있다.변경된 값이 존재할 경우 200(OK), 그렇지 않을 경우 304 Not Modified e. E-mail세가지 큰 요소 유저 에이전트-메일서버-SMTP(simple mail transfer protocol)유저 에이전트: 메일을 읽고 , 수정 수행. 서버에 저장된 메시지를 가져오거나 보냄.메일 서버 : 유저로부터 메일을 받음. 보낼 메일들을 메세지 큐에 담음.SMTP : 메일 서버 간 연결해주는 역할 f. SMTPreliably transfer를 위해서 TCP를 이용. 포트 번호 25번direct transfer : 서버끼리 통신은 직접한다.transfer는 세가지 단계를 거친다 (handshaking-transfer-closure)메세지는 반드시 7비트 ASCII코드로 이뤄져야한다.SMTP는 persistent연결을 사용메세지 종료는 마침표(.)로 결정. g. HTTP와 SMTP의 비교HTTP는 클라이언트의 요구를 서버가 응답하는 것(pull)SMTP는 클라이언트의 데이터를 서버가 받아 저장하는 것(push) 둘 다 ASCII 커맨드&#x2F;응답 상호작용과 status code를 사용.HTTP는 매 오브젝트를 캡슐화해서 하나의 응답 메시지로 보냄SMTP는 여러 오브젝트를 한번에 싹 가져온다. h. 메일 메세지 포맷 i. 메일 액세스 프로토콜-메일 서버에 직접 접근하지 않고 내 pc에서 처리하는 프로토콜-pop3 : 권환확인, 메시지 불러오기, 메시지 삭제 등 지원download and delete (서버에서 불러오면 서버는 비움)download and keep (삭제해도 복사본을 서버가 갖고 있기) -imap : 서버에서 모든 메시지를 보관, 클라이언트가 접속해서 사용동기화에 유리, 메시지 중 일부만 보기 가능. DNSj. DNS : domain name system각각의 노드들을 식별하기 위한 id가 필요하다.대표적인 예시로 ip 주소(32비트)를 활용한다.www.something...com이라는 는 주소로 들어갈 경우DNS가 이 도메인주소를 ip주소로 변환하여 컴퓨터들이 인식할 수 있게한다.분산데이터 : 계층적인 구조를 갖는 네임서버들어플리케이션 계층 프로토콜 : UDP를 사용 k. DNS : serviceshost aliasing : 실제 이름을 줄여서 사용할 수 있게 해준다.예를 들어 www.abcd.ef...com을 www.abcd.com 으로도 접속 가능하게 지원한다. mail server aliasing : 메일서버도 별명을 활용할 수 있다.load distribution : 하나의 웹서버가 모든 요청을 다루기 보다 여러 웹서버가 나눠서 다루는 게 효과적.하나의 도매인에서 여러 ip로 나타내게 하여 요청을 나눠서 다룰 수 있음. 왜 DNS는 분산 형식을 가질까?하나로 모았을 경우 DNS 하나가 망가지면 모두 접속하기 어려워짐한 DNS에 너무 많은 트래픽이 몰림유지보수에도 불리 l. DNS : 계층구조예시. amazon.com을 입력했을 경우1. Root DNS 서버가 TLD DNS 서버 중 com DNS 서버를 찾아 전달2. com DNS 서버는 amazon.com의 DNS 서버를 찾아줌3. amazon.com DNS 서버는 해당 ip를 찾아줌그 외로 local DNS name 서버가 있음.-사용자와 근접하게 작동. 계층 구조에는 포함 안됨.-사용자가 어떤 도매인을 입력하면 해당 도매인에 캐쉬가 있는지 확인하고-있으면 해당 ip를 반환하고, 없을 경우 프록시로 동작하여 쿼리를 계층구조로 요청을 보냄 n. DNS 작동 방식iterated query : local DNS 프록시 역할로 여러 서버와 연결 recursive query : local DNS가 계층 구조에 일을 넘김 m. DNS 캐싱이전에 접속했던 쿼리에 대한 ip를 일정기간동안 기억하고 있다.일정 기간(TTL) 이후 해당 매핑을 지운다.자주 방문하는 쿼리의 TLD서버를 local name 서버가 캐시해놓는다. o. DNS 레코드RR : DNS에 저장되는 데이터의 형식RR format: (name, value, type, ttl)type에 따른 형식 변화-type&#x3D;A : name은 호스트이름, value는 ip주소-type&#x3D;NS : name은 도매인주소, value는 authoritative name server의 호스트이름-type&#x3D;CNAME : name은 alias name(별명), value는 canonical name(원래 이름)-type&#x3D;MX : name은 메일서버의 alias name, value는 canonical name p. DNS 프로토콜identification : 어떤 query에 대한 응답인지를 구분해주는 역할flag : QR(1비트) : 쿼리인지 응답인지Op code(4비트) : 0(일반적인 쿼리 혹은 응답), 1(inverse query), 2(서버 상태 요청), 4(주의), 5(업데이트) q. DNS에 새로운 레코드 삽입-DNS reigistar 사업자에게 도매인과 해당 ip를 매핑 P2Pr. pure P2P 구조-항상 켜져있는 서버가 존재하지 않음-end system 끼리 직접 통신하게 된다.-이 end system을 peer라고 부른다.-한 서버가 여러 end system에게 전송하는 거 보다 end system끼리 자료를 주고 받게 하는 P2P가 더 확장성이 있음. s. Bit-torrent파일을 256kb의 청크로 나눠 peer들 끼리 청크를 주고 받는 형식traker는 피어들이 누구인지, 누가 참여하고 있는지를 추적하는 장치.만약 새로운 피어가 들어왔을 때 이 피어는 트래커를 통해 어떤 피어와 연결해야하는지를 알 수 있다.청크는 내 이웃 피어들에게서 가져오는데, 이때 청크는 가능한 희귀한(피어들이 덜 가지고 있는) 청크를 가져온다.청크를 보내는 기준은 나에게 많은 청크를 보내준 피어에게 청크를 보내주는 식이다.10초마다 청크 수송신 상황을 점검하고, 30초마다 랜덤한 피어에게 무조건으로 청크를 보내준다. CDNt. DASH (Dynamic, Adaptive, Streaming over HTTP)서버에서는 비디오 파일을 여러개의 청크로 나누고청크들을 여러 방법으로 인코딩하고 저장 manifest file : 다양하게 저장된 청크들이 어디에 저장됐는지(URL) 알려주는 파일 클라이언트에서는 서버-클라이언트 대역폭(다운로드 속도)을 측정해서속도에 따라 manifest가 적당하게 인코딩된 청크 위치를 찾아 보내준다. u. CDN지역적으로 여러개의 서버를 두고 중앙서버로 연결.enter deep : 네트워크 엣지에 CDN을 설치하는 방법. 유저와 가깝고 성능도 좋지만..CDN의 수가 많아지고 관리하기도 힘들다 bring home : 네트워크 엣지가 아닌 ISP코어에 저장하는 방법","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"3. 어플리케이션 계층","slug":"cs/network/network3","date":"2021-09-16T12:31:20.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network3/","excerpt":"","text":"a. 네트워킹 어플리케이션 제작서로 다른 엔드시스템에서 네트워크를 통해 소통하며 작동한다.일반적으로 네트워크에 대해 몰라도 어플리케이션 제작 가능 b. 클라이언트-서버 구조서버 : 항상 연결, 영구적 IP주소, 더 많은 양을 처리하기 위해선 데이터 센터 구비클라이언트 : 간헐적으로 연결, 다이나믹 IP주소 사용(위치에 따라 변경), 직접 통신하진 않음. 통신의 시작 c. P2P(peer to peer) 구조항상 연결된 서버가 없는 구조.엔드시스템끼리 직접 통신 가능자가확장성(self-scalability) : 더 많은 peer가 참여하면 처리 능력도 높아진다.peer들이 연결됐다가 해제됐다가 빈번. 관리 어렵고 IP주소가 자주 바뀜 d. 프로세스어플리케이션 프로그램이 호스트에서 실행되는 것을 프로세스라 함.동일한 호스트 내에서 두 프로세스가 소통할 때 : inter-process communication다른 호스트끼리 프로세스들이 소통할 때 : exchanging messages e. 소켓소켓은 쉽게 API로 이해하자.소켓은 어플리케이션 하위 계층(네트워크 링크…)를 몰라도 호스트끼리 연결될 수 있게 돕는다.메세지만 내가 작성하고 나머지 연결하는 일은 소켓이 한다. f. 포트넘버IP는 호스트의 위치를 나타내는 주소라고 했다.그런데 호스트에도 다양한 프로세스가 존재하는데내가 받은 메시지가 어떤 프로세스에 줘야하는 지는 포트넘버를 통해 이뤄진다. g. 어플리케이션 프로토콜의 역할헤더의 메시지 타입 정의(request인지 response인지)메시지의 어디까지를 헤더로 하고 어디까지를 페이로드로 정할지.(필드 지정)메시지의 정의(100110를 request로 정의하자..)언제 어떻게 메시지를 보내고 답변하는 규칙 수립 h. 어플리케이션 프로토콜의 종류오픈 프로토콜 : RFC에 정의된 프로토콜, 상호연동성 확보, ex.http, smtp사설 프로토콜 : 서비스만하고 프로토콜은 공개하지 않는 경우 ex.스카이프… i. 어플리케이션이 필요로 하는 요소1. data integrity : 정확한 메시지 전달해야 하는지, 그 정도는 아닌지를 파악2. timing : 딜레이가 낮은 것이 중요한지(실시간 게임)3. throughput(bps) : 일정한 속도로 전송받아야 하는지 (스트리밍 서비스)4. security j. TCP UDP 간단하게 알아보기TCP는 data integrity를 제공그 외는 제공하지 않으므로 어플리케이션에서 해결해야 한다.(ex.버퍼링)UDP는 data integrity를 미제공 k. SSL보안을 담당하는 어플리케이션 SSL수송 계층(TCP, UDP)에서는 보안을 지원하지 않아서 SSL같은 어플리케이션에서 해결해야 한다. l. webweb : HTML 베이스, 여러가지 오브젝트 포함URL을 통해 식별(http://www.someschool.edu(호스트이름)/someDept/pic.gif(패스이름)) n. httphttp : hypertext transfer protocolTCP를 사용. 포트번호 80번을 사용.stateless &#x3D;상태를 기억하지 않음=서버는 클라이언트를 기억하지 않는다. 이전에 통신됐던 클라이언트도 기억해내지 못한다. m. http 종류non-persistent HTTP연결할 때 하나의 오브젝트만 TCP를 통해 전달할 수 있음여러개의 오브젝트를 전달하려면 여러번 연결을 해야함 persistent HTTP한 TCP연결로 여러 오브젝트를 보낼 수 있음 o. http 연결RTT &#x3D; 패캣이 클라에서 출발해 서버를 거쳐 다시 클라로 올 때 걸리는 시간. HTTP 연결하려면..초기 TCP연결을 위한 최초 RTT요청 HTTP와 응답 HTTP2RTT(persist HTTP)2RTT+file transmission time(non-persist HTTP) p. HTTP 요청 메시지ASCII 형식에 따름.헤더예시 일반적인 헤더 모양 q. 업로딩 형식 입력method 부분에 어떤 것이 오느냐에 따라 달라진다.POST method : input을 entity body에 넣어서 전달GET method(URL method) : input을 request line의 URL에 넣어서 전달(겟 메소드를 사용시 주소창에 ?와 &amp;이 생김) r. 메소드 타입HTTP&#x2F;1.0 : GET, POST, HEADHTTP&#x2F;1.1 : GET, POST, HEAD, PUT, DELETE s. HTTP 응답 메시지 t. HTTP 응답 상태 코드첫번 째 줄 두번째 요소를 담당.OK(200) 요구 전달완료. 요구한 오브젝트가 있음Moved Permanently(301) 요구한 오브젝트가 이동되었음. 해당 위치를 담았음Bad Request(400) 서버가 요구 메시지를 이해하지 못했음Not Found(404) 요구 문서를 서버에서 찾을 수 없음505 HTTP Version Not Supported","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"2. 프로토콜","slug":"cs/network/network2","date":"2021-09-16T12:24:09.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network2/","excerpt":"","text":"a. 프로토콜 레이어각 레이어는 순차적으로 서비스를 진행.보내는 쪽에서는 상위-하위 계층 순, 받는 쪽에서는 하위-상위 순으로 진행된다.상위 계층은 하위 계층에게 서비스를 요청, 하위 계층은 상위 계층에게 서비스 제공.이때 보내는 쪽과 받는 쪽이 같은 계층에 위치한 레이어끼리는 peer라고 부른다.각 peer끼리는 헤더와 페이로드를 공유. 헤더에는 송수신지의 내용이 담겨있음. b. 왜 레이어링을 사용하는가복잡한 시스템을 유지보수하기 유리함.한 레이어를 바꾼다고 해도, 다른 레이어에는 큰 영향을 안줌.레이어링은 계층들이 가장 근접한 계층들끼리 서비스를 요청하고 제공하는 시스템인데,최근 들어 몇몇 계층을 생략하고 서비스를 요청하고 제공하는 시스템을 구축하기도.(크로스 레이어, 기존의 레이어링이라고 보기 힘듬.) c. 인터넷 프로토콜 스택어플리케이션 : 네트워크 어플리케이션을 지원 ex.HTTP, FTP, SMTP, WWW, E-mail…수송 : 프로세스간의 데이터를 주고 받는 기능을 지원 ex. TCP, UDP네트워크 : 소스부터 목적지까지 데이터그램의 경로를 결정 ex. IP, routing protocol링크 : 근접한 네트워크를 처리 ex. 이더넷, wifi, PPP물리 : 전자기 신호와 비트를 변환이 프로토콜의 각 계층마다 여러가지 경로(plane)이 존재하는데,데이터 플레인(data plane) : 사용자가 실제로 보내는 데이터가 지나가는 경로컨트롤 플레인 : 프로토콜의 작동 제어를 담당하는 서비스가 지나가는 경로매니지멘트 플레인 : 컨트롤 플레인과 유사. 컨트롤 플레인보다 긴 시간동안 작동 제어한다고 이해. d. ISO&#x2F;OSI 레퍼런스 모델표준화 모델. 기존의 인터넷 스택에 presentation, session을 추가한 모델(인터넷 스택에서는 어플리케이션에 포함)presentation : 데이터가 어떤 방식으로 이뤄져있는지 분별. ex. 인코딩 방식, 압축 방식 등…session : 송수신지의 동기화, 예기치 못한 전송 중단을 대비한 체크포인트 및 복구 등을 담당 e. 캡슐화메세지는 각 계층의 인접한 peer끼리 control plane에 따라 제어된다.source의 link 계층 peer는 switch의 link가 되고source의 network 계층 peer는 router의 network가 된다.각 peer들은 헤더를 추가하거나 읽으면서 메세지를 제어한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"1. 네트워크 구조와 인터넷","slug":"cs/network/network1","date":"2021-09-16T12:12:51.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network1/","excerpt":"","text":"1. 인터넷이란 무엇인가.a. 네트워크 하드웨어PC, 서버, 스마트폰 등 &#x3D; 호스트(엔드 시스템)호스트를 연결해주는 선 &#x3D; 통신 링크(커뮤니케이션 링크)ex.광섬유 등… bandwidth(전송률)이 중요.교환 노드(패켓 스위치, 허브) : 자체로는 데이터를 발생시키지 않지만 중간에 위치한 것.통신 링크가 여러개.ex. 라우터, 스위치, 공유기 b. 인터넷ISP (internet service provider): 인터넷 사업자. sk, kt…인터넷 : 다양한 ISP들을 서로 연결 “network of networks”프로토콜 : 데이터를 주고받기 위해 네트워크를 제어하는 규약ex. TCP, IP, HTTP인터넷 표준 : 프로토콜을 정하는 행위. ex. RFC, IETF c. 서비스 차원의 인터넷다양한 서비스들의 인프라프로그래밍 인프라 제공 : 누구나 인터넷을 통해 프로세서를 개발 가능ex. 소켓. d. 프로토콜포맷&#x2F;순서&#x2F;송수신 위치&#x2F;다양한 상황에 따른 행동규칙 등을 정해놓은 규약. 세밀한 관점의 네트워크 구조네트워크 엣지(엑세스 네트워크) : 어떤 사용자(호스트)와 정보를 주고받는 첫 교환노드와 연결된 노드집합.네트워크 코어 : 엣지를 제외한 나머지. 사용자들이 보지 못하는 내부 노드들.클라이언트 : 데이터를 요구하는 호스트서버 : 데이터를 제공하는 호스트 e. 엑세스 네트워크와 피지컬 미디어유선이냐 무선이냐에 따라공유된 것이냐 아니냐에 따라전송 속도가 유의미하게 달라진다. f. 호스트 : 데이터 패켓을 보내는 것패켓 : 데이터를 보내기 위해 여러 조각으로 나눠지는 단위전송속도 R, 용량 L 일 때 걸리는 시간은 L&#x2F;R※호스트(비트)-&gt;(피지컬 미디어에 따라 다양한 방법으로 전자기 신호로 변화)-&gt;(비트로 다시 변화)호스트 g. 네트워크 코어교환노드로 구성. 최종 목적지를 파악하고 어디로 보내야 될 지를 결정 후 전달.패켓 스위치 : 예약 없이 보내는 스타일 ex. 인터넷서킷 스위치 : 예약 하고 보내는 스타일 ex. 집전화 h. 패캣 스위칭한 패캣이 모두 전달될 떄까지 저장한 다음 목적지로 전송.end-end delay &#x3D; 출발지에서 목적지까지 걸리는 지연시간 &#x3D; 2L&#x2F;R큐잉 딜레이 : 여러 호스트가 패캣을 보낼 때 교환 노드가 이를 저장하고 있는 상황.*예약하지 않고 막 들어오다 보면, 대기열이 생긴다.-한정적인 메모리를 사용. 꽉차게 될 경우 큐잉 로스가 발생 가능. i. 교환 노드의 주 기능라우팅 : 경로를 결정하는 하는 기능*라우팅 테이블 : 어떤 목적지로 가기 위한 경로를 적어놓은 표*라이퉁 알고리즘 : 경로를 알아내는 알고리즘포워딩 : 패캣헤더를 인식하여 알맞은 목적지를 향해 패캣을 보내주는 행위 j. 서킷 스위칭수신과 발신지의 경로를 예약하여 나만 이용할 수 있음큐잉 딜레이가 발생하지 않음.실시간이 중요한 경우 서킷 스위칭을 사용. k. 패킷 스위칭과 서킷 스위칭의 비교.패킷스위칭은많은 이용자들이 사용할 수 있게 한다.활성화 시간비율이 낮을 떄 유리하다.서킷스위칭은적은 이용자들이 사용할 때 유리하다.활성화 시간비율이 높을 수록 유리하다.(이 경로를 예약한 시간대비 실제로 이용하는 시간)ex.tv, 라디오는 24시간 계속 정보를 보냄… l.서킷스위칭 FDM vs TDM 주파수를 어떻게 나누느냐에 따라 달라짐. j. 인터넷 구조 : 네트워들의 네트워크다양한 액세스 ISP(회사, 가정, 대학 등…)들을 서로 연결하려면?글로벌 ISP를 만들어 교환 노드에 연결한다.이런 글로벌 ISP들이 여러개가 생겨나면서 서로 연결하는 peering link와 IXP(internet exchange point)를 만든다.지역단위 네트워크는 액세스 넷과 글로벌 ISP 사이에서 연결하는 역할을 한다.컨텐츠 제공자 네트워크 : 넷플릭스 구글 같은 존재. 이미 존재하는 네트워크를 사용하기 보다 자기들이 글로벌 ISP역할을 자처함. k. 페켓 딜레이와 로스다양한 호스트가 한 라우터로 패캣을 전송하면,패캣을 다음 노드로 전송할 수 있을 때까지 패캣 조각을 저장하여 딜레이 발생전달된 패켓의 양이 라우터 버퍼가 저장할 수 있는 양보다 많을 때 로스가 생긴다. l. 패켓 딜레이 : 트랜스미션 딜레이와 프로파게이션 딜레이트랜스미션 딜레이 : 패캣길이&#x2F;대역폭, 한 라우터에서 패캣을 전송할 때 생기는 딜레이프로파게이션 딜레이 : 피지컬링크 길이&#x2F;프로파게이션 속도, 한 라우터를 떠나 다른 라우터를 도착할 때까지 딜레이 n. 큐잉 딜레이링크 대역폭 : R패켓 길이 : L평균 패캣 전달되는 양 : aLa&#x2F;R이 1에 근접하면 큐잉 딜레이 발생1보다 크면 로스 발생, 딜레이 무한대 m. traceroute딜레이와 라우트의 작동을 알아보는 기능한 경로에 있는 라우터들마다 3번의 프로브를 보내 응답시간을 체크 n. Throughput어떤 특정한 시간에 얼마나 많은 비트를 전송할 수 있는지를 나타내는 비율.쉽게 말해 링크의 전송능력.정보를 전달 할 때 쓰루풋이 큰 링크에서 작은 링크로 흐르는 것이 유리(딜레이가 발생하기 때문)bottleneck link : end-end path 에서 가장 저조한 throughput을 가진 링크","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"osi 7계층","slug":"cs/network/network0","date":"2021-09-16T12:12:50.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/09/16/cs/network/network0/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/16/cs/network/network0/","excerpt":"","text":"응용 계층(application) 사용자가 접근 할 수 있는 계층 네트워크 활동에 대한 기본적인 인터페이스 제공 사용자가 볼 수 있는 유일 게층 표현 계층(presentation) 응용 계층과 주고 받은 데이터를 인코딩&#x2F;디코딩 보안을 위해 암호화와 복호화 형식 보유 세션 계층(session) 통신하기 위한 세션을 생성, 유지, 중단 모든 통신 장비를 연결, 관리 연결이 단방향인지 양방향인지 결정 TCP&#x2F;IP 세션을 담당 전송 계층(transport) 하위 계층이 데이터를 안전하게 전송하도록 함(신뢰) 연결 지향 프로토콜, 비연결 지향 프로토콜을 제공 흐름 제어, 분할, 재조립, 오류 관리 포함 네트워크 계층(network) 물리적인 네트워크 사이의 라우팅 담당 라우터가 이 계층에서 작동 논리적인 주소(IP)를 관리, 패킷을 분할, 프로토콜 인식, 오류 탐지 데이터링크 계층(datalink) 물리적인 네트워크 사이의 데이터 전송 담당 물리적 장비를 식별하는 주소 지점 체계와 데이터 오류 확인 담당 브리지와 스위치가 이 계층에 해당 물리 계층(physical) 데이터가 전송될 때 사용되는 물리체계 전압, 허브, 어댑터 등 모든 하드웨어의 물리적, 전자적 특성 정의 아날로그 &lt;–&gt; 디지털 변환을 담당","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Network","slug":"computer-science/network","permalink":"https://yangdongjue5510.github.io/categories/computer-science/network/"}]},{"title":"18.[블로그 프로젝트] 인덱스페이지 글목록 표시하기","slug":"spring/blog/blog18","date":"2021-09-15T05:52:22.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/15/spring/blog/blog18/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/15/spring/blog/blog18/","excerpt":"","text":"화면 구성일단 index.jsp를 수정하자. 123456789101112131415&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;c:forEach var=&quot;board&quot; items=&quot;$&#123;boards&#125;&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;$&#123;board.title&#125;&lt;/h4&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt;&lt;/div&gt;&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; JSTL을 이용해서 for each문을 사용했다.이제 인덱스 분기 처리를 해야되는데, 이걸 하기위해 DB에서 내용들을 가져오는 일을 서비스에 구현해야 한다. 글 조회를 서비스에 구현1234567public class BoardService &#123; @Autowired private BoardRepository boardRepository; public List&lt;Board&gt; postList() &#123; return boardRepository.findAll(); &#125;&#125; 이제 분기처리를 하자 컨트롤러에서 분기처리12345678@Autowiredprivate BoardService boardService;@GetMapping(&#123;&quot;/&quot;, &quot;&quot;&#125;)public String index(Model model)&#123;//스프링에서 데이터를 가져올 땐 Model이 필요!! model.addAttribute(&quot;boards&quot;, boardService.postList()); return &quot;index&quot;; //그냥 컨트롤러는 return시 viewResolver가 작동! -&gt; 해당 인덱스 페이지로 모델의 정보를 들고 이동!&#125; 스프링에서 데이터를 가져올 땐 Model이 필요하다!Model은 컨트롤러에서 생성한 데이터를 view로 전달할 때 사용한다.model에 boards변수로 board리스트를 할당한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"17.[블로그 프로젝트] 글쓰기 구현","slug":"spring/blog/blog17","date":"2021-09-14T06:55:01.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/14/spring/blog/blog17/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/14/spring/blog/blog17/","excerpt":"","text":"BoardControllerBoardController에 글쓰기 버튼을 눌렀을때 분기처리 메소드를 만들자. 12345//USER 권한 필요@GetMapping(&quot;/board/saveForm&quot;)public String saveForm()&#123; return &quot;board/saveForm&quot;;&#125; 화면 구성그리고 views폴더에 board 디렉토리를 만들고 saveForm.jsp를 만들자.부트스트랩에서 타이틀과 textarea를 가져오고글작성 템플릿을 위해 서머노트를 사용하자. header.jsp에서 summernote를 임포트하자!head태그에 다음 코드를 넣어주자. 123&lt;%-- summernote--%&gt;&lt;link href=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-bs4.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-bs4.min.js&quot;&gt;&lt;/script&gt; 그리고 부트스트랩과 서머노트를 적용한 saveForm을 작성하자. 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;Title&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter title&quot; id=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;Content:&lt;/label&gt; &lt;textarea class=&quot;form-control summernote&quot; rows=&quot;5&quot; id=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-save&quot; class=&quot;btn btn-primary&quot;&gt;글쓰기 완료&lt;/button&gt;&lt;/div&gt;&lt;%--summernote--%&gt;&lt;script&gt; $(&#x27;.summernote&#x27;).summernote(&#123; tabsize: 2, height: 300 &#125;);&lt;/script&gt;&lt;script src = &quot;/js/board.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; 글쓰기 완료 버튼이 form 바깥에 둠으로써, 글 데이터를 폼데이터가 아닌 json데이터로 전달한다는 걸 알 수 있다. 글작성 버튼 누르면 작동되는 js파일 구현이제 board.js를 작성해서, 글내용이 json으로 변환되서 전달해야 한다. 123456789101112131415161718192021222324252627282930313233343536let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. // $(&quot;#btn-login&quot;).on(&quot;click&quot;,()=&gt;&#123; // this.login(); // &#125;);//btn-login을 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; title: $(&quot;#title&quot;).val(), content: $(&quot;#content&quot;).val(), &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //글쓰기를 요청 type : &quot;POST&quot;, url : &quot;/api/board&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;글쓰기 완료!&quot;); location.href = &quot;/&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 2개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); 이제 버튼이 클릭되면, 아약스로 &#x2F;api&#x2F;board로 json 데이터를 보낸다.그러면 해당 uri에 맞는 분기처리를 해줘야 겠다!작성된 글을 데이터베이스에 저장하려면 사용자 정보, DB 레포지토리, 글작성 서비스가 필요하다.이제 JPA로 레포지토리를 만들어보자. JPA레포지토리로 Board 테이블 연결하기1234public interface BoardRepository extends JpaRepository&lt;Board, Integer&gt; &#123; //기본적인 CRUD는 모두 가지고 있음.&#125; 글작성 서비스 만들기1234567891011@Servicepublic class BoardService &#123; @Autowired private BoardRepository boardRepository; @Transactional public void writePost(Board board, User user)&#123; board.setCount(0); board.setUser(user); boardRepository.save(board); &#125;&#125; 서비스에 글작성 트랜잭션을 구현했다.이제 분기처리를 해보자. BoardApiController로 분기처리123456789101112@RestControllerpublic class BoardApiController &#123; @Autowired private BoardService boardService; @PostMapping(&quot;/api/board&quot;) public ResponseDto&lt;Integer&gt; save(@RequestBody Board board, @AuthenticationPrincipal PrincipalDetail principal)&#123; boardService.writePost(board, principal.getUser()); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;&#125; save메소드는 바디로 글 정보를 얻고, 시큐리티 세션에 있는 PrincipalDetail을 매개변수를 받아왔다.이를 통해 트랜잭션 메소드에 글내용과 글쓴 유저정보를 인수로 담아 보내고,그 결과를 반환한다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"2. 데이터의 종류(진수, 보수, 논리 게이트)","slug":"cs/struct/struct2","date":"2021-09-14T05:13:54.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/09/14/cs/struct/struct2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/14/cs/struct/struct2/","excerpt":"","text":"보수특정 비트의 최대값을 만드는 a+b가 존재한다면, a와 b는 서로 1진 보수 관계다.2비트의 최대값은 11이다. 10 + 1은 서로 1진 보수다 최대 표현자리 수(modulus)를 형성하는데 서로 보완관계를 이루는 a b를 2진 보수 관계라 한다.1진 보수에 1 더하면 2진보수다. 쉽게 말하면 a &#x3D; 0011일때, b가 1진보수면 1100이고, 2진보수면 1진보수에 1더한 1101이 된다. 재밌는 사실은 4비트로 수를 표현한다고 할 때 0&#x3D;0000이다.0의 1진보수는 1111이지만, 2진보수는 10000이다. 즉 5비트가 되버린다!!!!그래서 0의 2진보수는 없도록 설정했고,총 16가지 숫자 중에 0이 보수가 없으므로, 2진보수는 음수가 하나 더 많다.(-8은 1000으로 표현, 하지만 8은 4비트로 표현안된다.)(한편 1진보수는 0의 보수 -0이 존재해서 홀수짝수 갯수가 일치한다.)1진보수로 표현한 4비트 &#x3D;&gt; (0, 17, -1-7, -0)2진보수로 표현한 4비트 &#x3D;&gt; (0, 17, -8, -7-1) 보수를 연산에 이용하기(1의 보수 활용) 보수는 뺄셈을 덧셈으로 처리할 수 있다.32-12 &#x3D;&gt; 32+87(12의 1진보수) &#x3D; 119이다.119에서 맨앞 숫자(캐리비트)를 제거하고나서 덧셈하면즉 19+1 &#x3D; 20이 된다! 만약 캐리비트가 발생하지 않는 경우는?32-4032+59 &#x3D; 91 여기서 1진보수를 취하고 부호를 바꿔주면 된다!-9!! 이진수로 해보면,1011 - 0010 일때,1011 + 1101&#x3D; 11000 여기서 캐리비트를 제거하고 덧셈하면,1000+0001 &#x3D; 1001.즉 1011 - 0010 &#x3D; 1001이 된다. 1011 - 11101011 + 0001 &#x3D; 1100 여기에 부호를 바꾼 1진보수를 구한다.1011 - 1110 &#x3D; -0011 정수고정 소숫점을 가지는 수.(소수점의 위치가 어디인지 항상 정확하게 인지)정수도 소숫점을 가진다. 다만 floating하지 않고 고정되어 있을 뿐. 부호화 절대치(signeagnitude) : 부호를 나타내는 비트. 맨 앞 비트가 담당 0이면 양수 1이면 음수 +0과 -0이 둘 다 존재하는 한계 &#x3D;&gt; 2진 보수를 활용해서 해결 10진수 정수 표현 Unpacked decimal : 1바이트마다 십진수 한 숫자 표현. 입출력용(연산x) Packed decimal : 1바이트마다 십진수 두 숫자 표현. 연산용(입출력x) 소수부동 소수점을 가지는 수.총 32비트를 (부호1+지수7+기수20) 이런식으로 분배.. 소수를 이진법으로 하기 소수를 나타내려면 일단 2를 곱해서 정수 부분이 해당 소숫점 자리 수가 된다.그리고 정수부분(캐리비트라고도 한다)을 버린 나머지를 다시 2를 곱해서 반복한다.이렇게 해서 0이 될때까지 하면 이진법으로 표현된다. 예를 들어 0.625는0.6252 &#x3D; 1.25 이므로 소수점 첫자리 수는 10.252 &#x3D; 0.5 이므로 소수점 두번째 자리는 00.5* &#x3D; 1.0 이므로 소수점 세번째 자리는 1그리고 남은수가 0이므로 과정이 종료되고,0.625의 이진법 표현은 0.101이 된다!!! 한계 그러나 0.3 같은 수는 이진법 표현식으로는 한계가 있다.0.6 -&gt; 1.2 -&gt; 0.4 -&gt; 0.8 -&gt; 1.6 -&gt; 0.2…이렇게 순환반복된다… 이런 상황에서 자료형에 따라 허용된 자리 수까지 표시한다.즉 정확하게 표시가 안된다!!!!!!!! BCD 코드입출력을 위해 10진수를 2진수로 표현해놓은 것.(일일히 2진수로 변환하기 싫어서 만든 것.) 논리 게이트논리 연산을 수행하는 전자소자.입력 받은 변수에 따라 정해진 논리 함수를 수행해서 결과값 반환하는 하드웨어 직렬 연결 스위치는? AND 표현과 동치!병렬 연결 스위치는? OR 표현과 동치!배타적 논리합(XOR) 서로 값이 다를때 1! 1비트 덧셈 구현 예시 각 1비트인 a,b로a + b를 구현해보자. C는 캐리비트고, s는 그 나머지다.a b C s0 0 &#x3D; 0 00 1 &#x3D; 0 11 0 &#x3D; 0 11 1 &#x3D; 1 0 자 이제 a,b,C,s 간 논리 게이트 관계를 따져보자.C는 a, b가 모두 1일 때 1이다. 즉 a AND b &#x3D; Cs는 a, b가 서로 다를 때 1이다. 즉 a XOR b &#x3D; s결과적으로 보면 논리연산자로 산술적 연산인 덧셈이 표현가능하다는 거다!이 결과를 논리 게이트로 표현하면 다음과 같다 부울 대수논리 회로의 형태와 구조를 기술하는 수학적 이론 교환법칙 AB &#x3D; BA (and) A+B &#x3D; B+A (or) 결합법칙 A(BC) &#x3D; (AB)C (A+B)+C &#x3D; A+(B+C) 분배법칙 A(B+C) &#x3D; AB+AC 드모르간 법칙 (부득이하게 여집합을 !로 표현.) !(A+B) &#x3D; !A!B !(AB) &#x3D; !A+!B 이 법칙들을 적용해 부울 식을 최대한 간편화 할 수 있다! 조합 논리 회로, 자료 기억 방법, 순차 논리 회로조합 회로 : 입출력을 가진 논리 게이트의 집합순차 논리회로는 게이트 뿐만 아니라 기억능력이 있는 플립플롭으로 구성.조합 회로가 연산을 수행한다고 할 때, 임시적으로 데이터를 잠깐 저장해야 할 일이 생긴다.그럴 때 플립플롭에 저장해놨다가 꺼내서 써먹는 방식이다. 대표적인 조합 회로 가산기 : 여러 입력값을 받아 결과물을 출력 멀티플렉서 : 여러 입력 중 하나만 골라서 출력 디멀티플렉서 : 하나의 입력을 여러개의 출력으로 나눠서 보냄 플립플롭 종류와 작동 방식 R-S 래치 : 두 값을 받아서 저장하고 수정할 수 있음.D 플립플롭 : 입력값 D에 따라서 수정, 유지를 할 수 있음 순차회로의 외부 출력은 외부 입력 + 플립플롭 현상태의 함수로 표현","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}]},{"title":"16.[블로그 프로젝트] 스프링 시큐리티 로그인","slug":"spring/blog/blog16","date":"2021-09-13T12:02:53.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog16/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog16/","excerpt":"","text":"시큐리티는 로그인 요청을 가로채간다.우리는 회원가입에 필요한 joinProc uri를 UserApiController에 정의했었다.그러나 로그인에 필요한 메서드는 만들지 않는다.왜? 시큐리티가 가로채가서 로그인을 실행하기 때문. SecurityConfigure 수정이제 로그인을 시큐리티가 실행할 수 있게 수정해보자. 12345678910111213141516@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() //csrf 토큰 비활성화 .authorizeRequests()//요청이 왔을 때 .antMatchers(&quot;/&quot;,&quot;/auth/**&quot;,&quot;/js/**&quot;,&quot;/css/**&quot;,&quot;/image/**&quot;) // /auth로 시작하는건 .permitAll() //모두 접근 가능 .anyRequest() //이 외의 다른 요청은 .authenticated() // 인증해야 접근 가능 .and() // 인증이 필요한 경우 .formLogin() // 로그인 할 수 있도록 한다. .loginPage(&quot;/auth/loginForm&quot;) //이 로그인 페이지에서 .loginProcessingUrl(&quot;/auth/loginProc&quot;) //시큐리티가 해당 주소로 오는 로그인 가로채고 수행 .defaultSuccessUrl(&quot;/&quot;); //요청이 성공하고 나서 해당 주소로 이동. //.failureUrl(&quot;/auth/loginForm&quot;);//실패시 해당 주소로 이동.&#125; .and()부터 로그인에 관련된 내용이다! config 패키지 하위에 auth 패키지 만들고 클래스 작성로그인하고 나면 시큐리티 세션에 사용자 정보가 UserDetails 형으로 저장된다고 했다.이때 UserDetails는 인터페이스로, 이를 구현한 클래스가 필요하다. 그래서 유저 정보를 담을 PrincipalDetail를 UserDetails의 추상메소드를 구현해서 만들어보자 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.cos.blog.config.auth;import com.cos.blog.model.User;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.ArrayList;import java.util.Collection;public class PrincipalDetail implements UserDetails &#123; private User user; public PrincipalDetail(User user)&#123;&#125;; //계정이 어떤 권한을 가졌는지. @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; Collection&lt;GrantedAuthority&gt; collectors = new ArrayList&lt;&gt;(); collectors.add(()-&gt;&#123;return &quot;ROLE_&quot;+user.getRole();&#125;);//role 앞에 ROLE_붙이는건 규칙!!! return collectors; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUsername(); &#125; //계정이 만료됐는지 리턴(true: 만료안됨) @Override public boolean isAccountNonExpired() &#123; return true; &#125; //계정이 잠겼는지 리턴(true: 안잠김) @Override public boolean isAccountNonLocked() &#123; return true; &#125; //비밀번호가 만료됐는지 리턴(true: 만료안됨) @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; //계정활성화 @Override public boolean isEnabled() &#123; return true; &#125;&#125; 이제 로그인된 정보는 PrincipalDetail 객체에 담겨서 UserDetails 형으로 시큐리티 세션에 저장하도록해야 된다. PrincipalDetailService 만들기이제 해쉬화된 비밀번호가 db에 있다는걸 안다. 근데 입력받은건 그냥 패스워드이다.입력받은 패스워드를 동일한 해쉬방식으로 해쉬화해야 db에 있는 것과 비교할 수 있다. 일단 유저정보를 username으로 찾아서 반환하는 서비스를 만들어야 한다.(비밀번호는 시큐리티가 알아서 검사한다.)username으로 정보를 찾아내는 메소드는 JPA에 없으므로 우리가 만들어야한다.UserRepository에서 추상메소드를 만들어보자. 1Optional&lt;User&gt; findByUsername(String username); 이제 해당 메소드를 활용해서 서비스를 만들어보자. 1234567891011121314151617@Service //Bean등록public class PrincipalDetailService implements UserDetailsService &#123; //username과 password를 가로채서 처리할때 //password는 알아서 처리하니까 //username만 DB에 있는지 확인하면 된다. @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User principal = userRepository.findByUsername(username) .orElseThrow(()-&gt;&#123; return new UsernameNotFoundException(&quot;해당 사용자를 찾을 수 없습니다.&quot;+username); &#125;); return new PrincipalDetail(principal); //이때 시큐리티의 유저정보 저장됨! 유저정보가 없다면, user, 콘솔창 비번이 유저정보로 저장될 것이다. &#125;&#125; 이제 이 서비스는 유저 이름을 받아서 레포지토리에 있는 유저정보를 찾아와서 PrincipalDetail로 담아서 반환한다!이제 시큐리티 세션에 PrincipalDetail에 유저정보가 담겨서 로드된다!! SecurityConfig에서 configure 추가하기이제 유저이름을 통해 유저정보를 찾았으니, 이 유저정보의 암호를 동일한 해쉬로 비교하는 configure메소드를 만들어보자. 123456@Autowiredprivate PrincipalDetailService principalDetailService; @Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(principalDetailService).passwordEncoder(encodePWD());&#125; 이제 암호 해쉬기준도 알려줬으니, 로그인은 시큐리티가 알아서 할 것이다! 컨트롤러에서 세션 호출하기 매개변수로 @AuthenticationPrincipal PrincipalDetail principal를 전달해주면됨 12345@GetMapping(&quot;/&quot;)public String index2(@AuthenticationPrincipal PrincipalDetail principal) &#123; System.out.println(&quot;로그인한 사용자 아이디 &quot;+principal.getUsername()); return &quot;index&quot;;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"10. CSRF 와 XSS","slug":"spring/boot/boot10","date":"2021-09-13T11:27:58.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/13/spring/boot/boot10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/boot/boot10/","excerpt":"","text":"XSS자바스크립트를 공격!글 쓰기 같은 내용에 스크립트 태그로 잔뜩 연산시키는 공격.보통 태그를 작성 못하게 막는데, Lucy XSS filter로 막을 수 있다. CSRF쿼리 파라미터로 특정 데이터를 조작할 수 있는 URI가 있을 때,보통 시큐리티로 관리자만 접근 가능하게 해놓는데,해커가 자신의 뜻대로 작성한 URI를 관리자가 클릭하게 만드는 행위. 이런 행위를 막기 위해서는 데이터를 조작하는 URI는 GET방식이 아닌 POST방식을 하는게 좋다. 혹은 CSRF 토큰을 사용한다.사용자가 요청하면 토큰을 생성해 세션에 저장한다.사용자는 요청할때마다 토큰을 보내서 서버가 이를 확인하고 정상임을 알아차린다.","categories":[],"tags":[],"keywords":[]},{"title":"15.[블로그 프로젝트] 비밀번호 해쉬화 해서 회원가입","slug":"spring/blog/blog15","date":"2021-09-13T07:37:23.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog15/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog15/","excerpt":"","text":"시큐리티는 어떤 원리로 작동할까?스프링에서 로그인 요청을 하면 시큐리티가 이를 지켜보다가username과 password를 가로채간다.시큐리티는 가로챈 username과 password로 로그인을 진행시키고,시큐리티 세션에 해당 유저 정보 객체를 저장하고, DI하여 사용하도록 한다.(이때, 세션에 저장된 유저 정보는 UserDetails 객체다.) 그러면 우리가 다루려는 객체 형과 UserDetails가 안맞는 경우가 생긴다.(ex. User !&#x3D; UserDetails)-&gt; 우리가 다루려는 객체 형이 UserDetails를 상속-&gt; (User extends UserDetails) 또한 시큐리티가 로그인을 진행할 때, 그냥 비밀번호 자체를 주면 안된다. 해쉬화 해서 진행해야 로그인이 된다.(DB에도 비밀번호를 해쉬값을 저장한다.) SecurityConfig에서 인코더 객체 Bean등록.1234@Bean //IoC / BCryptPasswordEncoder객체를 스프링이 관리public BCryptPasswordEncoder encodePWD()&#123; return new BCryptPasswordEncoder();&#125; UserService 수정BCryptPasswordEncoder 객체를 DI하고,encode 메서드로 주어진 값을 해쉬화한다! 12345678910111213141516@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; @Autowired private BCryptPasswordEncoder encoder; @Transactional //메소드 속 여러 트랜잭션이 하나의 트랜잭션을 묶임 public void signUp(User user)&#123; String rawPassword = user.getPassword(); String encPassword = encoder.encode(rawPassword); user.setRole(RoleType.USER); user.setPassword(encPassword); userRepository.save(user);//잘못된 예외발생시 GlobalExceptionHandler가 예외처리 &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"14.[블로그 프로젝트] 스프링 시큐리티 체험, 로그인 페이지 커스터마이징","slug":"spring/blog/blog14","date":"2021-09-13T06:35:26.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog14/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog14/","excerpt":"","text":"Spring starter security일단 스프링 시큐리티를 이용하기 위해 pom.xml에 있는 관련 dependency를 모두 주석해제하자.그리고 전통적 방식 로그인 메서드를 주석처리하고 다시 사이트에 들어가려면…이렇게 시큐리티가 로그인 화면을 띄우게 된다. 이렇게 Spring starter security는 진입할 때 로그인 정보를 입력하도록 한다! 여기에아이디 : user비밀번호 :콘솔창에 Using generated security password: 뒤에 나온 걸 넣으면 된다. 이렇게 로그인하면 자연스럽게 세션에 적용된다. Spring security taglib일단 링크를 참고하자.header.jsp에서 태그라이브러리를 쓰기 위해 임포트하자. 1&lt;%@ taglib prefix=&quot;sec&quot; uri=&quot;http://www.springframework.org/security/tags&quot; %&gt; 그리고 밑에 다음과 같이 적어주자. 123&lt;sec:authorize access=&quot;isAuthenticated()&quot;&gt;//로그인 됐는지 확인 &lt;sec:authentication property=&quot;principal&quot; var=&quot;principal&quot;&gt;&lt;/sec:authentication&gt;&lt;/sec:authorize&gt; 로그인 됐는지 확인하고, 로그인됐으면 html의 principal변수에 세션의 principal 속성을 집어넣는거다. 스프링 시큐리티 로그인 페이지 커스터마이징일단 전통적인 방법의 로그인과는 달리 user.js로 로그인하지 않을 것이다. 폼으로 전달해줄 것이다.그러기 위해선 loginForm.jsp를 수정해줘야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%-- Created by IntelliJ IDEA. User: MUHN2-031 Date: 2021/09/07 Time: 9:39 오후 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix = &quot;c&quot; uri = &quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;sec&quot; uri=&quot;http://www.springframework.org/security/tags&quot; %&gt;&lt;sec:authorize access=&quot;isAuthenticated()&quot;&gt;//로그인 됐는지 확인 &lt;sec:authentication property=&quot;principal&quot; var=&quot;principal&quot;&gt;&lt;/sec:authentication&gt;&lt;/sec:authorize&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Yangdongjue blog&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-md bg-dark navbar-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Mudura&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapsibleNavbar&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapsibleNavbar&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;empty principal&#125;&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/auth/loginForm&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/auth/joinForm&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/board/Form&quot;&gt;글쓰기&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/Form&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/logout&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/div&gt;&lt;/nav&gt;&lt;br&gt; 그리고 이제 로그인하지 않아도 접근 그낭한 곳은 &#x2F;auth를 붙인 uri라고 하고 login과 join은 auth를 붙여서 처리하자. config 패키지 - SecurityConfig 클래스프로젝트 폴더에 config 패키지를 만들고,SecurityConfig 클래스를 만들자. 123456789101112131415161718@Configuration //빈 등록(Ioc)@EnableWebSecurity //시큐리티 필터를 등록. 필터 설정을 메소드에서@EnableGlobalMethodSecurity(prePostEnabled = true) //특정 주소를 접근하면 권한/인증을 미리 체크하겠다는 의public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests()//요청이 왔을 때 .csrf().disable() //csrf 토큰 비활성화(테스트시에만!!!) .antMatchers(&quot;/&quot;,&quot;/auth/**&quot;,&quot;/js/**&quot;,&quot;/css/**&quot;,&quot;/image/**&quot;) // /auth로 시작하거나, static한 데이터는 .permitAll() //모두 접근 가능 .anyRequest() //이 외의 다른 요청은 .authenticated() // 인증해야 접근 가능 .and() // 인증이 필요한 경우 .formLogin() // 로그인 할 수 있도록 한다. .loginPage(&quot;/auth/loginForm&quot;); //이 로그인 페이지에서 &#125;&#125; 이제 인증이 필요한 주소 방문시 -&gt; 로그인 페이지인증 불필요한 주소 방문시 -&gt; 접근 허용이렇게 작동한다!!!csrf 토큰은 반드시 테스트에만 비활성화하라!!csrf가_뭔지_모른다면…","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"13.[블로그 프로젝트] 전통적인 로그인 구현","slug":"spring/blog/blog13","date":"2021-09-13T04:33:12.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/13/spring/blog/blog13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/13/spring/blog/blog13/","excerpt":"","text":"loginForm.jsp회원가입을 구현했던 것과 비슷하게 진행한다.loginForm.jsp에서 button 태그를 form 밖으로 빼고, 스크립트 태그를 추가해 user.js를 읽을 수 있게 했다. 123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form &gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/form&gt; &lt;button id=&quot;btn-login&quot; class=&quot;btn btn-primary&quot;&gt;로그인&lt;/button&gt;&lt;/div&gt;&lt;script src = &quot;/blog/js/user.js&quot;&gt;&lt;/script&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; user.js이제 user.js에 로그인 버튼이 눌렸을 때 액션을 만들어서 추가해줘야 한다. 이전에 만든 save와 비슷하게 만든다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. $(&quot;#btn-login&quot;).on(&quot;click&quot;,()=&gt;&#123; this.login(); &#125;);//btn-login을 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //회원가입을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;, login : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), &#125;; //ajax 호출 시 비동기 호출 $.ajax(&#123; //로그인을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user/login&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); UserRepository이제 UserService 서비스에 login 트랜잭션을 만들어야되는데, userRepository에 회원확인 할 수 있는 메소드를 만들어야 한다!!! JPA Naming 쿼리 메소드 이름을 통해 쿼리를 작성하는 효과를 얻기. 123//JPA Naming query //SELECT * FROM user WHERE username = ? AND password = ? User findByUsernameAndPassword(String username, String password); 이런 식으로 작성하면 우리가 원하는 쿼리와 동일한 역할을 하는 메소드를 만들 수 있다. 네이티브 쿼리 JPA Naming 쿼리와 같은 효과를 네이티브 쿼리로도 얻을 수 있다. 12@Query(value = &quot;SELECT * FROM user WHERE username = ?1 AND password = ?2&quot;, nativeQuery = true)User login2(String username, String password); 이런 방식은 쿼리가 복잡해질 때 유리하다. 서비스이제 우리에게 필요한 쿼리를 만들었으니 서비스에서 적용시켜보자. 1234@Transactional(readOnly = true)public User login(User user)&#123; return userRepository.findByUsernameAndPassword(user.getUsername(), user.getPassword());&#125; readOnly &#x3D; true는 select 할 때 트랜잭션이 시작되고, 서비스 종료될 때 트랜잭션도 종료해서 정합성을 유지하는 역할을 한다. 컨트롤러 수정123456789@PostMapping(&quot;/api/user/login&quot;)public ResponseDto&lt;Integer&gt; login(@RequestBody User user, HttpSession session)&#123; System.out.println(&quot;UserApicontroller : login called&quot;); User principal =userService.login(user); if (principal != null)&#123; session.setAttribute(&quot;principal&quot;, principal); &#125; return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);&#125; 컨트롤러도 HTTPSession을 추가했다.로그인에 성공하면 세션에 principal를 추가한다.이 속성으로 서버가 사용자를 추측할 수 있게한다. 그리고 HTTPSession을 private로 따로 빼서 @Autowired해도 된다. 그러면 함수 인자로 전달안해도 된다. JSTL 라이브러리 추가하기이제 로그인 완료한 사용자의 헤더에는 로그인이 뜨면 안된다.이걸 처리하기 위해서 세션에 principal 속성을 확인하고, 이에 따라 분기 처리를 해줘야 한다. 따라서 JSTL의 태그 라이브러리를 사용할 것이다. 1&lt;%@ taglib prefix = &quot;c&quot; uri = &quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 이 코드를 header.jsp 맨위에 붙여놓고, 서버를 실행한다.그 이후, pom.xml에 가서 JSTL dependency가 잘 설정됐는지 확인한다. header.jsp 고치기JSTL의 태그 라이브러리에 따르면, 123456&lt;c:choose&gt; &lt;!-- if문 --&gt; &lt;c:when test=&quot;&quot;&gt; &lt;/c:when&gt; &lt;!-- else문 --&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 이런식으로 jsp 안에 조건문을 사용할 수 있다. 12345678910111213141516171819202122232425262728&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;empty sessionScope.principal&#125;&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/loginForm&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/joinForm&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/board/writeForm&quot;&gt;글쓰기&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/userForm&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/blog/user/logout&quot;&gt;회원정보&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; 지금까지 전통적 로그인을 구현했다. 하지만 스프링에는 스프링 시큐리티를 이용하면 더 쉽게 구현 가능하다.(시큐리티를 이용할꺼면 만든거 주석처리해주자.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"9. 스프링의 전통적인 트랜잭션","slug":"spring/boot/boot9","date":"2021-09-12T08:15:34.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/12/spring/boot/boot9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/12/spring/boot/boot9/","excerpt":"","text":"스프링이 시작되면 톰캣 시작 web.xml 읽음 context.xml 읽고 DB 연결테스트되면 세팅 끝! 이러고 나서 요청이 들어오면,web.xml -&gt; 필터 -&gt; 스프링컨테이너[컨트롤러-서비스-레파지토리] -&gt; 영속성컨텍스트 -&gt; DB 전통적인 방식 (모두가 다같이 처음에 시작!) web.xml과 필터를 거치게되면… DB 연결 세션 생성(JDBC가 연결됨, CRUD가능) 트랜잭션이 시작. 영속성 컨텍스트 시작. 스프링 컨테이너로 오게되면… 컨트롤러에서 요청을 분기하고 요청에 맞는 서비스를 요청 서비스는 해당 트랜잭션들을 JDBC레파지토리를 통해 실행. 레파지토리의 메소드에 따라 영속성 컨텍스트에서 DB엔티티를 객체화해서 가져옴 객체화된 데이터를 서비스에서 수정하고 컨트롤러에 결과를 전달. 컨트롤러는 json이나 html을 반환 이때 트랜잭션이 종료된다. 영속성 컨텍스트는 값의 변경됨을 인식하고 DB에 flush해서 변경된 값으로 업데이트. 영속성 컨텍스트 종료 DB연결 세션을 종료. 기존방식 개산안과 그 문제점기존의 방식이 너무 쓸데없이 오래걸린다. 개선해보자. 기존방식 개선해볼까(문제가 있음.) 기존에는 컨트롤러로 요청이 넘어가기전에DB 연결 세션 생성 &#x2F; 트랜잭션이 시작 됐는데,이걸 그냥 서비스가 호출될 때 실행하도록 개선 또, 컨트롤러가 종료될 때트랜잭션 종료 &#x2F; DB연결 세션 종료 &#x2F; DB flush 및 영속성 종료 됐는데,이걸 그냥 서비스가 종료될 때 실행되도록 개선 하지만 이렇게 하면 문제가 발생한다!만약 DB에서 MANY TO ONE 관계에서 MANY side에 있는 데이터를 가져오려고 할 때,영속성 컨텍스트는 해당 값을 DB에서 가져올 때 EAGER 전략을 취하면(디폴트 전략이 EAGER),MANY side에 해당하는 데이터 뿐만 아니라 ONE side에 해당하는 자료도 가져온다.그래서 데이터가 컨트롤러에 전달되서 영속성 컨텍스트가 종료되어도,MANY side 데이터나, ONE side 데이터 모두 다룰 수 있다. 만약 LAZY 전략으로 변경하면, ONE side에 해당하는 데이터를 가져오지 않는다.ONE side 데이터의 프록시 객체를 가져온다.(그냥 연결된 빈 객체다.)그래서 컨트롤러에 전달된 데이터는 MANY side 데이터랑 프록시 데이터 뿐이라,ONE side의 데이터를 다룰 수 없다.(게다가 컨트롤러에 전달될 때 영속성 컨텍스트가 종료되서 DB에 요청도 못한다.) OSIV (open session in view, session에 영속성 컨텍스트)아하! 이 문제를 해결하기 위해서 영속성 컨텍스트는 원래대로 컨트롤러가 반환할 때 종료하자!영속성 컨텍스트가 살아있다면, 프록시를 통해 JDBC, 트랜잭션이 종료됐었어도 스스로 JDBC 커넥션을 시작해서프록시에 해당하는 데이터를 가져올 수 있다!(그러고나서 JDBC 커넥션을 닫는다!)하지만 여전히 업데이트는 불가능…(트랜잭션이 종료되서…) 1hibernate.enable_lazy_load_no_trans: true application.yml에 우리가 이렇게 쓰면 문제점을 고친 방식으로 활용 가능하다.(디폴트)하지만 false로 하면 Lazy Loading이 불가능한 방식으로 작동한다. 정리하자면… 영속성 컨텍스트는 컨트롤러가 작동하면서 생성 및 종료!!트랜잭션과 JDBC 커넥션은 서비스가 작동하면서 생성 및 종료! Lazy Loading지금까지 살펴본 일들은, 다 Lazy Loading을 처리하기 위한 일들이다.Lazy Loading은 Eager와 달리, 지금 요청한건 가져오고, 얘랑 관련된건 나중에… 이런 느낌이다.그래서 프록시를 대신해서 가져오고, 프록시를 통해 관련된 데이터를 가져오라고 할 수 있다.(영속성 컨텍스트에 살아있을 때) 즉 영속성 컨텍스트를 언제 생성하고 언제 종료 시킬 것이냐에 대한 포스트였다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"2. DB 격리 수준","slug":"cs/database/database2","date":"2021-09-12T07:37:55.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/09/12/cs/database/database2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/12/cs/database/database2/","excerpt":"","text":"DB 격리 수준트랜잭션의 결과물을 데이터베이스에 적용시키는 기준을 의미 오라클의 READ COMMIT예를 들어 오라클에선 READ COMMIT이란 격리 수준을 가짐.READ COMMIT은 커밋된 것만 읽을 수 있다는 의미다. 만약에 특정 데이터를 수정한다면,원래 데이터는 undo 영역에 복사되고,해당 트랜잭션이 커밋되지 않은 동안 해당 데이터를 select하면,undo에 복사된 데이터가 반환된다.(즉 수정 내용이 적용되지 않는다.)특정 트랜잭션의 변경 사항이 적용되려면 트랜잭션이 끝나고 커밋되어야한다. 문제점 update를 해도 그 즉시 데이터베이스에 적용되지 않는다.즉 한 트랜잭션이 커밋되지 않은 상태에서 다른 트랜잭션이 개입하면예상과 다른 결과를 얻을 수 있다.(정합성이 깨짐, Phantom read) MySQL(InnoDB 스토리지 엔진)의 Repeatable Read자신보다 늦은 트랜잭션의 undo는 반영하지 않는 방식. 즉 한 트랜잭션이 먼저 select로 한 데이터에 여러번 접근한다고 할 때,중간에 다른 트랜잭션이 시작되어 해당 데이터를 수정하고 먼저 커밋되도,먼저 시작한 트랜잭션은 자기보다 늦게 시작한 트랜잭션의 undo를 반영하지 않는다.(즉 그냥 나보다 늦게 시작한 애가 바꾼건 신경 안쓴다.) 이 방식은 트랜잭션을 실행하고 있는 와중에는!데이터의 정합성을 지킬 수 있다!데이터를 조회하는 행위에도 트랜잭션처리를 해주면, 데이터 정합성을 지킬 수 있다","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}]},{"title":"28. 소수 판별 문제(제곱근, 에라토스테네스의 체)","slug":"cs/algorithm/problem/al28","date":"2021-09-11T07:43:30.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/11/cs/algorithm/problem/al28/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/11/cs/algorithm/problem/al28/","excerpt":"","text":"제곱근으로 판별소수를 판별할 때, 굳이 모든 수를 검사 하지 않아도 된다.주어진 수의 제곱근에 해당하는 수까지 검사하면 된다. 1234567boolean isPrime(int num)&#123; if(num == 1) return false; for(int i = 2 ; i &lt; Math.sqrt(num); i++)&#123; if(N%i == 0) return false; &#125; return true;&#125; 에라토스테네스의 체이건 제곱근과는 달리 값의 범위 안에서 소수를 찾는다.배열에 원하는 수 만큼 담아서 2를 만나면 그 뒤 2의 배수는 다 소수가 아니고,그 다음에 3을 만나면 소수처리하고 그 뒤 3의 배수는 다 소수가 아니고…이런식으로 구하려는 범위의 제곱근까지만 검사하면된다!!!! 1234567891011121314public static final int MAX = 100000;boolean[] findPrime()&#123; boolean isPrime = new boolean[MAX+1]; for(int i = 2 ; i &lt;= MAX; i++)&#123; isPrime[i] = true; &#125; for(int i = 2 ; i &lt;= Math.sqrt(MAX) ; i++)&#123; if(isPrime[j] == false) continue; for(int j = i * 2 ; j &lt;= MAX ; j+=i)&#123; isPrime[j] = false; &#125; &#125; return isPrime;&#125; 관련된 문제로 백준6588번 문제가 있다. 123456789101112131415161718192021222324252627282930313233343536import java.util.*;import java.io.*;public class Main &#123; public static final int MAX = 1000000; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); boolean[] isPrime = new boolean[MAX+1]; for(int i = 2; i &lt;= MAX; i++) &#123; isPrime[i] = true; &#125; for(int i = 2; i &lt;= MAX; i++) &#123; if(isPrime[i] == false) continue; for(int j = i * 2; j &lt;= MAX; j += i) &#123; isPrime[j] = false; &#125; &#125; while(true) &#123; int n = Integer.parseInt(bf.readLine()); boolean ok = false; if(n == 0) break; for(int i = 2; i &lt;= n/2; i++) &#123; if(isPrime[i] &amp;&amp; isPrime[n-i]) &#123; System.out.println(n + &quot; = &quot; + i + &quot; + &quot;+(n-i)); ok = true; break; &#125; &#125; if(!ok) System.out.println(&quot;Goldbach&#x27;s conjecture is wrong.&quot;); &#125; &#125;&#125; 이번 문제에서 제일 신기했던건 printf보다 println이 훨씬 빠르다는 것!!!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"1. MongoDB로 NoSQL 찍먹하기","slug":"cs/database/database1","date":"2021-09-09T11:05:01.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/09/09/cs/database/database1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/09/cs/database/database1/","excerpt":"","text":"데이터베이스와 파일시스템의 가장 큰 차이는?자기기술성파일 시스템은 파일을 특정 응용프로그램이 있어야 열 수 있다.db는 sql만 있으면 어떤 응용프로그램이든 열 수 있다.즉 sql은 자기기술성을 가진다. NoSQLNoSQL &#x3D; Not only SQL &#x3D; 데이터 접근 방식이 sql말고 다른 거도 가능함Document 타입 : key : value에서 value에 또다른 key value 집합이 들어올 수 있음.(중첩) 확장 가능성이나 스키마 없는 데이터 모델에 유리(데이터의 형태가 일정하면 RDB, 아니면 NoSQL)join을 지원하지 않음(reference 등으로 구현)트랜잭션이 없음.수평확장에 용이 NoSQL 사례 key: value 형식 - RedisDocument &#x3D; MongoDBColumn &#x3D; Cassandra MongoDBBSON(binary json)기반 key-value storejson 형태 문서Collection -&gt; Document -&gt; key:value data MongoDB 사용하기(파이썬 기준) pip install pymongopip install requestspip install jupyter[DB인스턴스생성]cloud.mongodb.com - db인스턴스생성 DB연결 123from pymongo import MongoClientclient = MongoClient(url, connect = False)client.DB이름.list_collection_names() DB, collection 할당 12db = client.&#123;DB이름&#125;new_Collection = db.&#123;CollectionName&#125; INSERT data 123456data = &#123; &quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;,&#125;new_Collection.insert_one&#123;data&#125;#여러개를 넣으려면, insert_many. SELECT쿼리에 넣은 기준에 따라 데이터 찾음 123query = &#123;&quot;key1&quot; : &quot;value1&quot;&#125;list(new_Collection.find_one(query))#key1이 value1인 데이터를 찾음 Operatorkey1 &#x3D; value1 or key2 &#x3D; value2인 경우.. 1234567query = &#123; $or : [ &#123;&quot;key1&quot; : &quot;value1&quot;&#125;, &#123;&quot;key2&quot; : &quot;value2&quot;&#125;, ]&#125;new_Collection.find(query)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Database","slug":"computer-science/database","permalink":"https://yangdongjue5510.github.io/categories/computer-science/database/"}]},{"title":"1. 컴퓨터 구조에 대한 인트로.","slug":"cs/struct/struct1","date":"2021-09-09T04:05:53.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/09/09/cs/struct/struct1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/09/cs/struct/struct1/","excerpt":"","text":"왜 하드웨어 배워야 되는가?컴퓨터 기본 구조를 알아야 정확하고 깔끔한 코드를 작성할 수 있다. 컴퓨터란 무엇인가?compute(연산하다) + er(하는 사람,도구)고정된 연산만 제공하면 Calculator연산을 작성하고 저장하기도 하면 Computer 컴퓨터는 3가지로 나뉜다 입출력장치CPU : 연산(program counter, arithmetic logic unit으로 나뉨)Memory : 연산 내용 기록 CPU 구성 ALU : 실제 프로그램을 연산(논리, 산술 연산)Control Unit : CPU가 처리해야 할 명령어 해석 후 적절한 신호 발생Bus interface : 다른 하드웨어와 데이터 주고 받는 통로레지스터 : cpu가 요청처리하는데 필요한 데이터를 일시 저장하는 기억장치하드디스크-&gt;RAM-&gt;CPU 이렇게 데이터를 가져오는 거보다 레지스터에서 바로 가져오는게 훨씬 빠르다! 캐시 메모리 : 메모리가 cpu보다 느려서 메모리에서 자주 쓰는걸 캐시에 저장해서 cpu가 빠르게 사용(병목현상 해결) 아키텍쳐 이름의 의미 8비트가 한번에 집어넣을 수 있으면 8비트!32비트 기반 프로세서를 x86이라고 부르는데, 80386처럼 뒤에 86이 고정적으로 붙는 프로세스를 의미.64비트 프로세스는 AMD사가 지배하면서 AMD64 구조라고 이름을 붙이게 됨여기서 비트는 명령을 한번에 처리할 수 있는 레지스터의 비트 수! 명령어 세트 CISC복잡한 명령구조어드레싱에 강점(인덱싱)전력소모가 큼(고성능 컴퓨팅에 사용)Intel x86, AMD64… RISC간단한 명령어메모리 접근 횟수 적음저전력 프로세싱에 사용SPARC, ARM(모바일) 메모리 정보를 저장하는 공간 &amp; 코드+데이터RAM(random access memory 임의접근 메모리)자유롭게 읽고 쓰는 주기억장치메모리 주소로 위치에 접근어떤 위치든 같은 시간에 접근(random access, 임의 접근, 무작위가 아니라 어느 위치든 같은 속도로 접근가능하다는 뜻)휘발성 메모리.(컴퓨터 끄면 다 사라짐.) ROM(read only memory)전원이 끊겨도 정보를 유지하는 주기억장치비싸거나 느려서 안정적인 정보를 저장할 때 사용.BIOS, OS, Firmware 정보 저장에 사용 보조기억장치하드디스크나 SSD같이 대용량의 데이터를 저장하는 곳.속도가 느리지만 저렴하고 대용량의 데이터를 저장할 수 있다. 정보와 데이터의 차이정보 : 가공된 데이터데이터 : 정보를 만들기 위해 필요한 자료, 정보를 처리할 때 좀 더 편리한 형태로 바뀐 자료(이진, 디지털), 정보의 원재료 데이터 표현 및 단위수치 데이터 : 연산용 데이터비수치 데이터 : 입출력용 데이터(문자가 대표적)특수문자 : 입출력&#x2F;연산용 데이터(암호를 위한 특수문자 등…)비트-바이트-킬로바이트-메가바이트-기가바이트… 폰노이만 구조저장소에 저장된 코드를 메모리로 복사해서 cpu에서 실행폰노이만 이전 : 다른 작업할때마다 하드웨어를 재설계!폰노이만 이후 : 소프트웨어만 교체하면 됨!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Computer Structure","slug":"computer-science/computer-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/computer-structure/"}]},{"title":"8. 스프링 부트의 서비스","slug":"spring/boot/boot8","date":"2021-09-08T11:52:21.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/08/spring/boot/boot8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/boot/boot8/","excerpt":"","text":"트랜잭션트랜잭션은 일이 처리되기 위해 데이터를 작성,수정하는 가장 작은 단위를 의미한다.여러 트랜잭션이 묶여서 하나의 트랜잭션이 될 수 있다.(유튜브 영상 찍기를 위해서 - 카메라 준비, 영상 찍기, 영상 편집 이렇게 세가지 트랜잭션이 된다.)(그리고 이 세가지 트랜잭션은 영상을 업로드하기 위한 트랜잭션으로 묶일 수 있다.) 여러 트랜잭션이 모인 것을 우리는 서비스라고 부른다. 서비스의 의미서비스는 여러가지 로직이 묶인 것이라고 이해하자.만약 송금 서비스라 한다면,보낸 사람의 잔고를 update하고, 받는 사람의 잔고를 update하는 두가지 로직이 묶인 것이다.서비스는 자신이 가진 모든 로직이 성공해야 commit을 한다. 즉 보낸 사람의 잔고를 update 했는데, 받는 사람의 잔고를 update 못했다면,송금 서비스는 두 로직 모두를 롤백 시킨다.이처럼 서비스는 여러 트랜잭션을 하나의 트랜잭션으로 묶어서 사용가능하다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"7. Ajax를 사용하는 이유?","slug":"spring/boot/boot7","date":"2021-09-08T10:03:28.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/08/spring/boot/boot7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/boot/boot7/","excerpt":"","text":"회원가입 같은 로직에서 Ajax를 사용하는 이유를 알아보자. 첫번째 이유 요청에 대한 응답을 html이 아닌 Data(json)을 받기 위해서! 만약 브라우저가 회원가입을 요청했다고 하자,요청을 받은 서버는 회원정보를 DB에 넣고, 브라우저에 응답을 보내줘야 하는데,회원가입 성공을 하면 메인화면 html을 보내줄 수 있다. 근데 클라이언트가 항상 브라우저일 수는 없다!예를 들어 앱의 경우 html을 받을 수 없다!앱의 경우 그냥 정상을 의미하는 데이터를 보내줘서 이를 앱이 처리한다. 즉 앱과 웹의 원하는 응답이 다르다!그러면 우리는 서버를 웹,앱 마다 새로 만들어줘야되는건가?아니다! 우리는 그냥 데이터를 응답하는 서버를 만들거다. 그렇다면 브라우저가 어떻게 이를 인식하는가?브라우저가 요청한 회원가입을 서버가 처리해 데이터를 브라우저에게 응답해주면,브라우저는 바로 메인화면을 보여달라는 요청을 보내도록 한다.그러면 서버는 html파일을 응답하고 브라우저는 그 파일을 표시하도록 작동한다. 앱은 그냥 데이터 받으면 자기가 메인화면을 띄울 수 있으므로(즉 html파일을 요청하지 않아도 되므로)즉시 메인화면으로 이동한다. 이렇게 앱과 웹에서 모두 데이터를 응답받을 수 있게 처리하는게 Ajax의 사용하는 이유다. 두번째 이유 비동기 통신을 하기 위해서(순서에 상관없이 처리) 순차적으로 작업을 진행할 경우, 시간이 오래걸리는 작업을 기다리느라(이를 peding이라함)다른 작업들은 기다리기만 하면 상당히 답답할 것이다.예를 들어 RAM과 HDD가 사용되는 작업(IO 등..)을 기다리느라CPU가 필요한 작업이 아무것도 못하게 되는 상황은 비효율적이다. Ajax는 작업을 순차적으로 진행하지 않는다.CPU가 필요하지 않은 작업은 다른 파트(RAM, HDD 등..)에 넘긴다.만약 CPU가 필요한 작업 중, 다른 파트의 작업이 필요한 경우(다운로드 받은 파일을 화면에 띄우기 등..)다른 파트에서 필요한 작업을 마무리 할 때까지 다른 작업을 하고 있거나, 대기하고 있는다.이런 작업 형태를 비동기적 작업이라고 한다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"12.[블로그 프로젝트] Ajax를 활용한 회원가입 세팅","slug":"spring/blog/blog12","date":"2021-09-08T08:14:35.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/08/spring/blog/blog12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/08/spring/blog/blog12/","excerpt":"","text":"JS 세팅resource - static에 js폴더를 만들고 그 안에 user폴더 생성한다.user폴더에 user.js를 만들고 다음같이 작성한다.그리고 jQuery를 사용해 다음같이 작성한다. 1234567891011let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; alert(&#x27;user의 함수 호출&#x27;); &#125;&#125;index.init(); 그리고 joinForm.jsp에 가서 button태그가 form에 있으면 submit이 같이 되기 때문에 button태그 바깥으로 빼준다.그리고 버튼 태그의 type 속성을 지우고, id &#x3D; “btn-save”를 넣어준다.그리고 스크립트 태그로 우리가 만든 user.js 태그를 사용해서 연결한다. 12345 &lt;/form&gt; &lt;button id=&quot;btn-save&quot; class=&quot;btn btn-primary&quot;&gt;회원가입&lt;/button&gt;&lt;/div&gt;&lt;script src = &quot;/blog/js/user.js&quot;&gt;&lt;/script&gt; 이제 joinForm.jsp에서 스크립트 태그를 읽게되면, js파일의 init을 호출하게 되고, init은 save함수를 호출하게 되므로 user의 함수 호출이라는 알림이 뜨게 된다! 그러고 나서 user.js를 다음같이 데이터를 받아오도록 하고 브라우저 개발자 도구의 콘솔로 확인해볼 수 있도록 해보자. 12345678910111213141516let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125; console.log(data); &#125;&#125;index.init(); Ajax 요청으로 회원가입 처리하기Ajax를 왜 사용할까? 링크 user.js에 Ajax로 다음과 같이 작성하자. 12345678910111213141516171819202122232425262728293031323334let index = &#123; init : function()&#123; $(&quot;#btn-save&quot;).on(&quot;click&quot;,()=&gt;&#123; this.save(); &#125;);//btn-save를 찾아 리스너를 킨다. &#125;, save : function()&#123; let data = &#123; username: $(&quot;#username&quot;).val(), password: $(&quot;#password&quot;).val(), email: $(&quot;#email&quot;).val() &#125;; //console.log(data); //ajax 호출 시 비동기 호출 $.ajax(&#123; //회원가입을 요청 type : &quot;POST&quot;, url : &quot;/blog/api/user&quot;, data : JSON.stringify(data), //자바가 js 객체를 인식못해서 json으로. contentType: &quot;application/json; charset=utf-8&quot;, //바디 데이터가 어떤 타입인지 dataType : &quot;json&quot; //서버가 보낸 응답이 왔을때 생긴게 json이면 js오브젝트로 변환해서 parse! &#125;).done(function (resp) &#123;//resp에는 json객체가 있겠죠. //성공시 수행 console.log(resp); alert(&quot;회원가입완료&quot;); location.href = &quot;/blog&quot;; //응답이 정상일때 출력할 링크 &#125;).fail(function (error) &#123; //실패시 수행 alert(JSON.stringify(error)); //에러도 json객체로 바꿈 &#125;);//ajax 통신을 이용해서 3개의 데이터를 json으로 변경해 insert요청! &#125;&#125;index.init(); 이 코드를 해석하면this.init은 btn-save를 가진 태그가 클릭되는지 감시하는 리스너를 활성화한다.클릭이 되면 this.save를 호출한다. this.save는 회원가입 페이지에서 입력한 3가지 변수를 가져와 js객체에 할당하고, Ajax로 서버에 회원가입을 요청한다. Ajax의 요청할 때 코드는 이런 의미다.어떤 종류의 요청인지?어떤 url로 요청할 것인가?(js오브젝트를 json으로)body에 어떤 데이터를 담아 보낼 것인가?body에는 어떤 형식의 데이터를 담았는가?응답을 받을 때 어떤 형식으로 오는가? 그리고 나서 성공했을 때의 done과 실패했을 때의 fail을 작성했다.done은 완료 메시지를 브라우저가 표시하고, 메인화면을 표시하도록 한다.fail은 자바 객체로 받은 error를 json으로 바꿔 브라우저에 표시한다. UserApiController 클래스이제 controller 패키지에 api 패키지를 만들고UserApiController 클래스를 만들어 메소드를 만들자. 1234567891011121314@RestControllerpublic class UserApiController &#123; @Autowired private UserService userService; @PostMapping(&quot;/api/user&quot;) public ResponseDto&lt;Integer&gt; save(@RequestBody User user)&#123; System.out.println(&quot;UserApiController save called&quot;); user.setRole(RoleType.USER); userService.signUp(user); return new ResponseDto&lt;Integer&gt;(HttpStatus.OK.value(), 1);//정상작동을 알림 &#125;&#125; 여기에는 dto와 service 개념이 필요한데,일단 dto 패키지를 만들어 ResponseDto클래스를 만들자. 12345678@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class ResponseDto &lt;T&gt;&#123; int status; T data;&#125; 이 객체는 데이터와 http 상태 코드를 저장하는 변수가 있다. 그리고 데이터베이스 트랜잭션을 담당하는 service는 링크를 참고하자.서비스도 service 패키지를 만들어서 UserService 클래스를 만들자. 1234567891011//스프링이 컴포넌트 스캔을 통해서 Bean에 자동 등록. IoC를 해줌@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; @Transactional //메소드 속 여러 트랜잭션이 하나의 트랜잭션을 묶임 public void signUp(User user)&#123; userRepository.save(user);//잘못된 예외발생시 GlobalExceptionHandler가 예외처리 &#125;&#125; 레포지토리를 DI로 가져와서, signUp메소드 속 트랜잭션들을 묶어서 처리한다. 요약이제 회원가입 페이지에 들어가면 user.js에 따라 버튼에 이벤트 리스너가 켜지고,내용을 넣고 회원가입 버튼을 누르면, 내용을 js객체로 담고 Ajax로 json으로 바꿔서 url로 요청한다. UserApiController에 있는 useService서비스를 실행시켜 데이터를 DB에 저장하고 ResponseDto에 http상태와 성공유무 알게 하는 정수 값을 반환한다.요청 성공&#x2F;실패에 따라, 브라우저가 메시지를 나타낸다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"11.[블로그 프로젝트] 로그인, 회원가입 화면 만들기","slug":"spring/blog/blog11","date":"2021-09-07T12:21:33.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/07/spring/blog/blog11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/blog/blog11/","excerpt":"","text":"템플릿 구성하기우리 블로그에서 모든 페이지에서 푸터가 동일하게 적용될 수 있도록 템플릿을 구성해보자.스크립트 태그를 바디가 끝나는 태그 바로 위에 두자.(다른방식도 있으니 유의하자.)views 폴더 안에 layout 폴더를 만들고, footer.jsp, header.jsp를 만들자. 그리고 index.jsp에서 헤더에 해당하는 부분을 header.jsp로 옮기고,푸터도 index.jsp에서 푸터에 해당하는 부분을 footer.jsp로 가져온다. 그 대신 index.jsp에서 원래 헤더가 있어야 할 자리에 1&lt;%@ include file=&quot;layout/header.jsp&quot;%&gt; 푸터가 있어야할 자리에는 1&lt;%@ include file=&quot;layout/footer.jsp&quot;%&gt; 이 코드를 넣어주면 정상작동한다! 회원가입, 로그인 페이지 컨트롤러 메소드 만들기1234567891011@Controllerpublic class UserController &#123; @GetMapping(&quot;/user/joinForm&quot;) public String joinForm()&#123; return &quot;user/joinForm&quot;; &#125; @GetMapping(&quot;/user/loginForm&quot;) public String loginForm()&#123; return &quot;user/loginForm&quot;; &#125;&#125; joinForm.jsp, loginForm 만들기부트스트랩4 staked form을 활용.joinForm.jsp 12345678910111213141516171819202122232425262728&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/action_page.php&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email address:&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;Enter email&quot; id=&quot;email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;회원가입&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt; loginForm.jsp 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ include file=&quot;../layout/header.jsp&quot;%&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/action_page.php&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Enter password&quot; id=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group form-check&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;로그인&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;%@ include file=&quot;../layout/footer.jsp&quot;%&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"6. intelliJ의 Spring boot 프로젝트에서 JSP파일 생성이 안될 때 해결 방법","slug":"spring/boot/boot6","date":"2021-09-07T10:59:06.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/07/spring/boot/boot6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/boot/boot6/","excerpt":"","text":"자 intellJ로 Spring Boot 프로젝트를 다루는 와중 문제가 생겼다.JSP를 추가하기 위해 디렉토리를 만들었는데…여기 WEB-INF 폴더에서 new를 해도 JSP파일을 고를 수가 없다..! 그래서 혼신의 구글링을 통해 해결방법을 찾았다.File - Project Structure - Web Resource Directory에서 우리가 만든 디렉토리 경로를 추가해주면 된다!wow!참고링크","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[{"name":"troubleShooting","slug":"troubleshooting","permalink":"https://yangdongjue5510.github.io/tags/troubleshooting/"}],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"5. 스프링 기본파싱전략과 JSON통신","slug":"spring/boot/boot5","date":"2021-09-07T08:17:14.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/07/spring/boot/boot5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/boot/boot5/","excerpt":"","text":"Get요청Get은 body에 데이터를 못 담는다.주소에 데이터를 담아 보낸다.데이터 형태는 key : value 형태이다. Post, Put, Delete 요청데이터를 담아보내야 할 것이 많다!body에 담아서 보낸다. form 태그 방식으로 post를 요청할 수 있지만,form은 get, post만 가능하므로자바스크립트로 요청하는게 일반적이다. 결국 자바스크립트로 ajax 요청 + 데이터는 json으로 통일해서 요청한다! 근데 스프링에는 form:form 태그가 있다.put, post, delete, get이 모두 가능하다.(그냥 있다고만 알자.) 스프링 컨트롤러의 기본 파싱전략(key : value 형태의 데이터, form태그 형식)스프링 컨트롤러는 기본적으로 key : value 형태로 파싱해서 변수에 할당한다.스프링은 key : value 형태 데이터를 자바 오브젝트로 파싱해서 받아주기도 한다.해당 자바 오브젝트에 setter가 없으면, key : value 데이터를 파싱하지 못한다.즉 오브젝트에 없는 요소를 넘겨줘도 문제가 일어난다는 의미다. key : value 형식이 아닌 데이터는 어떻게 파싱할까?json이나 text데이터를 스프링 컨트롤러가 받기 위해서는@RequestBody 어노테이션이 필요하다!!!@RequestBody를 붙이면 MessageConverter 클래스를 구현한 jackson라이브러리가 발동되면서데이터를 자바 오브젝트로 파싱해 받아온다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"10.[블로그 프로젝트] 부트스트랩으로 메인화면 만들기","slug":"spring/blog/blog10","date":"2021-09-07T07:56:17.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/09/07/spring/blog/blog10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/spring/blog/blog10/","excerpt":"","text":"웹 UI를 구현할 때, 굳이 html, css를 모두 구현할 필요가 없다.Bootstrap이나 Materialize를 통해서 쉽게 구현할 수 있다. 우리는 w3school에서 bootstrap4의 collapsing the navigation bar의 코드를 복사한다. 이렇게 프로젝트 구조를 만들어서 index.jsp에 우리가 아까 복사한 내용을 덮어쓰운다.(3번째 줄부터 붙여써야한다.) 그리고 com.cos.blog 하에 controller 패키지를 만든다.그 패키지 안에 BoardController, UserController 클래스를 만든다.다음과 같이 작성해보자. 12345678@Controllerpublic class BoardController &#123; @GetMapping(&#123;&quot;&quot;,&quot;/&quot;&#125;) //아무것도 적지 않거나, /를 붙였을 때 모두 public String index()&#123; return &quot;index&quot;; &#125;&#125; 이렇게 작성 후 localhost:8000&#x2F;blog&#x2F;에 접속하면 우리가 아까 만든 index.jsp가 웹에 전달된다..! 그 비밀은 application.yml에 있다. 12345spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp 보다시피 html을 전달해줘야되는 경우, 미리 경로를 지정한 곳에서 파일을 가져가도록 했다. 부트스트랩에서 푸터와 카드 코드를 가져와 약간 수정을 해주면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%-- Created by IntelliJ IDEA. User: MUHN2-031 Date: 2021/09/07 Time: 8:06 오후 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Bootstrap Example&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-md bg-dark navbar-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/blog&quot;&gt;Mudura&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapsibleNavbar&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapsibleNavbar&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/login&quot;&gt;로그인&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/user/join&quot;&gt;회원가입&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;&lt;/br&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;card m-2&quot; &gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h4 class=&quot;card-title&quot;&gt;제목&lt;/h4&gt; &lt;p class=&quot;card-text&quot;&gt; 내용 &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;%--푸터자리--%&gt;&lt;div class=&quot;jumbotron text-center&quot; style=&quot;margin-bottom:0&quot;&gt; &lt;p&gt;🧑‍💻 created by Yangdongjue5510&lt;/p&gt; &lt;p&gt;💭 Backend Dev.&lt;/p&gt; &lt;p&gt;🌱 Powered by Spring Boot&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"27. 최소공배수, 최대공약수 (GCD, 유클리드 호제법)","slug":"cs/algorithm/problem/al27","date":"2021-09-06T23:49:20.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al27/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al27/","excerpt":"","text":"최대공약수, 최소공배수를 다룬 문제가 나오면 GCD나 유클리드 호제법을 반드시 알고 있어야한다!알아보자! GCD 최대공약수를 구하는 알고리즘두 수 중 작은 수가 0이 될 때까지 반복하면 된다.큰수는 작은수가 되고, 작은수는 큰수를 작은수로 나눈 나머지가 된다. 123456789//a&gt;bint GCD(int a, int b)&#123; while(b !=0)&#123; int r = a % b; a = b; b = r; &#125; return a;&#125; 실제 백준 문제로 확인해보자. 123456789101112131415161718192021import java.util.*;import java.io.*;public class Main&#123; public static int GCD(int a , int b)&#123; while(b != 0)&#123; int r = a%b; a = b; b = r; &#125; return a; &#125; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); int small = GCD(a, b); int big = (a*b)/small; System.out.printf(&quot;%d\\n%d&quot;,small,big); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"26. 백준 10799번 쇠막대기","slug":"cs/algorithm/problem/al26","date":"2021-09-06T23:32:27.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al26/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al26/","excerpt":"","text":"접근 아이디어 스택을 사용해서 “(“이 나올 때마다 push!“)”이 나올때마다 pop하고 나서 스택에 남은 요소 만큼 쇠막대기가 더해지거나 하나만 더해진다.이전에 “(“ 였으면 스택 요소 갯수만큼, 이전에 “)”였으면 그냥 1만 더해진다. 필요한 개념 삼항 연산자에 대해 알아보자.조건문 ? true일 경우 : false일 경우 1int add = prev == &#x27;)&#x27; ? 1 : stk.size(); 코드 12345678910111213141516171819202122232425import java.io.*;import java.util.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); char[] arr = br.readLine().toCharArray(); int result = 0; char prev = &#x27; &#x27;; for(char c : arr)&#123; switch(c)&#123; case &#x27;(&#x27;: stk.push(c); break; case &#x27;)&#x27;: stk.pop(); int add = prev == &#x27;)&#x27; ? 1 : stk.size(); result += add; break; &#125; prev = c; &#125; System.out.println(result); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"25. 백준 17413번 단어 뒤집기2","slug":"cs/algorithm/problem/al25","date":"2021-09-06T23:14:56.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/09/07/cs/algorithm/problem/al25/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/07/cs/algorithm/problem/al25/","excerpt":"","text":"접근 아이디어 &lt; &gt;안에 있는 단어를 그렇지 않은 단어와 다르게 처리해야 한다.그러나 언제 &lt; &gt;가 나올지 모르는게 문제다!그래서 “&gt;”를 기준으로 문장을 나누면 &lt; &gt; 문자열의 위치에 규칙이 생긴다.만약 &lt; &gt;가 있으면 항상 뒤 쪽에 있다는 것! 필요한 문법 이번엔 라벨을 사용해서 루프를 빠져 나왔다. 123456outerLable: for (int i = 0; i&lt;arr.length ; i++)&#123; char c = arr[i]; switch(c)&#123; case &#x27;&lt;&#x27;: break outerLable; 코드 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine(),&quot;&gt;&quot;,true); Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); StringBuilder sb = new StringBuilder(); while(st.hasMoreTokens())&#123; char[] arr = st.nextToken().toCharArray(); int tmp = 0; outerLable: for (int i = 0; i&lt;arr.length ; i++)&#123; char c = arr[i]; switch(c)&#123; case &#x27;&lt;&#x27;: break outerLable; case &#x27; &#x27;: while(stk.size()!=0) sb.append(stk.pop()); sb.append(&#x27; &#x27;); break; default: stk.push(c); break; &#125; tmp++; &#125; while(stk.size()!=0) sb.append(stk.pop()); for (int i = tmp; i&lt;arr.length ; i++) sb.append(arr[i]); &#125; System.out.println(sb); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"9. [블로그 프로젝트] update, delete 테스트","slug":"spring/blog/blog9","date":"2021-09-06T11:35:28.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/06/spring/blog/blog9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/blog/blog9/","excerpt":"","text":"update1. save 메소드를 활용한 update123456789101112131415@PutMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public User updateUser(@PathVariable int id, @RequestBody User requestUser)&#123; System.out.println(&quot;id :&quot;+id); System.out.println(&quot;username: &quot;+requestUser.getUsername()); System.out.println(&quot;password:&quot;+requestUser.getPassword()); System.out.println(&quot;email:&quot;+requestUser.getEmail()); User user = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;수정 실패하였습니다.&quot;); &#125;); user.setUsername(requestUser.getUsername()); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); userRepository.save(user); return user;&#125; Body에서 json 객체를 가져오기 위한 @RequestBody 어노테이션을 사용해서 객체에 할당한다. 일단 save메소드의 특징을 알아보자.객체를 DB에 저장할 때, 해당 id가 이미 있으면, 그 객체 그대로 update한다!즉 일부 속성을 변경하려 하면, 해당 id에 맞는 객체를 DB에서 찾아오고, 그 객체 필드를 수정하고 save해야 올바른 업데이트다.(이거 은근 귀찮다.) save 메소드 id 없이 사용되면 insertid를 넘겨주고, DB에 해당 데이터 있으면 updateid를 넘겨주고, DB에 해당 데이터 없으면 insert 2. @Transactional으로 update(더티 체킹)save하지 않아도 업데이트 된다. 객체를 찾아서 값만 변경하면 반영된다! 12345678910111213141516@Transactional@PutMapping(&quot;/dummy/user2/&#123;id&#125;&quot;)public User updateUser2(@PathVariable int id, @RequestBody User requestUser)&#123; System.out.println(&quot;id : &quot;+id); System.out.println(&quot;username: &quot;+requestUser.getUsername()); System.out.println(&quot;password : &quot;+requestUser.getPassword()); System.out.println(&quot;email: &quot;+requestUser.getEmail()); User user = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;update fail!!!!!!!&quot;); &#125;); user.setUsername(requestUser.getUsername()); user.setPassword(requestUser.getPassword()); user.setEmail(requestUser.getEmail()); return user;&#125; 더티체킹_좀더알기 delete삭제는 참 쉽다! 1234567891011//delete@DeleteMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public String delete(@PathVariable int id)&#123; try&#123; userRepository.deleteById(id); &#125;catch(EmptyResultDataAccessException e)&#123; return &quot;삭제 실패했습니다. 해당 id는 데이터베이스에 없습니다.&quot;; &#125; return &quot;삭제됐습니다! id: &quot;+id;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"4. 영속성 컨텍스트와 더티체킹","slug":"spring/boot/boot4","date":"2021-09-06T08:36:10.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/09/06/spring/boot/boot4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/boot/boot4/","excerpt":"","text":"영속성 컨텍스트?영속성 컨텍스트는 JPA안에 존재하는 개념인데,우리가 만든 컨트롤러에서 save메소드를 호출하게 되면, 영속성 컨텍스트에 1차 캐시라는 것이 생성되고,1차 캐시에 우리가 save메소드의 인자로 보낸 객체가 쌓인다.이 과정을 영속화 되었다고 한다. 이렇게 영속화된 객체를 실제 DB에 저장하는 행위를 flush라고 한다.근데 flush이후에 1차 캐시에는 여전히 해당 객체가 남아있다.나중에 영속화된 객체를 select하는 경우, 데이터베이스에 가지 않고 JPA의 1차 캐시에서 가져오기 때문이다. update하는 경우에도 비슷하다.DB에서 원하는 데이터를 1차 캐쉬에 영속화시키고,컨트롤러가 가져와 수정한다.수정이 끝난 객체를 다시 1차 캐쉬에 영속화 시켜야 하는데, 이때, 1차 캐쉬에는 이미 변경 전 데이터가 영속화되어있다.그리고 변경 후 데이터를 영속화(save메소드)시키려 할 때, 변경 전 데이터와 id값이 같으므로,그냥 변경 전 데이터를 변경 후 데이터처럼 수정 시키는 것으로 영속화를 대신한다. @Transaction 어노테이션 해당 메소드가 종료되면 자동으로 commit한다! (변경 여부를 파악하고 변경된 경우만 DB에 업데이트!)&#x3D;&gt; 이 기능이 바록 더티 체크일반적으로 DB에서는 변경사항을 모았다가 한번에 반영하는 것을 의미하지만,JPA에서는 변경사항을 인식해서 반영하는 것을 의미한다.[더티체크_예시]","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"8. [블로그 프로젝트]select 테스트","slug":"spring/blog/blog8","date":"2021-09-06T06:12:26.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/06/spring/blog/blog8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/06/spring/blog/blog8/","excerpt":"","text":"select1. 하나의 데이터 select하기!123456789101112131415161718192021@GetMapping(&quot;/dummy/user/&#123;id&#125;&quot;)public User detail(@PathVariable int id)&#123; //1. User user = userRepository.findById(id).orElseGet(new Supplier&lt;User&gt;() &#123; @Override public User get() &#123; return new User(); &#125; &#125;); //2. User user2 = userRepository.findById(id).orElseThrow(new Supplier&lt;IllegalArgumentException&gt;() &#123; @Override public IllegalArgumentException get() &#123; return new IllegalArgumentException(&quot;해당 유저는 없습니다. id :&quot;+id); &#125; &#125;); //3.Ramda User user3 = userRepository.findById(id).orElseThrow(()-&gt;&#123; return new IllegalArgumentException(&quot;해당 사용자가 없네요. id: &quot;+ id); &#125;); return user2; 일단 jpaRepository 메소드인 findById를 알아보자.findById는 id를 받아 optional 클래스를 반환한다.(null을 그냥 반환하면 문제가 생길 수도 있기 때문.)그래서 반환형에 안맞으니, 따로 처리를 더 해주자. 1번은 Optional 클래스의 orElseGet메소드로 값이 없는 경우를 처리한다.이때 orElseGet메소드는 supplier 인터페이스를 받으므로, user는 익명 클래스로 get을 오버라이딩해서 처리해줬다. 2번은 Optional 클래스의 orElseThrow로 값이 없는 경우에 예외를 발생시킬 수 있다.3번은 익명 클래스 대신 람다 표현식으로 간단하게 표현했다. 자바에서 자바 객체를 전달하는데 웹브라우저가 어떻게..? 자바 객체를 웹브라우저가 이해하려면 json으로 바꿔줘야한다!스프링 부트는 MessageConverter가 response시 작동해서Jackson 라이브러리를 호출해서 변환한다! 2. 전체 데이터 select1234@GetMapping(&quot;/dummy/users&quot;)public List&lt;User&gt; list()&#123; return userRepository.findAll();&#125; JpaRepository 인터페이스의 findAll메서드는 모든 데이터를 리스트 형식으로 반환한다.참 쉽죠? 3. 페이지로 데이터 select123456@GetMapping(&quot;/dummy/user&quot;) public List&lt;User&gt; list2(@PageableDefault(size = 2, sort = &quot;id&quot;,direction = Sort.Direction.DESC)Pageable pageable)&#123; Page&lt;User&gt; pagingUser = userRepository.findAll(pageable); List&lt;User&gt; users = pagingUser.getContent(); return users; &#125; @PageableDefault를 붙인 Pageable 인터페이스를 인자로 보내준다.@PageableDefault는 한 페이지 당 데이터 갯수, 정렬 기준, 정렬 방향(내림차, 오름차)findAll메서드에 Pageable인터페이스를 인자로 보내주면, 기준에 맞춘 페이지 객체들을 리스트로 만들어 반환한다.이 리스트를 getContent하면 우리가 가져오는 데이터 객체를 가져올 수 있다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"9. 어노테이션","slug":"java/java-basic/java9","date":"2021-09-05T00:48:35.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/05/java/java-basic/java9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/05/java/java-basic/java9/","excerpt":"","text":"어노테이션어노테이션은 자바 소스코드에 추가적인 정보를 제공하는 메타데이터이다.어노테이션 선언 방법을 알아보자 1. 마커 어노테이션표시만 해두는 어노테이션. 메서드 없이 선언하면 마커 어노테이션이 된다.@Override, @Deprecated 가 대표적 예시. 1public @interface Marker&#123;&#125; 이렇게 선언을 해놓으면, 12@Markerpublic class Main(String[] args)&#123;&#125; 2. single value 어노테이션하나의 값을 입력받을 수 있는 어노테이션. 1234public @interface Single&#123; int value(); //이 변수의 이름은 반드시 value //int[] value(); 이렇게 하면 여러 int값을 받을 수 있다.&#125; 이런 식으로 선언할 수 있다. 123456789101112131415161718192021package annotation;import java.lang.annotation.*;import java.lang.reflect.*;@Retention(RetentionPolicy.RUNTIME)@interface Single&#123; int value();&#125;public class Main &#123; @Single(10) public static void myMethod() throws NoSuchMethodException &#123; Main obj = new Main(); Method m = obj.getClass().getMethod(&quot;myMethod&quot;); Single single = m.getAnnotation(Single.class); System.out.println(single.value()); &#125; public static void main(String[] args) throws NoSuchMethodException &#123; myMethod(); &#125;&#125; 이렇게 사용할 수 있다! 3. multi value 오너테이션여러 개의 값을 저장할 수 있는 어노테이션이다. 12345public @interface MultiValue&#123; int id(); String name() default &quot;yang&quot;; String[] roles() default &#123;&quot;Student&quot;, &quot;backend&quot;&#125;;&#125; 이런 식으로 선언할 수 있다. 12@MultiValue(id = 1, name = &quot;yang&quot;, roles = &#123;&quot;a&quot;, &quot;b&quot;&#125;)public void myMethod()... 이런식으로 활용할 수 있다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"8. 객체지향 개념(상속, 업캐스팅, 오버라이딩, 인터페이스)","slug":"java/java-basic/java8","date":"2021-09-03T12:49:07.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/03/java/java-basic/java8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/03/java/java-basic/java8/","excerpt":"","text":"1. 상속extends로 특정 객체의 필드와 메소드를 상속받을 수 있다.이때, super클래스의 private 필드나 메소드는 자식클래스도 직접 접근할 수 없다. 그렇다면 자식 클래스는 상위 클래스의 멤버 변수를 어떤 원리로 사용할 수 있는 건가? 12345678public Super()&#123; className = &quot;super&quot;;&#125;....public Sub()&#123; //super();를 컴파일러가 추가해준다. className = &quot;Sub&quot;;&#125; 즉 자식 클래스의 생성자에는 상위 클래스의 디폴트 생성자를 컴파일러가 추가한다. 2. 업캐스팅 vs 다운캐스팅업캐스팅 : 서브 클래스 -&gt; 슈퍼 클래스서브 클래스 객체더라도 슈퍼 클래스의 필드, 객체만 사용가능. 1Super super = new Sub(); 다운 캐스팅 : 슈퍼 클래스 -&gt; 서브 클래스업캐스팅을 먼저 하고, 슈퍼 클래스를 괄호로. 1Sub sub = (Sub)super; 3. 오버라이딩 vs 오버로딩오버라이딩 : 같은 상속 관계 클래스 간의 같은 이름의 메서드를 재정의 123456789//super.javapublic void methodExample()&#123; ...&#125;//sub.java@Overridepublic void methodExample()&#123; ...&#125; 이때 리턴형, 메소드 이름, 매개변수가 같아야한다! 오버로딩 : 같은 이름 메소드를 매개변수 유형과 개수를 다르게 확장하는 행위 1234567//super.javapublic void methodExample()&#123; ...&#125;public void methodExample(int i)&#123; ...&#125; 4. 클래스 vs 인터페이스클래스 :생성자 가짐인스턴스화 가능다중 상속 가능여러 접근 제어자A는 B의 추상 클래스 &#x3D; B is a kind of A 인터페이스 :생성자 가질 수 없음인스턴스화 불가능다중 상속 가능항상 publicA는 B의 인터페이스 &#x3D; B is able to A 인터페이스 키워드 생략 1234(public) interface 인터페이스이름 &#123; (public static final) 변수타입 상수이름 = 값; (public abstract) 반환형 메서드이름(매개변수...);&#125; 괄호 안에 있는 키워드들은 우리가 생략해도, 컴파일러가 넣어준다. 인터페이스의 구현된 메소드 (default, static, private) static method구현된 메소드. 하지만 구현된 클래스에 상속되지 않는다!즉 인터페이스에서만 접근 가능한 메소드인 셈이다. default method이 친구도 구현된 메소드다. 근데 얘는 구현된 클래스에 상속된다.디폴트 메소드는 인터페이스를 구현한 클래스들이 나중에 인터페이스에 추가된 메소드를 구현하지 않아도 사용가능하도록 하기 위해 추가됐다. private method이 녀석도 구현된 메소드이다.static을 붙이기도 한다.근데 이 녀석은 구현된 클래스에 상속되지 않는다.이 녀석은 인터페이스 구현에 필요한 상세 내용을 캡슐할 때 사용된다. confilct 여러 인터페이스의 디폴트 메서드 간의 충돌이 발생하면? 12345678910interface a&#123; default void method&#123;&#125;&#125;interface b&#123; default void method&#123;&#125;&#125;public class c implements a, b&#123; @Override public void method&#123;&#125;&#125; 오버라이딩으로 우리가 사용할 메소드를 재정의해야 컴파일 에러가 나지 않는다! 디폴트 메서드와 상위 클래스의 메소드 간의 충돌이 난다면? 1234567class a&#123; public void method&#123;&#125;&#125;interface b&#123; default void method&#123;&#125;&#125;class c extends a implements b&#123;&#125; 이럴 경우 a의 method가 우선순위이므로, 수퍼 클래스의 메소드가 실행된다. Collections vs Collection Collection :콜렉션 프레임워크의 인터페이스각 자료구조들이 공통적으로 가지는 메서드들을 포함추상메소드, 정적메소드, 디폴트메소드 모두를 포함가능 Collections콜렉션 프레임워크 객체들을 유용하게 사용할 수 있는 유틸리티 메소드가 정의된 클래스모든 메소드가 정적메소드.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"7. [블로그 프로젝트] 회원가입을 위한 insert 구현하기","slug":"spring/blog/blog7","date":"2021-09-02T11:29:25.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/02/spring/blog/blog7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/02/spring/blog/blog7/","excerpt":"","text":"JpaRepository이제 DB에 insert하기 위해 프로그램을 작성해볼 것이다!먼저 com.cos.blog 패키지 하위에 repository라는 폴더를 만들자.그리고 그 안에 UserRepository 인터페이스를 만들자.이 인터페이스는 DB 저장소에 update할 메소드를 제공한다. 12345678910package com.cos.blog.repository;import com.cos.blog.model.User;import org.springframework.data.jpa.repository.JpaRepository;//자동으로 bean으로 등록//@Repository 생략가능public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; //기본적인 CRUD는 모두 가지고 있음.&#125; JpaRepository&lt;\\User, Integer&gt; : &lt;\\해당 테이블, 그 테이블의 기본키 객체 형&gt;이렇게 JpaRepository를 상속해서 만들면 CRUD에 해당하는 메소드를 이용할 수 있다.그리고 이렇게 처리를 하면 bean으로 자동으로 등록된다! 실제로 잘 되는지 한번 테스트 해보자. Insert 테스트우리는 dummyDataController를 만들어 우리가 만든 레포지토리 인터페이스를 실험해보자. 1234567891011121314151617181920212223242526272829303132333435363738package com.cos.blog.test;import com.cos.blog.model.RoleType;import com.cos.blog.model.User;import com.cos.blog.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DummyControllerTest &#123; @Autowired//해당 클래스가 메모리에 올려지면, 해당 변수 타입에 맞는 객체가 메모리에 있으면 변수에 할당.(DI, 의존성 주입) private UserRepository userRepository; @PostMapping(&quot;/dummy/join&quot;) public String join(String username, String password, String email)&#123; //x-www.form-urelencoded는 key-value형태로 받는데 이는 스프링이 함수의 파라미터로 밸류값을 다 저장해준다. //@RequestParam(&quot;username&quot;) String u...이런식으로 변수명을 유연하게도 가능! System.out.println(&quot;username: &quot;+username); System.out.println(&quot;password: &quot;+password); System.out.println(&quot;email: &quot;+email); return &quot;회원가입이 완료 되었습니다!&quot;; &#125; @PostMapping(&quot;/dummy/join2&quot;) public String join2(User user)&#123; //객체 형태로도 가능하다!(다만 데이터의 키값이 객체의 변수명과 일치해야 함 System.out.println(&quot;role: &quot;+user.getRole()); System.out.println(&quot;username: &quot;+user.getUsername()); System.out.println(&quot;password: &quot;+user.getPassword()); System.out.println(&quot;email: &quot;+user.getEmail()); System.out.println(&quot;createDate: &quot;+user.getCreateDate()); user.setRole(RoleType.USER); //User 클래스의 @DynamicInsert를 대신하는 문장. userRepository.save(user); //회원정보 저장. return &quot;회원가입이 완료 되었습니다!&quot;; &#125;&#125; @Autowired : 이 어노테이션이 담긴 클래스가 메모리에 올라가면, 이 어노테이션 밑 변수에 형에 맞는 객체를 주입(DI)이 어노테이션을 통해 저장소 객체를 변수에 할당할 수 있다.그리고 테이블 객체를 save메소드로 DB에 저장할 수 있다!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"6. [블로그 프로젝트] 데이터 테이블 생성 및 관계 설정.","slug":"spring/blog/blog6","date":"2021-09-01T05:26:09.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/09/01/spring/blog/blog6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/01/spring/blog/blog6/","excerpt":"","text":"application.yml의 JPA일단 application.yml파일에 있는 jpa 관련 내용을 해석해보자. 12345678910jpa: open-in-view: true hibernate: naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl use-new-id-generator-mappings: false ddl-auto: create show-sql: true properties: hibernate.format_sql: true use-new-id-generator-mappings : true면 JPA가 사용하는 기본 넘버링 전략을 사용한다는 의미!ddl-auto : 매 서버를 시작할 때마다 있던 테이블은 지우고, 새로 만들거나(create), 있던 걸 업데이트(update)show-sql : 서버 콘솔에 쿼리를 표시hiberate.format_sql : 쿼리가 정렬되서 나오도록 표시physical-strategy : DB에 이름을 어떻게 저장할 것인가. (현재는 자바 객체 이름 그대로) 데이터 테이블 만들기현 프로젝트의 블로그의 댓글을 위해 user테이블, board테이블, reply테이블을 만들자.JPA로 데이터를 전달하기 위해, User, Board, Reply 클래스를 만들어서각 속성들을 private로 선언한다.이제 각 어노테이션에 대해 알아보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.DynamicInsert;import javax.persistence.*;import java.sql.Timestamp;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entity //User 클래스가 mysql에 테이블이 생성된다.//@DynamicInsert //null인 속성은 insert에서 제외한다.(null이 아닌 default값으로 채우겟다.) 어노테이션에 의존하기보다 로직으로 해결하자.public class User &#123; @Id//primary key @GeneratedValue(strategy = GenerationType.IDENTITY) //넘버링 전략, 프로젝트에 연결된 db의 넘버링 전략을 따라(identity전략) private int id; //시퀀스, auto-increment @Column(nullable = false, length = 30) private String username; @Column(nullable = false, length = 100) //해쉬때문에 넉넉히 잡음 private String password; @Column(nullable = false, length = 50) private String email; //@ColumnDefault(&quot;&#x27;user&#x27;&quot;) //&quot; &#x27;user&#x27; &quot;로 써야함! //private String role; //Enum을 쓰는게 좋지만, 지금은 String사용. @Enumerated(EnumType.STRING)//DB에는 RoleType이란게 없으니까 이 속성이 문자열임을 알 private RoleType role; //Enum을 쓰는 예시. ADMIN, USER @CreationTimestamp //시간이 자동 입력됨. private Timestamp createDate;&#125;package com.cos.blog.model;public enum RoleType &#123; USER, ADMIN&#125; @Entity : 해당 클래스를 JPA에서 테이블로 다루겠다!@Id : 해당 변수를 기본키로 설정@GeneratedValue(strategy &#x3D; GenerationType.IDENTITY) : 프로젝트에 연결된 DB의 넘버링 전략을 그대로 사용한다.(따로 입력안해도 된다. 자동으로 할당)@Column(nullable &#x3D; false, length &#x3D; 10) : null을 허용하지 않고 길이가 10이하인 속성 선언@ColumnDefault(“~”) : 속성의 기본값을 설정 (문자열은 “‘문자열’”로 해줘야!)@Enumerated(EnumType.STRING) : 변수가 enum일때, DB에 저장될 형식 선언@CreationTimestamp : 시간을 생성해 변수에 할당. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.CreationTimestamp;import javax.persistence.*;import java.sql.Timestamp;import java.util.List;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entitypublic class Board &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(nullable = false, length = 100) private String title; @Lob //대용량 데이터를 다룰 때 사용 private String content; //섬머노트 라이브러리 &lt;html&gt;태그가 섞여서 디자인이 된다. @ColumnDefault(&quot;0&quot;) //default value private int count; //자바에서 객체를 저장하면, DB에서는 FK로 구현된다. //객체를 다루려면, 관계를 설정해줘야 한다. @ManyToOne(fetch = FetchType.EAGER) //Many = Board, One = User 한 유저가 여러 게시물을 작성 가능한 관계. //fetch 전략이 해당 클래스를 가져오면 반드시 가져온다.(게시물을 불러오면 user를 반드시 조인해서 불러와라!) @JoinColumn(name = &quot;userId&quot;)//데이터베이스는 객체를 저장할 수 없으므로 userId라는 값이 대신 테이블에 저장된다. private User user; //DB에서는 오브젝트를 저장할 수 없다. 그래서 FK를 사용. 반면 자바는 오브젝트를 저장할 수 있다. @OneToMany(mappedBy = &quot;board&quot;, fetch = FetchType.EAGER) //LAZY : board를 불러온다고 무조건 가져올 필요는 없다!(기본값으로 설정되어잇음) //EAGER : 게시물이 불러오면 무조건 조인해서 가져와야됨! private List&lt;Reply&gt; reply; @CreationTimestamp private Timestamp createDate;&#125; @Lob : 대용량 데이터를 사용할 때 사용.@ManyToOne : 관계를 설정(현재 클래스 to 대상 클래스)fetch &#x3D; FetchType.EAGER : 해당 클래스를 가져올 때 조인해서 같이 가져오도록함fetch &#x3D; FetchType.LAZY : 해당 클래스를 가져올 때 반드시 가져올 필요는 없음@JoinColumn(name &#x3D; “~”) : 데이터베이스에 객체로 저장이 안되므로, 저장되는 속성이름을 지정mappedBy &#x3D; “~” : 이건 외래키를 가진 객체가 해당 속성의 주인(즉 외래키를 가진 DB에 해당 속성이 있다는 의미. 단지 객체지향적 의미로 해당 클래스에 리스트로 객체들이 선언되있음.) 123456789101112131415161718192021222324252627282930313233343536package com.cos.blog.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.CreationTimestamp;import javax.persistence.*;import java.sql.Timestamp;//lombok@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entitypublic class Reply &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(nullable = false, length = 200) private String content; @ManyToOne//Many reply to One board @JoinColumn(name=&quot;boardId&quot;) private Board board; @ManyToOne @JoinColumn(name = &quot;userId&quot;) private User user; @CreationTimestamp private Timestamp createDate;&#125; 여기보면 Reply가 BoardId 외래키로 가지고 있다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"7. 객체지향 입문(생성자, this, static)","slug":"java/java-basic/java7","date":"2021-09-01T05:25:42.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/09/01/java/java-basic/java7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/09/01/java/java-basic/java7/","excerpt":"","text":"1. 클래스 vs 객체 vs 인스턴스12345678public class CreditCard&#123; ... public static void main(String[] args)&#123; CreditCard card1, card2;//객체 card1 = new CreditCard();//인스턴스 card2 = new CreditCard();//인스턴스 &#125;&#125; 클래스는 class 키워드 뒤에 붙여진 CreditCard객체는 클래스의 타입으로 생성된 실체.인스턴스는 메모리에 할당된 객체. 2. 생성자객체에 구현되어 있는 생성자.디폴트 생성자(매개변수가 없는 생성자)는 생략되어 추가되어 있음. 생성자는 참조 데이터 타입에만 허용. 기본 데이터 타입은 객체가 아니므로 불필요. 3. 접근 제어자private : 같은 클래스 내부에서만 접근!default : 같은 패키지에서만 접근!protected : default + 상속 관계 클래스 접근가능!public : 어디서나 접근 가능~! 4. this 생성된 인스턴스의 메모리 주소 같은 클래스 내의 생성자. this(~~)이런식을 사용 자신의 주소 5. static여러 인스턴스가 공유하는 메소드, 변수, 클래스에 사용하는 키워드프로그램 실행 시 Method area에 생성되고, 프로그램 실행 종료 후 사라진다. 이때 static 메서드(클래스 메서드)는 인스턴스 변수를 사용할 수 없다!!!!(인스턴스 변수가 메모리에 아직 로딩되지 않았으므로.) 그리고 정적 메소드는 오버라이드 하면 안된다! 깊은 복사 vs 얕은 복사 얕은 복사 : 객체의 참조값을 복사!-&gt;원본이 변경되면 복사본도 변경!깊은 복사 : 객체의 실제 값을 복사-&gt;값이 변경되도 복사본은 상관 없음.System.arraycopy() : 얕은 복사.clone() : 깊은 복사 (원소 별로 new 인스턴스화) 객체는char[]기반 가변 문자열!AbstractStringBuilder 이런 걸 상속받아 만든다!!StringBuffer &#x3D; 동기화 o (synchronized)StringBuilder &#x3D; 동기화 x생성시 16trimToSize() &#x3D; 실제 문자열만큼 용량을 줄임. 리플렉션 프로그래밍JVM에서 런타임동작을 감시하거나 수정할 수 있는 기능이 있는 프로그램 (스프링 프레임워크, 하이버네이트) 예를들면, 클래스 파일이 없어도, Class 클래스를 활용… static은 왜 오버라이딩 안되냐?","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"6. JVM 구조와 가비지 컬렉터","slug":"java/java-basic/java6","date":"2021-08-30T04:18:40.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/30/java/java-basic/java6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/30/java/java-basic/java6/","excerpt":"","text":"JVM 구조아시다시피, 자바는 운영체제의 종류와 무관하게 실행가능하다.자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 읽을 수 있는 기계어로 바꿔준다.JVM은 크게 4가지로 나뉜다. 1. Class Loader자바로 코드를 작성하면 java파일이 생성된다..java파일을 컴파일하면 .class파일(바이트 코드)이 생성된다.이렇게 생성된 .class파일들을 JVM이 할당받은 메모리 영역인 Runtime Data Area에 적재하는 역할을 Class Loader가 한다. 여러 종류의 클래스 로더 Bootstrap ClassLoader : jre의 lib폴더의 rt.jar 파일 속 기본 자바 API 라이브러리 로드. Extension ClassLoader : jre의 lib폴더의 ext폴더에 모든 확장 코어 클래스파일 로드. Application ClassLoader : 사용자가 만든 클래스파일 로드. 2. Execution EngineClass Loader가 적재한 클래스(.class 바이트 코드)를 기계어로 번경해 명령어 단위로 실행한다. 3. Garbage CollectorHeap, Stack, Method 메모리 영역에 생성된 객체들 중 참조되지 않은 객체를 찾아 제거한다. 4. Runtime Data AreaJVM의 메모리 영역. 어플리케이션을 실행할 때 쓰이는 데이터를 적재.이 영역도 여러갈래로 나뉜다. 자바 런타임 메모리 구조1. Method Area모든 클래스의 정보가 저장되는 공간.클래스의 필드와 메소드 정보, Constant Pool(상수 풀: 리터럴 상수 값, 객체 참조를 저장), static 변수 등을 생성하고 저장 2. Heap Area모든 인스턴스 오브젝트가 저장되는 공간.new 키워드로 생성된 객체가 저장되는 영역.메소드 영역에 있는 클래스만 생성이 가능. GC가 참조되지 않는 메모리를 확인하고 제거 3. Stack Area지역 변수, 파라미터, 리턴 값, 임시 값 등 저장되는 곳각 쓰레드마다 개별적으로 스택이 생성된다.메소드를 호출할 때 스택에 스택 프레임이라는 스택 메모리가 쌓이는 방식. 4. PC Register(CPU의 레지스터와 다름)쓰레드가 생성될 때마다 생성되는 영역.Program Counter, 즉 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장. 5. Native Method Stack자바 외 언어로 작성된 코드를 위한 메모리 영역. 여기서 heap, Method Area는 쓰레드끼리 공유하고,stack, pc register, native method stack은 서로 공유되지 않고 각자 생성한다. heap과 GC원래는 JVM이 관리하지만, 최신 자바는 OS과 관리해서할당받아 실행하지 않는다는 장점이 있다. Heap 영역은 5개 영역으로 나뉜다.eden, survivor1, survivor2, old, permanent Minor GC : New 영역에서 일어나는 GC최초에 객체가 생성되면 eden 영역에 생성된다.eden이 가득차면 survivor1 영역에 메모리 그대로 복사 후 survivor1 제외한 영역 객체 제거이후 eden, survivor1 모두 차면, 그 중에 참조되고 있는 객체가 있는지 확인참조되고 있는 객체만 survivor2로 이동 후 다른 영역 객체 제거위 과정을 여러번해서 survivor2에 남으면, old영역으로 이동시킨다. Major GC : old 영역에서 일어나는 GCold 영역에서 참조되지 않은 객체들을 모아 한번에 제거한다.제거되어 heap 중간중간 빈 공간을 다시 재구성해 채운다.(그래서 GC가 일어나면 GC를 다루는 쓰레드 이외엔 모든 쓰레드가 정지한다.)","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"5. [블로그 프로젝트] Maven, Lombok, application.yml","slug":"spring/blog/blog5","date":"2021-08-26T11:11:05.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog5/","excerpt":"","text":"Maven자 만약에 우리가 프로젝트를 할 때 어떤 라이브러리를 사용한다고 하자.우리에게는 3가지 시나리오가 있다. 라이브러리를 다운받고, 각 프로젝트의 lib 폴더에 복사하기. 프로젝트 만들 때마다 복사해야 된다… 라이브러리를 외부에 두고 프로젝트들이 가져다 쓰기 하지만 배포할 때 라이브러리가 포함되지 않아서 힘들다.. 중앙 저장소에 라이브러리들을 저장하고, 프로젝트에 어떤 라이브러리를 쓸지 써놓기 pom.xml에 어떤 라이브러리를 쓸 지 써놓는다! 빌드 과정에서 pom.xml보고 라이브러리 다운받는다! Lombok(다운을 받아야하는데 이건 검색을 통해 해결해자!)일단 간단하게 알아보자 @Data : getter와 setter를 만듬 @AllArgsConstructor : 모든 클래스멤버를 인자로 받고 초기화하는 생성자 만듬 @RequiredArgsConstructor : 클래스 멤버 중 final 키워드가 붙은 멤버들만 인자로 받는 생성자 만듬 @NoArgsConstructor : 빈 생성자 만듬 yaml (yml)스프링 프로젝트의 전반적인 설정을 해놓는 파일.원래는 xml에 저장했으나 최근에는 yml을 주로 사용yaml은 json, xml보다 가벼움. 키와 밸류 사이에는 스페이스가 한칸 띄어져 있어야 한다!(중요!)json의 중괄호 대신, yml은 들여쓰기(스페이스 두번)으로 대체한다! application.yml스프링의 모든 설정을 다루는 파일.스프링 부트를 시작하기 전에 먼저 application.yml을 읽는다!web.xml, root-context.xml, servlet-context.xml의 합본! 우리 프로젝트의 application.yml에 다음을 복붙하자 1234567891011121314151617181920212223242526272829303132333435server: port: 8000 servlet: context-path: /blog encoding: charset: UTF-8 enabled: true force: true spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul username: 데베계정이름 password: 데베 비번 jpa: open-in-view: true hibernate: ddl-auto: create naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl use-new-id-generator-mappings: false show-sql: true properties: hibernate.format_sql: true jackson: serialization: fail-on-empty-beans: false server : 내 서버의 진입점을 정의. 비워놓을시 8080포트에 &#x2F;로 초기화 mvc : jsp 연결을 위해 설정 @Controller는 파일을 리턴하는데, 기본경로가 “src&#x2F;main&#x2F;resources&#x2F;static”이다. 이때 그냥 “file.html”을 리턴하면, “src&#x2F;main&#x2F;resources&#x2F;staticfile.html”을 찾게된다. 그래서 “&#x2F;file.html”을 리턴해줘야 올바른 경로를 찾는다. static 폴더는 브라우저가 인식가능한, css, html, js, png 등등.. 만 담는다. 컴파일이 필요한 동적파일(jsp 등)은 static에 넣으면 인식못한다. 그래서 mvc는 @Controller의 return이 어느 위치에서 찾을지를 설정한다. (위 예시에서는 views폴더에서 리턴값에 .jsp를 붙인 파일을 찾는다.) (이렇게 하면 톰캣이 jsp를 컴파일해서 브라우저에 전달한다.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"4. [블로그 프로젝트] 스프링 부트로 HTTP 데이터 전달하기","slug":"spring/blog/blog4","date":"2021-08-26T07:08:56.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog4/","excerpt":"","text":"HTTP는 어떻게 데이터를 전달할까? GET get은 URI의 쿼리 파라미터로 데이터를 전달한다.(? 뒤의 쿼리를 의미한다.)코드로 받아오는 방법은 두가지가 있다. @RequestParam : 메소드에 해당 어노테이션을 붙인 변수를 만들어서 받아온다! 클래스를 만들어서 가져오기 : 메소드에 해당 클래스 객체를 넣어주면 알아서 매핑되서 받아온다.이때 변수 명이나, URI의 key값이 클래스 멤버 변수와 동일해야 한다!!!12345@GetMapping(&quot;/http/get&quot;)//public String getTest(@RequestParam int id, @RequestParam String username...)public String getTest(Member m)&#123; return &quot;get id :&quot; + m.getId() + &quot;, username: &quot;+m.getUsername()+&quot;, password : &quot;+m.getPassword()+&quot;, email : &quot;+m.getEmail();&#125; GET 외의 api들(POST, PUT …) get을 제외한 api들은 다양한 데이터를 전달할 수 있다.그렇다면 어떻게 데이터를 보낼까?바로 body에 담아서 보낸다!! 그런데, body에서 전달하는 방식도 여러가지가 있다.포스트맨에서 확인해보자. x-www.form-unlencoded여기 보이는 x-www.form-unlencoded는 HTML에서 보이는 form태그 방식으로 데이터를 보낸다.이럴 경우에는 우리 코드 상의 메소드의 매개변수를 그냥 객체 형식으로 보내도 상관없다.form을 전제로 하기 때문에 자연스럽게 파싱된다. raw하지만 raw는 그렇지 않다. 우리 코드상의 메소드의 매개변수 앞에 @RequestBody를 붙여줘야 파싱한다.이때 raw도 그냥 raw가 아니라 다양한 MIME형식을 가질 수 있다.(text&#x2F;plain , application&#x2F;json) 123456 @PostMapping(&quot;/http/post&quot;) public String postTest(@RequestBody Member m)&#123; //json받기// public String postTest(@RequestBody String text)&#123; //text받기 return &quot;post id :&quot; + m.getId() + &quot;, username: &quot;+m.getUsername()+&quot;, password : &quot;+m.getPassword()+&quot;, email : &quot;+m.getEmail(); //return text; &#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"3. [블로그 프로젝트] 스프링 부트로 HTTP 체험해보기","slug":"spring/blog/blog3","date":"2021-08-26T06:39:51.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/26/spring/blog/blog3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog3/","excerpt":"","text":"HTML을 체험하기 위해 필요한 POSTMAN 추후 알게 되겠지만, POSTMAN이라는 프로그램을 다운받자.(브라우저로 테스트하면 get요청밖에 확인가능하기 때문이다.)일단은 웹브라우저로 해보자. @RestController 와 @Controller@RestController는 사용자가 요청하면 데이터를 응답하는 어노테이션이다.@Controller는 사용자가 요청하면 HTML을 응답하는 어노테이션이라고 알자! 알맞은 패키지 아래에이제 BlogControllerTest 클래스를 만들어보자. 1234567891011package com.cos.blog.test;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BlogControllerTest &#123; @GetMapping(&quot;/test/hello&quot;) public String hello() &#123; return &quot;&lt;h1&gt;hello spring boot&lt;/h1&gt;&quot;; &#125;&#125; 이제 웹 브라우저 주소창에 http://localhost:8080/test/hello 를 입력하면반환값을 html로 해석한 페이지가 등장한다! 이제 다양한 요청을 처리하는 HttpControllerTest를 만들어보자 123456789101112131415161718192021222324package com.cos.blog.test;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HttpControllerTest &#123; @GetMapping(&quot;/http/get&quot;) public String getTest()&#123; return &quot;get&quot;; &#125; @PostMapping(&quot;/http/post&quot;) public String postTest()&#123; return &quot;post&quot;; &#125; @PutMapping(&quot;/http/put&quot;) public String putTest()&#123; return &quot;put&quot;; &#125; @DeleteMapping(&quot;/http/delete&quot;) public String deleteTest()&#123; return &quot;delete&quot;; &#125;&#125; 이제 http://localhost:8080/http/get 을 하면 get이라는 글자가 화면에 나온다!(와우!)근데 http://localhost:8080/http/post 를 해보면…?(어라?)에러가 뜬다!앞서 언급했듯이 이게 우리가 POSTMAN을 쓰는 이유다!이제 앞으로 포스트맨으로 결과를 확인하자!!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"2. [블로그 프로젝트] HTTP 1.1과 MIME type, MySQL프로젝트 연결하기","slug":"spring/blog/blog2","date":"2021-08-26T05:13:05.000Z","updated":"2022-01-22T16:20:00.037Z","comments":true,"path":"2021/08/26/spring/blog/blog2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog2/","excerpt":"","text":"HTTPHTTP_더_알아보기HTTP는 문서를 전송하는 stateless 통신 프로토콜이다!종류는 다음과 같다!GET : 데이터 줘!POST : 데이터 추가해줘!PUT : 데이터 수정해줘!DELETE : 데이터 삭제해줘! 그렇다면 ‘어떤’ 데이터를 요청하거나 보낼지를 알려줄까?이는 쿼리 파라미터(URI의 ? 부분)를 쓰거나,MIME type으로 알려줄 수 있다! MIME typeHTTP는 데이터를 패킷이라는 단위로 나눠서 보낸다.이 패킷은 헤더+바디 인데, 헤더는 보내는 데이터에 대한 설명이고, 바디는 데이터를 담는다. 이때 헤더에는 우리가 보낼 데이터가 어떤 데이터인지를 알려주는 MIME type을 포함한다.MIME type은 type&#x2F;subtype형태를 가진다.MIME_type_더알아보기 MySQL 연결하기MySQL를 제대로 설치했다면mysql -uroot -p 로 접근이 가능하고,mysql.server start로 데이터베이스를 시작할 수 있다. 이렇게 설치된 상황에서mysql -uroot -p로 mysql을 열고, 1234567-- 유저이름@아이피주소create user &#x27;cos&#x27;@&#x27;%&#x27; identified by &#x27;cos1234&#x27;;-- ON DB이름.테이블명-- TO 유저이름@아이피주소GRANT ALL PRIVILEGES ON *.* TO &#x27;cos&#x27;@&#x27;%&#x27;;CREATE DATABASE blog CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;use blog; 를 입력하면 우리가 활용할 db가 생성된다.그리고 디비 서버를 켜주자. 그런 다음 우리 프로젝트 폴더 중 resources 폴더 안에는application.properties라는 파일이 있다.이 파일의 확장자를 yml로 바꾼 다음에 이렇게 써주자. 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul username: 디비 계정 password: 디비 비밀번호 (yml은 json 형식이다. 그래서 properties보다 덜 써도 같은 효과를 본다.)(url은 시간 설정이라고 생각하자.)이렇게 하면 db 연결은 끝이다!!!","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"1. [블로그 프로젝트] 개발 환경, 의존성 설정하기.","slug":"spring/blog/blog1","date":"2021-08-26T04:09:25.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/08/26/spring/blog/blog1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/26/spring/blog/blog1/","excerpt":"","text":"이번엔 스프링부트를 통해 블로그를 한번 만들어보자!유튜버 데어프로그래밍의 강좌를 보며 제작한다!!! 먼저 Oracle JDK SE와 MySQL을 설치해주자.JDK는 홈페이지에서 다운받고, MySQL은 맥의 homebrew로 설치가 가능하다!MySQL 설치 관련 링크 그리고 이클립스에서 스프링을 사용할 수 있게해주는 STS 툴 이라는 게 있다.나는 인텔리제이를 써서 생략하겠다. 그리고 어떤 에디터를 쓰든 utf-8으로 인코딩 설정을 해주자!!! utf-8? 자 1bit &#x3D; 2^1 는 0과 1 즉 두가지 결과를 만들어낸다.8bit &#x3D; 2^8 &#x3D; 256 &#x3D; 1 byte 이다. 자 이제 영어 알파벳을 생각해보자. 대소문자 다합쳐서 50여개다.여기에 숫자와 몇몇 특수기호를 합치면 꽤 많이 될 것이다.만약 256개 이하라면, 우리는 문자 1개당 하나씩 할당해주면모든 문자를 이진수로 표현할 수 있다! 근데 한글과 중국한자은 어떻게 한다는 말인가!한글은 대략 2byte가 필요하고, 한자는 3byte가 필요하다. 우리가 설정한 UTF-8은 3byte를 가진 문자체계다.즉 영어, 한글, 한자를 모두 소화할 수 있는 인코딩 체계라는 말씀!! 의존성 설정하기.이번 프로젝트에서는 maven으로 패키지를 관리한다.그리고 의존성에서 우리가 사용할 것들을 살펴보자. Spring boot Dev Tool : 스프링의 성능을 향상 시키고, 개발을 편리하게 돕는 도구 정도로 이해하자. Lombok : getter, setter같은 메소드를 어노테이션으로 퉁치는 기능을 제공해주는 도구 JPA : 자바 객체를 변환해서 데이터베이스에 저장할 수 있게 해주는 도구 MySQL Driver : MySQL을 사용할 수 있게 해주는 도구 Spring Web : 각종 어노테이션과 내장 톰캣을 사용할 수 있게해주는 도구 Spring Security : 세션, 권한 등 다양한 보안 기능을 제공하는 도구 사용할법하지만 사용하지 않는 의존성 기능들도 참고 삼아 알아보자. OAuth2 Client : 카카오톡 같은 소셜 로그인을 지원하는 도구(하지만 우리는 학습을 위해 직접 구현) 각종 템플릿 : 우리는 JSP를 사용할 거다.(스프링은 JSP를 제공하지 않으므로 따로 폴더파서 만들어줘야됨) 좀 더 디테일하게 말하면, 스프링 프로젝트의 source&#x2F;temple 폴더에 JSP를 만들어도 인식을 못한다. 잠깐 주의사항 패키지를 다룰 때 패키지 위치를 정확하게 해줘야된다.java의 com.cos.blog안에 패키지를 넣어야 알맞은 IoC가 실행된다. 그리고 우리는 몇가지 의존성을 더 넣어줄꺼다.pom.xml이라는 파일이 있다. 여기에 각종 dependecies가 있는데 우리는 다음을 복붙해줄거다 1234567891011121314151617&lt;!-- 시큐리티 태그 라이브러리 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- JSP 템플릿 엔진 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- JSTL --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 그리고 우리는 MySQL, JPA, Security를 사용하지 않으므로, 주석처리해주자.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Project","slug":"spring/project","permalink":"https://yangdongjue5510.github.io/categories/spring/project/"}]},{"title":"3. Spring boot 동작원리 with 데어 프로그래밍","slug":"spring/boot/boot3","date":"2021-08-25T04:43:08.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/08/25/spring/boot/boot3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/25/spring/boot/boot3/","excerpt":"","text":"스프링 부트 동작원리 톰캣 필터 권한, 인증, 인코딩… 디스패처 요청된 주소에 맞는 컨트롤러를 호출 &lt;얘네는 요청때마다 메모리에 로딩&gt;&lt;요청이 올 때까지 대기&gt;재사용하는 게 아니라 새 쓰레드를 사용함4. 컨트롤러 - 요청에 포함된 데이터 받음, 다른 서비스 호출..5. 서비스6. JPA 레포지토리7. 영속성 컨텍스트 데이터소스 DB와 연결 view Resolver 페이지를 만들어서 응답. 일반적인 컨트롤러일 때 작동 RestController일 땐 작동 x 세션 인터셉터 보안에 민감한 함수가 실행 직전에 요청자가 권한을 가졌는지 확인 소켓 통신과 http 통신 Socket : 운영체제가 가지고 있는 소통 창구 같은 것!한 포트에서 소캣을 열어서 다른 컴퓨터와 연결을 확인하고,다른 포트에서 소캣을 열고 스레드를 할당해 해당 연결을 진행하게 한다.그와 동시에 연결을 확인하는 소캣은 계속 열어두어서, 다른 컴퓨터가 연결 요청을 할 수 있다. 이런 소켓통신은 여러 컴퓨터가 계속 연결되어 있기 때문에 부하가 크다! 이런 단점을 해결하는게 stateless 방식의 http 통신!!http는 문서를 전달하는 방식이다.http는 한 소켓에서 요청을 받아서 응답을 해주고 해당 컴퓨터와 연결을 끊는다.부하가 적지만, 다시 연결하려면 매번 새로운 연결을 만들어야 한다.그리고 서버가 클라이언트를 기억하지 않는다.(웹서버는 이를 해결한다.) 1. 내장 톰캣을 가진다.웹서버(스프링에선 아파치)란?클라이언트가 원하는 자료들을 가지고 있고, 클라의 request를 받고, url,uri (자원을 요청하는 주소, 식별자에 접근하는 주소)에 따라적절한 자원(정적인 자원 static)을 응답해서 보낸다!하지만, 이 중에 만약 자바 코드(.jsp)로 이뤄진 자원을 요청받으면, 아파치는 이를 다루지 못한다.(웹 브라우저도 html, css, js 파일정도만 이해할 수 있으니까… 자바파일은 이해못한다.)그래서 이럴 경우 톰캣에게 이를 처리하도록 한다. 톰캣이란? 자바 파일(.jsp)를 컴파일하고, html로 만들어 아파치에게 돌려주는 역할을 한다.톰캣은 요청객체와 응답객체를 알아서 메모리에 생성한다. 2. 서블릿 컨테이너스프링은 url으로는 접근이 불가능하다. uri로 접근만 가능하게 했다.그래서 특정한 파일을 요청을 할 수 없다는 의미다!!결국 요청할 때는 무조건 자바를 거쳐야 된다.(즉 톰캣을 거쳐야!) 서블릿? 자바로 웹할 수 있게 한 것.서블릿 컨테이너? 서블릿의 집합(여기서는 톰캣을 의미.)서블릿 컨테이너에서는 최초 요청이 오면, 스레드를 생성해서 서블릿 객체를 만든다!(왜 스레드를 만드냐? 여러 요청이 동시에 올 수 있으니까!, 동시접근 허용.)우리가 최대 스레드를 20개라고 설정했으면 스레드가 20개가 될 때까지 새 스레드를 만들어서 서블릿 객체를 만든다. 이때 20개의 요청을 처리하여 20개의 서블릿 객체를 서블릿 컨테이너에 만들었다고 가정하면다음 요청때는 만들어진 서블릿 객체를 다시 재사용한다! 3. web.xml서버를 하나의 성으로 비유하면,web.xml은 서버의 문지기와도 비슷하다. -ServletContext의 초기 파라미터 : 일종의 암구호-Session의 유효시간 설정 : 들어온 사람이 누구인지, 얼마나 있을지-Servlet&#x2F;JSP에 대한 정의 : 들어온 사람의 성 속 목적지를 인식(식별자 인식)-Servlet&#x2F;JSP 매핑 : 들어온 사람의 성 속 목적지로 가는 길을 안내(식별자에 따른 자원 매핑)-Mime Type 매핑 : 들고오는 데이터 타입(mime type)을 성에 맞게 매핑-Welcome File list : 아무 이유 없이 온 사람들을 보내는 곳-Error Pages 처리 : 잘못된 목적을 가지고 온 사람들을 보내는 곳-리스너&#x2F;필터 설정 : 잘못된 성을 온 사람이나, 맞지 않는 사람을 못들어오게 함(리스너는 문지기를 도와 같이 들어오는 사람을 특정한 조건을 확인하는 역할)-보안 4. frontController 패턴web.xml이 모든 servlet, jsp를 매핑하기 힘들다…그래서 특정 주소(.do)는 frontController가 먼저 나서서 처리한다.이렇게 가져온 요청들은 frontController가 직접 자원에 접근하도록 다시 요청한다!(내부에서는 자원에 직접 접근하는 요청이 가능하다.) 5. RequestDispatcher근데 다시 요청한다는게 어떤 의미인가?새로운 요청객체를 만드는게 아니라, 처음 만들어진 요청 객체를다시 내부에서 직접 접근하도록 사용한다는 것!(이 일을 RequestDispatcher가 한다.) 이렇게 하면 어떤 페이지에서 가져온 데이터를 다른 페이지로 넘어가도 그대로 가져갈 수 있게된다! 6. DispatchServlet스프링에는 DispatchServlet은 FrontController + RequestDispatcher라고 생각하자.얘 덕분에 우리는 굳이 frontController와 RequestDispatcher를 구현 안해도 된다. DipatchServlet이 프로젝트 패키지 내부의 모든 자바 파일을 뒤져서필요한 객체들(@Controller, @RestController…)을 자동 생성하고,이 객체들을 IoC로 관리된다.(대부분 필터들이다.) 7. 스프링 컨테이너ApplicationContextDispatchServlet이 만든 수많은 객체들을 관리하는 애가 스프링 컨테이너다.이 객체들은 ApplicationContext에 등록되어 관리된다.(IoC)우리는 new가 아닌 DI로 객체를 다룰 것이다. ApplicationContext는 두가지가 있다.(root-applicationContext, servlet-applicationContext)DispatchServlet은 각 스레드 별로 클래스들의 객체들을 만들지만 서로 다른 스레드라서 충돌은 일어나지 않는다.웹과 관련된 어노테이션을 찾아 메모리에 띄우는 파일인 sevlet-applicationContext이 객체를 생성한다. 다만 DB 같이 쓰레드들이 공유해야 하는 데이터는 ContextLoaderListener이 공유해서 사용하도록 한다.root-ApplicationContext 파일에 어떤 걸 공유해야 할 지 정해져 있고,ContextLoaderListener는 이 파일을 읽고, 공유해야 할 내용은 공유한다.(ContextLoaderListener는 DispatchServlet보다 먼저 실행된다.)sevlet-applicationContext에서 생성된 객체는 root-applicationContext에서 만들어진 객체를 참조 가능하지만,반대는 불가능하다~!(생성시점이 다르기 때문이다.) Bean FactoryBean Factory도 필요한 객체를 등록해놓은 곳인데, 다만 초기에 메모리에 로드되는게 아니고,필요할 때 getBean()으로 호출되어야 메모리에 로드된다.(IoC)ApplicationContext는 초기에 메모리에 로드되는 반면, Bean Factory는 그렇지 않은 lazy loading이다. 8. 응답 Handler Mapping (요청 주소에 따른 적절한 컨트롤러 요청)어떤 요청이 오면, 그 요청에 맞는 적절한 컨트롤러의 함수를 찾아 실행한다. 응답할 때는 html로 할 지, data를 응답할 지 결정해야 하는데,html로 할 때는 ViewResolver가 관여하고(반환값을 jsp파일명으로 인식!),data로 할 때는 MessageConverter가 작동하게 된다.(기본 컨버팅 값은 json이다.)","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"24. 백준 1406번 에디터","slug":"cs/algorithm/problem/al24","date":"2021-08-24T04:48:01.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al24/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al24/","excerpt":"","text":"이 문제는 참 고생 많이 했다 ㅋㅋ… 틀렸던 접근 1 주어진 문자열을 char 배열로 받은 다음, 이 녀석을 ArrayList에 저장하자.그 다음 arrayList를 하나더 추가해서 마치 스택처럼 사용하자.그렇게 모든 명령을 수행하고 나면두 arraylist에 저장된 요소들을 반복문으로 하나씩 출력하자. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; var bf = new BufferedReader(new InputStreamReader(System.in)); char[] charArr = (bf.readLine()).toCharArray(); //List list = Arrays.asList(charArr); //var wordStk = new ArrayList&lt;Character&gt;(Arrays.asList(charArr)); var wordStk = new ArrayList&lt;Character&gt;(); var testCase = Integer.parseInt(bf.readLine()); var tmpStk = new ArrayList&lt;Character&gt;(); for (char c : charArr) wordStk.add(c); for (int i = 0 ; i &lt; testCase ; i++)&#123; var cmdLine = new StringTokenizer(bf.readLine()); var cmd = cmdLine.nextToken(); if (cmd.equals(&quot;P&quot;))&#123; wordStk.add(cmdLine.nextToken().charAt(0)); &#125; else if (cmd.equals(&quot;L&quot;))&#123; if (wordStk.size() != 0)&#123; tmpStk.add(wordStk.get(wordStk.size()-1)); wordStk.remove(wordStk.size()-1); &#125; &#125; else if (cmd.equals(&quot;D&quot;))&#123; if (tmpStk.size() != 0)&#123; wordStk.add(tmpStk.get(tmpStk.size()-1)); tmpStk.remove(tmpStk.size()-1); &#125; &#125; else if (cmd.equals(&quot;B&quot;))&#123; if (wordStk.size() != 0)&#123; wordStk.remove(wordStk.size()-1); &#125; &#125; &#125; for (char c : wordStk) System.out.print(c); for (char c : tmpStk) System.out.print(c); &#125;&#125; 문제점들…근데 문제가 있다. Arrays.asList(char[])가 작동을 안한다…asList가 배열이나, 가변인자를 받기 때문이다. 가변인자란 여러 인자를 받으면, 이를 배열로 만들어서 인자로 활용하는 개념이다.즉 asList에 기본값을 가진 배열이 오면, List&lt;\\char[]&gt;이 온다..!(다르게 말하자면, 오토박싱이 이뤄지지 않는다. 개별의 값만 오토박싱한다.)그래서 기본값을 가진 배열은 asList로 다룰수 없다.(래퍼클래스 배열만 가능) 그리고 출력할 때도 문제가 있다.무지성으로 여러번 출력하는 거보다 한방에 모아서 출력하는게(StringBuffer) 훨씬 속도가 빠르다! 그리고 나는 자바에 스택이 있는 걸 깜빡하고 arrayList로 작성했는데,다시 찾아보니 스택을 지원했다. 그래서 스택으로 고쳐 써봤다. 고친 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;import java.io.*;import java.util.stream.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; var bf = new BufferedReader(new InputStreamReader(System.in)); var sb = new StringBuilder(); var charArr = bf.readLine().toCharArray(); var wordStk = new Stack&lt;Character&gt;(); var testCase = Integer.parseInt(bf.readLine()); var tmpStk = new Stack&lt;Character&gt;(); for (char c : charArr) wordStk.add(c); for (int i = 0 ; i &lt; testCase ; i++)&#123; var cmdLine = new StringTokenizer(bf.readLine()); var cmd = cmdLine.nextToken(); if (cmd.equals(&quot;P&quot;))&#123; wordStk.push(cmdLine.nextToken().charAt(0)); &#125; else if (cmd.equals(&quot;D&quot;))&#123; if (tmpStk.size() != 0)&#123; wordStk.push(tmpStk.pop()); &#125; &#125; else if (wordStk.size()==0) continue; else if (cmd.equals(&quot;L&quot;))&#123; tmpStk.push(wordStk.pop()); &#125; else if (cmd.equals(&quot;B&quot;))&#123; wordStk.pop(); &#125; &#125; for (char c : wordStk) sb.append(c); while(!tmpStk.isEmpty()) sb.append(tmpStk.pop()); System.out.println(sb); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"23. 백준 9012번 괄호","slug":"cs/algorithm/problem/al23","date":"2021-08-24T04:42:43.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al23/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al23/","excerpt":"","text":"문제괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 아이디어 괄호를 열 때마다 변수를 1 키우고, 괄호가 닫힐 때마다 변수가 1씩 줄이자. 이때 0보다 작아지면 잘못된 식임을 감지한다. 코드 1234567891011121314151617181920212223242526import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); var testCase = Integer.parseInt(bf.readLine()); for (int i = 0 ; i &lt; testCase ; i++)&#123; char[] arr = bf.readLine().toCharArray(); int openCount = 0; for (char c : arr)&#123; if (c == &#x27;(&#x27;) openCount++; else if (c == &#x27;)&#x27;)&#123; openCount--; if (openCount &lt; 0) break; &#125; &#125; if (openCount == 0) System.out.println(&quot;YES&quot;); else System.out.println(&quot;NO&quot;); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"22. 백준 9093번 단어 뒤집기","slug":"cs/algorithm/problem/al22","date":"2021-08-24T04:04:45.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/24/cs/algorithm/problem/al22/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/24/cs/algorithm/problem/al22/","excerpt":"","text":"문제문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. 단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다. 입출력입력 : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. 단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다.출력 : 각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다. 아이디어 받은 문자열을 공백 기준으로 나눈 다음, 각 문자열을 거꾸로 출력하도록 하자. 필요한 문법 StringTokenizer : 이 문제에 핵심 역할을 하는 클래스다.생성자가 StringTOkenizer(bf.readLine(),” “, false)세번째 요소에 true를 넣으면 구분자를 포함하여 토큰을 자른다!(false면 구분자를 제외한다.)그리고 다음 토큰이 존재하는 지 확인하려면 **hasNextTokens()**메소드를 사용해야 한다.(hasNext가 아님..) StringBuilder : String과 달리, 배열의 크기를 여유롭게 생성해 크기를 자유롭게 활용가능.문자열에 연산을 많이 해야하는 경우 사용하자.append() 특정값을 추가delete() 특정값을 삭제 코드 12345678910111213141516171819202122import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); int testCase = Integer.parseInt(st.nextToken()); for (int i = 0 ; i &lt; testCase ; i++)&#123; StringTokenizer inputStr = new StringTokenizer(bf.readLine(),&quot; &quot;,true); while(inputStr.hasMoreTokens())&#123; char[] wordChar = inputStr.nextToken().toCharArray(); StringBuilder sb = new StringBuilder(); for (int j = wordChar.length -1 ; j &gt; -1 ; j--)&#123; sb.append(wordChar[j]); &#125; System.out.print(sb); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"21. 백준 10828번 스택","slug":"cs/algorithm/problem/al21","date":"2021-08-22T06:09:21.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/22/cs/algorithm/problem/al21/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/22/cs/algorithm/problem/al21/","excerpt":"","text":"문제정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다. push X: 정수 X를 스택에 넣는 연산이다.pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 스택에 들어있는 정수의 개수를 출력한다.empty: 스택이 비어있으면 1, 아니면 0을 출력한다.top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. 아이디어 arrayList로 스택을 구현한다. 필요한 문법ArrayList remove(인덱스), get(인덱스), add(값), size() 메소드BufferedReader엔터를 경계로 입력받아 String으로 가져온다. 상대적으로 scanner보다 빠르다.선언할때 InputStreamReader(System.in) 객체를 생성자의 인수로 가져와서 사용한다.readLine으로 가져와서 사용한다.StringTokenizer문자열과 구분자(선택), true&#x2F;false(선택)을 인수로 전달하면, 구분자 기준으로 문자열을 쪼개서 나눈다.true&#x2F;false는 구분자를 하나의 토큰으로 취급할지, 다른 토큰에 포함시킬지를 결정한다.Integer.pareInt(~)문자열과 숫자를 인수로 전달하면, 해당 문자를 숫자에 맞는 진수법에 맞춰 정수화 한다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine()); var commandCount = Integer.parseInt(st.nextToken()); var stack = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i &lt; commandCount ; i++)&#123; var tk = new StringTokenizer(bf.readLine()); var command = tk.nextToken(); if(command.equals(&quot;push&quot;))&#123; var inputNum = Integer.parseInt(tk.nextToken()); stack.add(inputNum); &#125; else if(command.equals(&quot;pop&quot;))&#123; if (stack.size() != 0)&#123; var output = stack.get(stack.size() - 1); stack.remove(stack.size()-1); System.out.println(output); &#125; else System.out.println(-1); &#125; else if(command.equals(&quot;size&quot;))&#123; System.out.println(stack.size()); &#125; else if(command.equals(&quot;empty&quot;))&#123; if (stack.size() == 0) System.out.println(1); else System.out.println(0); &#125; else if(command.equals(&quot;top&quot;))&#123; if (stack.size() == 0) System.out.println(-1); else System.out.println(stack.get(stack.size()-1)); &#125; &#125; bf.close(); &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"20. 백준 1004번 어린 왕자","slug":"cs/algorithm/problem/al20","date":"2021-08-21T13:41:45.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/21/cs/algorithm/problem/al20/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/21/cs/algorithm/problem/al20/","excerpt":"","text":"문제어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다.어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다.하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다.은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입&#x2F;이탈 횟수를 구하는 프로그램을 작성해 보자.행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다. 아이디어 행성계를 원으로 생각했을 때, 출발점과 도착점 중 하나가 원 안에 있으면 반드시 그 행성계를 지난다.(그렇지 않으면 지나지 않는다.) 필요한 문법 Math.sqrt(double a) : double 값을 제곱근한 값을 반환Math.pow(double a, double b) : a를 b제곱한 값 반환 코드 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class No1004 &#123; public static boolean inOrOut(int x1, int x2, int y1, int y2, int r)&#123; if (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) &lt;= r)&#123; return true; &#125; return false; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int testCase = sc.nextInt(); int[] x = new int[2]; int[] y = new int[2]; for (int i = 0 ; i &lt; testCase ; i++)&#123; x[0] = sc.nextInt(); y[0] = sc.nextInt(); x[1] = sc.nextInt(); y[1] = sc.nextInt(); int planetCount = sc.nextInt(); int result = 0; for (int j = 0 ; j &lt; planetCount ; j++)&#123; int planetX = sc.nextInt(); int planetY = sc.nextInt(); int planetR = sc.nextInt(); if(inOrOut(x[0], planetX, y[0], planetY, planetR))&#123; if(!inOrOut(x[1], planetX, y[1], planetY, planetR))&#123; result += 1; &#125; &#125; else&#123; if(inOrOut(x[1], planetX, y[1], planetY, planetR))&#123; result += 1; &#125; &#125; &#125; System.out.println(result); &#125; &#125;&#125;","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"2. Spring과 JPA의 특징 with 데어 프로그래밍","slug":"spring/boot/boot2","date":"2021-08-20T08:36:50.000Z","updated":"2022-01-22T16:20:00.039Z","comments":true,"path":"2021/08/20/spring/boot/boot2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/20/spring/boot/boot2/","excerpt":"","text":"1. 스프링이란? by 데어 프로그래밍스프링은 프레임워크이다.스프링은 오픈소스이다.스프링은 IoC 컨테이너를 가진다.스프링은 DI 를 지원한다.스프링은 엄청나게 많은 필터를 가지고 있다.스프링은 엄청나게 많은 어노테이션을 가지고 있다. (리플렉션, 컴파일체킹)스프링은 MessageConverter를 가지고 있다. 기본값은 현재 Json이다.스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.스프링은 계속 발전중이다. IoC(Inversion of Control) 제어의 역전일반적인 java 객체를 new로 생성해서 개발자가 관리하는 게 아닌,Spring Container에 모두 맡긴다. 개발자가 관리하는게 아닌 프레임워크가 제어하므로, 제어의 역전이라 한다.개발자가 클래스들을 만들면, 스프링 컨테이너가 이를 읽고 나서 인스턴스화(힙 메모리 공간에 띄운다) 해서 관리한다.개발자가 코드로 new 할 필요가 없다는 의미다! DI(Dependecy Injection) 의존성 주입외부로부터 내가 사용할 객체를 주입받는다!(스프링 컨테이너가 주입해준다.)스프링 컨테이너는 하나의 인스턴스를 만들어 그 인스턴스를 공유해 사용하도록 한다.(익숙한데..? 그렇다 싱글톤 패턴!) DI 장점 의존성에서 격리, 코드 테스트에 용이하다 불가능한 상황을 Mock 같은 기술을 통해 안정적으로 테스트 가능 코드를 확장하거나 변경 할 때 영향 최소화(추상화) 순환참조 예방. 스프링의 필터톰캣을 거쳐서 스프링 컨테이너에 접근하려는 시도들 중 권한이 있는 것만을 통과하도록 필터를 사용할 수 있다.이때 톰캣에서 사용되는 필터는 web.xml에 filter로 생성되어 있고,스프링 컨테이너의 필터는 인터셉터라고 부른다.(AOP개념이 이때 사용되기도 한다. 천천히 공부하자!) 컴파일 체킹어노테이션도 일종의 주석인데, 컴파일러가 무시하지 않고, 컴파일러가 체크하도록 해놓은 표시같은거다!그래서 어노테이션에 맞지 않을 경우 컴파일러가 멈추도록 한다. 스프링에서는? 스프링의 어노테이션은 보통 객체를 생성하는 역할을 한다.@component(클래스를 읽어서 메모리에 로딩해라!),@Autowired(로딩된 객체를 해당 변수에 집어넣어!) 이런식이다. 스프링 컨테이너는 런타임동안 클래스 내부를 분석(리플렉션)해서 해당 클래스의메소드, 필드, 어노테이션을 찾아서 어떻게 작동해야할지를 정한다. MessageConverter서로 다른 언어가 서로 데이터를 주고 받으려면, 서로 합의한 형식을 주고 받기로 하자.우리는 이 합의로 한 형식을 JSON으로 사용하고 있다.즉 자바 시스템에서 파이썬 시스템으로 어떤 데이터를 보내고 싶어할 때는자바 - json - 파이썬 이런 식으로 전달된다. MessageConverter? 메세지컨버터(jackson이 기본)는 요청할 때 자바 오브젝트를 json으로 바꿔주거나응답받을 때 json을 자바 오브젝트로 바꿔주는 라이브러리다. BufferedWriter, BufferedReader를 용이하게 사용?보통 inputStream으로 1byte(8bit) 씩 읽어드리는데,효율적인 사용을 위해 BufferedReader로 가변적인 문장길이를 갖는 데이터를 쉽게 받을 수 있다. 스프링에서는 @ResponseBody라는 어노테이션을 쓰면 자연스럽게 BufferedWriter를 사용하고@RequestBody라는 어노테이션을 쓰면 자연스럽게 BufferedReader를 사용한다! 2. JPA란?JPA는 Java Persistence API 이다.JPA는 ORM 기술이다.JPA는 반복적인 CRUD 작업을 생략하게 해준다.JPA는 영속성 컨텍스트를 가지고 있다.JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)방언 처리가 용이하여 Migration하기 좋음. 유지보수에도 좋음.(다양한 dbms 제공)JPA는 쉽지만 어렵다. Java Persistence API?RAM은 휘발성 메모리다. 꺼지면 날라간다.그래서 우리는 하드디스크나 DBMS에 저장하는데, 이를 Persistence라고 부른다. JPA는 말 그대로, 자바로 만든 걸 persistence하게 저장할 수 있게하는 api이다. 근데 API가 뭐에요? 어플리케이션 프로그래밍 인터페이스다.즉 프로그램을 만드는 기준을 알려주는 것.이때 인터페이스라는 말은 기준을 제공하는 자와 기준에 따르는 자의 관계가 상하관계가 존재한다.(이것이 프로토콜과의 차이다.) JPA는 ORM?object를 데이터베이스에 넣는 방법론 중 하나. (일반적으로 데이터베이스 설계 - 이에 맞게 자바 클래스 모델링)데이터베이스의 형태와 자바 데이터타입이 다르기 때문에자바는 클래스로 데이터베이스의 형태를 자바에 모델링한다. (JPA는 먼저 클래스 설계 - 이에 맞게 데이터베이스 생성)자바가 클래스로 데이터베이스로 만들고 싶은 형태를 만든다.그러면 자연스럽게 데이터베이스에 클래스 형태에 맞도록 모델링된다. 예를 들면 db는 객체를 저장하지 못하지만, 자바는 가능하다.자바에서 객체와 자료형으로 데이터를 저장하면 JPA가 이를 db에 맞도록 변환해서 db에 저장한다! CRUD 작업 코드 생략(일반적 상황 - 매 쿼리마다 일어나는 반복적인 행동)자바가 db에 접근해서 세션을 오픈하고자바가 db에 쿼리를 보내고, db는 그에 맞는 데이터를 보낸다.이때 자바는 db가 보낸 데이터를 이해 못하므로, 이를 이해하기 위한 중간 작업을 한다.이 작업이 끝나면 세션을 닫는다. (JPA 도입 - 위 모든 행동들을 하나의 함수로 해결!) 영속성 컨텍스트영속성은 어떤 데이터를 영구적으로 저장할 수 있게 한다는 의미.컨텍스트는 어떤 대상의 모든 정보를 의미한다. 영속성 컨텍스트는 db에 저장하기 위해 필요한 모든 정보를 의미한다.자바와 db사이에서 이를 조율하는 역할로 이해하면 편하다.자바가 데이터를 가져와서 수정하면,영속성 컨텍스트가 이를 반영하고, db의 내용도 업데이트 해주는 등 db를 위한 모든 일은 영속성 컨텍스트를 통해 이뤄진다.","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"13. 부팅","slug":"cs/os/os13","date":"2021-08-18T12:25:03.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/18/cs/os/os13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/os/os13/","excerpt":"","text":"부팅컴퓨터를 켜서 동작시키는 절차. 부트 프로그램운영체제 커널을 저장소에서 특정 주소의 물리 메모리에 복사하고, 커널의 처음 실행 위치로 PC를 가져다 놓음ROM : 꺼져도 내용이 기억되는 특별한 RAM 바이오스를 메모리에 올리고 바이오스가 컴퓨터 초기화 저장매체의 MBR(master boot record)에 가서 부트 로더를 메모리로 가져옴부트 로더에 있는 파티션 테이블을 보고 어떤 파티션이 메인 파티션인지를 찾아낸다. 저장매체의 부트 섹터를 찾아가 부트 코드를 가져옴 부트 코드에 있는 커널 이미지(실행 파일)을 읽어옴","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"12. 파일 시스템","slug":"cs/os/os12","date":"2021-08-18T10:56:05.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/18/cs/os/os12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/os/os12/","excerpt":"","text":"파일 시스템운영체제가 저장매체에 파일을 쓰기 위한 자료구조, 알고리즘 파일 시스템은 왜 만들어졌을까? 비트 단위로 주소를 매겨서 사용하기에는 너무 비효율적!그렇다고 블록 단위(4kb)로 하자니 사용자가 각 블록의 고유번호로 관리하기 힘듬…그래서 추상적(논리적) 객체를 도입 : 파일사용자는 파일 단위로 다루고, 각 파일은 블록 단위로 관리하자! ~ 저장매체에 효율적으로 파일 저장하기가능한 연속적인 공간에 파일을 저장하는 게 좋다.하지만 각 파일들의 크기가 가변적이라, 불연속 공간에 파일을 저장해야 한다. 블록 체인 : 블록을 링크드 리스트로 연결(끝에 있는 블록 찾으려면 처음부터 찾아가야..) 인덱스 블록 : 각 블록에 대한 위치 정보를 기록, 한번에 어느 블록이든 찾아갈 수 있음 운영체제 별 파일 시스템 윈도우즈 : FAT, FAT32, NTFS블록 위치를 FAT라는 자료구조에 기록 리눅스(UNIX): ext2, ext3, ext4인덱스 블록 기법인 inode 방식 사용 파일 시스템과 시스템 콜 다양한 파일 시스템 방식에 상관없이 시스템콜을 사용해도 동일한 기능을 활용할 수 있도록 함.즉 시스템콜을 실행하면, 그 파일 시스템에 맞게 운영체제가 처리한다.실제로 어떻게 저장하는지는 약간 다를 수 있다. inode 방식 파일 시스템 파일 시스템 기본 구조 수퍼 블록 : 파일 시스템 정보 아이노드 블록 : 파일 상세 정보 데이터 블록 : 실제 데이터 파일 : inode 고유값과 자료구조에 의해 주요 정보 관리 ‘파일이름:inode’로 표현, 파일이름은 inode 번호와 매칭 파일 시스템은 inode를 기반으로 파일 엑세스 inode 기반 메타 데이터 저장 프로세스 생성 - process ID 부여 - PCB에 세부 정보 저장파일 생성 - inode 번호 부여 - inode 블록에 세부 내용(메타데이터) 저장이렇게 이해하자. inode 구조inode 기반 메타 데이터 : 파일 권한, 소유자 정보, 파일 사이즈, 시간 관련 정보(생성 시간), 데이터 저장 위치 등..위 사진에서 윗 4칸이 메타 데이터를 담고 있고,direct blocks에는 실제 데이터가 저장된 주소값 들이 저장되어 있다. direct blocks에는 대략 12개의 주소값을 저장하고 있는데, 한 블록마다 대략 4kb를 가질 때direct blocks이 처리할 수 있는 데이터량은 48kb밖에 안된다… 그래서 우리는 single indirect, double indirect, triple indirect를 도입하자.싱글 - 다이렉트 블록 포인터(1024개)더블 - 싱글(1024) - 다이렉트(1024 *1 024)트리플 - 더블(1024) - 싱글(1024 * 1024) - 다이렉트(1024 * 1024 * 1024)간접 4kb를 갖는데 대략 1024개의 주소를 가질 수 있다. 디렉토리 엔트리(덴트리)리눅스의 경우..&#x2F;home&#x2F;ubuntu&#x2F;link.txt 일 때, 각 디렉토리 엔트리를 탐색 (각 엔트리는 해당 디렉토리 파일, 디렉토리 정보를 가짐)맨 앞 슬래시는 루트 디렉토리라 하여, 해당 덴트리에서 home을 찾고 - ubuntu를 찾고 - link.txt를 찾아 실행하는 방식 가상 파일 시스템(Virtual File System)다른 파일 시스템이더라도 같은 시스템콜을 써도 잘 돌아가게 하는 시스템다양한 기기에도 파일 시스템 인터페이스를 통해 관리 가능하게 됨","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"1. GET API","slug":"spring/boot/boot1","date":"2021-08-18T08:02:00.000Z","updated":"2022-01-22T16:20:00.038Z","comments":true,"path":"2021/08/18/spring/boot/boot1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/spring/boot/boot1/","excerpt":"","text":"학습목표스프링부트로 GET API의 path variable, query parameter를 처리한다. 들어가기 전에… resource 폴더의 application.properties는 포트설정을 할 수 있다. (server.port&#x3D;9090)controller 패키지를 만들고 그 안에서 GetApiController 클래스를 만들어서 진행한다. 어노테이션 몇가지도 알고 시작하자.@RestController : 해당 클래스는 REST API를 처리하는 컨트롤러임을 알리는 어노테이션@RequestMapping(“&#x2F;blah-blah”) : 이어져 오는 클래스나 메소드의 URI를 지정해주는 어노테이션.@GetMapping(“&#x2F;blah) : GET 요청을 매핑해주는 URI 1234567891011121314package com.example.demo.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController //해당 클래스는 rest api 처리하는 컨트롤러@RequestMapping(&quot;/api&quot;) //RequestMapping은 URI를 지정해주는 Annotationpublic class ApiController &#123; @GetMapping(&quot;/hello&quot;) //http://localhost:9090/api/hello public String hello()&#123; return &quot;hello spring boot!&quot;; &#125;&#125; GET API이번 포스트에서는 GET 으로 쿼리 파라미터와 path variable을 설정해보자. Path variable1. path 변수 사용하기@GetMapping 안에 path &#x3D; “&#x2F;hello”를 넣어 사용해도 된다. 2. RequestMapping으로 GET 처리하기앞서 살펴본 대로 @GetMapping으로 GET 요청을 URI지정해줄 수 있다.그런데 이 기능을 @RequestMapping으로도 가능하다.다만, value &#x3D; “&#x2F;blah”, method &#x3D; RequestMethod.GET을 인수로 넣어줘야 한다. 3. Path variable 처리하기주소에 변화하는 값을 처리해야 할 때가 있다.사람마다 다른 id를 URI에 넣어 사용할 때가 대표적인데,이때는 Mapping 인수에 변수를 {variable}로 넣자. 그리고 이어지는 메소드의 인수에 @PathVariable(아까 정한 변수이름 &#x3D; “아까 정한 변수이름”) String pathName을 넣어주자.이때 pathName은 입력된 변수값이 된다. 코드로 확인하기 12345678910111213141516171819202122232425package com.example.demo.controller;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/api/get&quot;)public class GetApiController &#123; @GetMapping(path = &quot;/hello&quot;) //http://localhost:9090/api/get/hello public String getHello()&#123; return &quot;get Hello&quot;; &#125; @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET) //method 없으면, get, post, put, delete 모두 작동. public String hi()&#123; return &quot;hi&quot;; &#125; //http://localhost:9090/api/get/path-variable/&#123;name&#125; //&#123;name&#125;은 변화하는 값. 변화할 때마다 주소를 다 추가할 순 없어! @GetMapping(&quot;/path-variable/&#123;name&#125;&quot;) public String pathVariable(@PathVariable(name = &quot;name&quot;) String pathName)&#123; System.out.println(&quot;PathVariable: &quot;+pathName); return pathName; &#125;&#125; query parameter 쿼리 파라미터? 흔히 URI를 보면 ?를 찾을 수 있다. ? 이후가 쿼리 파라미터다.?이후 나오는 &amp;를 기준으로 나누면, key &#x3D; value 형식이 된다. 1. Map을 활용해서 쿼리 파라미터 만들기@RequestParam 어노테이션을 활용해서 URI에서 파라미터를 가져올 수 있다.key &#x3D; value 형식을 찾아 Map에 저장하게 된다. 2. 여러 변수 받기.메소드 인수부분에 여러 @RequestParam을 사용하면, 해당 키값과 일치하는 내용을 변수에 저장한다.이때 변수명은 당연히 키값과 일치해야 할 것이다. 3. 객체로 인수 받기일일히 2번 같은 방식으로 변수 만들려면 힘들다.다른 클래스 파일을 만들어서, 우리가 사용할 변수를 private로 만들고, 그 값을 다룰 getter, setter 메소드를 만든다.이후 컨트롤러에는 인수 자리에 그냥 객체처럼 만들면 된다.이때 중요한 점은, @RequestParam이 필요 없다는 것이다. 이 어노테이션이 없어도 스프링부트에서 객체가 오면 자연스럽게 파라미터로 인식한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.demo.controller;import com.example.demo.dto.UserRequest;import org.springframework.web.bind.annotation.*;import java.util.Map;@RestController@RequestMapping(&quot;/api/get&quot;)public class GetApiController &#123; //쿼리 파라미터 //http://localhost:9090/api/get/query-param?user=steve&amp;email=naver&amp;age=25 @GetMapping(path = &quot;query-param&quot;) public String queryParam(@RequestParam Map&lt;String, String&gt; queryParam)&#123; StringBuilder sb = new StringBuilder(); queryParam.entrySet().forEach(entry-&gt;&#123; System.out.println(entry.getKey()); System.out.println(entry.getValue()); System.out.println(&quot;\\n&quot;); sb.append(entry.getKey()+&quot; = &quot;+entry.getValue()+&quot;\\n&quot;); &#125;); return sb.toString(); &#125; //쿼리 파라미터 - 여러 변수 받기. @GetMapping(&quot;query-param02&quot;) public String queryPram02( @RequestParam String name, @RequestParam String email, @RequestParam int age )&#123; System.out.println(name); System.out.println(email); System.out.println(age); return name+&quot; &quot;+email+&quot; &quot;+age; &#125; //쿼리 파라미터 - DTO @GetMapping(&quot;query-param03&quot;) public String queryPram03(UserRequest userRequest)&#123; System.out.println(userRequest.getName()); System.out.println(userRequest.getEmail()); System.out.println(userRequest.getAge()); return userRequest.toString(); &#125;&#125; dto라는 패키지에 다른 클래스를 따로 만들었다. 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.demo.dto;public class UserRequest &#123; private String name; private String email; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;UserRequest&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}],"tags":[],"keywords":[{"name":"Spring","slug":"spring","permalink":"https://yangdongjue5510.github.io/categories/spring/"},{"name":"Boot","slug":"spring/boot","permalink":"https://yangdongjue5510.github.io/categories/spring/boot/"}]},{"title":"19. 그래프 깊이우선탐색(DFS)","slug":"cs/algorithm/theory/al19","date":"2021-08-18T04:21:23.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/18/cs/algorithm/theory/al19/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/cs/algorithm/theory/al19/","excerpt":"","text":"깊이우선탐색(DFS)현재 방문중인 노드와 연결된 이웃 노드 중 아직 방문하지 않은 노드 있으면, 그 노드를 다음에 방문.재귀함수로 작성, 마치 트리의 preorder방식과 비슷. psuedo code 12345678910DFS(v): mark v as visited node pre[v] = curr_time #pre리스트는 해당 노드에 첫 방문시각 기록 curr_time += 1 for each edge (v, w): if w is unmarked: parent[w] = v #parent리스트는 해당 노드에 접근 직전에 방문했던 노드 기록 DFS(w) post[v] = curr_time #post리스트는 해당 노드의 이웃이 모두 방문됐을 때 시간 기록 curr_time += 1 DFS 트리방문순서를 부모-자식 관계로 나타낸 트리.왼쪽 트리에 나타난 실선 화살표를 트리 에지라 하고, 오른쪽 트리에 나온 점선 화살표를 백 에지라고 부른다.즉 DFS의 에지는 트리 에지와 백 에지 두 종류로 나뉘고, 백 에지가 존재함은 사이클이 존재함을 의미한다. python 코드 노드 갯수와 엣지 갯수 입력 후,엣지를 입력 받았을 때. 방문한 노드를 순서대로 출력하고,[pre, post] 쌍을 출력한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def DFS(G, v): global curr_time # pre, post를 위한 time stamp # 그래프 G의 노드 v를 DFS 방문한다 visited[v] = True pre[v] = curr_time curr_time += 1 neighbor = [] for i in G: if v in i: if i[0] == v and visited[i[1]] == False: neighbor.append(i[1]) elif i[1] == v and visited[i[0]] == False: neighbor.append(i[0]) neighbor.sort() for j in neighbor: if visited[j] == False: parent[j] = v DFS(G, j) post[v] = curr_time curr_time += 1def DFSAll(G): # 그래프 G를 DFS 방문한다 for v in range(n): if visited[v] == False: DFS(G, v)# 입력 처리n, m = [int(x) for x in input().split()]G = [[] for _ in range(n)]# G 입력 받아 처리for _ in range(m): x = list(map(int, input().split(&#x27; &#x27;))) G.append(x)# visited, pre, post 리스트 정의와 초기화visited = [0]*npre = [1]*npost = [1]*nparent = [0]*n# curr_time = 1로 초기화curr_time = 1DFSAll(G)# 출력result = []for i in range(n): result.append([pre[i], post[i]])for p in range(len(pre)): minIndex = pre.index(min(pre)) print(minIndex, end=&#x27; &#x27;) pre[minIndex] = max(pre)+1print()for k in result: print(k, end=&#x27; &#x27;)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"4. 팩토리 패턴","slug":"java/java-basic/design-pattern/dp4","date":"2021-08-18T00:54:52.000Z","updated":"2023-01-20T10:08:50.213Z","comments":true,"path":"2021/08/18/java/java-basic/design-pattern/dp4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/18/java/java-basic/design-pattern/dp4/","excerpt":"","text":"Circle c = new Circle(origin, 1);이 코드는 DIP를 위반한다. 구체 클래스에 의존하기 때문이다. 사실 new 키워드를 쓰는 순간 구체 클래스에 의존하게 되며 해당 구체 클래스의 변경에 취약해진다. 다만 해당 구체 클래스가 쉽게 변경되지 않는다면 큰 문제가 되지 않을 수 있다 팩토리 패턴을 사용하면 추상 인터페이스에만 의존해서 구체 클래스의 인스턴스를 얻을 수 있다. 이 경우 한창 개발중이라 쉽게 변경되는 구체 클래스가 많을 때 효과적이다. 그리고 팩토리 패턴은 추상적인 팩토리 인터페이스를 통해 아예 다른 팩토리 구현체로 교체할 수 있어서 구체 클래스 인스턴스 집합을 바꿔야 할 때도 유리하다. 팩토리 메서드 패턴인스턴스 생성에 대한 인터페이스(일반적 의미)를 만들어, 서브 클래스에서 어떤 클래스의 인스턴스를 만들지 결정하도록 설계하는 것. 추상 팩토리 패턴구현된 클래스 없이 관련된 클래스들을 만드는 인터페이스를 제공하는 패턴 배울 내용 요약 추상화에 의존해라. 구현된 클래스에 의존하지 말라. 예시 간단한 팩토리 예제신발 가게에서 신발 종류에 따라 생성해서 포장해보자! 먼저 신발 추상 클래스를 만들어보자.(얘를 상속해서 종류에 따라 만들거다.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Factory;public abstract class Shoes &#123; String modelName; int price; public abstract void prepare(); public abstract void wrap(); public abstract void box();&#125;package Factory;public class BasketballShoes extends Shoes&#123; @Override public void prepare() &#123; System.out.println(&quot;ready for the basketball shoes.&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping basketball shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing basketball shoes&quot;); &#125;&#125;package Factory;public class FootballShoes extends Shoes&#123; @Override public void prepare() &#123; System.out.println(&quot;prepare for football shoes&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping football shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing football shoes&quot;); &#125;&#125; 이제 객체를 만들 팩토리 클래스를 만들어보자. 12345678910111213package Factory;public class SimpleNikeFactory &#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; if (type.equals(&quot;basketball&quot;))&#123; shoes = new BasketballShoes(); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new FootballShoes(); &#125; return shoes; &#125;&#125; 자세히 살펴보면, new가 안에 들어있다. 이 팩토리 클래스를 사용하는 신발가게 클래스를 만들어보자. 12345678910111213141516171819package Factory;public class ShoeStore &#123; SimpleNikeFactory factory; public ShoeStore(SimpleNikeFactory factory)&#123; this.factory = factory; &#125; public Shoes orderShoes(String type) &#123; Shoes shoes; shoes = factory.createShoes(type); shoes.prepare(); shoes.wrap(); shoes.box(); return shoes; &#125;&#125; 이 경우도 팩토리와 가게가 HAS-A 관계임을 알 수 있다. 간단하게 결과를 알아보자. 12345678910package Factory;public class Tester &#123; public static void main(String[] args) &#123; SimpleNikeFactory factory = new SimpleNikeFactory(); ShoeStore store1 = new ShoeStore(factory); store1.orderShoes(&quot;basketball&quot;); store1.orderShoes(&quot;football&quot;); &#125;&#125; 이 정도가 간단한 예시고, 팩토리 메서드 패턴과 추상 팩토리 패턴을 더 알아보자. 팩토리 메서드 패턴 예제자, 이제 매장이 나이키 매장과 아디다스 매장이 있다고 가정하자.나이키 매장과 아디다스 매장마다 각자의 보여줄 메시지와 사은품으로 줄 아이템이 다르다고 할 때,이를 코드로 구현해보자. 즉 어떤 객체들이 만들어지는 과정과 가진 요소들을 분류해서 캡슐화! 일단 신발을 기본적으로 가져야 할 내용을 추상 클래스로 만들어보자 1234567891011121314151617181920212223package Factory;import java.util.ArrayList;public abstract class Shoes &#123; String modelName; String cushion; String signaturePlayer; ArrayList&lt;String&gt; shoeItem = new ArrayList&lt;&gt;(); public void prepare()&#123; System.out.println(&quot;ready for &quot;+ modelName); System.out.println(&quot;ready for &quot;+ cushion); System.out.println(&quot;this shoes are for &quot;+ signaturePlayer); for (String item : shoeItem)&#123; System.out.println(&quot;add &quot;+item); &#125; &#125; public String getModelName()&#123; return this.modelName; &#125; public abstract void wrap(); public abstract void box();&#125; 그리고 신발을 팔 가게들도 필요한 역할을 나타내는 추상 클래스도 만들어보자 123456789101112131415package Factory;public abstract class ShoeStore &#123; public Shoes orderShoes(String type) &#123; Shoes shoes; shoes = createShoes(type); shoes.prepare(); shoes.wrap(); shoes.box(); return shoes; &#125; public abstract Shoes createShoes(String type);&#125; 신발 클래스를 상속해서 우리가 만들고 싶은 구체적인 신발 클래스를 만들자 123456789101112131415161718192021222324252627282930313233343536373839package Factory;public class NikeFootballShoes extends Shoes&#123; public NikeFootballShoes()&#123; this.modelName = &quot;Nike Football&quot;; this.cushion = &quot;NO cushion&quot;; this.signaturePlayer = &quot;Ronaldo&quot;; this.shoeItem.add(&quot;nike football sticker&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping Nike football shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing Nike football shoes&quot;); &#125;&#125;package Factory;public class AdidasBasketballShoes extends Shoes&#123; public AdidasBasketballShoes()&#123; this.modelName = &quot;Adidas basketball&quot;; this.cushion = &quot;Boost cushion&quot;; this.signaturePlayer = &quot;Lillard&quot;; this.shoeItem.add(&quot;Adidas shoe string&quot;); &#125; @Override public void wrap() &#123; System.out.println(&quot;wrapping Adidas basketball shoes&quot;); &#125; @Override public void box() &#123; System.out.println(&quot;boxing Adidas basketball shoes&quot;); &#125;&#125; 이제 우리가 만들 신발 클래스를 만들었으니, 이 신발들을 만들 팩토리 클래스를 작성해보자.팩토리 클래스는 신발 가게 추상 클래스를 상속해서 만든다. 12345678910111213141516171819202122232425262728package Factory;public class NikeShoeStore extends ShoeStore&#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; if (type.equals(&quot;basketball&quot;))&#123; shoes = new NikeBasketballShoes(); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new NikeFootballShoes(); &#125; return shoes; &#125;&#125;package Factory;public class AdidasShoeStore extends ShoeStore&#123; @Override public Shoes createShoes(String type) &#123; Shoes shoes = null; if(type.equals(&quot;basketball&quot;)) &#123; shoes = new AdidasBasketballShoes(); &#125; else if(type.equals(&quot;football&quot;))&#123; shoes = new AdidasFootballShoes(); &#125; return shoes; &#125;&#125; 이제 잘 돌아가는지 확인해보자\u001f 1234567891011package Factory;public class Tester &#123; public static void main(String[] args) &#123; ShoeStore nikeShoeStore = new NikeShoeStore(); ShoeStore adidasShoeStore= new AdidasShoeStore(); adidasShoeStore.orderShoes(&quot;basketball&quot;); System.out.println(); nikeShoeStore.orderShoes(&quot;football&quot;); &#125;&#125; 결론 결론을 말하자면 자신이 만들고 있는 클래스가 바뀔 가능성이 있다면 팩토리 메소드 패턴 같은 기법을 써서 변경될 수 있는 부분을 캡슐화 하여야 한다. 신발공장 -(의존)-&gt; 신발 이었던 것을개별 신발 공장 -&gt; 신발공장 추상클래스 가 되고,신발공장 추상 클래스 -&gt; 신발 추상 클래스 이 되고,개별 신발 클래스 -&gt; 신발 추상 클래스 (의존성 뒤집기)이 된다. 즉 신발 특성이 신발 종류와 제조사에 따라 다르고, 신발 제작 방식이 제조사마다 다르므로신발과 신발 팩토리를 추상화해서 만들었다. 추상 팩토리 예제신발과 신발 공장 뿐만 아니라, 신발 재료 공장을 따로 만들어보자.신발 요소는 재조사 별로 사용하는 재료가 다를 수 있다고 가정할때,nike의 신발 요소 공장을 만들어봤다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package Factory;public interface ShoeIngredientFactory &#123; public Shoelace createShoelace(); public Outsole createOutsole(); public Cushion creatCushion(); public Colors[] createColors();&#125;package Factory;public class NikeShoeIngredientFactory implements ShoeIngredientFactory&#123; @Override public Shoelace createShoelace() &#123; return new NikeShoelace(); &#125; @Override public Outsole createOutsole() &#123; return NikeOutsole(); &#125; @Override public Cushion creatCushion() &#123; return NikeCushion(); &#125; @Override public Colors[] createColors() &#123; return new Colors[] = &#123;new BredColor()&#125;; &#125;&#125;이제 요소 팩토리에서 만든 요소들을 통해 신발을 만드는 신발 추상클래스를 만들자.이때 신발클래스는 요소 팩토리를 조합해서 만들어진다!```javapackage Factory;public abstract class Shoes &#123; String modelName; Cushion cushion; Outsole outsole; Shoelace shoelace; Colors colors[]; public abstract void prepare(); public String getModelName()&#123; return this.modelName; &#125; public void setModelName(String str)&#123; this.modelName = str; &#125; public void wrap()&#123; System.out.println(&quot;wrapping...&quot;); &#125; public void box()&#123; System.out.println(&quot;boxing...&quot;); &#125;&#125;package Factory;public class BasketballShoes extends Shoes &#123; ShoeIngredientFactory shoeIngredientFactory; public BasketballShoes(ShoeIngredientFactory shoeIngredientFactory) &#123; this.shoeIngredientFactory = shoeIngredientFactory; &#125; @Override public void prepare() &#123; this.cushion = shoeIngredientFactory.creatCushion(); this.shoelace = shoeIngredientFactory.createShoelace(); this.outsole = shoeIngredientFactory.createOutsole(); &#125;&#125; 자 이제 나이키 신발 요소 공장에서 신발 요소들을 만들어서 원하는 신발을 제작할 수 있는 나이키 매장을 만들어보자.(신발 가게 클래스는 이전과 동일.) 1234567891011121314151617package Factory;public class NikeShoeStore extends ShoeStore&#123; public Shoes createShoes (String type)&#123; Shoes shoes = null; ShoeIngredientFactory shoeIngredientFactory = new NikeShoeIngredientFactory() if (type.equals(&quot;basketball&quot;))&#123; shoes = new NikeBasketballShoes(shoeIngredientFactory); shoes.setModelName(&quot;basketball&quot;); &#125; else if (type.equals(&quot;football&quot;))&#123; shoes = new NikeFootballShoes(shoeIngredientFactory); shoes.setModelName(&quot;football&quot;); &#125; return shoes; &#125;&#125; 후! 힘들지만 다 살펴봤다!","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"17. Backtracking 활용 - Subste Sum 문제","slug":"cs/algorithm/problem/al17","date":"2021-08-17T06:46:12.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/17/cs/algorithm/problem/al17/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/cs/algorithm/problem/al17/","excerpt":"","text":"Subset sum주어진 집합의 부분집합의 원소 합이 특정 값이 되는 조건을 만족하는 집합을 찾아내는 문제.모든 집합을 찾아보는 건 2^n개임 DP로 푼다면?(안좋은 예시) 어떤 숫자가 포함될 경우와 그렇지 않은 경우를 모두 재귀적으로 표현 123456789subsetSum(A, i, S): #A는 배열, i는 포함 여부를 살펴보는 수의 인덱스 , S는 특정 값 if S == 0 : #조건에 맞는 경우 return True elif S &lt; 0 or i == -1 : #조건에 안맞는 경우 return False else: withNum = subsetSum(A, i-1, S-A[i])#A[i]가 부분집합에 포함되는 경우를 백트래킹 withoutNum = subsetSum(A, i-1, S)#포함되지 않는 경우 백트래킹 return withNum or withoutNum 즉 subsetSum(A, i, S) &#x3D; subsetSum(A, i-1, S-A[i]) or subsetSum(A, i-1, S)마치 dp점화식처럼 보인다.DP[i][S] &#x3D; DP[i-1][S-A[i]] or DP[i-1][S]이 dp테이블을 채우려면 O(n*S)인데 이것은 S가 큰 값으로 주어지면 큰 문제가 생긴다. 백트래킹으로 푼다면? 해당 원소가 부분집합에 포함 여부(1,0)를 기록하는 리스트 x를 사용 123456789101112subsetSum(k): #인덱스 k의 값이 포함되는지 판단 currentSum = 현재까지 선택된 원소들의 값 if k &gt;= len(A): if currentSum == S: print(X) else: #포함 미포함 두가지 가능성 모두 검사 #A를 오름차순으로 정렬했다고 가정 if currentSum + A[k] &lt;= S: #A[k]가 포함되려면, 포함했을 때 S보다 작거나 같아야됨 X[k] = 1 subsetSum(k+1) X[k] = 0 subsetSum(K+1)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"5. Class 클래스","slug":"java/java-basic/java5","date":"2021-08-17T06:10:14.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java5/","excerpt":"","text":"Class 클래스자바의 모든 클래스, 인터페이스는 .class 파일로 저장됨Class 클래스는 컴파일 된 class 파일을 로드하여 객체를 동적으로 로딩하고, 정보를 가져오는 메서드 제공 Class.forName(“클래스 이름”) 메서드로 클래스를 동적으로 로드 클래스 이름으로 직접 가져오기 인스턴스에서 가져오기1234567//1.Class c = Class.forName(&quot;java.lang.String&quot;);//2.Class c = String.class;//3.String s = new String();Class c = s.getClass(); 스트링 클래스의 정보를 c가 다룰 수 있게 된다.이제 c의 인스턴스를 생성하고 싶으면 c.newInstace()로 생성할 수 있다. 동적 로딩컴피일 시 데이터 타입이 정해지는 것이 아닌, 런타임 중에 정해지는 방법.데이터 타입을 유연하게 사용할 수 있지만, 오류 발생 가능성이 높고 속도도 떨어짐일반적으로 해당 자료형을 모를때 사용한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"4. 추상 클래스, 인터페이스","slug":"java/java-basic/java4","date":"2021-08-17T04:38:28.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java4/","excerpt":"","text":"추상 클래스구현 코드 없이 메서드 선언만 있는 추상 메서드를 포함한 클래스추상 클래스는 new 할 수 없음(인스턴스 생성 불가)추상 클래스의 추상 메서드는 하위 클래스가 상속하여 구현 인터페이스구현된 메서드가 없는 것(디폴트 메서드와 정적 메서드로 일부 구현된 메서드 존재 가능) 디폴트 메서드는 구현한 클래스들이 모두 공통적으로 갖게되는 메서드(오버라이딩 가능)정적 메서드는 인스턴스 생성 여부 상관없이 인터페이스 타입으로 사용할 수 있는 메서드private 메서드는 구현한 클래스가 사용하거나 오버라이딩이 안됨.(인터페이스 내부에서만 사용) 인터페이스는 기존 클래스와 다르게, 여러 인터페이스를 상속받을 수 있다.(다중상속 가능) 해당 클래스를 활용하기 위한 설명서 같은 역할(다형성에 유리) 모든 메서드가 추상 메서드임(public abstract)모든 변수는 상수로 선언됨(public static final)상속이 아닌 구현으로 해결. 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 할 수 있음 1Readable readable = new Reader(); 이때, 당연히 인터페이스의 내용만 사용가능함.클래스와 달리 여러 인터페이스를 구현할 수 있음","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"3. 다형성, 상속, 결합, 다운 캐스팅","slug":"java/java-basic/java3","date":"2021-08-17T04:06:28.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/08/17/java/java-basic/java3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/java3/","excerpt":"","text":"다형성하나의 코드가 여러 자료형으로 구현되어 실행되는 것.같은 코드에서 상황에 따라 다른 결과가 반환.상위 클래스에서 공통 부분을 구현하고, 하위 클래스에서 각 클래스에 맞는 기능 구현여러 클래스를 하나의 타입(상위 클래스)로 핸들링 가능 상속은 언제 사용할까IS-A관계(inheritance, 상속) 일반적(상위) vs 구체적(하위) 관계 상위 클래스 수정이 하위 클래스에 영향을 크게 미침 상속은 클래스간의 결합도 높음 계층구조가 복잡하면 비추. HAS-A관계(composition) 클래스가 다른 클래스를 포함하는 관계(변수로 선언) 상속을 사용하지 않아 결합도 낮은 편. 다운 캐스팅 업캐스팅된 클래스를 다시 원래의 타입으로 형 반환(원래 자기 클래스로) 하위로 형 변환은 명시적으로 해야 함12Customer vc = new VIPCustomer();VIPCustomer vCustomper = (VIPCustomer)vc; 변환할 때, vc가 VIPCustomer의 인스턴스가 아닌데 형변환을 하려고 한다면 에러가 일어난다. 원래 인스턴스의 형이 맞는지 확인하는 instanceof1234Customer vc = new GoldCustomer();if (vc instanceof VIPCustomer)&#123; VIPCustomer vCustomper = (VIPCustomer)vc;&#125; 위에서 언급한 오류 가능성을 체크하여 다운캐스팅하는 예시이다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"3. 데코레이터 패턴","slug":"java/java-basic/design-pattern/dp3","date":"2021-08-17T00:14:02.000Z","updated":"2023-02-16T11:18:02.885Z","comments":true,"path":"2021/08/17/java/java-basic/design-pattern/dp3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/17/java/java-basic/design-pattern/dp3/","excerpt":"","text":"데코레이터 패턴동적으로 객체에 부가적인 책임을 더하는 패턴.상속으로 확장하는 것이 아닌, 객체들의 결합으로 역할을 확장한다.특히 원본 코드에 영향을 주지 않고 기능을 추가할 수 있다!!!하지만 각 데코레이터마다 클래스를 만들어줘야 한다. 그래서 같은 기능을 서로 다른 여러 클래스에 적용하려면 매번 새로운 클래스를 만들어 줘야 한다.(이를 해결하기 위한 동적 프록시도 존재한다.) 배울 내용 요약 클래스들은 코드 수정없이 새로운 동작과 협동할 수 있도록 확장되어야 한다. 예제 음료와 첨가물에 따라 가격과 음료 내용을 출력하는 프로그램을 만들어보자 먼저 음료를 추상화한 클래스를 만들어보자. 123456789package Decorator;public abstract class Beverage &#123; String description = &quot;Unknown Beverage&quot;; public String getDescription()&#123; return description; &#125; public abstract double cost();&#125; 첨가물을 추상화한 클래스를 만들어보자.이 클래스가 데코레이터 역할을 추상화하게 된다.이때 주목할 점은, 데코레이터도 Beverage임을 기억하라. 12345package Decorator;public abstract class CondimentDecorator extends Beverage&#123; public abstract String getDescription();&#125; 음료 클래스를 구체화하는 에스프레소, 하우스블랜드 클래스를 만들어보자. 123456789101112131415161718192021package Decorator;public class Espresso extends Beverage&#123; public Espresso()&#123; description = &quot;Espresso&quot;; &#125; public double cost()&#123; return 1.99; &#125;&#125;package Decorator;public class HouseBlend extends Beverage&#123; public HouseBlend()&#123; description = &quot;House Blend COffee&quot;; &#125; public double cost()&#123; return .89; &#125;&#125; 첨가물 클래스를 추상화하는 모카 클래스를 만들어보자.생성자를 잘 보면, 장식할 클래스를 인자로 가져온다는 걸 알 수 있다. 123456789101112131415package Decorator;public class Mocha extends CondimentDecorator&#123; Beverage beverage; public Mocha(Beverage beverage)&#123; this.beverage = beverage; &#125; public String getDescription()&#123; return beverage.getDescription() + &quot;, Mocha&quot;; &#125; public double cost()&#123; return .20 + beverage.cost(); &#125;&#125; 이제 잘 되는지 실험해보자! 123456789101112package Decorator;public class StarbuzzCoffee &#123; public static void main(String[] args) &#123; Beverage beverage = new Espresso(); System.out.println(beverage.getDescription() + &quot;$&quot; + beverage.cost()); Beverage beverage2 = new HouseBlend(); beverage2 = new Mocha(beverage2); System.out.println(beverage2.getDescription() + &quot;$&quot; + beverage.cost()); &#125;&#125; 데코레이터 패턴과 프록시 패턴 데코레이터 패턴과 프록시 패턴 같은 역할을 하는 객체를 추가해서 원래 협력하던 객체를 감싸서 대신 협력에 참여하도록 한다. 이 두 패턴의 구현은 매우 비슷하지만 의도에 따라서 구분할 수 있다.감싸는 객체를 통해 기능을 추가하고 싶은 경우는 데코레이터 패턴, 감싸는 객체를 통해 접근 제어를 하는 경우는 프록시 패턴이라고 한다. 배운 내용 확인하기 클래스들은 코드 수정없이 새로운 동작과 협동할 수 있도록 확장되어야 한다.기존의 음료에 첨가물을 추가할 때, 상속으로 새로운 클래스로 만들 필요가 없이, 그냥 데코레이터로 기존 음료를 인수로 전달하면 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"2. 옵저버 패턴","slug":"java/java-basic/design-pattern/dp2","date":"2021-08-13T12:01:13.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/13/java/java-basic/design-pattern/dp2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/13/java/java-basic/design-pattern/dp2/","excerpt":"","text":"옵저버 패턴하나의 객체(서브젝트)가 변할 때, 자동으로 다른 여러 객체들(오브젝트)에게 영향을 동적으로 반영하는 일대다 관계 패턴이때 여러 오브젝트가 추가 될 수 있어야 한다. 배울 내용 요약 1. 서로 상호작용하는 객체들은 느슨하게 연결되어야 한다. 예제로 알아보자. NBA사무국에서는 선수들의 정보를 관리하고 있다.NBA방송국 NBC, TNT에서는 이 정보를 받아 방송하고 있다. 선수들의 정보가 변하게 될 때, 이 두 방송국에서 자동으로 정보를 바꾸고, 바뀐 정보를 방송하는 프로그램을 만들어보자. 일단 방송국들이 반영할 사무국에 대한 인터페이스를 만들어보자 1234567package Observer;public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125; 방송국들의 인터페이스도 만들어주자. 12345package Observer;public interface Observer &#123; public void update(float ppg, float rpg, float apg);&#125; 사무국의 인터페이스를 기반으로 사무국 클래스를 만들어보자. 123456789101112131415161718192021222324252627282930313233343536373839package Observer;import java.util.ArrayList;public class NBAData implements Subject&#123; private ArrayList observers; private float ppg; private float rpg; private float apg; public NBAData()&#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o)&#123; observers.add(o); &#125; public void removeObserver(Observer o)&#123; int i = observers.indexOf(o); if (i &gt;= 0)&#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++)&#123; Observer observer = (Observer)observers.get(i); observer.update(ppg, rpg, apg); &#125; &#125; public void measurementChanged()&#123; notifyObservers(); &#125; public void setMeasurements(float ppg, float rpg, float apg)&#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; measurementChanged(); &#125;&#125; 자, 이제 사무국은 값을 변경할 수 있고, arrayList에 옵저버(방송사)들을 추가하거나 제거하여, 자신의 변경사항을 방송국에게 전달해줄 수 있다.이번엔 방송국 클래스를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Observer;public class NBCDisplay implements Observer, DisplayElement&#123; private float ppg; private float rpg; private float apg; private Subject nbaData; public NBCDisplay(Subject nbaData)&#123; this.nbaData = nbaData; nbaData.registerObserver(this); &#125; public void update(float ppg, float rpg, float apg)&#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; display(); &#125; public void display() &#123; System.out.printf(&quot;This is from NBC!&quot;); System.out.printf(ppg+&quot;points &quot;+rpg+&quot;rebounds &quot;+apg+&quot;assists!!!!\\n&quot;); &#125;&#125;package Observer;public class TNTDisplay implements Observer, DisplayElement&#123; private float ppg; private float apg; private float rpg; private Subject nbaData; public TNTDisplay(Subject nbaData)&#123; this.nbaData = nbaData; nbaData.registerObserver(this); &#125; @Override public void display() &#123; System.out.printf(&quot;This is from TNT!&quot;); System.out.printf(ppg+&quot;points &quot;+rpg+&quot;rebounds &quot;+apg+&quot;assists~!\\n&quot;); &#125; @Override public void update(float ppg, float rpg, float apg) &#123; this.ppg = ppg; this.apg = apg; this.rpg = rpg; display(); &#125;&#125; 마지막으로 우리가 만든 녀석들이 잘 작동하는지 확인해보자! 12345678910111213package Observer;public class NbaBroadcast &#123; public static void main(String[] args) &#123; NBAData nbaData = new NBAData(); TNTDisplay tntDisplay = new TNTDisplay(nbaData); NBCDisplay currentConditionsDisplay = new NBCDisplay(nbaData); nbaData.setMeasurements(10.2f, 5.23f, 3.3f); nbaData.setMeasurements(20.4f, 12.4f, 7.4f); &#125;&#125; 배운 내용 확인하기 1. 서로 상호작용하는 객체들은 느슨하게 연결되어야 한다.우리는 인터페이스를 통해 옵저버와 서브젝트를 구현했다. 이들은 서로가 어떻게 구현됐는지 관심없다.그냥 서로가 약속한 인터페이스를 구현하면 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"1. 전략 패턴","slug":"java/java-basic/design-pattern/dp1","date":"2021-08-12T10:24:17.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/12/java/java-basic/design-pattern/dp1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/java/java-basic/design-pattern/dp1/","excerpt":"","text":"전략 패턴변경 가능하고 독립적인 알고리즘의 구성으로 만든 패턴 특징 특정한 계열의 알고리즘을 정의 각 알고리즘을 캡슐화 이 알고리즘들을 해당 계열 안에서 상호 교체 가능 배울 내용 요약 1. 다양하게 변화할 법한 내용은 캡슐화하자.2. 구현이 아닌 인터페이스로 프로그래밍하자.3. 상속보다는 구성(IS-A, HAS-A, 구현을 구분하라) IS-A는 상속 관계로 표현되고, HAS-A는 구성으로 표현된다. 우리는 상속보다 구성을 택할 경우, 런타임 중에 동적으로 행동을 줄 수 있다. 예제로 알아보자 목적 : 다양한 농구 선수들이 플레이 내용을 출력하는 프로그램을 만들어보자 요구사항 : 농구 선수는 여러 포지션을 가질 수 있다. 농구 선수는 모두 슛과 드리블을 할 수 있다. 각 포지션 마다 독특한 슛과 드리블을 구사할 수 있다. 특정 농구선수는 여러 슛과 드리블을 구사할 수 있다. 이제 슛과 드리블을 인터페이스로 캡슐화 해서 구현해보자 player class 123456789101112131415161718package Strategy;public abstract class Player &#123; DribbleBehavior dribbleBehavior; ShootBehavior shootBehavior; public abstract void display(); //dynamically public void setShootBehavior(ShootBehavior sb)&#123; shootBehavior = sb; &#125; public void setDribbleBehavior(DribbleBehavior db)&#123; dribbleBehavior = db; &#125; public void performDribble()&#123; dribbleBehavior.dribble(); &#125; public void performShoot()&#123; shootBehavior.shoot(); &#125;&#125; 이제 인터페이스를 만들어서 캡슐화해보자~ 1234567891011package Strategy;public interface DribbleBehavior &#123; public void dribble();&#125;package Strategy;public interface ShootBehavior &#123; public void shoot();&#125; 이제 인터페이스에 따라 다양한 슛과 드리블 클래스를 만들자 12345678910111213141516171819202122232425262728293031323334353637package Strategy;public class ThreePointShoot implements ShootBehavior&#123; @Override public void shoot()&#123; System.out.println(&quot;from the downtown... It&#x27;s good!!!!!!&quot;); &#125;&#125;package Strategy;public class DunkShoot implements ShootBehavior&#123; public void shoot()&#123; System.out.println(&quot;here comes the hammer!!!!!&quot;); &#125;&#125;package Strategy;public class CrossOverDribble implements DribbleBehavior&#123; @Override public void dribble() &#123; System.out.println(&quot;what a dribble... wazzle dazzle!&quot;); &#125;&#125;package Strategy;public class HegiDribble implements DribbleBehavior&#123; @Override public void dribble() &#123; System.out.println(&quot;look at that hegi..&quot;); &#125;&#125; 이제 player 클래스를 구현하는 포지션 별 행동을 잘 구성하자! 12345678910111213141516171819202122232425package Strategy;public class Guard extends Player&#123; public Guard()&#123; dribbleBehavior = new CrossOverDribble(); shootBehavior = new ThreePointShoot(); &#125; @Override public void display() &#123; System.out.println(&quot;Here comes new Guard!&quot;); &#125;&#125;package Strategy;public class Foward extends Player&#123; public Foward()&#123; dribbleBehavior = new PowerDribble(); shootBehavior = new DunkShoot(); &#125; @Override public void display() &#123; System.out.println(&quot;Here comes new Forward...!&quot;); &#125;&#125; 자 이제 잘 작동하는지 한번 해보자. 123456789101112131415161718package Strategy;public class MiniPlayerSimulator &#123; public static void main(String[] args)&#123; Player curry = new Guard(); curry.display(); curry.performDribble(); //dynamically setter curry.setDribbleBehavior(new HegiDribble()); curry.performDribble(); curry.performShoot(); Player james = new Foward(); james.display(); james.performDribble(); james.performShoot(); &#125;&#125; 배운 내용 확인하기 1. 다양하게 변화할 법한 내용은 캡슐화하자. 슛과 드리블은 다양하게 나뉘므로 선수 클래스로부터 캡슐화 했다 2. 구현이 아닌 인터페이스로 프로그래밍하자. 슛과 드리블은 오버라이딩 같은 방식이 아닌, 인터페이스로 다향성을 구현했다. 3. 상속보다는 구성(IS-A, HAS-A, 구현을 구분하라) 가드가 삼점 슛과 크로스오버를 가진 것처럼 구성하였다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Design Pattern","slug":"java/design-pattern","permalink":"https://yangdongjue5510.github.io/categories/java/design-pattern/"}]},{"title":"11. 가상 메모리와 페이징 시스템, 세그멘테이션 기법","slug":"cs/os/os11","date":"2021-08-12T04:56:15.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/12/cs/os/os11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/cs/os/os11/","excerpt":"","text":"가상 메모리실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음.(리눅스는 하나의 프로세스가 4기가를 차지함) 적은 메모리에서 여러 프로세스를 다루기 위해 등장한 개념이 가상 메모리! cpu가 한 프로세스의 모든 영역을 사용하지는 않는다,프로세스가 모두 4기가 씩을 부여 받더라도, 정작 사용하는 공간은 제한적이다.사용할 영역만 RAM에 저장하여 실행하는 방식으로 하면 메모리가 부족해도 여러 프로세스를 작동 시킬 수 있다. 가상 메모리의 기본 아이디어 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 바꿔주자. virtual address : 프로세스가 참조하는 주소 physical address : 실제 메모리 주소 MMU(Memory Managemnet Unit) cpu에 코드 실행 시, 가상 주소 메모리 접근이 필요할 경우, 해당 주소를 물리 주소 값으로 변환하는 하드웨어. 주소 변환을 빠르게 하기 위해 하드웨어 장치를 사용. cpu는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU가 물리 메모리 접근 페이징 시스템(paging system) 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리 하드웨어 지원 필요(intel x86(32bit)는 4kb, 2mb, 1gb 지원) 리눅스에서는 4kb로 paging 가상 메모리를 페이징 단위에 맞게 잘게 쪼개서 페이징 번호를 부여하고,page table에 해당 페이징에 맞는 물리 주소 매핑 정보를 저장한다. 4gb짜리 프로세스와 PCB에 page table 구조체를 가리키는 주소가 존재해서cpu가 어떤 가상 메모리 주소에 접근하면 해당 페이징에 맞는 page table에 접근해서,매핑 되어 있는 물리 주소를 얻어 물리 주소로 접근하는 방식이다. 내부 단편화 : 4kb씩 데이터를 나눈다고 했을 때 만약 1kb가 남으면…? 1kb도 4kb크기의 페이지로 할당.(공간 낭비) 페이징 시스템 구조1. page 혹은 page fram: 고정된 크기의 block 가상 주소 v &#x3D; (p, d) p: 가상 메모리 페이지 번호 d: p안에서 참조하는 위치(변위 혹은 오프셋이라고도 부름)(페이지 안에서도 내가 접근할 위치의 값에 접근할 수 있도록 하는 것이 d)(즉 어떤 페이지의 시작 주소가 있을 텐데 그 페이지에서 d 만큼 내려오면 우리가 원하는 주소) 2. page table: 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표(CR3라는 레지스터에 page table 시작 주소가 담겨져 있다.) 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는 지 확인 page 번호가 있으면 이 page가 매핑된 첫 물리주소가 p’이 됨 page 번호가 있어도 해당 page가 램에 저장되지 않았을 수 있음(필요 없다고 생각해서) p’+d 가 실제 물리 주소가 됨 다중 단계 페이징 시스템32bit 시스템에서 한 프로세스가 4gb(리눅스 기준)인데,이를 4kb 기준으로 다 잘라서 다 테이블에 저장하려면 너무 비효율적이다. 따라서 페이징 정보를 단계를 나누어 생성하자.즉 필요없는 페이지는 생성하지 말자! 가상 주소를 page directory, page table, offset으로 만들어서필요 없는 페이지들은 페이지 테이블을 안 만들도록 할 수 있다~! MMU와 TLB(컴퓨터 구조)한번 가상 주소를 통해 얻은 물리 주소를 TLB라는 캐쉬에 저장해놓는다.만약 다시 동일한 주소를 요청하면, 해당 테이블을 찾아보지 않아도 TLB를 통해 얻을 수 있다. 이를 통해 메모리에서 접근하고 값을 찾는 과정을 줄일 수 있다. 페이징 시스템과 공유 메모리프로세스 간 동일한 물리 주소를 가르킬 수 있다.즉 서로 다른 프로세스 a, b의 내용이 같은 영역은 물리주소로 변환할 때 같은 물리 주소로 줄 수 있다. 엥? 서로 한 프로세스가 데이터를 변경할 수 있잖아요..?그렇다. 하지만 생각해보자. 만약 a 영역에서 물리주소를 얻어 데이터를 변경하려고 한다면?그때 메모리 상에 다른 물리주소를 복사해서 그 주소를 b에게 주고, 원래 물리 주소를 요청대로 수정하면 된다. 이런 방식을 통해 각 프로세스가 1기가 정도 점유하고 있는 커널 공간을 모두 같은 물리 주소로 변환해,용량 낭비를 줄일 수 있다. 프로세스 생성 시간도 줄어들고, 공유 공간을 물리 메모리를 공유로 효율적으로 쓸 수 있다. 요구 페이징(demanding paging, demanded paging)프로세스 모든 데이터를 메모리에 담지 않고, 실행 중 필요한 시점에만 메모리로 적재더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)(선행 페이징이 이와 반대되는 개념. 모두 메모리에 적재.) 페이지 폴트 인터럽트(page fault interupt)어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트.운영체제는 이 인터럽트를 받으면, 해당 페이지를 물리 메모리에 올리고 다시 작업을 실행시킨다.페이지 폴트는 인터럽트이므로, 앞서 배웠던 인터럽트 처리과정을 동일하게 발생시킨다. 스레싱(Thrashing) 페이지 폴트가 자주 일어나면, 시간이 오래 걸린다. 반복적으로 페이지 폴트가 발생해, 과도하게 페이지 교체작업이 일어나 실제로는 아무 일도 진행 안되는 상태. 자주 쓰일 것 같은 페이지는 미리 메모리에 올려 놓는게 좋다.(알고리즘) 페이지 교체 정책(page replacement policy)물리 메모리가 가득 찼는데 특정 페이지를 물리 메모리에 올려야 할 때어떤 페이지를 선택해 빼고 넣으려고 했던 페이지를 넣는다. FIFO 알고리즘 가장 먼저 들어온 페이지가 나가자! OPT 알고리즘 오랫동안 안 쓸 페이지를 내리자!(일반적인 OS에서는 예측 불가) LRU 알고리즘 가장 오래 전에 사용한 페이지가 나가자! LFU 알고리즘 지금까지 가장 적게 쓰인 페이지가 나가자! NUR 알고리즘 각 페이지마다 참조 비트, 수정 비트를 (R, M)으로 표현하여 (0,0)-&gt;(0,1)-&gt;(1,0)-&gt;(1,1) 로 우선순위로 나가라! 세그멘테이션 기법페이징과 비교해서 기억하는 정도만 보자.가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할(페이징은 일관된 크기로 분할) 세그먼트 가상 주소v &#x3D; (s,d) s: 세그먼트 번호, d: 블록 내 세그먼트 범위 외부 단편화 : 세그먼트의 크기가 들어갈만한 연속적인 물리 공간이 없으면 문제가 생김.(크기가 지 맘대로다 보니…)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"16. Backtracking","slug":"cs/algorithm/theory/al16","date":"2021-08-12T04:11:49.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/12/cs/algorithm/theory/al16/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/12/cs/algorithm/theory/al16/","excerpt":"","text":"Backtracking답이 x1, x2, x3… 이런 형식으로 도출되는 문제에서, 유효한 답을 모두 찾는 경우 사용되는 알고리즘 기법 x1부터 차례대로 결정하면서 만약 어느 순간 조건에 맞는 답을 도출 못하는 상황에 마주하면,그 전 단계로 돌아가 다른 선택지로 다시 답을 찾아가는 방법이다. 이 기법은 굳이 더 알아보지 않아도 되는 경우를 확인하지 않도록 설계하는 것이 가장 중요하다. psuedo code 123456789def backtrack(k): if k &gt; n: print(x) else: for each possible value x of x[k]: if B(x[1], ... , x[k]) is valid: #B는 x1~xk가 해의 일부가 될 수 있는지를 검증 x[k] = x backtrack(k+1) 이런 방식은 미로 탈출하기 등에 적용할 수 있다. N queens 문제n X n 체스판에 n개의 퀸을 배치해야 한다.다만 각 퀸들의 공격권에 다른 퀸이 있으면 없도록 배치해야 할 때, 배치 가능한 방법 갯수를 구하라. x라는 배열이 각 퀸의 위치를 인덱스가 행을, 밸류값을 열로 나타낸다.이제 x[0] &#x3D; 0은 (0,0)에 퀸이 존재함을 의미한다. 그러면 이제 backtracking을 위해 x[0] &#x3D; 0 이라고 가정하자.x[1]는 0과 1이 될 수 없다.(세로줄 겹침, 대각선 겹침.)x[1] &#x3D; 2인 경우는 일단 문제는 없으니 x[1] &#x3D; 2 로 가정하고 넘어간다. x[2] 는 이제 0, 1, 2, 3 모두 될 수 없다.(두 퀸과 무조건 겹침)즉 조건을 만족할 수 없으므로, x[1]의 경우로 backtracking한다! 이런 과정을 통해 x[3]이 배치될 때까지 반복하면 backtracking을 통해 답을 찾을 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"15. 그리디 알고리즘 활용 - 허프만 코딩","slug":"cs/algorithm/problem/al15","date":"2021-08-11T10:38:21.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/11/cs/algorithm/problem/al15/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/algorithm/problem/al15/","excerpt":"","text":"허프만 코딩 문제(Huffman coding problem)아스키 코드 : 알파벳과 문자들을 0~255개의 숫자로 배정한 것. 즉 8bit로 표현.이렇게 표현된 8비트의 비트들을 고정길이코드(fixed-length code)라고 한다.(문자열 100개면 800비트가 필요하게 된다.) 이때 a e i o u 같은 모음들은 빈도수가 높고 q z y는 빈도수가 낮다.그렇다면, 자주 사용되는 문자의 아스키 코드 비트값은 줄이고, 그렇지 않은 문자들 비트 수는 늘리면 어떨까?이렇게 변한 길이의 코드를 가변길이 코드라고 하자. 즉 a가 100번, b가 30번, c가 5번이라고 하면,고정 길이코드로 할 경우, 모두 8비트로 부여할 경우 총 800 + 240 + 40 &#x3D; 1080 비트가 필요 가변 길이코드로 부여하면, a &#x3D; 0, b &#x3D; 101, c &#x3D; 100으로 할 경우,100 + 90 + 15 &#x3D; 205 비트면 충분하게 된다. 하지만 만약 코드를 더 줄이고 싶으면 다음과 같이 하면 된다고 생각할지 모른다.a &#x3D; 0, b &#x3D; 1, c &#x3D; 10 하지만 그렇게 된다면, 1001010을 baacc 혹은 caabab 등등 해석이 불분명해진다.따라서 각 문자에 비트를 구분가능하게 부여해야하는데, 이를 prefix-free code라고 한다.다시 말하면, 각 코드들은 앞부분이 다른 코드와 동일하면 안된다.(위 예시는 c의 앞부분이 b와 동일했다.) 트리 형태로 생각하기. 위에서 설명한 규칙들을 기반으로 트리를 만들면 위와 같다.여기서 짧은 코드를 할당받기 위해서는? 루트노드와 가까워야 한다!그렇다면 도대체 어떻게 구현한다는 것인가…!! 먼저 빈도 내림차로 문자들을 배열에 정렬하여 만들고,(위 사진은 그러지 않았다.)빈도가 작은 수끼리 빈도를 합쳐가면서 만들면… 우리가 앞서 본 트리와 비슷한 모양이 그려진다. 즉 코드로 구현하려면, 가장 작은 값과 두번째로 작은 값을 찾아 더해야 하는데… 이는 힙으로 구현 가능하다! 이제 우리가 알고싶은 특정 문자열의 총 비용은 모든 문자의 빈도수 X 트리에서 깊이 이다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"14. 그리디 알고리즘","slug":"cs/algorithm/theory/al14","date":"2021-08-11T07:17:39.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/11/cs/algorithm/theory/al14/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/algorithm/theory/al14/","excerpt":"","text":"그리디 알고리즘현재 상태에서 가장 좋은 선택을 반복해서 해를 구성하는 알고리즘 문제는 이 그리디 알고리즘을 통해 얻은 해가 진짜 최선의 선택으로 얻은 해이냐는 것인데,이를 증명하기 위해서는 귀류법을 통해 증명해봐야 한다. 즉 우리가 찾은 해가 해가 아님을 가정으로 하여 다른 해를 가정하여,그 해를 논리적으로 추론하여 모순을 찾아내면, 우리가 찾은 그리디는 증명된 것이다. 예를 통해 이해해보자. L &#x3D; [1, 2, 3, 4, 5]라는 배열에서 원소의 합이 9 (&#x3D; T)를 넘지 않도록 원소를 추출할 때, 가장 원소가 많은 경우는 몇 개인지 구할 때,우리는 당연히 가장 작은 원소부터 하나씩 더해가면서 합이 9가 넘어가기 전 원소들만 추출 할 것이다.(1,2,3. 즉 세개)(가장 작은 값부터 뽑는 방식으로 T까지 뽑으면(p) -&gt; 3개가 가장 최대 갯수이다.(q)) 이 논리를 검증하려면 ~q -&gt; ~p임을 증명하면 된다.즉 3개가 보다 더 많이 뽑을 수 있다고 가정했을 때 p가 모순을 일으키면 우리의 원래 p-&gt;q가 증명된 것이다. 우리는 3이라는 답을 우리의 논리(p)로 찾아냈다.이를 증명하기 위해 3보다 많은 갯수가 해가 존재한다(~q)고 가정해보자. 그렇다면 우리의 논리(가장 작은 값부터 뽑기, p) 찾은 값들 a1, a2, a3가 있을 것이고역의 해 b1, b2, b3, b4 …가 있을 것이다.(이때, a와 b 모두 오름차순이라 하자) 자 이제 a1+a2+a3 &#x3D; X라 하고, b1+b2+b3 &#x3D; Y라 하면,p에 의해 무조건 X &lt;&#x3D; Y 이다. (p &#x3D; 가장 작은 값부터 뽑는다.)그리고 문제 조건에 따라 Y + b4 &lt;&#x3D; T이다. 그런데 p에 따르면X + a4 &gt;T 이고 a4 &lt;&#x3D; b4 이다. 즉 종합해보면X &lt;&#x3D;Y , a4 &lt;&#x3D; b4 인데X + a4 &gt; T 인데 Y + b4 &lt;&#x3D; T 인 모순적인 상황이 발생한다! 즉 우리의 그리디가 옳았다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"10. 쓰레드","slug":"cs/os/os10","date":"2021-08-11T04:09:16.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/11/cs/os/os10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/11/cs/os/os10/","excerpt":"","text":"ThreadLigth Weight Process라고도 하는 데, 프로세스와 비슷하지만 프로세스보다 가벼운 존재다. 프로세스 : 프로세스끼리는 서로 데이터에 접근 불가스레드 : - 하나의 프로세스 안에서 여러 스레드 생성 가능 - 스레드들은 동시에 실행 가능 - 프로세스 안에 있으므로 해당 프로세스 데이터를 모두 접근 가능 쓰레드는 어떤 프로세스 안에서 code, data, heap 영역은 공유하지만,각자 개인의 스택 영역을 가진다.(프로세스의 스택 영역은 공유하지 않는다.) 멀티 프로세싱과 쓰레드멀티 태스킹 : 한 cpu가 여러 프로세스를 시분할 하여 돌아가며 작업 수행멀티 프로세싱 : 여러 cpu가 프로세스들을 병렬로 작업 수행. -&gt; 이 작업은 쓰레드를 여러개로 만들면 가능한 일! 쓰레드 장단점 장점 1. 사용자에 대한 응답성 향상만약 어떤 작업과 동시에 사용자와 커뮤니케이션 해야 되는 경우, 쓰레드를 사용하지 않으면, 해당 작업이 모두 끝나야 커뮤니케이션이 가능하다.반면 쓰레드를 사용하면 작업과 커뮤니케이션을 병렬적으로 처리 가능하다. 2. 자원 공유 효율 - IPC 작업 같은 프로세스 간 자원 공유를 위한 작업이 필요 없음 3. 작업이 분리되어 코드가 간결(이건 작성자에 따라 다르다.) 단점 1. 스레드 중 한 스레드만 문제 있어도, 프로세스 전체가 영향 받음 - 프로세스는 서로 독립되어 있어서, 서브 프로세스들 중 하나가 문제 생겨도 다른 서브 프로세스에 영향이 덜 감 - 반면 쓰레드는 해당 프로세스의 자원을 공유하기 때문에, 한 쓰레드의 오류가 큰 문제를 일으킴. 2. 스레드를 많이 생성하면 context switching이 많이 일어나 성능이 저하된다. - 스레드를 스케쥴링해야 하므로, context switching이 많이 일어나게 된다. 쓰레드 동기화 이슈동기화: 작업들 사이에 실행 시기를 맞추는 것여러 스레드가 동일한 자원을 접근해 수정할 경우 동기화 이슈가 발생. 여러 쓰레드가 한 변수를 읽고 쓰기를 한다고 상상해보자.이때 어떤 쓰레드A가 한 변수를 쓰고, 다른 쓰레드B가 읽는 순으로 진행되어야 하는데, 만약 B가 변수를 읽고 A가 변수를 쓰게 된다면?우리가 원하는 결과를 얻을 수 없게 된다. 자 g_count라는 변수가 0으로 초기화되어 있고, g_count &#x3D; g_count +1 이라는 코드를 쓰레드1과 쓰레드2에게 각각 실행시켜최종적으로 g_count가 2라는 결과값을 얻고자 할 때 예상되는 동기화 이슈를 살펴보자.g_count &#x3D; g_count +1 은 세가지 연산이 필요한다. (메모리에서 g_count값을 읽고, 레지스터에서 덧셈을 진행하고, 진행한 값을 다시 g_count 메모리에 저장.)근데 이때, 쓰레드1에서 덧셈만하고 저장하지 못한 채로 context switching이 일어나, 쓰레드2가 작업을 시작하면 문제가 생긴다! 동기화 이슈 해결 방안상호 배제(Mutual exclusion, LOKING 매커니즘) 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근 못하도록 막기! 임계 자원(critical resource) : 접근이 제한되는 자원 임계 영역(critical section) : 접근이 제한되는 영역(코드 상에서) 1234lock.acquire()for i in range(100000): g_count += 1lock.release() Mutex와 Semaphore Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어 갈 수 있음 Semaphore : 임계구역에 여러 스레드가 들어 갈 수 있음 counter를 두어서 동시에 리소스에 접근 할 수 있는 스레드 수를 제어 Semaphore 로직 P: 검사(임계영역에 들어갈 때) S &gt;&#x3D; 1 이면, 임계 영역 진입 &amp;&amp; S -1 (S&#x3D;&#x3D;0이면 대기) V: 증가(임계영역에서 나올 때) S+1 하고 임계 영역 나옴 S: 세마포어값(초기 값만큼 여러 프로세스가 동시에 임계 영역 접근 가능) 바쁜 대기(busy waiting) : 프로세스가 대기 중임을 코드로 표현하기 위해 루프를 사용함.즉 대기를 위해 cpu리소스가 사용되는 비효율적 상황 대기큐 : S가 음수일 경우, 바쁜 대기 대신 대기큐에 넣자! psuedo code 123456789101112131415161718192021222324P(S): wait(S)&#123; while S &lt;= 0 //대기(busy waiting. 기다리는데 cpu 자원 사용...) ; S--; //다른 프로세스 접근 제한&#125;V(S): signal(S) &#123; S++; //다른 프로세스 접근 허용&#125;//대기큐wait(S) &#123; S-&gt;counter--; if(S-&gt;count &lt;0) &#123; add this process to S-&gt;queue; block() //대기를 위해, 프로세스를 대기큐에 넣고 block 상태로... &#125;&#125;signal(S)&#123; S-&gt;count++; if (S-&gt; count &gt;= 1)&#123; remove a process P from S-&gt;queue; wakeup(P) //큐에서 프로세스를 꺼내서 깨운다! &#125;&#125; 교착상태(Deadlock)와 기아상태(Starvation) 교착상태 무한 대기 상태 : 복수의 작업이 서로 상대방 작업이 끝나길 기다리느라 다음 단계로 진행되지 않는 상황 스레드1은 lock하여 리소스 1을 사용하고 리소스 2를 사용하기 위해 대기하고,스레드2는 lock하여 리소스 2를 사용하고 리소스 1을 사용하기 위해 대기한다면?둘 다 다음 단계로 진행되지 않는다! 교착 상태 발생조건(모두 성립 시 교착상태 발생 가능) 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적 통제권 요구 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원 대기 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음 순환대기(Circular wait): 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다 이런 원인 중 일부를 해결하면 교착상태를 해결할 수 있다 기아상태 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태 교착상태와 차이? 교착상태 : 여러 프로세스가 동일 자원 점유를 요청할 때 발생 기아상태 : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 할당 안됨 예를 들면 어떤 변수를 10번 접근해서 변경하라는 명령을 100개의 쓰레드가 사용된다면, 일부 쓰레드는 영영 작업을 해보지 못할 것이다! 기아상태 해결 프로세스 우선순위를 수시로 변경 오래 기다린 프로세스의 우선순위 상향 우선순위가 아닌 요청순으로 FIFO 기반 요청큐 사용","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"9. 프로세스 구조와 프로세스간 커뮤니케이션","slug":"cs/os/os9","date":"2021-08-09T04:34:54.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/09/cs/os/os9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/09/cs/os/os9/","excerpt":"","text":"프로세스 구조프로세스 구조는 4가지 영역으로 나뉜다. 스택 : 최상단 스택 주소를 가리키는 EBP, 함수 결과를 반환해줄 주소(return address), 함수와 관련된 인자나 변수를 저장하는 영역 힙 : 동적으로 할당된 메모리를 저장하는 영역. (ex. malloc) 이 영역의 메모리 주소를 통해 힙에 저장된 내용을 다른 영역에서 사용! 데이터 : 선언된 변수가 저장되는 영역(전역변수가 저장된다.) 코드 : 컴파일된 소스코드가 저장되는 영역 스택에 쓰이는 레지스터들 :program counter, stack pointer, EBP, EAXprogram counter(pc)는 cpu 내부의 레지스터 중 하나로, 다음에 실행될 명령어의 주소를 가지고 있다. stack pointer는 cpu 내부 레지스터 중 하나로, 스택에 데이터가 채워진 위치를 가르킨다. EBP 얘도 레지스터인데, 우리가 함수를 작성할 때 함수 안에 다른 함수를 부를때마다 그 전에 stack pointer가 가르키던 주소를 스택에 집어넣고 EBP에도 저장한다.이를 통해 프로그램 진행 중 문제가 생겼을 때, 어떤 함수에서 문제가 발생했는지 알 수 있게 된다. EAX 얘도 레지스터인데, 스택에서 실행된 함수의 반환값을 저장하는 레지스터다! 데이터 영역은 두 가지로 나뉜다. (BSS, DATA)BSS : 초기화되지 않은 전역변수. DATA : 초기화된 전역변수 컨텍스트 스위칭스케쥴러가 어떤 프로세스를 실행하다가, 이를 멈추고 다른 프로세스를 실행시키는 행위를 컨텍스트 스위칭이라 한다!컨텍스트 스위칭은 빈번하게 일어나므로, 빠르게 실행하기 위해 어셈블리어로 작성되어 있는 경우가 많다. 이때 앞에 배웠던 program counter와 stack pointer이 저장하고 있는 두 주소값을해당 프로세스의 PCB(Process Control Block. 프로세스의 상태를 저장하는 구조체)라는 곳에 저장해 놓고!다른 프로세스로 넘어가서 작업을 시작하고 이 프로세스의 PCB에도 해당 값을 저장하고,이제 처음에 했던 프로세스를 이어서 하기위해, PCB에 있던 데이터를 가져와 cpu의 pc와 sp를 업데이트하고 디스패치(ready-&gt;running)한다! PCB에 저장되는 내용들리눅스 PCB 예시 Process ID Register value(PC, SP…) Scheduling info (Process state. running, block, ready…) Memory Info(memory size…) 프로세스간 커뮤니케이션(IPC, Inter Process Communication)프로세스들이 서로 마음대로 접근해서 바꾸면? 당연히 문제가 된다! 하지만 프로세스간 통신 해야 될 경우도 분명히 존재한다. 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행 이 때 프로세스간 상태 확인 및 데이터 송수신 필요. &#x3D;&gt; 그래서 프로세스간 통신이 필요하다. 프로세스간 공유하는 파일 사용하기프로세스간 코드에 접근할 수는 없지만, 특정 저장매체를 공유할 수 있게 해서,한 프로세스가 전달할 내용을 파일에 쓰고, 다른 프로세스가 해당 파일을 읽는 방식이다. 하지만 실시간으로 원하는 프로세스에 데이터 전달이 어려움… 이때, 프로세스들은, 다른 영역이 아닌 커널 공간(이 부분은 다른 프로세스도 비슷하므로)를 공유해 사용한다.IPC는 쉽게 요약하면, 이 커널 공간을 통해 어떻게 공유할 지 결정하는 방법이라 할 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"13. 다이나믹 프로그래밍-3(LCS 문제)","slug":"cs/algorithm/problem/al13","date":"2021-08-05T12:11:41.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/05/cs/algorithm/problem/al13/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/problem/al13/","excerpt":"","text":"LCS(최장공통부문자열) 문제부문자열은 문자열에서 0개 이상의 문자를 제외하고 남은 문자열을 의미YANG에서 A를 제외한 YNG같이… 하지만 AGY는 안된다! 공통 문자열은 두개의 문자열의 부문자열이 동일한 것을 말한다!이 문제는 가장 긴 길이의 공통부문자열을 찾는 문제이다! Xn 을 x1, x2, x3, … xn 즉 n개의 글자를 갖는 문자열이라고 하고,**LCS(i, j)**를 Xi와 Yj의 최장공통부문자열의 길이라고 한다면,xn과 yj(즉 두 문자열의 마지막 글자)가 같은 경우와 그렇지 않은 경우를 생각해야 한다. 만약 마지막 글자가 같으면, 그 글자를 제외하고 생각할 수 있다!즉 LCS(i, j) &#x3D; LCS(i-1, j-1) + 1 이런 점화식이 가능하다! 하지만 마지막 글자가 다르다면?Xi와 Y(j-1). 즉 X전체와 Y에서 마지막을 제외한 문자열의 LCS값과X(i-1)과 Yj. 즉 X에서 마지막을 제외한 문자열과 Y전체의 LCS값 중 최대값을 구하면된다즉 LCS(i, j) &#x3D; max(LCS(i, j-1), LCS(i-1, j)) 자 이제 이 점화식을 이차원 리스트로 표현할 수 있다!if xi&#x3D;&#x3D;yj LCS[i-1][j-1] + 1if xi!&#x3D;yj max(LCS[i][j-1], LCS[i-1][j]) 이렇게 대략적으로 테이블이 그려지면, 이제 특이 조건들을 찾아야 된다!예를 들면 LCS(0,x) 혹은 LCS(x,0) 같은 값들! 이들은 모두 0이다! 그 다음엔, 어떤 절차로 작은 값을 통해 큰 값을 구해낼지 추론해야 한다!이렇게 테이블을 모두 채우는데 O(mn)의 시간이 걸린다! 만약, 길이가 아닌 문자열 자체를 구하라하면, 테이블을 숫자로 채운 다음, 역으로 추론해가며 올라가자.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"8. 선점형 스케쥴러와 인터럽트","slug":"cs/os/os8","date":"2021-08-05T07:47:28.000Z","updated":"2022-01-22T16:20:00.032Z","comments":true,"path":"2021/08/05/cs/os/os8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/os/os8/","excerpt":"","text":"선점형 스케쥴러하나의 프로세스가 다른 프로세스 대신에 프로세서(cpu)를 차지할 수 있다!어떤 프로세스가 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체가능! 비선점형 스케쥴러하나의 프로세스가 끝나지 않으면 다른 프로세스는 cpu 사용할 수 없음…자발적으로 wait으로 되거나, 혹은 실행이 끝났을 때만 다른 프로세스로 교체 가능!즉 cpu가 임의로 실행 중인 프로세스를 종료시키지 못한다. &#x3D;&#x3D;&#x3D; 인터럽트 cpu는 명령 하나하나 실행 중일때, 다른 장치와 어떻게 커뮤니케이션 할까? cpu가 프로그램을 실행 중 일때, 장치, 혹은 예외 상황이 발생해 처리가 필요할 경우 cpu에 알려서 처리하는 기술.인터럽트는 특정 프로세스의 코드가 아닌 일종의 이벤트.이벤트에 맞게 운영체제가 처리한다! 인터럽터 필요 이유 선점형 스케쥴러 구현 어떤 프로세스가 running 중에 이를 중단시킬 때, 인터럽터가 필요. IO 디바이스와 커뮤니케이션 저장매체에서 처리 완료 시, 프로세스를 깨워야 함(block -&gt; ready) 예외 상황 핸들링 어떤 문제가 생겼을 때, cpu에서 이를 처리할 수 있도록 cpu에 알려줘야 함 인터럽트 종류1. 0으로 나누는 코드 실행 시 (Divide by Zero Interrupt) 12345int main()&#123; int zero = 0 int data = 1/zero; return 0;&#125; 이런 시도를 하게 되면, 운영체제가 해당 프로세스를 종료시키고, 인터럽트를 발생시킨다! 2. 타이머 인터럽트 - 선점형 스케쥴러를 위해 필요. 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다!cpu가 다른 프로세스를 실행 중이라 바쁠 때, 특정 시간마다 인터럽트를 일으켜 알려준다! 3. 입출력 인터럽트 - 프린터, 키보드, 마우스…. 인터럽트 종류 내부 인터럽트(소프트웨어 인터럽트) 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생. 0으로 나누거나, 사용자 모드에서 허용하지않는 명령 실행, overflow, underflow… 외부 인터럽트(하드웨어 인터럽트) 주로 하드웨어에서 발생되는 이벤트(프로그램 외부) 전원 이상, IO 관련 이벤트, Timer이벤트… &#x3D;&#x3D;&#x3D; 인터럽트 내부 동작 구조시스템 콜 인터럽트 시스템 콜은 인터럽트를 활용해야 함. 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어 cpu에 실행 시켜야 함 기계어로 컴파일 될 때 시스템 콜 코드가 삽입된다.123mov eax, 1 //eax레지스터에 시스템콜 번호 넣고mov ebx, 0 //ebx레지스터에는 시스템 콜에 해당하는 인자값 넣고int 0x80 //소프트웨어 인터럽트 명령 호출하면서 0x80값 넘겨준다. 시스템콜 인터럽트 명령이 호출되면서 0x80값을 넘겨주고, cpu는 사용자모드에서 커널 모드로 전환 IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행 인터럽트 번호에 맞는 주소(코드)를 적어놓은 테이블 ex) 0x80 : system.call() 찾은 system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동 system_call()에서 시스템 콜 번호에 따라 매칭 되는 함수를 찾아서 실행 시킴 해당 시스템 콜 실행 후, 다시 커널 모드를 사용자 모드로 전환, 해당 프로세스의 다음 코드 진행. 인터럽트와 IDT인터럽트는 미리 정의되어 각 번호와 실행 코드를 가리키는 주소가 기록되어 있다. where? : IDT(Interrupt Descriptor Table)에 기록해 놨다. when? : 컴퓨터 부팅시 운영체제가 기록한다. what? : 운영체제의 내부 코드를 기록한다. 인터럽트와 프로세스의 관계 프로세스 실행 중 인터럽트 발생 현 프로세스 실행 중단 인터럽트 처리 함수 실행(운영체제) 현 프로세스 재실행","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"12. 다이나믹 프로그래밍-2(행렬 곱셈 문제)","slug":"cs/algorithm/problem/al12","date":"2021-08-05T06:38:27.000Z","updated":"2022-01-22T16:20:00.025Z","comments":true,"path":"2021/08/05/cs/algorithm/problem/al12/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/problem/al12/","excerpt":"","text":"행렬 곱셈 문제 n개의 행렬 곱셈을 최소 비용으로 푸는 문제 만약 무지성으로 pXq , qXr 인 두 행렬을 3개 for루프로 풀면, O(pqr)번 연산이 필요하다.이때 여러개의 행렬이 주어졌을 때는, 행렬을 어느 순서로 곱하느냐에 따라 기본 연산 횟수가 달라진다.a &#x3D; 1x2, b&#x3D;2x3, c&#x3D;3x4 일때, (ab)c와 a(bc)의 차이는 1x2x3x1x3x4 vs 1x2x4x2x3x4 의 차이다. 그렇다면 어떤 곱셈을 먼저 해야 최소 비용으로 행렬의 곱셈을 구할 수 있을까? 우리는 다이나믹 프로그래밍으로 풀어보자.먼저 해의 성질은 분석해보자n개의 행렬이 있다고 했을 때,n개 곱셈비용은 어떤 행렬 i를 기점으로 곱셈 형식으로 된다.즉 (M1 x…x Mi) X (M(i+1) x…x Mn) 이런 식이 될 것이다. 그렇다면? 결국 Mn &#x3D; pn x qn 이라고 했을때행렬의 곱셈 원칙에 따라, M1&#x3D;p1 x p2, M2&#x3D;p2 x p3… 이런 식이 되고,{p1 x p(i+1)} x {p(i+1) x p(n+1)} 인 꼴이 된다. 점화식을 구현해보자즉 M1 ~ Mn까지 최소 비용 &#x3D; M1 ~ Mi 최소비용 + M(i+1) ~ Mn까지 최소비용 + 이 둘을 곱하는 비용{&#x3D;p1 * p(i+1) * p(n+1)}T(1,n) &#x3D; T(1,i)+T(i+1, n)+둘 곱하는 비용뭔가 점화식처럼 생겼다! 하지만 우리는 i가 어떤 수인지 모른다.. dp테이블을 구현해보자그려면 dp테이블을 사용해서 다 해보자!T에 두가지 수가 필요하므로, dp를 2차원 배열로 하여..dp[1][n] &#x3D; min(dp[1][i]+dp[i+1][n]+p1 * p(i+1) * p(n+1))으로 해서i&#x3D;1~n-1까지 대입해서 이 중 최소값을 찾으면 된다!!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Problem Solving","slug":"computer-science/algorithm/problem-solving","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/problem-solving/"}]},{"title":"11. 다이나믹 프로그래밍-1","slug":"cs/algorithm/theory/al11","date":"2021-08-05T05:08:48.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/05/cs/algorithm/theory/al11/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/theory/al11/","excerpt":"","text":"다이나믹 프로그래밍문제를 여러 작은 문제로 나누어 재귀적으로 해결하는 방법. divde and conquer와 차이점은? 큰 문제의 답이 작은 문제의 답들의 식으로 표현되지만,그 답을 얻을 때 재귀적으로 얻는게 아니라 미리 계산하여 기록해 놓은 값을 재귀 식에 따라 계산! 즉 원래 문제의 답을 작은 문제들의 재귀 식으로 표현하는 것이 핵심!!!!점화식을 찾아내고, 점화식에 필요한 값들만 중복 없이 리스트에 저장하여 문제를 해결하는 게 중요! 예를 들면, 계단 오르기 문제.한번에 계단을 하나 혹은 두개씩 오른다고 할 때n번째 계단에 오는 경우의 수는? k번째 계단에 오는 경우의 수 &#x3D; k-1번째 계단에 오는 경우의 수 + k-2번째 계단에 오는 경의의 수 이다. (k-1에서 한칸 오르거나 ,k-2에서 두칸 오르는 것의 합)즉 T(k) &#x3D; T(k-1)+T(k-2)인 점화식이 완성된다. T(1) &#x3D; 1, T(2) &#x3D; 2이므로, 이들을 리스트에 넣고, T(3) &#x3D; 3 을 구한 다음,T(2), T(3)을 리스트에 기록 후, T(4) &#x3D; 6을 구하고… 이런 식으로 T(n)까지 구해가는 게 다이나믹 프로그래밍이다! 최대 구간 합 문제랜덤한 n개의 수를 가진 배열이 주어지고, 이 배열에서 연속된 수의 합이 최대값을 구하라. divide &amp; conquer배열을 반으로 잘라서, 왼쪽, 오른쪽 혹은 가운데에서 최대값을 구함. 1234567891011121314151617181920def max_interval(A, l, r): if l &gt;= r : return A[l] m = (l+r)//2 L = max_interval(A, l, m) R = max_interval(A, m+1, r) #가운데 최대값 구하기 bigLeft =0 sumLeft =0 sumRight=0 bigRight=0 for i in range(m, l-1,-1): sumLeft+=A[i] if(sumLeft&gt;bigLeft): bigLeft=sumLeft for j in range(m+1, r+1, 1): sumRight+=A[j] if(sumRight&gt;bigRight): bigRight=sumRight M = bigRight+bigLeft return max(L, M, R) 이 방식은 T(n) &#x3D; 2T(n&#x2F;2)+ cn 이므로 ,O(n log n) 다이나믹 프로그래밍으로 풀기일단 다이나믹 프로그래밍을 풀기 위해 4가지 단계를 기억하자. 큰 문제를 작은 문제로 분할한다.(해를 분석하라는 의미!) 큰 문제의 해가 작은 문제 해 점화식으로 표현 dp테이블에 작은 문제의 해를 차근차근 저장 정확성을 증명. &#x3D;&#x3D;&#x3D; 이 네가지 단계로 최대 구간 합 문제를 풀어보자 A[k]로 끝나는 최대 구간의 값은? A[k] + A[k-1]로 끝나는 최대구간합!!즉 T(k) &#x3D; T(k-1)+A[k] 이제 dp테이블 S에 해를 저장해보자.S[k] &#x3D; max(S[k-1]+A[k], A[k])이고,S[0] &#x3D; A[0] 123456def max_interval_DP(A): S = [0] * len(A) S[0] = A[0] for k in range(1,n): S[k]=max(S[k-1]+A[k], A[k]) return max(S) 이 알고리즘은 O(n) 밖에 안된다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"10. Merge 정렬 알고리즘","slug":"cs/algorithm/theory/al10","date":"2021-08-05T04:05:18.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/08/05/cs/algorithm/theory/al10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/05/cs/algorithm/theory/al10/","excerpt":"","text":"Merge 정렬 알고리즘퀵 소트가 피벗을 어떻게 선택하냐에 따라 속도가 달라지는 단점을 상쇄하는 알고리즘 배열은 반으로 나눠 재귀적으로 정렬하고 정렬된 두 배열을 원소 하나씩 비교해서 병합하는 방식.주어진 배열만큼 새로운 배열을 사용해야 하기 때문에 not in-place 알고리즘이다. 먼저 중간 인덱스를 찾는다. 중간 인덱스를 기준으로 나눠서 두 배열을 재귀적으로 정렬한다. 정렬된 두 배열의 첫 요소부터 하나씩 서로 비교해서 더 작은 값은 새로 만든 배열에 추가한다. 추가된 요소의 배열은 다음 인덱스로 넘어가고, 다시 각 배열의 원소 하나와 비교한다. 어느 한쪽의 배열이 모두 비교될 때까지 반복한다. 어느 한쪽 배열이 모두 새 배열에 추가되고 나면, 다른 쪽의 배열을 다 새 배열에 추가한다. 원래 배열의 내용을 새 배열의 내용으로 덮어쓴다. 1234567891011121314151617181920212223def merge_sort(A, first, last): #1.~2. if first &gt;= last : return middle = (first+last)//2 merge_sort(A,first, middle) merge_sort(A, middle+1, last) #3.~5. B = [] i = first j = middle+1 while i &lt;= middle and j &lt;= last: if A[i] &lt;= A[j]: B.append(A[i]) i+=1 else: B.append(A[j]) j+=1 #6.~7. for i in range(i, middle+1): B.append(A[i]) for j in range(j, last+1): B.append(A[j]) for k in range(first, last+1): A[k] = B[k-first] 수행시간T(n) &#x3D; 2*T(n&#x2F;2) + cn &#x3D; O(n log n) 상황에 관계 없이 성립하므로, 퀵 소트보다 좋다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"7. 프로세스 상태와 스케줄러 알고리즘의 관계","slug":"cs/os/os7","date":"2021-08-04T08:19:51.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/08/04/cs/os/os7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/os/os7/","excerpt":"","text":"멀티 프로그래밍과 waitwait : 프로세스가 실행 중임에도 불구하고 cpu를 사용하지 않고 기다리는 시간멀티 프로그래밍은 wait 때문에 발생하는 비효율을 줄이는 스케쥴링 알고리즘!그렇다면 이렇게 효율적으로 하기 위해서는 어떻게 해야할까?어떤 시점에 어떤 프로세스를 실행시켜야 될지 판단해야 하는데.. 이때 중요한게 프로세스 상태다!프로세스 상태 running state : 현재 cpu의 실행하고 있는 상태 ready state : cpu 실행 가능 상태(대기 상태) block state : 특정 이벤트 발생 대기 상태(wait 상태) exit state : 프로세스가 활용한 리소스를 해제하고 종료하는 상태 특정 이벤트를 대기(block) 특정 이벤트를 확인후 준비 상태로 변환(ready) 스케쥴려가 해당 프로세스를 선택해 실행 상태로 전환(running) 특정 시간동안 실행하고 다른 프로세스를 실행시키기 위해 다시 준비 상태로 전환(ready) 하지면 여전히 CPU가 어떤 프로세스를 실행시켜야 할 때 상태 정보만으로는 부족하다! state queue 도입이를 위해 state queue를 도입한다.ready state queue, running state queue, block state queue를 만들어서 한 단위 시간에 많은 요청이 왔을 때, 이 요청들을 ready state queue에 넣고,그 중 먼저 하나를 빼와서 running state queue에 넣는다. 하지만 어떤 프로세스가 한 단위 시간에 다 끝나지 않는 경우가 있다.그렇다면 그 프로세스는 running 큐에 들어가고 나서 또 다시 ready 큐에 새롭게 삽입된다.(시식코너에서 한입하고 다시 줄서는 느낌..) 반면, running 도중, wait 상태에 들어간 프로세스는 block queue로 따로 빼서 관리한다.block에 있던 프로세스는 해당 wait이 끝나면, 다시 ready queue로 들어간다. 만약 프로세스들이 완료되거나, block 상태에 있다면, cpu는 ready queue에서 pop할 수 없다.이 상태를 cpu idle 상태라고 한다!. state queue 대신 우선순위 기반으로 할 경우 FIFO가 아닌 다른 방식(프로세스 간 우선순위에 따라)으로 진행될 수 있다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"9. Quick 정렬 알고리즘","slug":"cs/algorithm/theory/al9","date":"2021-08-04T06:10:36.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/04/cs/algorithm/theory/al9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/algorithm/theory/al9/","excerpt":"","text":"퀵 정렬 알고리즘이론적으로는 빠르지 않지만(O(n^2)), 실제로는 가장 빠른 정렬 알고리즘quick selection과 비슷한 원리임. not in-place quick sort algorithm 어떤 list A를 퀵 정렬 하려면… 피벗을 A[0]으로 잡고, S,M,L 세가지 배열을 선언함 A에 있는 모든 수들이 피벗보다 크면 L, 작으면 S, 같으면 M에 append &#x3D;&gt;n-1번 비교 재귀적으로, quickSort(S)+M+quickSort(L)을 반환하면 끝이다. 123456789def notInPlaceQuickSort(A): if len(A)&lt;=1: return A pivot = A[0] S, M, L = [], [], [] #1. for x in A:#2. if x&lt; pivot : S.append(x) elif x&gt;pivot: L.append(x) else M.append(x) return notInPlaceQuickSort(S)+M+notInPlaceQuickSort(L)#3. 실행 시간은 T(n)&#x3D; T(S)+T(L)+cn#여기서 cn은 n-1번 비교를 상수번 했다는 의미. 최악의 경우는 S, L 중 하나가 0이 되는것.T(n)&#x3D;T(n-1)+cn &#x3D; O(n^2) &#x3D;&gt; 이렇게 될 확률이 낮다! 최선의 경우는 S, L이 균등하게 나뉘는 것T(n) &#x3D; T(n&#x2F;2)+T(n&#x2F;2)+cn &#x3D; O(n*log n) &#x3D;&gt; 평균적으로 이렇게 시간이 걸림! 그런데, 지금 하는 방식은 배열을 복사해서 하는 방식. 즉 not in-place이다.in-place quick sort algorithm 다른 방식으로 구현해보자. 인수로 배열 A와, 퀵소트할 첫 인덱스와 끝 인덱스를 전달한다. quickSort(A, first, last) 새로운 배열을 사용하지 않고, A 안에서 분류하기 위해 left, right 변수를 도입한다. left는 가장 왼쪽 값(피벗을 제외한), right는 가장 오른쪽 값을 가르킨다. left, right &#x3D; first+1, last left가 가르키는 수가 피벗보다 더 작으면 다음 수로 넘어간다. right는 가르키는 수가 피벗보다 더 크면 이전 수로 넘어간다.(이때 같은 경우도 넘어간다.) 이제 두 변수가 멈췄고, left가 right보다 작거나 같다면 두 수가 가르키는 값을 바꾼다 이제 left가 right보다 클 때까지 다시 4-6번을 진행한다. 이제 first+1 ~ right은 S가 되고, left ~ last는 L이 된다. 이제 S와 L 사이에 피벗을 집어넣으면 SML 분리가 끝난다. 이제 S와 L을 재귀적으로 퀵소트하면된다. 12345678910111213141516171819def quickSort(A, first, last): #1.~3. if first &gt;= last : return left, right = first+1, last pivot = A[first] #4.~7. while left &lt;= right: #7. while left &lt;= last and A[left]&lt;pivot: #4. left +=1 while right &gt; first and A[right] &gt;=pivot: #5. right -=1 if left &lt;= right: #6. A[left], A[right] = A[right], A[left] left += 1 right -=1 #8.~10. A[first], A[right] = A[right], A[first] quickSort(A, first, right-1) quickSort(A, right+1, last)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"8. 기본 정렬 알고리즘","slug":"cs/algorithm/theory/al8","date":"2021-08-04T04:56:38.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/08/04/cs/algorithm/theory/al8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/04/cs/algorithm/theory/al8/","excerpt":"","text":"파이썬에서 제공하는 정렬 123A = [3,1,2,-5]A.sort() #[-5,1,2,3]A.sort(reverse = True) #[3,2,1,-5] 정렬 알고리즘의 두 가지 특성 stable vs unstable만약 [2,5,2,7]을 오름차 정렬했을 때 ,[2,2,5,7]로 정렬이 될 텐데, 이 두 개의 2가 입력 순으로 정렬되면 stable하다고 한다.(첫번째 2가 정렬해도 첫번째 2가 되는지) in-place vs not in-place상수 개의 변수를 사용하는지 여부를 말한다.추가 메모리 사용을 O(1) 사용하는 in-place 알고리즘이고, O(n)이면 not in-place이다. 정렬 알고리즘을 만들 때, stable &amp; in-place를 추구해야 한다. 간단하지만 느린 알고리즘 : 기본 알고리즘n-1번의 라운드를 통해 일일히 비교해 자리 바꾸는 방식의 알고리즘selection, bubble, insertion 이 있다. selection 매 라운드마다 정렬되지 않은 수 중 가장 큰 값을 찾는다. 그 값을 정렬되지 않은 수 중 가장 끝 수와 swap한다. 이 과정을 n-1번 한다. n*(n-1)&#x2F;2 비교 + (n-1) 교환 1234def selection_sort(A,n): for i in range(n-1, 0, -1): m = A.index(max(A[0:i+1])) #정렬되지 않은 수 중 가장 큰 값의 인덱스 A[i], A[m]=A[m], A[i] bubble 매 라운드마다 맨 뒤부터 두 개의 수를 비교하여, 앞 수가 뒷 수보다 크면 둘을 swap한다. 이 비교를 끝까지 하면, 가장 작은 수는 맨 앞으로 가게 된다. 이 과정을 n-1번 한다. n*(n-1)&#x2F;2 비교 + n*(n-1)&#x2F;2 교환 12345def bubble_sort(A,n): for i in range(n): for j in range(n-1, i, -1): if A[j-1] &gt; A[j]: A[j-1], A[j] = A[j], A[j-1] insertion 맨 처음에는 앞 두개를 비교해서 정렬한다. 그 다음 라운드부터는 다음 수와 앞에 정렬한 수들과 비교해서 해당 수가 들어가야할 자리를 찾아 사이에 넣는다. 이런식으로 하면 처음에는 2개의 수가 정렬, 그 다음엔 3개의 수, 4개의 수…. 이 과정을 n-1번 한다. n*(n-1)&#x2F;2 비교 + n*(n-1)&#x2F;2 교환 123456789def insertion_sort(A,n): for i in range(1,n): m=0 for j in range(i-1, -1, -1): if A[j]&lt;A[i]: m=j+1 break for k in range(i, m, -1): A[k], A[k-1] = A[k-1], A[k] 이 세 알고리즘 모두 O(n^2)!모두 in-place하고, selection만 unstable하다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"10. 최단경로 알고리즘(벨만포트, 다익스트라)","slug":"cs/datastructure/ds10","date":"2021-08-03T10:52:04.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/08/03/cs/datastructure/ds10/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/03/cs/datastructure/ds10/","excerpt":"","text":"최단 경로 알고리즘아주 중요한 그래프 문제.엣지에 가중치가 부여된 상황에서 특정 노드에서 다른 노드로 가는 최적의 경로를 찾는 문제. 특징 노드 s에서 v까지 최단 경로 중 엣지(u, v)가 포함되면, 이 경로에서 s부터 u까지 부분도 역시 최단 경로다.M(v)를 s에서 v까지 최단 경로라고 길이라고 하면,M(V) &#x3D; M(u)+min(u,v) 인 셈이다! (DP식과 비슷하다?) 벨만포드 알고리듬relax라는 연산을 배워보자. 아주 중요하다! d[v] : M[v]를 저장하기 위한 배열 (무한대로 초기화)p[v] : s-v최단 경로에서 v직전에 오는 노드를 저장하기 위한 배열 1234def relax(u,v): if d[v] &gt; d[u] + cost(u,v): d[v] = d[u] + cost(u,v) p[v] = u 모든 노드 v에 대해 d[v]가 최단경로(M[v])를 저장할 때까지 relax를 반복! 만약 d[u] &#x3D; M[u]일때, 엣지 (u, v)에 대해 relax 함수를 호출하면, d[v] &#x3D; M[v]가 된다! 이런 식으로 하나하나 relax 해가면 어떤 특정 노드까지 최단 경로를 찾을 수 있다! 벨만 포드 알고리즘 psuedo code 123456def Bellamn-Ford(G = (V, E)): d = [inf]*n, d[s]=0 for i in range(1,n): for each edge e = (u, v): #매번 엣지마다 relax(u,v) return d (n-1) * all edges…벨만포드는 O(nm)&#x3D;O(n^3)의 복잡도를 가진다. 다익스트라 알고리듬다익스트라 알고리즘에서는 현재까지 d[v]값 중 최소 값을 고르면 d[v] &#x3D; M(v)이다.(greedy)d[v]가 결정되고 나서 인접한 이웃노드들에게 relax하면 그들의 d값도 다 갱신될 수 있다! 모든 d[v] 중 최소 값이 매번 필요하므로, minHeap, 즉 최소값이 최상단노드가 되는 힙이 필요하다!minHeap에는 deleteMin과 decreaseKey 연산이 필요하다. deleteMin: 말 그대로 힙의 최상단 노드를 제거하고 다시 힙정렬하는 연산 decreaseKey : 힙의 어떤 노드의 키값을 변경(인하)하고 힙정렬하는 연산 다익스트라 알고리즘은 각 노드까지 최단 경로 중 가장 작은 값을 제거 가장 작은 값의 노드 이웃노드를 상대로 벨만 포트 식 진행 이웃 노드들의 값이 달라지면 반영.(물론 더 작아진 경우만 반영) 모든 노드가 힙에서 사라질 때까지 다시 1번부터 반복 psuedo code로 구현해보자. 123456789101112131415def Dijkstra(G): n, m = numbers of nodes and edges of G s = source node, simply 0 d = [0, inf, inf, ... inf] parent = [0, None, None, ... , None] H = make_heap(nodes v of G with key d[v]) while len(H): #heap에 아무것도 없을때까지. u = H.deleteMin() #heap의 최상위 노드, 즉 최소값 제거 for each v adjacent to u : #최소값 갖는 노드와 인접한 노드 v if(u, v) is an edge of G: if d[u]+cost(u,v)&lt; d[v] : #벨만포트 식! d[v] = d[u] + cost(u, v) parent[v] = u H.decreaseKey(v, d[v]) # 값을 수정시키고 힙의 위치 알맞게 조절 return dist, parent 다익스트라 알고리즘의 수행시간?make_heap : n* insertwhile loop : n * deleteMinfor loop : m * decreaseKey&#x3D;&gt; 어떤 힙을 쓰느냐에 따라 다르다! minHeap &#x3D; O((n+m)log n)!FibonacciHeap &#x3D; O(n log n + m) All to All shortest Path problem지금까지는 source to All 최단 경로를 구하는 알고리즘이었다. 이젠 모든 노드쌍에 대해 최단 노드를 구해보자. for each node s in V: Dijkstra(s) &#x3D; O(다익스트라 연산 * n)&#x3D; O(n * m * log n) &#x3D;O(n^3) DP 방법. Floyd-Warshell 알고리즘 Floyd Warshell 알고리즘sp(a, b) &#x3D; 노드 a, b의 최단 경로이고, d(a,b)는 해당 경로의 최단 경로 비용이라고 할 때, sp(i,j) &#x3D; sp(i,k) + sp(k,j) 이므로,d(i,j) &#x3D; d(i,k) + d(k,j)가 성립한다! &#x3D;&gt;DP식! px(a, b)를 px(a, b) &#x3D; p(x-1)(a, x)+p(x-1)(x, b)를 만족하는 중간 노드 값 x에 대한 식이라고 하면,pn(a, b) &#x3D; p(n-1)(a, n) + p(n-1)(n, b)즉 dn(a, b) &#x3D; d(n-1)(a, n) + d(n-1)(n, b) 혹은 d(n-1)(a,b). 이 두 값 중 최솟값이 되겟다. 이 식을 기반으로 n이 0일때, 1일때 dp테이블을 작성해 나아간다. 이를 간단하게 구현하는 과정을 설명하자면 d를 표현하기 위한 2차원 리스트(n*n)를 무한대로 초기화해서 선언 d 초기에는 만약 (i,j)가 엣지가 존재하면 d[i,j]를 해당 엣지 가중치로 할당 for k in range(1,n+1)로 4번을 루프 돌린다. 모든 (i,j)에 대해 d[i][j] &#x3D; min(d[i][j], d[i][k]+d[k][j]) 이 과정을 마치고 나면 (i,j)에 대해 최소 경로를 얻을 수 있다!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"9. 그래프","slug":"cs/datastructure/ds9","date":"2021-08-03T05:46:26.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/08/03/cs/datastructure/ds9/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/03/cs/datastructure/ds9/","excerpt":"","text":"그래프G &#x3D; (V, E)V &#x3D; vertex set, E &#x3D; edge set동그라미가 버택스(혹은 노드), 버택스를 잇는 링크를 엣지라 한다. degree(분지수) 어떤 노드의 이웃한 노드 갯수.어떤 그래프의 분지수는 그 그래프의 최대 분지수를 말한다. 인접하다는 의미는 두 노드가 링크로 서로 연결 되어있는 상태를 말한다. 경로는 노드를 중복하지 않고 지나가는 행위사이클은 노드를 중복하지 않고 출발점으로 다시 돌아오는 경로. 표현법인접행렬 : 노드 i 와 j에 엣지가 존재하면 G[i][j]&#x3D;1(혹은 가중치), 없으면 0인접 리스트 : 1차원 배열 G로 표현, 노드 i에 인접한 노드들은 G[i]에 연결리스트로 표현 노드 갯수 &#x3D; n, 엣지 갯수 &#x3D; m일 때, 인접행렬O(n^2)만큼 메모리 사용.탐색은 O(1)인접한 모든 노드를 보려할때 O(n) 이때 인접노드가 많던 적던 모두 찾음노드 삽입은 O(1)노드 삭제는 O(1) 인접리스트O(n+m)만큼 메모리 사용.탐색은 O(n)인접한 모든 노드를 보려할때 O(n) 이때 인접노드가 적으면 연산도 짧아짐.노드 삽입은 O(1)노드 삭제는 O(n) 대부분 인접행렬은 상수 시간에 연산을 완료한다. 메모리 측면은 인접리스트가 유리하다. 그래프 순회그래프에는 DFS(깊이 우선 탐색), BFS(너비 우선 탐색) 두가지 방법이 존재한다. DFS방문한 노드와 연결된 이웃 노드 중 아직 방문하지 않은 노드가 있으면 그 노드를 다음에 방문.만약 안가본 노드가 없다면 방문하기전 노드로 가서 다시 검사한다.재귀함수로 작성하는게 일반적. 이런 그래프에서 a부터 알파벳 순서가 빠른 노드부터 방문한다고 하면A-B-D-F-E-C-G pseudo code로 이해해보자 123456789101112131415def DFS(V): mark V as visited node #visited[V] = True pre[V] = curr_time #record the first visiting time curr_time +=1 for each edge(V, W): #for all neighbor node if w is unmarked: parent[W] = V DFS(W) post[V] = curr_time #V에서 DFS완료된 시간 curr_time+=1def DFSALL(G): for all nodes in G: mark[V]= unvisited for all nodes V: if mark[V]!=visited :DFS(V) pre는 해당 노드에 처음 방문한 시간, post는 해당 노드에서 DFS가 완료된 시각(모든 이웃을 이미 방문).parent 리스트를 활용해서 트리 모양으로 그래프를 표현할 수 있다. 재귀를 사용하지 않고 스택을 통해 구현할 수 있다. 12345678910def DFS(s): #s 부터 DFS시작. stack.push((None, s)) #(부모노드, 현재 방문노드) 튜플을 추가 while stack is not empty: p, v = stack.pop() if v in unmarked: mark[v]= visited parent[v] = p for each edge(v, W): if w is unmarked: stack.push((v,w)) 노드의 엣지가 방향성을 갖는 방향 그래프도 알아두자 BFSBFS는 루트노드-루트의 이웃 - 이웃의 이웃… 이런 식으로 level by level로 방문한다.queue 자료구조로 비재귀 코드로 작성하는게 일반적이다.이런 그래프에서 방문 순서는 다음과 같다(A)-(B-C-E)-(D-F-G) psuedo code로 보자 1234567891011121314151617def BFS(G = (V,E)): #node 0에서 시작. #n은 노드의 갯수 visited = [False]*n parent = [-1]*n dist = [0]*n Q = Queue() for all source node s in G: Q.enqueue(s) while Q is not empty: v = Q.dequeue() #dequeue는 방문을 의미 visited[v] = True for each edge v.neighbor w: if no visited[w]: Q.enqueue(w) parent[w] = v dist[w] = dist[v] +1 출발 노드에서 다른 노드 v까지의 최단 경로 길이는 dist[v]에 저장.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"8. 균형이진탐색트리","slug":"cs/datastructure/ds8","date":"2021-08-02T12:09:55.000Z","updated":"2022-01-22T16:20:00.029Z","comments":true,"path":"2021/08/02/cs/datastructure/ds8/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/02/cs/datastructure/ds8/","excerpt":"","text":"균형이진탐색트로(BST)?이진트리는 search, insert, delete 연산들이 O(h) 시간이 걸린다는 걸 기억하자. 즉 이 연산들을 효율적으로 하려면 트리의 높이를 최소화해야 한다.이진트리에서 빼곡히 노드를 채워넣어 높이를 최소로 하면 대략 log n 정도가 되는데,균형이진탐색트리는 노드를 최대한 채워넣어 높이를 log n이 되도록 유지하는 자료구조다! 트리의 높이를 최소화하는 rotation 회전 연산 한쪽의 서브트리가 지나치게 아래로 치우쳐져있으면,해당 서브트리에서 반대쪽 서브트리로 회전을 시켜서 전체 트리 높이를 낮춘다. 12345678910111213141516171819202122def rotateRight(self, z): # left도 가능, z가 최상위 노드 x가 올라가는 노드 if not z = return x = z.left if x == None:return #이런 경우, left로 회전해야... b = x.right x.parent = z.parent #x를 맨위 노드로... if z.parent: #만약 z의 부모가 존재하면 부모와의 관계를 x로 다 바꿈 if z.parent.left == z: z.parent.left = x else: z.parent.right = x if x: x.right = z #최상위 노드가 x가 됐으니, 이제 z와 x의 관계를 설정 z.parent = x z.left = b #x의 오른쪽 서브트리가 z의 왼쪽 서브트리가 됨 if b : b.parent = z #b와 z의 관계를 새롭게 설정 #만약 z가 루트노드인 경우. if z == self.root and z != None: sefl.root = x AVL 트리균형이진트리의 일종. 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1 이하인 이진탐색트리 AVL 트리에서 삽입&#x2F;삭제하면, 서브트리 높이 차가 1보다 커지는 경우 발생 가능.. 이럴 경우, 회전연산을 통해 높이를 다시 맞춰야 함.(rebalance) AVL은 BST의 일종이므로, BST의 Node 클래스에 height를 추가한 노드 클래스를 사용한다. class AVL(BST): #상속 def insert(self,key): v = super(AVL, self).insert(key) # BST클래스의 insert 함수 호출 삽입 insert(key) v &#x3D; super(AVL, self).insert(key) 로 BST에서 정의한 insert를 실행 삽입연산에 따라 균형이진탐색트리의 균형이 무너졌을 경우, 삽입 위치부터 올라가며, 무너진 곳을 순서대로, x y z로 함. 트리의 균형을 맞추는 rebalance연산을 실행하고 원래 z의 자리에 올 노드를 w로 하자. rebalance 연산은 x y z의 형태에 따라 달라짐. 만약 w가 루트노드라면, self.root&#x3D;w을 해주자. 결과적으로 O(log n)이다. 삭제 delete(u) v &#x3D; super(AVL, self).deleteByCopying(u) 이때 삭제연산은 삭제하고 나서 삭제된 노드의 부모를 반환한다. v가 None이 될 때까지 루프. 만약 v가 균형이 깨지지 않았다면, v의 부모노드가 v가 된다. 만약 v가 균형이 깨진다면, v 위치 노드를 z로 하고, z의 자식 중, 깊이가 더 큰 쪽 노드를 y, y의 자식 중 깊이가 더 큰 쪽 노드를 x라 한다. 이제 rebalance 연산을 한다. x&lt;\\y&lt;\\z 일 경우 로테이션 한번, x&gt;y&amp;&amp;z&gt;y일 경우 로테이션 두번 한다. 6. 로테이션 후, 원래 z의 위치에 오는 노드를 v라 한다.7. 이제 v의 트리는 균형을 성공했지만, v의 부모 노드로 가서 동일한 과정을 해야 한다.8. w &#x3D; v, v&#x3D;v.parent로 하여 w는 v의 자식 노드가 되고, v는 위쪽으로 한칸 가서 동일한 작업을 한다. 결과적으로 최약의 경우에는 회전연산(상수시간)을 log n번 하게 되어, O(log n)이다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"병렬 데이터 처리와 성능","slug":"java/java-basic/modern-java-in-action/modern7","date":"2021-08-01T05:43:01.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/08/01/java/java-basic/modern-java-in-action/modern7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/08/01/java/java-basic/modern-java-in-action/modern7/","excerpt":"","text":"병렬 스트림컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다. 예시만약 n을 입력받아 1부터 n까지 합계를 구하는 메서드를 구현한다고 하자. 12345678910111213public long sequentialSum(long n)&#123; return Stream.iterate(1L, i-&gt;i+1) .limit(n) .reduce(0L, Long::sum);&#125;//이걸 병렬로 처리하려면? 아주 간단하다!!!!!public long parrallelSum(long n)&#123; return Stream.iterate(1L, i -&gt; i+1) .limit(n) .parallel() //병렬 스트림!! .reduce(0L, Long::sum);&#125; parallel메서드는 순차 스트림을 병렬 스트림으로 만들고,sequential메서드는 병렬 스트림을 순차 스트림으로 만든다. 근데 이 두 메서드는 마지막으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.파이프라인에 parallel, sequential parallel 이렇게 마구잡이로 써도, 결국 가장 마지막에 나온 메서드가 병렬&#x2F;순차를 결정한다. 하지만 병렬 스트림을 사용한다고 무조건 성능이 좋을까? 병렬 스트림이 오히려 순차 스트림보다 성능이 별로 좋아지지 않는 경우가 있다.위 예시도 실제로 돌려보면, 일반적인 반복문 버전, 순차적 스트림 버전, 병렬 스트림 버전 이렇게 세가지를 비교하면,반복문이 제일 빠르고, 순차적 스트림, 병렬 스트림 순이다. 왜 그럴까?일반적 반복문은 저수준으로 동작하고, 기본값을 박싱언박싱을 할 필요가 없어서 더 빠르다.그렇다면 같은 스트림이더라도 왜 병렬이 더 느렸는가? 이는 두가지로 요약된다. 반복 결과로 박싱된 객체가 만들어지는데, 숫자를 더하려면 매번 언박싱을 해야함. 반복 잡업은 병렬로 수행할 수 있는 독립 단위로 나누기 어렵다. 즉 해당 연산을 할 스트림 요소가 얼마나 되는지 컴퓨터는 모르니, 이를 청크로 나눌 수 없다는 의미다. 더 특화된 메서드 사용예를 들어 LongStream.rangeClosed 메서드를 사용하면 iterate 메서드에 비해 두가지 장점을 가진다. 기본형 long을 사용하므로 박싱언박싱 오버헤드가 사라짐. rangeClosed는 쉽게 청크로 분할할 수 있는 숫자 범위 제공한다. 즉 이런 예시를 보면 알 수 있듯이, 병렬화는 공짜가 아니다!효과적인 병렬화를 이뤄낼려면, 스트림을 재귀적으로 분할해야 하고, 각 서브 스트림을 서로 다른 스레드 리듀싱 연산으로 할당하고, 이 결과를 하나의 값으로 합쳐야 한다. 게다가 코어 간 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 설계해야 한다. 병렬 스트림의 올바른 사용법자 일단 기존의 방식대로 명령형 프로그래밍 방식으로, n까지 자연수를 더하면서 공유된 누적자를 바꾸는 프로그램이다. 12345678910public long sideEffectSum(long n)&#123; Accumulator accumulator = new Accumulator(); LongStream.rangeClosed(1, n).forEach(accumulator::add); return accumulator.total;&#125;public class Accumulator&#123; public long total = 0; public void add(long value)&#123; total += value;&#125;&#125; 위 코드를 병렬적으로 처리한다면, 큰일난다.공유된 total 변수에 다수의 스레드가 동시에 데이터에 접근하는 데이터 레이스 문제가 발생할 수 있다.즉 병렬 스트림과 병렬 계산을 사용할 때는 공유된 가변 상태를 피해야 한다. 올바른 병렬 스트림을 위한 지침 박싱을 주의하라(자바 8부터 제공하는 IntStream, LongStream, DoubleStream을 애용하자.) 요소의 순서에 의존하는 연산은 병렬 스트림이 효과적이지 않다.(limit, findFirst 등.. 요소가 상관없다면 unordered로 비정렬 스트림으로 하자) 만약 한 요소 당 연산 비용이 높아지면, 병렬 스트림이 효과적이다. 소량 데이터는 병렬 스트림이 효과보기 힘들다. 스트림을 구성하는 자료구조가 적잘한지 확인하라.(모든 요소를 손쉽게 파악할 수 있는 ArrayList가 LinkedList보다 유리하다.) 스트림의 특성과 중간 연산에 따라 분해 과정 성능이 달라진다.(중간연산에서 스트림을 분해하는 경우, 병렬처리가 더 손쉬워진다.) 최종 연산의 병합 과정 비용이 높으면, 병렬 스트림에서 얻은 이익이 각 서브스트림의 최종 연산 병합에서 상쇄된다. 포크&#x2F;조인 프레임워크포크&#x2F;조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음,서브 태스크 결과를 합쳐서 전체 결과를 만들도록 설계됐다.서브태스크를 스레드 풀의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"인스턴스 생성과 힙 메모리","slug":"java/java-basic/java2","date":"2021-07-30T11:24:44.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/07/30/java/java-basic/java2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/java2/","excerpt":"","text":"인스턴스클래스는 객체의 속성을 정의하고 기능을 구현하여 만들어놓은 코드 상태. 이 클래스를 기반으로 new 키워드를 사용하여 인스턴스를 생성. 힙 메모리생성된 인스턴스는 **동적 메모리(heap memory)**에 할당된다. c&#x2F;cpp에서는 프로그래머가 직접 사용한 메모리를 해제해줘야 하지만 자바는 garbage collector가 주기적으로 사용하지 않는 메모리를 수거 스택에서 지역변수로 선언된 레퍼런스(참조변수)가 new 키워드를 사용하면 힙에 인스턴스가 할당되고, 레퍼런스가 인스턴스를 가리키게 된다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"함수와 메서드","slug":"java/java-basic/java1","date":"2021-07-30T10:41:02.000Z","updated":"2022-01-22T16:20:00.034Z","comments":true,"path":"2021/07/30/java/java-basic/java1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/java1/","excerpt":"","text":"함수 호출과 메모리1234567891011public static int add(int num1, int num2)&#123; int result; result = num1 + num2; return result;&#125;public static void main(String[] args)&#123; int n1 = 20; int n2 = 10; int total = add(n1, n2);&#125; 이런 식으로 코드가 짜여 있을 때, 스택 메모리에는 어떤 일이 생길까?? 일단 스택 메모리에 main함수가 놓이게 된다.그러면 main함수의 지역변수 n1,n2,total이 놓이게 되는데, 이때 add함수가 호출된다. add함수가 호출되면, main 함수 위에 add함수가 놓이게 되어 add 함수의 지역변수가 호출된다.(num1, num2, result) 스택 메모리이므로 나중에 들어온 add함수를 먼저 해결하고, main함수로 돌아가 마저 마무리하게 된다. 함수와 메서드의 차이?함수는 어디에 속하지 않은 함수. 메서드는 클래스에 속한 함수로 생각하자.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}],"tags":[],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"},{"name":"Java Basic","slug":"java/java-basic","permalink":"https://yangdongjue5510.github.io/categories/java/java-basic/"}]},{"title":"web 개론","slug":"cs/web/web1","date":"2021-07-30T06:02:27.000Z","updated":"2022-01-22T16:20:00.036Z","comments":true,"path":"2021/07/30/cs/web/web1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/web/web1/","excerpt":"","text":"웹의 기본 3가지 요소 URI Uniform Resource Identifier. 리소스 식별자다양한 정보에 접근할 수 있는 정보 HTTP Hypertext Transfer Protocol어플리케이션 컨트롤GET, POST, PUT… HTMLHyper Text Markup LanguageXML 바탕으로 한 범용 문서 포맷.브라우저가 사용자가 볼 수 있는 형태로 표현. REST(자원의 상태 전달) - 네트워크 아키텍처 Client, Server : 클라이언트와 서버가 서로 독립적이고 분리 Stateless : 요청에 대해서 클라이언트의 상태를 서버에 저장하지 않음 Cache : 클라이언트는 서버 응답을 임시저장(cache로)할 수 있어야 함.클라이언트가 캐시를 통해 응답 재사용이 가능해야 하고, 이를 통해 서버 부하를 낮춰야 함 계층화 : 서버와 클라이언트 사이에, 방화벽, 게이트웨이, 프록시 등 다양한 계층 형태로 구성되어야 함. 인터페이스 일관성 : 인터페이스가 일관성 있어야 하고, 아키텍처를 단순화시켜 작은 단위로 분리하여 클라이언트, 서버가 독립적으로 개선할 수 있어야 한다. Code on Demand(optional) : 특정한 기능을 서버로부터 클라이언트가 받아 코드를 실행할 수 있어야 한다. 인터페이스의 일관성을 잘 지켰느냐에 따라 REST를 준수했는지 판단 자원 식별리소스에 접근할 때 사용되는 URI에 자원을 식별하는 내용이 있어야 한다. 메시지를 통한 리소스 조작리소스를 조작할 때, 데이터 전체를 전달하지 않고, 메시지로 전달해야 한다. 자기 서술적 메시지요청하는 데이터가 어떻게 처리되야하는지 충분한 내용을 드러내야한다. 애플리케이션 상태에 대한 엔진으로써 하이퍼미디어REST API를 개발할 때 단순히 클라이언트 요청에 대한 데이터만 응답하는게 아닌, 관련된 리소스에 대한 링크 정보도 같이 포함해야 한다. URI URI vs URLIdentifier vs LocatorURI : 인터넷 특정 자원을 나타내는 주소 값. 해당 값은 유일(응답은 달라질 수 있음)URL : 인터넷 상에서의 자원, 특정 파일이 어디에 위치하는지 식별하는 주소URL은 URI의 하위 개념 URI 설계 원칙(RFC-3986) 슬래시 구분자(&#x2F;)는 계층 관계를 나타날 때 사용 URI 마지막 문자로 슬래스를 포함하지 않음 하이픈(-)은 가독성을 위해 사용 밑줄(_)은 사용하지 않음. 세션 ID를 포함하지 않음 메소드 명을 이용하지 않음 단수형보다 복수형 사용 컨트롤러 이름으로는 동사를 사용 경로 부분 중 변하는 부분은 유일한 값을 대체 CRUD 기능을 나타내는 것은 URI에 사용하지 않는다. URI Query Parameter 디자인(컬렉션의 결과 필터링 등) 서브 도메인은 일관성 있게 사용 클라이언트 개발자 포탈 서브 도메인을 일관성 있게 만듬 HTTP Protocolweb에서 데이터를 주고 받는 프로토콜.하이퍼텍스트 전송용 프로토콜로 정의되어 있지만 실제로는 JSON, XML, Image 등 여러 가지를 전송!TCP 기반으로 한 REST 특징을 모두 구현한 web기반 프로토콜! HTTP는 요청을 주고 받는 (Request, Response) 형태의 통신 방법! HTTP 메소드&nbsp;의미CRUD멱등성(몇번을 요청해도 같은 응답)안정성Path VariableQuery ParameterDataBodyGET리소스 취득RooooxPOST리소스 생성, 취득Cxxo?oPUT리소스 갱신, 생성C / Uoxo?oDELETE리소스 삭제DoxooxHEAD해더 데이터 취득&nbsp;oo&nbsp;&nbsp;&nbsp;OPTIONS지원하는 메소드 취득&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;TRACE요청메시지 반환&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;CONNECT프록시 동작이 터널 접속으로 변경&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *멱등성(여러번 요청한 값이 한번 요청한 값과 같음), 안정성(요청할 때 리소스에 영향을 주지 않음)","categories":[],"tags":[],"keywords":[]},{"title":"6. 스케쥴링 알고리즘의 기본","slug":"cs/os/os6","date":"2021-07-30T05:59:10.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/30/cs/os/os6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/os/os6/","excerpt":"","text":"프로세스란?메모리에 올려져 실행 중인 프로그램은 프로세스라고 한다.프로세스는 작업, task, job과 혼용되어 사용한다. 하지만 응용프로그램 !&#x3D; 프로세스다.왜냐면, 한 응용프로그램에 여러 개의 프로세스로 이뤄져있을 수 있기 때문! 스케쥴러스케줄러는 프로세스 실행을 관리하는 녀석. RTOS(RealTime OS) 응용 프로그램 실시간 성능 보장을 목표로 한 OS 정확하게 프로그램 시작, 완료 시간을 보장! 공장, 공정 같은 곳에서 사용. GPOS(General Purpose OS) 프로그램 실행시간에 민감하지 않음. 일반적인 목적으로 사용됨 스케쥴링 알고리즘어느 순서대로 프로세스를 실행시킬지 정하는 알고리즘 시분할 시스템 : 프로세스 응답 시간을 가능한 짧게 멀티 프로그래밍 : CPU 활용도를 최대한 높여서 프로세스를 빨리 실행 CPU를 처음부터 끝까지 사용을 가정. (저장매체를 읽는다던지, 프린팅한다던지 작업 없이) FIFO 스케쥴러 가장 간단한 스케쥴러(배치 처리 시스템) 먼저 들어온 프로세스를 먼저 실행 큐 자료구조를 활용해서 구현 최단 작업 우선(SJF) 알고리즘 Shortest Job First 프로세스 실행시간이 짧은 프로세스 먼저 실행시키는 알고리즘 우선순위 기반 스케쥴러(Priority-Based) 정적 우선순위(프로세스마다 우선순위를 미리 지정) 동적 우선순위(스케줄러가 상황에 따라 우선순위를 동적으로 변경) Round Robin 스케쥴러 시간 단위마다 각 프로세스마다 돌아가면서 프로세스를 실행시키는 방법(시분할 시스템 기반) 자기 차례 이후에도 작업이 더 필요한 프로세스는 RoundRobin queue에 들어가 다시 자기차례가 오기를 기다린다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"5. 배치 처리, 멀티 태스킹, 멀티 프로세싱, 멀티 프로그래밍","slug":"cs/os/os5","date":"2021-07-30T04:41:36.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/30/cs/os/os5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/cs/os/os5/","excerpt":"","text":"프로세스 스케줄링배치 처리배치 처리는 어플리케이션을 순차적으로 처리하는 방식이다. 마치 큐처럼 FIFO방식을 준수한다. 단점어떤 프로그램은 실행이 너무 오래 걸려서, 다른 프로그램이 실행될 때까지 많이 기다려야 하는 경우가 존재.동시에 여러 작업이 불가능하다.(동시성)여러 사용자가 한 컴퓨터를 사용할 때 비효율적이다.(다중 사용자 지원) 이런 단점을 극복하고자 멀티 프로그래밍, 시분할 시스템이 등장하게 된다. 시분할 시스템시간을 작은 단위로 쪼개서 프로그램마다 돌아가면서 할당받는 시스템.여러 사용자들이 한 컴퓨터를 사용을 원할하게 하는 시스템. 멀티 태스킹단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템.굉장히 짧은 시간마다 여러 응용프로그램이 돌아가면서 실행되서 사용자는 이를 눈치채지 못한다. 멀티 프로세싱멀티 태스킹 : 단일 cpu, 멀티 프로세싱 : 여러 cpu에서 하나의 응용 프로그램을 병렬로 실행 멀티 프로그래밍최대한 cpu를 일정 시간 당 많이 활용하도록 하는 시스템 시간 대비 cpu 활용도 향상 응용 프로그램을 짧은 시간안에 완료 가능! 응용 프로그램은 온전히 cpu를 쓰기보다, 다른 작업을 중간에 필요로 하는 경우가 많다 파일을 읽을 때 프린팅 할 때 핵심 여러 응용 프로그램 실행을 가능토록 함 응용 프로그램이 동시에 실행되는 것처럼 보이게 함 cpu를 쉬지 않고 응용 프로그램을 실행하게 함(짧은 시간에 실행 완료시킴) 컴퓨터 응답 시간도 짧게 해줘서 다중 사용자 지원함","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"스트림으로 데이터 수집","slug":"java/java-basic/modern-java-in-action/modern6","date":"2021-07-30T00:49:07.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern6/","excerpt":"","text":"컬렉터란 무엇인가?일단 예시를 하나 보자. 123456789101112131415//통화별로 트랜잭션을 그룹화한 코드(명령형 버전)Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = new HashMap&lt;&gt;();for (Transaction transaction : transactions)&#123; Currency currency = transaction.getCurrency(); List&lt;Transaction&gt; transactionsForCurrency = transactionsByCurrencies.get(currency); if (transactionsForCurrency == null)&#123; transactionsForCurrency = new ArrayList&lt;&gt;(); transactionsByCurrencies.put(currency, transactionForCurrency); &#125; transactionsForCurrency.add(transaction);&#125;//함수형 버전Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream().collect(groupingby(Transaction::getCurrency)); 딱봐도 함수형 프로그래밍이 훨씬 쉽다.위 예제에서 collect 메서드로 Collector 인터페이스 구현을 전달했다.Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다. 컬렉터는 고급 리듀싱 기능을 수행한다. 스트림에 collect를 호출하면, 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행된다.collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다. 미리 정의된 컬렉터Collectors 클래스에서 미리 정의된 팩터리 메서드의 기능은 크게 세가지로 분류된다. 스트림 요소를 하나의 값으로 리듀스하고 요약. 요소 그룹화 요소 분할 이 세가지에 대해 더 알아보자. 리듀싱과 요약컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있었다.하나의 결과란 복잡한 다수준 그룹화 맵 일 수도, 그냥 평범한 정수 형태 일 수도 있다. counting()이란 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산해보자 123long howManyDishes = menu.stream().collect(Collectors.counting());//불필요한 과정을 제외하면,long howManyDishes = menu.stream().count() 요약 연산스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산을 요약 연산이라 부른다.물론 요약 연산에도 리듀싱 기능이 자주 사용된다. Collectors 클래스는 Collectors.summingInt라는 요약 팩토리 메서드를 제공한다.summingInt 인수로 전달된 함수는 객체를 int로 매핑하는 함수를 인수로 받는다.int로 매핑한 컬렉터를 collet 메서드에 전달되면, 요약 작업을 수행한다. 1int totalCalories = menu.stream().collect(summingInt(Dish::getCalories)); 이런 역할은 summingInt 뿐만 아니라,summingLong, summingDouble 등이 있다.합계를 구하는 과정 말고, 평균을 구하는 averagingInt도 가능하다 두 개 이상의 연산을 해야 되면..? summarizingInt가 반환하는 내용을 사용하면 된다!하나의 요약 연산으로 여러가지 연산값을 얻을 수 있다! 123IntSummaryStatics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));//출력 시.IntSummaryStatics&#123;count =9, sum = 4300, min=120, average=477.777778, max=800&#125; 문자열 연결컬렉터에 joining 팩터리 메서드를 사용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 만든다.joining 메서는 내부적으로 StringBuilder를 이용해 문자열을 하나로 만든다. 12345String shortMenu = menu.stream().map(Dish::getName).collect(joining());//만약 스트림 객체가 toString이 요구 대로 정의되어 있다면?String shortMenu = menu.stream().collect(joining());//문자열 사이에 쉼표를 넣어줄 수도 있다.String shortMenu = menu.stream().collect(joining(&quot;, &quot;)); collect와 reduce의 차이? 둘 다 비슷한 결과를 만들 수 있어서 어떤 것을 사용해야하는지 헷갈린다.collect 메서드는 결과를 누적하는 컨테이너로 바꾸도록 설계된 메서드이고,reduce는 두 값을 하나로 도출하는 불변형 연산이다! 그룹화분류 함수인 groupingBy 메서드를 활용해보자. 12Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType)); Dish 클래스의 Type을 키로 키에 맞는 스트림 요소들을 map에 담아 반환했다. 하지만 여러 가지 기준으로 그룹화하려면 어떨까..? 그룹화된 요소 조작고기, 생선, 그 외 음식들로 분류하고, 500칼로리가 넘는 음식을 얻으려면 어떻게 해야 할까? 123Map&lt;Dish, Type, List&lt;Dish&gt;&gt; caloricDishesByType = menu.stream().filter(dish-&gt;dish.getCalories() &gt; 500) .collect(groupingBy(Dish::getType)); 이 방식에는 치명적인 문제가 있다. 만약 생선류에 500칼로리가 넘는 음식이 없으면 아예 그 키를 없앤다는거다.출력하면 {OTHER&#x3D;[french fries, pizza], MEAT&#x3D;[pork, beef]}가 출력된다. groupingBy는 두번째 인수로 Collector를 가질 수 있도록 만들어 이를 해결한다.두번째 Collector 안에 필터 프레디케이트를 넣으면 된다.Collectors의 정적 팩토리 메서드 filtering메소드는 프레디케이트를 인수로 받아 리스트로 만든다. 1234Map&lt;Dish.Type, List&lt;Dish&gt;&gt; caloricDishesByType = menu.stream() .collect(groupingBy(Dish::getType, filtering(dish-&gt;dish.getCalories()&gt;500, toList()))); mapping메소드 사용 예시도 보자 123Map&lt;Dish.Type, List&lt;String&gt;&gt; dishNameByType = menu.stream() .collect(groupBy(Dish::getType, mapping(Dish::getName, toList()))); 이러면 이름을 기반으로 한 맵이 반환될 것이다. flatmapping메소드 사용 예시도 보자dishTags가 음식이름, 관련 문자열 리스트로 매핑된 맵이라고 했을 때, 1234Map&lt;Dish.Type, Set&lt;String&gt;&gt; dishNamesByType = menu.stream() .collect(groupingBy(Dish::getType, flatMapping(dish -&gt; dishTags.get(dish.getName().stream(),toSet())))); groupingBy 여러개를 연결해서 다수준 그룹화 123456789101112Map&lt;Dish.Type, Map&lt;Caloriclevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish-&gt;&#123; if (dish.getCalories()&lt;=400)s return CaloricLevel.DIET; else if(dish.getCalories()&lt;=700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;) )); 종류로 그룹화 칼로리로 DIET, NORMAL, FAT으로 그룹화이 과정을 버킷 개념으로 생각하면 편한다. 첫 그룹화로 한 버킷에 육류 음식들이 담기고, 그 버킷을 또 칼로리별로 여러 버킷으로 나눠 담았다! 분할분할은 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능.이런 분류 함수는 분할 함수라고 하는데, 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean이다.즉 분할 그룹화는 최대 두 개 그룹으로 나뉜다. 123Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(true); 분할은 참 거짓 두가지 요소 스트림 리스트를 모두 유지한다는 장점이 있다. 1234Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = menu.stream().collect( partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"다양한 형태의 스트림 만들기","slug":"java/java-basic/modern-java-in-action/modern5","date":"2021-07-30T00:39:50.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern5/","excerpt":"","text":"숫자형 스트림reduce 메서드로 스트림 요소의 합을 구하는 사례를 보자 123int calories = menu.stream() .map(Dish::getCalories) .reduce(0, Integer::sum); 이런 경우, reduce에 박싱비용이 포함되어 있다. 합계를 계산하기 전에 Integer를 기본형으로 언박싱해야한다. 기본형 특화 스트림자바에서는 이런 박싱 비용을 피할 수 있도록 세 가지 기본형 특화 스트림을 제공한다. int 특화 IntStream double 특화 DoubleStream long 특화 LongStream 이런 특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련 있으며, 스트림에 추가 기능을 제공하지는 않는다. 숫자 스트림으로 매핑스트림을 특화 스트림으로 변환할 때는 mapToInt, mapToDouble, mapToLong 세가지 메서드를 주로 사용한다.이 메서드들은 기존의 map과 동일한 기능이지만, Stream 대신 특화된 스트림을 반환한다. 123int calories = menu.stream() .mapToInt(Dish::getCalories) .sum(); mapToInt 메서드가 각 요리에서 모든 칼로리를 추출하고(Integer), IntStream을 반환한다.따라서 IntStream이 제공하는 sum메소드를 활용할 수 있다. 숫자 스트림을 객체 스트림으로 복원하기숫자 스트림은 기본형의 값만 만들 수 있다. 만약 다른 값을 반환하려면 어떻게 해야 할까?boxed 메서드를 활용하면 특화 스트림을 일반 스트림으로 변환할 수 있다. 12IntStream intStream = menu.stream().mapToInt(Dish::getCalories);Stream&lt;Integer&gt; stream = intStream.boxed(); 기본값 : OptionalInt숫자 스트림에서 해당 조건에 만족하는 요소가 없는 경우와, 해당 조건에 맞는 요소가 0인 경우, 둘 다 0을 반환해서 혼동이 올 수 있다.그렇다면 이 두 가지 경우를 어떻게 해야 구분할 수 있을까? 바로 OptionalInt, OptionalDouble, OptionalLong으로 가능하다. 123OptionalInt maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max(); 이제 조건에 맞는 값이 없는 경우와 0이 반환되는 요소가 서로 구별 가능하므로 다음과 같은 기본값도 명시할 수 있다. 1int max = maxCalories.orElse(1); 숫자 범위 정하기 스트림에서 특정 범위의 숫자를 사용해야 되는 상황에서는 어떻게 해야 할까? IntStream과 LongStream에서는 range와 rangeClosed 두가지 정적 메서드를 제공한다.두 메서드 모두 첫 인수는 시작값, 두번째 인수는 종료값을 갖는다.range는 시작값과 종료값이 범위에 포함되지 않고,rangeClosed는 시작값과 종료값이 범위에 포함된다. 123IntStream evenNumbers = IntStream.rangeClosed(1, 100) .filter(n-&gt;n%2==0);System.out.println(evenNumbers.count()); 이 예시는 1~100까지 한정한 상황에서 필터로 짝수만 찾아 출력한 코드이다. 스트림 만들기컬렉션이나 숫자 뿐만 아니라 다양한 방식으로 스트림을 만들 수 있다.배열, 파일, 함수를 이용한 스트림을 알아보자 값으로 스트림 만들기 임의의 수들을 인수로 받는 정적 메서드 Stream.of를 이용해 스트림을 만들수 있다. 12Stream&lt;String&gt; stream = Stream.of(&quot;Modern&quot;, &quot;Java&quot;, &quot;Action&quot;);stream.map(String::toUpperCase).forEach(System.out::println); 또한 empty 메서드로 스트림을 비우거나 빈 스트림을 만들 수 있다. 1Stream&lt;String&gt; emptyStream = Stream.empty(); null이 될 수 있는 객체로 스트림 만들기 null을 가질 수 있는 객체는 null일 경우를 검사해서 빈 스트림을 반환해야 한다. 기존의 방식으로 null을 검사하면 다음과 같다 12String homeValue = System.getProperty(&quot;home&quot;);Stream&lt;String&gt; homeValueStream = homeValue == null ? Stream.empty() : Stream.of(value); 하지만 자바 9에서 지원하는 Stream.ofNullable을 이용해 다음과 같이 구현할 수 있다! 1Stream&lt;String&gt; homeValueStream = Stream.ofNullable(System.getProperty(&quot;home&quot;); flatMap과 사용하면 다음과 같은 코드도 가능하다! 12Stream.of(&quot;config&quot;, &quot;home&quot;, &quot;user&quot;) .flatMap(key-&gt;Stream.ofNullable(System.getProperty(key))); 배열로 스트림 만들기 정적 메서드 Arrays.stream를 통해 숫자 스트림이나 일반 스트림을 만들어낼 수 있다. 12int[] numbers = &#123;2,3,4,5,6&#125;;int sum = Arrays.stream(numbers).sum(); 파일로 스트림 만들기 java.nio.file.Files 의 많은 정적 메서드가 스트림을 반환한다. 123456789long uniqueWords = 0; try(Stream lines = Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset()))&#123; uniqueWords = lines.flatMap(line-&gt;Arrays.stream(line.split(&quot; &quot;))) .distinct() .count();&#125;catch(IOException e)&#123; //예외처리&#125; 위 예시에서 File.lines로 파일의 각 행 요소를 반환하는 스트림을 얻는다.스트림 소스가 I&#x2F;O 자원이므로, try-catch 블록으로 감싸고 finally 블록으로 자원을 닫아줘야 하지만.스트림 인터페이스는 AutoCloseable 인터페이스를 구현하므로 try 블록 자원을 자동으로 관리한다.각 행 요소를 split메서드를 통해 단어별 요소로 만들고,이 단어들을 distinct와 count를 연결해 고유 단어들의 갯수를 계산했다. 함수로 무한 스트림(언바운드 스트림) 만들기 크기가 고정되지 않은 스트림은 두 정적 메서드 Stream.iterate, Stream.generate로 구현한다. iterate와 generate에서 만든 스트림은 요청때마다 주어진 함수로 값을 만든다.보통 무한한 스트림을 제한하기 위해 limit을 연결해 사용한다. iterate 메서드123Stream.iterate(0, n-&gt;n+2) .limit(10) .forEach(System.out::println); iterate메소드는 초기값과 람다를 인수로 받아 무한히 실행한다.예제에서는 n-&gt;n+2이므로, 0, 2, 4, 6 …. 이런식으로 요소들을 만들어 낸다.limit으로 10개의 요소만 생성하고, 각 요소를 출력하며 스트림을 끝낸다. 자바 9의 iterate 메소드는 프레디케이트를 지원한다. 12IntStream.iterate(0, n-&gt;n&lt;100, n-&gt;n+4) .forEach(System.out::println); 그런데 여기서 이런 의문이 생긴다.다음과 같은 코드는 작동할까? 123IntStream.itrerate(0, n-&gt;n+4) .filter(n-&gt;n&lt;100) .forEach(System.out::println); 언뜻 보면 잘 작동할 것 같지만, 위 코드는 무한히 계산하여 종료되지 않는다!!!!! 엥 왜?filter는 이 작업이 언제 끝내야되는지 모르기 때문이다.filter는 100이 넘어가도 계속 자신의 해야할 계산을 한다. 우리의 의도를 달성하려면 _스트림 쇼트서킷_을 지원하는 takeWhile을 사용해야 한다. 123IntStream.iterate(0, n-&gt;n+4) .takeWhile(n-&gt;n&lt;100) .forEach(System.out::println); generate 메서드generate는 iterate와 다르게, 생산된 각 값을 연속적으로 계산하지 않는다. generate는 Supplier를 인수로 받아 새로운 값을 생산한다. 123Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 이 코드는 0과 1 사이의 임의 더블 수 다섯개를 만든다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"스트림 더 알아보기","slug":"java/java-basic/modern-java-in-action/modern4","date":"2021-07-30T00:37:30.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern4/","excerpt":"","text":"a. 필터링스트림 요소를 선택하는 방법을 필터링이라고 한다.프레디케이트 필터링과 고유 요소만 필터링하는 방법에 대해 알아보자! 프레디케이트로 필터링하기프레디케이트를 인수로 받아 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환하는 방식을 말한다.대표적으로 filter method가 있다. 예시로 보자! 123List&lt;Dish&gt; vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(toList()); 고유 요소 필터링고유 요소로 이뤄진 스트림을 반환하는 distinct method를 지원한다.여기서 고유 요소라는 말은 중복된 요소가 없는 요소를 의미한다.중복된 요소를 검증은 hashCode, equals로 결정된다. 12345List&lt;Integer&gt; numbers = Arrays.asList(1,2,3,3,2,4);numbers.stream() .flter(i -&gt; i%2 ==0) .distinct() .forEach(System.out::println);//2,4 b. 스트림 슬라이싱스트림 요소를 선택하거나 스킵하는 여러 방법에 대해 알아보자.프레디케이트 이용하기, 스트림 초기 몇 요소 무시하기, 특정 크기로 스트림 줄이기 등 다양한 방법이 있다. b-1. 프레디케이트 :takeWhile 활용스트림의 요소(음식)들이 이미 칼로리로 정렬되어 있을 때, 특정 칼로리보다 높은 칼로리를 갖는 음식들만 보고 싶으면 어떻게 해야 될까?이전에 배웠던 filter로 모든 요소를 확인해볼수 있지만, 요소들은 이미 칼로리로 정렬되어 있다.즉 특정 칼로리와 비교 연산의 결과가 달라지는 순간부터는 굳이 다음 요소를 검증하지 않아도 된다는 의미다.takeWhile은 처음 거짓이 나올 때까지 요소들을 모은다. 즉 거짓이 나오면 요소를 그만 모은다.이를 takeWhile연산으로 구현할 수 있다. 123List&lt;Dish&gt; sliceMenu1 = specialMenu.stream() .takeWhile(dish-&gt;dish.getCalories() &lt; 320) .collect(toList()); b-2. 프레디케이트 :dropWhile 활용takeWhile과는 달리 dropWhile은 정반대이다. 조건에 거짓이 되는 요소가 나오게 되면 그 지점에서 작업을 중단하고, 남은 모든 요소를 반환한다.dropWhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다. 1234List&lt;Dish&gt; sliceMenu1 = specialMenu.stream() .takeWhile(dish-&gt;dish.getCalories()&lt;320) .collect(toList()); b-3. 스트림 축소: limit주어진 값 이하의 요소를 갖는 스트림을 반환하는 limit(n)을 활용하면 스트림을 줄일 수 있다. 1234List&lt;Dish&gt; dishes = specialMenu.stream() .filter(dish-&gt;dish.getCalories() &gt; 300) .limit(3) .collect(toList()); 처음 일치하는 n개의 요소만 반환한다. b-4. 요소 건너뛰기: skip스트림으로 들어온 요소 n개를 제외한 스트림을 반환하는 skip(n) 메서드를 활용할 수 있다. 1234List&lt;Dish&gt; dishes = menu.stream() .filter(d -&gt; d.getCalories() &gt; 300) .skip(2) .collect(toList()); c. 매핑특정 객체에서 특정 데이터를 선택하는 map과 flatMap으로 매핑을 구현한다 c-1. 스트림의 각 요소에 함수 적용하기: mapmap은 함수를 인수로 받아 각 요소에 적용한 결과가 새로운 요소로 매핑된다. 123List&lt;String&gt; dishNames = menu.stream() .map(Dish::getName) .collect(toList()); c-2. 스트림 평면화: flatMap자 flatMap을 배우기 전에, 이게 왜 필요한지 알아보자.hello와 world라는 문자열 두개를 배열에 저장한 다음, 각 문자열의 고유문자만 모아 리스트에 넣어 반환하고 싶다고 하자.우리가 원하는 결과물은 h,e,l,o,w,r,d를 가진 리스트다. flatMap을 활용하지 않고 하면 시도를 하면 이렇게 된다 1234words.stream() .map(word-&gt;word.split(&quot;&quot;)) .distinct() .collect(toList()); 근데 이렇게 하면 map에서 해당 함수를 적용해도 문자배열을 가진 두 객체가 요소가 되는거지, 하나하나의 문자가 스트림요소가 되는게 아니다!즉 {h,e,l,l,o}, {w,o,r,l,d} 이렇게 두 요소가 반환되는거지, h,e,l,l,o,w,o,r,l,d 이런 식으로 문자들이 다 요소가 되는 게 아니다.결국 이렇게 하면 distinct 메소드는 두 요소를 비교하게 되는데, 두 요소는 엄연히 다른 요소이므로, 두 문자열 둘다 살아남게 된다.이제 collect를 통해 문자열 두개를 포함한 리스트가 반환된다. 자 그러면 이제 flatMap을 활용해보자.일단 우리가 원하는 목표를 달성하기 위해서는 배열 스트림이 아닌 문자열 스트림이 필요하다.문자열을 받아 문자열 스트림으로 활용하려면, Arrays.stream() 메서드를 활용하면 된다. 12String[] arrayOfWords = &#123;&quot;hello&quot;, &quot;world&quot;&#125;;Stream&lt;String&gt; streamOfWords = Arrays.stream(arrayOfWords); 이런 파이프라인으로 하면 문자열 스트림이 생성된다.이 파이프라인으로 우리가 원래 하려던 것을 해보자 12345words.stream() .map(word -&gt;word.split(&quot;&quot;)) .map(Arrays::stream) //각 배열을 별도의 스트림으로 생성 .distinct() .collect(toList()); 하지만 아직 문제가 있다. .map(Arrays::stream)을 하면, 각 문자열 배열들이 개별의 스트림이 되어toList() 반환값이 List이 되어버린다. 즉 스트림을 가진 리스트가 되어버린다. 우리가 원하는건 문자열은 가진 리스트다. 이를 위해 flatMap을 도입하자. flatMap 각 배열을 스트림이 아닌 한 스트림의 컨텐츠로 매핑한다. 123456List&lt;String&gt; uniqueCharacters = words.stream() .map(word-&gt;word.split(&quot;&quot;)) .flatMap(Arrays::stream) .distinct() .collect(toList()); d. 검색과 매칭d-1. anyMatch 프레디케이트가 적어도 한 요소와 일치하는지 확인123if(menu.stream().anyMatch(Dish::isVegetarian))&#123; System.out.println(&quot;the menu is vegetarian friendly!&quot;);&#125; d-2. allMatch 프레디케이트가 모든 요소와 일치하는지 검사12boolean isHealthy = menu.stream() .allMatch(dish -&gt; dish.getCalories()&lt;1000); d-3. noneMatch 프레디케이트와 일치하는 요소가 없는지 검사allMatch와 반대 되는 메서드라고 생각하자. 1boolean isHealthy = menu.stream().noneMatch(d-&gt;d.getCalories() &gt;= 1000); 이렇게 anyMatch, allMatch, noneMatch, findAny는 논리연산자 &amp;&amp;,||와 비슷하게 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다. 이를 쇼트 서킷이라 부른다!(특히 무한한 요소를 가진 스트림을 유한 요소 스트림으로 줄일 때 유용하다!)(limit도 포함!)d-4. findAny 요소 검색해서 해당 요소 반환123Optional&lt;Dish&gt; dish = menu.stream() .filter(Dish::isVegetarian) .findAny(); 여기서 optional은 추후에 더 공부할 것이니 넘어가고, 지금은 조건에 맞는 요소들을 찾아 반환해준다는 사실만 확인하고 넘어가자. d-5. findFirst 논리적인 순서를 가진 스트림에서 첫번째 요소 찾기12345List&lt;Integer&gt; someNumbers = Arrays.asList(1,2,3,4,5);Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream() .map(n-&gt;n*n) .filter(n-&gt;n%3 ==0) .findFirst(); //9 findFirst와 findAny는 언제 사용하나? 병렬 실행에서는 첫번째 요소를 찾기가 어렵다! 그럴 때 findFirst를 사용하고 그렇지 않으면, findAny를 사용한다!! e. 리듀싱리듀스 연산은 모든 스트림 요소를 처리해서 값으로 도출하는 연산이다.함수형 프로그래밍 언어로는 폴드라고 부른다. d-1. reduce 요소의 합요소의 합을 구하는 reduce에는 일반적으로 두 개의 파라미터가 필요하다.하나는 누적값의 초기값, 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator (보통 람다로 표현). 1int product = numbers.stream().reduce(1, (a,b)-&gt;a*b); 위 코드는 1부터 시작해서, 1+첫요소가 다시 누적값이 되고 (1+첫요소)+두번째요소가 되는 식이다.(물론 얘도 다음 요소와 연산될 때는 누적값이 된다.) 초기값을 받지 않는 reduce도 있다. Optional을 반환한다. 1Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a+b)); d-2. reduce로 최댓값 최솟값 찾기최대 최소를 구할 때는 reduce의 초기값(누적)이 필요가 없다. 그저 요소를 순서대로 받아 max연산을 하면 된다. 12Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min); reduce 메서드의 장점과 병렬화 반복으로 합계를 구하는 것과 reduce의 차이는 뭘까?reduce는 스트림이므로, 내부 구현으로 병렬로 실행할 수 있다. 스트림 연산 : 상태 없음과 상태 있음map, filter는 각 요소를 하나씩 받아 결과를 출력 스트림으로 보내는 내부 상태를 갖지 않는 연산이다.한편 reduce, sum, max 같은 연산은 결과를 누적할 내부 상태가 필요하다. 스트림의 요소 수와 관계없이 내부 상태의 크기는 한정적이다.하지만 sorted, distinct는 요소를 하나하나 받아 결과를 출력 스트림으로 보내는 연산이 아니라, 모든 요소를 버퍼에 추가하여 결과를 출력 스트림으로 보내는 연산이다.이런 연산들은 무한 스트림을 입력받으면 안된다. 예를 들어 모든 소수를 담은 무한 스트림을 sorted 할 수 있을까? 세상에서 가장 큰 소수가 맨 앞으로 와야되는데, 그런 연산은 불가능하다!. 이런 연산들을 우리는 내부 상태를 갖는 연산이라고 한다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"스트림에 대해 간략하게 알아보자","slug":"java/java-basic/modern-java-in-action/modern3","date":"2021-07-30T00:36:18.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern3/","excerpt":"","text":"a. 스트림이 뭘까?스트림은 자바 8 API에 새로 추가된 기능이다. 스트림을 이용하면 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현이 가능)으로 컬렉션 데이터를 처리할 수 있다. 쉽게 말하면, 스트림은 데이터 컬렉션 반복을 멋지게 처리하는 기능이라고 생각하자. 또한 스트림을 사용하면 멀티스레드 코드를 쓰지 않고도 투명하게 데이터를 병럴로 처리할 수 있다.(추후 알아보자) 일단 코드로 이해해보자 먼저 요리 중 저칼로리 요리명을 반환하고, 칼로리 기준으로 요리를 정렬하는 자바 7 코드를 보자. 123456789101112131415161718//요소 필터링List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();for (Dish dish : menu) &#123; if(dish.getCalories() &lt; 400) &#123; lowCaloricDishes.add(dish); &#125;&#125;//요소 정렬Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() &#123; //익명 클래스 public int compare(Dish dish1, Dish dish2) &#123; return Integer.compare(dish1.getCalories(), dish2.getCalories()); &#125;&#125;//요소 이름을 저장List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();for(Dish dish : lowCaloricDishes) &#123; lowCaloricDishesName.add(dish.getName());&#125; 이 코드를 보면 요소 정렬하면서 lowCaloricDishes라는 가비지 변수를 사용했다. lowCaloricDishes는 그저 정렬된 요소를 임시로 저장했다가 새로운 리스트인 lowCaloricDishesName에 전달해주는 역할을 한다. 자바 8에서는 이런 컨테이너 역할을 하는 중간 변수 구현을 라이브러리 내에서 모두 처리한다. 1234567import static java.util.Comparator.comparing;import static java.util.stream.Collections.toList;List&lt;String&gt; lowCaloricDishesName = menu.stream() .filtered(d -&gt; d.getCalories() &lt; 400) .sorted(Comparing(Dish::getCalories)) .map(Dish::getName) .collect(toList()); stream()을 parallelStream()으로 바꾸면, 멀티코어 아키텍처에서 병렬로 실행할 수 있다.(추후 게시물로 공부하자) 그렇다면 스트림을 사용하면 어떤게 좋을까? 선언형으로 코드를 구현할 수 있다.즉, 반복문이나 조건문같은 제어블록을 사용해서 상황에 따라 어떻게 행동할 지 구현할 필요없이, 동작의 수행을 지정할 수 있다.선언형 코드와 동작 파라미터화를 활용하면 요구사항에 쉽게 대응할 수 있다.(람다만 적절하게 바꿔주면 된다!) 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.위 예시에서처럼 filtered, sorted, map, collect등 연결해 더 복잡한 파이프라인을 만들 수 있다. 고수준 빌딩 블록(filter, sorted, map, collect 등..)은 특정 스레딩 모델에 제한되지 않고 사용가능 하다.이 블록들은 멀티코어 아키텍처를 최대한 투명하게 활용할 수 있게 구현되어 있다. 덕분에 데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정할 필요가 없다. 마지막으로 스트림의 특징을 요약하면서 다음 챕터로 넘어가자! 선언형 : 더 간결, 가독성 상승 조립 가능 : 유연성 병렬화 : 성능 향상 b. 스트림 시작하기스트림에 대해 공부하기 앞서, 스트림이 정확하게 어떤 것을 의미하는 지 살펴보고 가자. 스트림이란 ‘데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소’를 의미한다. 무슨 말인지 아직도 모르겠다… 정의에 나온 단어 하나하나 파악해보자 연속된 요소?컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이뤄진 연속된 값 집합의 인터페이스를 제공한다.컬렉션은 요소 저장 및 접근 연산이 주를 이루지만, 스트림은 요소들의 표현이나 계산식이 주를 이룬다. 소스?스트림은 컬렉션, 배열, 입출력 자원 등 데이터 제공 소스로부터 데이터를 소비한다.컬렉션에서 요소들을 스트림에 연결하면, 컬렉션에 저장된 순서대로 스트림 요소가 소비된다는 의미! 데이터 처리 연산?스트림은 함수형 프로그래밍 언어나 데이터베이스와 비슷한 연산을 지원한다.(filter, map, reduce, find, match, sort…) 스트림의 정의는 이렇게 이해할 수 있게 됐다. 한편 스트림의 두 가지 중요한 특징도 짚고 넘어가자! 파이프라이닝대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록, 스트림 자신을 반환한다! 내부 반복반복자를 이용해서 명시적으로 반복하는 컬렉션과는 달리 스트림은 내부 반복을 지원한다. 지금까지 배운 내용을 코드로 이해해 보자 12345678import static java.util.stream.Collectors.toList;List&lt;String&gt; threeHighCaloricDishNames = menu.stream() //List&lt;Dish&gt; menu에서 스트림얻음 .filter(dish -&gt; dish.getCalories() &gt; 300) //고칼로리 필터링 .map(Dish::getName) //필터링 된 요리를 이름을 추출 .limit(3) //선착순 세개만 저장 .collect(toList()); //결과를 다른 리스트로 저장System.out.println(threeHighCaloricDishNames); 이 코드를 도표로 나타내면 다음과 같다 [##Image|kage@bhCDUs&#x2F;btq9TEvcCqe&#x2F;zfB1YOZVyffzyU46TnHLVK&#x2F;img.png|alignCenter|data-origin-width&#x3D;”715” data-origin-height&#x3D;”506” width&#x3D;”666” height&#x3D;”471” data-ke-mobilestyle&#x3D;”widthOrigin”|||##] c. 스트림과 컬렉션자 이제, 스트림과 컬렉션을 비교해보자. 앞서 살펴본 것처럼 스트림과 컬렉션은 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. 연속된 이란 의미는 아무렇게나 값에 접근할 수 있는 것이 아닌 순차적으로 값에 접근한다는 의미다. 스트림과 컬렉션을 DVD와 비디오스트리밍의 관계로 이해할 수 있다. DVD(컬렉션)비디오스트리밍(스트림)전체 자료구조가 저장되어 있음전체가 저장되어 있지않고 사용할 일부만 받아와 사용 c-1. 데이터를 언제 계산하는가컬렉션과 스트림의 가장 큰 차이를 보이는 게 바로 데이터를 언제 계산하는 지이다. 컬렉션은 모든 데이터를 메모리에 저장하는 자료구조다.즉 컬렉션에 어떤 값을 추가하거나, 삭제하려 할 때마다 컬렉션의 모든 값이 메모리에 저장되어야하고, 추가하려는 값은 미리 계산되어야 한다. 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다. 고정됐다는 의미는 요소를 삭제하거나 제거할 수 없다는 의미다. 사용자가 요청하는 값만 스트림에서 추출하는 것이 핵심이다. 구글검색을 한다고 가정했을 때 모든 검색 결과를 가져올 때까지 기다리는 방식이 컬렉션이고, 가장 연관있는 10개를 먼저 보여주고 그 다음 페이지로 넘어가면 그 때 다음 10개를 가져오는 방식이 스트림이라고 이해하자! c-2. 딱 한 번만 탐색할 수 있다.반복자(iterator)와 마찬가지로 스트림도 단 한번만 탐색할 수 있다. 어떤 요소가 한 스트림에서 이미 탐색됐을 때, 그 요소에 다시 접근하려면 새로운 스트림으로 접근해야 한다는 의미다. (물론 데이터 소스도 반복 접근이 가능해야 한다. 입출력 소스 처럼 반복 사용할 수 없는 경우 스트림을 새로 만들어도 접근 불가능이다.) c-3. 외부 반복, 내부 반복컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.(반복문을 써서) 이를 외부 반복이라고 한다. 하지만 스트림은 내부 반복을 사용한다. 내부 반복은 반복을 알아서 처리하고, 결과 스트림 값을 어딘가에 저장하는 방식이다. 함수에 동작만 결정하면 반복과 저장은 알아서 해준다는 의미다. 12345678List&lt;String&gt; names = new ArrayList&lt;&gt;();for(Dish dish: menu) &#123; names.add(dish.getName());&#125;List&lt;String&gt; names = menu.stream() .map(Dish::getName) .collect(toList()); 내부 반복이 외부 반복보다 편리한 이유는 무엇일까?방에 쓰레기를 주우라고 명령할 때 외부 반복은 마치 쓰레기가 있니? - 왼쪽에 쓰레기가 있네요- 주우렴 - 다시 쓰레기가 아직도 있니 - 오른쪽에도 쓰레기가 있네요 - 주우렴- …. 이런식인데, 내부 반복은 방에 있는 쓰레기를 모두 주우렴 - 주웠어요. 이렇게 실행된다. 또한 내부 반복은 쓰레기를 두 손으로 동시에 주울 수도 있고(투명한 병렬 처리), 쓰레기통을 가끼이 두고 빨리 처리 할 수 있다.(최적화) 내부반복과 외부반복은 라이브러리가 반복을 자기 안에서 해결하느냐 마느냐로 구분한다고 이해하자. 하지만 스트림의 내부 반복은 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다.(filter, map..) d. 스트림 연산스트림 연산은 크게 중간 연산, 최종 연산 두 가지로 나누어진다. d-1. 중간 연산중간 연산은 다른 스트림을 반환하는 연산이다. (filter, map…) 중간 연산의 가장 중요한 특징은 최종 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것이다. 중간 연산이 연결되어 합쳐지고, 이 것을 최종 연상으로 한번에 처리한다. 연산형식반환 형식연산의 인수함수 디스크립터filter중간Stream&lt;T&gt;Predicate&lt;T&gt;T -&gt; booleanmap중간Stream&lt;R&gt;Function&lt;T, R&gt;T -&gt; Rlimit중간Stream&lt;T&gt;&nbsp;&nbsp;sorted중간Stream&lt;T&gt;Comparator&lt;T&gt;(T, T) -&gt; intdistinct중간Stream&lt;T&gt;&nbsp;&nbsp; d-2. 최종 연산최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에서는 스트림이 아닌 List, Integer, void 등 도출된다. 연산형식반환 형식목적forEach최종void스트림 각 요소를 람다를 적용하면서 소비count최종long스트림 요소 갯수 반환collect최종collection스트림을 리스트, 맵, 정수 형식 컬렉션으로 만든다 스트림 이용 과정은 다음 세가지로 요약 가능하다. 질의를 수행할 데이터 소스(컬렉션, 배열, 입출력 소스) 스트림 파이프라인을 구성할 중간 연산 연결 스트림 파이프라인을 실행하고 결과를 만들 최종 연산","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"람다표현식","slug":"java/java-basic/modern-java-in-action/modern2","date":"2021-07-30T00:25:25.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern2/","excerpt":"","text":"a. 람다란 무엇인가?람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다! 익명 : 람다 표현식에는 이름이 없다. 함수 : 람다는 메서드와 달리 특정 클래스에 종속되지 않으므로 함수라 부른다. 전달 : 메서드 인수로 전달하거나 변수로 저장할 수 있다. 간결성 : 익명 클래스보다 간결하다. 커스텀 Comparator 객체 구현 예시로 람다의 힘을 느껴보지! 12345678Comparator&lt;Apple&gt; byWeight = new Comparator&lt;Apple&gt; &#123; public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;//RamdaComparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); 람다는 크게 세 부분으로 이뤄져있다. 파라미터 리스트 : (Apple a1, Apple a2) 화살표(-&gt;) : 람다의 파라미터 리스트와 바디를 구분 람다 바디 : a1.getWeight().compareTo(a2.getWeight()); 람다의 반환같이 해당하는 표현식. 람다는 표현식 스타일과 블록 스타일로 나타낼 수 있다. 표현식 스타일(parameters) -&gt; expression 블록 스타일(parameters)-&gt; { statements; } 구문(statements)와 표현식(expression)을 잘 구분해서 맞는 스타일대로 작성하기로 바란다! 아래 다양한 람다 사례를 보며 람다 표현식을 익혀보자! 12345678(List&lt;String&gt; list)-&gt; list.isEmpty()()-&gt;new Apple(10)(Apple a)-&gt; &#123; System.out.println(a.getWeight());&#125;(String s)-&gt; s.length()(int a, int b) -&gt; a*b(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) b. 어디에 어떻게 람다를 사용할까?b-1. 함수형 인터페이스함수형 인터페이슨느 정확히 하나의 추상 메서드를 지정하는 인터페이스다. 대표적으로 Predicate, Comparator, Runnable 등이 있다. (d 항목에서 더 자세히 다뤄본다.) 123456public interface Predicate&lt;T&gt; &#123; boolean test (T t);&#125;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; #인터페이스는 디폴트 메서드를 포함할 수 있다. 디폴트 메서드를 가지고 있더라도 추상메서드가 오직 하나면 함수형 인터페이스다. 함수형 인터페이스로 뭘 할 수 있을까? 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다. 즉 전체 표현식을 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급할 수 있다!! b-2. 함수 디스크립터먼저 함수 디스크립터에 대해 알아보기 전에 메서드 시그니처에 대해 알아보자. 시그니처란 메소드의 이름과 매개변수 이름을 제외한 나머지이다. 즉 int sum(int a, double b) , int sum2(int c, double d) 이 두 메소드는 서로 시그니처가 같다. 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다. (함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 부른다.) 123456public void process(Runnable r) &#123; r.run();&#125;process(()-&gt; System.out.println(&quot;This is awesome!!&quot;));//process(() -&gt; &#123; System.out.println(&quot;This is awesome!!&quot;);&#125;); Runnable 인터페이스의 유일한 추상 메소드인 run 메소드는 인수와 반환값이 없으므로, 람다 표현식의 함수 디스크립터도 해당 시그니처에 맞춰 작성됐다. #이때 왜 람다 표현식에 중괄호를 사용하지 않았는지 궁금할텐데, 이는 하나의 void 메소드 호출은 중괄호를 생략한다. @FunctioalInerface는 무엇일까? 다음에 나오는 인터페이스가 함수형 인터페이스임을 알리는 어노테이션. 함수형 인터페이스가 아닐경우 에러 발생. c. 람다 활용 : 실행 어라운드 패턴데이터베이스의 파일 처리를 구현한다고 상상해보자 자원을 열고(설정), 처리한 다음에, 자원을 닫는(정리) 순으로 구현할 것이다. 이런 순환 패턴의 코드를 실행 어라운드 패턴이라 부른다. (다음 예시는 try with resources 구문을 사용했다. 자원을 명시적으로 닫지 않아도 된다.) 12345public String processFile() throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123; return br.readLine(); &#125;&#125; 이 예시를 람다로 간결하게 구현하는 과정을 한번 경험해보자! c-1. 1단계, 동작 파라미터화를 기억하라현재 코드는 파일에서 한번에 한 줄만 읽을 수 있다. 만약 요구사항이 한번에 두 줄을 읽거나 자주 사용되는 단어를 반환하라는 등으로 바뀌면 어떻게 해야하나? 그렇다! 설정과 정리 과정은 재사용하고, processFile 메소드만 다른 동작으로 작동할 수 있으면 된다! 즉 processFile의 동작을 파라미터화 하는 것이다!!!!! 자 이제 다음 단계부터 차근차근 동작 파라미터화를 구현해보자! c-2. 2단계, 함수형 인터페이스를 이용해서 동작 전달람다로 활용하려면 함수형 인터페이스를 이용해야 한다. processFile 의 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다. BufferedReaderProcessor라고 정의해 인터페이스를 구현하고, processFile 메서드의 인수로 전달해보자! 12345678@FunctionalInterfacepublic interface BufferReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125;public String processFile(BufferedReaderProcessor p) throws IOException &#123;//...&#125; c-3. 3단계, 동작 실행자 이제 BufferedReaderProcessor에 process 메서드의 시그니처와 일치하는 람다를 전달할 수 있다. 이렇게 하면 함수형 인터페이스의 추상 메소드를 람다가 구체화해서 precessFile에서 실행할 수 있게 된다. 즉 람다로 구현된 다양한 요구조건들을 받는 그릇이 준비된 셈이다. 12345public String processFile(BufferedReaderProcessor p) throws IOEXception &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123; return p.process(br); &#125;&#125; c-4. 4단계, 람다 전달이제 람다를 이용해서 다양한 동작을 processFile 메서드로 전달할 수 있다. 123String oneLine = processFile(BufferedReader br) -&gt; br.readLine());String twoLine = processFile(BufferedReader br) -&gt; br.readLine()+br.readLine(); d. 함수형 인터페이스 사용다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다! 자바 8에는 java.util.function 패키지로 여러가지 함수형 인터페이스를 제공한다. d-1. Predicatejava.util.function.Predicate 인터페이스는 test라는 추상 메소드를 정의한다! test는 T 객체를 인수로 받아 불리언을 반환한다! 123456789101112131415@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; results = new ArrayList&lt;&gt;(); for(T t: list) &#123; if(p.test(t)) &#123; results.add(t); &#125; &#125; return results;&#125;Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();List&lt;String&gt; nonEmpty = filter(listOfStrings, nonEmptyStringPredicate); d-2. Consumerjava.util.function.Consumer 인터페이스는 accept라는 추상 메소드를 정의한다! accept는 T 객체를 인수로 받아 어떤 동작을 수행하고 반환값은 없다. for each를 Consumer로 구현한 사례를 보자 1234567891011@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;public &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c) &#123; for(T t: list) &#123; c.accept(t); &#125;&#125;forEach(Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.println(i)); d-3. Functionjava.util.function.Function&lt;T, R&gt; 인터페이스는 추상 메서드 apply를 정의한다 apply는 T를 인수로 받아 R 객체로 반환한다. 입력을 출력으로 매핑하는 람다를 정의할 때 사용할 수 있다. String 리스트를 인수로 받아, 각 String 길이를 포함하는 Integer 리스트로 변환하는 map메서드 구현 사례를 보자! 123456789101112131415@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;public &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t: list) &#123; result.add(f.apply(t)); &#125; return result;&#125;List&lt;Integer&gt; l = map(Arrays.asList(&quot;lambdas&quot;, &quot;in&quot;, &quot;action&quot;), (String s) -&gt; s.length());//[7,2,6] d-4. 기본형 특화이 글을 보고 있는 사람들은 아시다시피, 제네릭에는 래퍼클래스(책에서는 참조형이라고 한다) 인스턴스만 사용가능하다. 이런 불편을 박싱과 언박싱으로 해소할 수 있지만, 그럴 경우 불필요한 메모리 소모가 생긴다. 자바 8에서는 기본형으로 입출력할 때 오토박싱을 피하기 위해 특별한 함수형 인터페이스를 제공한다. 아래는 IntPredicate를 활용한 예시이다. 123456789public interface IntPredicate &#123; boolean test(int i);&#125;IntPredicate evenNumbers = (int i) -&gt; i%2==0;evenNumbers.test(1000); //참이고 박싱이 진행되지 않음Predicate&lt;Integer&gt; evenNumbers2 = (int i) -&gt; i%2==0;evenNumbers2.test(1000); //참이고 박싱이 진행됨 Predicate와 IntPredicate의 차이를 알아차리기 바란다! d-5. 람다와 함수형 인터페이스 예제를 표로 정리사용 사례람다 예제대응하는 함수형 인터페이스불리언 표현(List&lt;String&gt; list) -&gt; list.isEmpty()리스트가 비었는지 확인Predicate&lt;List(String)&gt;객체 생성() -&gt; new Apple(10)Supplier&lt;Apple&gt;객체 소비(Apple a) -&gt; System.out.println(a.getWeight())Consumer&lt;Apple&gt;객체에서 선택/추출(String s) -&gt; s.length()Function&lt;String, Integer&gt;ToIntFunction&lt;String&gt;두 값 조합(int a, int b) -&gt; a*bIntBinaryOperator두 객체 비교(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())Comparator&lt;Apple&gt; 또는BiFunction&lt;Apple, Apple, Integer&gt;,ToIntBiFunction&lt;Apple, Apple&gt; 복잡하긴 하다. d-6. 예외, 람다, 함수형 인터페이스의 관계함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다. 즉 예외를 던지는 람다 표현식을 만들려면, 함수형 인터페이스에서 예외를 선언하도록 직접 정의하거나, 람다를 try catch문으로 감싸야 한다. 예외를 처리하는 함수형 인터페이스를 선언하는 예시를 보자. 12345@FunctionalInterfacepublic interface BufferedReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125;BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine(); 하지만 이미 자바 API에 정의된 함수형 인터페이스를 사용하려 하는데예외 때문에 다시 직접 만들어 쓰기는 쉽지 않다… 이럴 때는 람다를 try catch로 감싸는 방법을 사용해보자!! 1234567Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; &#123; try &#123; return b.readLine(); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125;&#125;; e. 형식 검사, 형식 추론, 제약람다로 함수형 인터페이스의 인스턴스를 만들 수 있는데, 정작 람다 표현식 자체에는 어떤 함수형 인터페이스를 구현하는지의 정보가 없다.. 어떻게 알고 인스턴스를 만드는걸까? e-1. 형식 검사람다가 사용되는 콘텍스트(람다가 전달될 메서드 파라미터, 람다가 할당되는 변수 등..)을 통해람다의 형식을 추론할 수 있다! 예시로 이해해보자. 1234567public &lt;T&gt; void filter(inventory, Predicate&lt;T&gt; p)&#123; if(p.test())&#123; inventory.add(p); &#125;&#125;List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); 위 코드의 형식 확인 과정은 다음과 같다. 람다가 사용된 콘텍스트는 뭐냐?filter 메서드에서 사용됐으니, filter메서드의 정의를 확인하자! 대상 형식은 뭐냐? #대상 형식이란, 컨텍스트에서 기대되는 람다의 형식.filter 메서드를 보니, 람다에 해당하는 대상형식은 Predicate이다! Predicate 인터페이스의 추상 메서드는 뭐냐?boolean test(Apple apple)이다! #d-1참고. 아하! 그러면 해당 람다는 Apple을 받아 boolean을 반환하면 되겠군! e-2. 같은 람다, 다른 함수형 인터페이스앞서 다룬 대상 형식(타겟타입)이란 개념 때문에 같은 람다 표현식도 여러 함수형 인터페이스에 사용할 수 있다! 물론 이렇게 활용되기 위해서는 해당 추상 메서드에 호환이 되어야 한다.(시그니처가 호환되어야 할 것이다.) 12Callable&lt;Integer&gt; c = () -&gt; 43;PrivilegedAction&lt;Integer&lt; p = () -&gt; 43; 위 두 코드에는 같은 람다식이 서로 다른 함수형 인터페이스에 할당 되었다. Callable과 PrivilegedAction 모두, 인수를 받지 않고 제네릭 형식 T를 반환하는 추상 메소드가 있어서 가능하다. #특별한 void 호환 규칙 람다의 바디에 일반 표현식이 있으면 void를 반환하는 함수 디스크립터(시그니처)와 호환된다. List의 add는 T를 받아 boolean을 반환하지만 T를 받는 void 형식에도 사용 가능하다. 12// Consumer는 void 반환값을 가지면, 일반 표현식이 와도 괜찮다!Consumer&lt;String&gt; b = s -&gt; list.add(s); e-3. 형식 추론람다 표현식의 파라미터 형식을 생략해도 컴파일러가 추론할 수 있다. 1List&lt;Apple&gt; greenApple = filter(inventory, apple -&gt; GREEN.equals(apple.getColor())); apple이 어떤 형식인지 말 안해줘도, filter 메소드을 통해 추론 할 수 있게된다. 형식을 써주는게 좋을 때도 있고, 생략해야 좋을 때도 있으니, 개발자가 가독성이 좋은 방향으로 선택하길 바란다! e-4. 지역 변수 사용(람다 캡처링)람다 표현식에 자유 변수(파라미터로 넘겨진 변수가 아닌 외부에 정의된 변수)를 활용할 수도 있다! 12int portNumber =1337;Runnable r = () -&gt; System.out.println(portNumber); 람다는 인스턴스 변수, 정적 변수 모두 사용 가능하지만 제약이 있다. 명시적으로 final 선언되어 있거나, 실질적으로 final 선언된 변수여야만 한다. 즉 람다는 한번만 할당할 수 있는 지역 변수를 사용할 수 있다. 다음 예시는 컴파일 에러를 일으킨다. 123int portNum = 1337;Runnable r = () -&gt; System.out.println(portNum);portNum=31338; //error 그렇다면 왜 제약이 있는 건가? 인스턴스 변수와 지역 변수의 태생적 차이 때문! 인스턴스 변수는 힙에 저장, 지역 변수는 스택에 저장된다. 람다가 지역 변수에 접근할 수 있는 상황에서 람다가 스레드에서 실행되면,변수를 할당한 스레드가 사라져 변수 할당이 해제되지만, 람다에서 해당 변수를 사용해야 된다. 즉 자바에서는 원래 변수에 접근하는 개념이 아니라, 원래 변수를 복사본을 제공하는 개념으로 구현한다. 따라서 복사본의 값이 바뀌면 않아야 되므로, 할당을 한번만 허용하는 것이다. f. 메서드 참조메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있다. 때로는 람다보다 메서드 참조가 더 가독성이 좋을 수 있다. 12345//람다 표현식inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));//메서드 참조inventory.sort(comparing(Apple::getWeight)); f-1. 메서드 참조 요약메서드 참조는 람다 표현식을 축약한 것이다. 위 코드에서 (Apple a1, Apple a2) -&gt; …. 을 Apple::getWeight로 줄인 것이다. 그렇다면 이 코드는 어떤 효과를 가질까? 람다로 이미 존재하는 메서드를 호출하려고 하면,굳이 그 내용을 설명할 것이 아니라, 해당 메소드명을 직접 참조하는 것이 편리하고 가독성이 좋다. (위 코드로 예시를 들면 getWeight메소드이 구현되어 있으면, 굳이 람다로 그 내용을 쓰지말고 메소드 명만 쓰는 메소드 참조를 하자는 것이다.) 이때 실제 메소드를 호출하는 것은 아니므로 괄호가 없다. 람다를 축약한 것임을 기억하자. 단축 표현 예시를 보자 람다메서드 참조 단축 표현(Apple apple) -&gt; apple.getWeight()Apple::getWeight() -&gt; Thread.currentThread().dumpStack()Thread.currentThread()::dumpStack(str, i) -&gt; str.substring(i)String::substring(String s) -&gt; System.out.println(s)(String s) -&gt; this.isValidName(s)System.out::printlnthis::isValidName 당장은 이해가 안되도 차근차근 공부해보자. f-2. 메서드 참조를 만드는 방법일단 메소드 참조에는 세가지 유형이 있다 정적 메서드 참조Integer의 parseInt는 Integer::parseInt로 표현 가능하다 다양한 형식의 인스턴스 메소드 참조String의 toUpperCase는 String::toUpperCase로 표현 가능하다즉 (String s) -&gt; s.toUpperCase()를 String::toUpperCase로 축약 가능하다. 기존 객체의 인스턴스 메서드 참조Transaction이라는 객체를 할당받은 expensiveTransaction 지역 변수가 있고, Transaction 객체에는 getValue메서드가 있다고 할 때, expensiveTransaction::getValue라고 표현 가능하다.즉 () -&gt; expensiveTransaction.getValue()를 expensiveTransaction::getValue라고 축약 가능하다. 람다 표현식을 메서드 참조로 표현하는 단축 규칙을 보여주는 도표이다. [##Image|kage@dUB92e&#x2F;btq9EO4XvW0&#x2F;KuP3ujmb0mkTZiKm9VA580&#x2F;img.jpg|alignCenter|data-origin-width&#x3D;”825” data-origin-height&#x3D;”659” data-ke-mobilestyle&#x3D;”widthOrigin”|||##] f-3. 생성자 참조ClassName::new처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다. 이는 정적 메서드의 참조를 만드는 방법과 비슷하다. 다음 예시들은 다양한 시그니처에 따른 생성자 참조를 보여준다. 12345678910111213141516171819//람다 스타일, new Apple() 이라는 생성자가 있을 경우Supplier&lt;Apple&gt; c1 = () -&gt; new Apple();Apple a1 = c1.get();//생성자 참조Supplier&lt;Apple&gt; c1 = Apple::new;Apple a1 = c1.get();//람다 스타일, new Apple(Integer)Funtion&lt;Integer, Apple&gt; c2 = (weight) -&gt; new Apple(weight);Apple a2 = c2.apply(110)//생성자 참조Function&lt;Integer, Apple&gt; c2 = Apple::new;Apple a2 = c2.apply(110)//람다 스타일, new Apple(String color, Integer)BiFUnction&lt;String, Integer, Apple&gt; c3 = (color, weight) -&gt; new Apple(color, weight);Apple a3 = c3.apply(GREEN, 110);//생성자 참조BiFunction&lt;Color, Integer, Apple&gt; c3 = Apple::new 이렇게 인스턴스화하지 않고도 생성자에 접근할 수 있는 기능을 다양한 상황에서 응용해보자. 12345678910//사과의 무게 정보와 함께 Apple 생성자 호출List&lt;Integer&gt; weights = Arrays.asList(7, 3, 4, 10);List&lt;Apple&gt; apples = map(weights, Apple::new);public List&lt;Apple&gt; map(List&lt;Integer&gt; list, Function&lt;Integer, Apple&gt; f) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for( Integer i : list) &#123; result.add(f.apply(i)); &#125; return result;&#125; 지금까지는 이미 존재하는 함수형 인터페이스를 활용해 생성자 참조를 했다. 만약 인수가 세개 이상을 필요로 하는 생성자의 생성자 참조는 어떻게 해야 할지 알아보자! 12345public interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125;TriFunction&lt;Integer, Integer, Integer, Color&gt; colorFactory = Color::new g. 람다, 메서드 참조 활용하기자 처음에 다룬 사과리스트를 다양한 요구조건에 맞춰 정렬하는 문제를 지금까지 배운 람다와 메서드 참조로 해결해보자! 우리가 얻을 최종 결과물은 다음과 같다. 1inventory.sort(comparing(Apple::getWeight)); g-1. 1단계, 코드 전달우리는 자바 8에 도입된 List API에서 sort 메소드를 활용해 정렬을 해결하기로 했다. 그런데 sort 메소드에 정렬 전략을 어떻게 도입할 수 있을까? 일단 sort 메소드의 시그니처를 알아보자 1void sort(Comparator&lt;? super E&gt; c) 위 코드는 Comparator 객체를 인수로 받아 두 사과를 비교한다. 즉 Comparator 객체에 다양한 동작을 포함시켜서 전략을 도입시킬 수 있을 것이다. 이제 ‘sort의 동작은 파라미터화 되었다.’ 말할 수 있다. 즉 sort에 전달된 정렬 전략에 따라 sort의 동작이 달라질 것이다. 그렇다면 우리는 맨 처음 코드를 다음과 같이 바꿀 수 있다. 123456public class AppleComparator implements Comparator&lt;Apple&gt; &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;inventory.sort(new AppleComparator()); 자 이제 AppleComparator 클래스의 동작을 바꿔주면 요구조건에 유연하게 대응할 수 있다! g-2. 2단계, 익명 클래스 사용하지만 한번만 사용할 Comparator를 1단계에서 처럼 구현하는 거 보다는 익명 클래스를 이용하는게 나아 보인다. 12345inventory.sort(new Comparator&lt;Apple&gt;() &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); g-3. 3단계, 람다 표현식 사용하지만 여전히 코드가 장황하다! 자바 8에서는 함수형 인터페이스(오직 하나의 추상 메서드를 정의하는 인터페이스)를 기대하는 곳 어디에서나 람다표현식을 사용할 수 있다! Comparator의 함수 디스크립터(추상 메서드의 시그니처)는 (T, T) -&gt; int다. 우리의 경우는 사과를 사용하므로, (Apple, Apple) -&gt; int로 표현할 수 있다. 123inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); 이렇게 코드를 작성할 수 있는데, 첫 줄은 자바 컴파일러가 inventory의 제네릭 타입에 따라 람다의 파라미터 형식을 추론한다! 이 코드의 가독성을 더 높여보자!! Comparator는 Comparable 키를 추출해서 Comparator 객체로 만드는 Function 함수를 인자로 받는 정적 매서드 comparing을 포함한다!!! 이 comparing 메소드를 활용해서 더 간단하게 작성할 수 있다. 12import static java.util.Comparator.comparing;inventory.sort(comparing(apple -&gt; apple.getWeight())); 람다표현식은 사과를 비교하는 데 사용할 키를 어떻게 추출할 것인지 지정하는 한 개의 인수만 포함한다. g-4. 4단계, 메서드 참조 사용이제 람다 표현식을 메서드 참조를 활용해 더 간단히 만들어보자 (앞서 본 거 처럼, java.util.Comparator.comparing은 정적으로 임포트했다고 가정하자) 1inventory.sort(comparing(Apple::getWeight)); h. 람다 표현식을 조합할 수 있는 유용한 메서드람다 8에서는 몇몇 함수형 인터페이스는 다양한 유틸리티 메서드를 포함한다. 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 의미다!!! 근데 함수형 인터페이스가 추가로 메서드를 제공하는 것에 의문이 생길 수 있다… 이 때 등장하는 개념이 바로 디폴트 메소드다.(추후에 관련 게시물로 추가 등록) h-1. Comparator 조합이전에 g-3에서 알아봤듯이, 정적메서드 Comparator.comparing을 이용해서 비교에 사용될 키를 추출하는 Function 기반의 추출하는 Function 기반의 Comparator를 반환할 수 있다. 1Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight); h-1-1. 역정렬내림차 정렬은 다른 Comparator 인스턴스를 만들 필요가 없다! reverse 디폴트 메소드에 제공되어 있으니 써먹으면 된다. (reverse 메소드는 비교자의 순서를 뒤바꾸는 역할을 한다.) 1inventory.sort(comparing(Apple::getWeight).reversed()); h-1-2. Comperator 연결만약 무게가 같은 두 사과가 존재하면, 어떻게 정렬해야 하는가? 이런 상황에 대비해, 비교 결과를 더 다듬을 수 있는 두번째 Comparator를 만들어 연결할 수 있다. 이때 사용되는 thenComparing 메소드를 활용해 두번째 비교자를 받아 사용할 수 있다. 다음 예시는 무게로 내림차순 정렬을 하고, 만약 같은 무게를 가진 경우, 생산 국가로 다시 정렬하는 예시이다. 1inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry)); h-2. Predicate 조합Predicate 인터페이스의 경우, 보다 복잡한 프레디케이트를 만들 수 있도록, negate, and, or 세가지 메서드를 제공한다. (당연히 얘네는 디폴트 메서드일 것이다.) h-2-1. negatenegate는 부정한다는 의미다. negate를 붙이면 앞서 진행됐던 프레디케이트를 반전시킬 수 있다. 쉽게 말해 여집합을 생각하면 편할 것이다. 1Predicate&lt;Apple&gt; notRedApple = redApple.negate(); 빨간 사과를 구분하는 Predicate 인터페이스 redApple 뒤에 negate메소드를 더해주면, 빨갛지 않은 사과만 뽑아낼 수 있다! h-2-2. andand는 두 람다를 조합할 수 있다. 1Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; 150); 빨간 사과를 구분하는 Predicate 인터페이스 redApple 뒤에 람다를 포함한 and메소드를 연결하면, 빨갛고 무거운 사과를 뽑아낼 수 있다. h-2-3. oror는 다양한 조건을 만들어 낼 수 있다. 예시로 보면 이해가 빠를 것이다. 12Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(apple -&gt; apple.getWeight() &gt; 150).or(apple -&gt; GREEN.equals(a.getColor())); h-3. Function 조합Function 인터페이스는 andThen과 compose 두가지 메소드를 제공한다! h-3-1. andThenandThen 메소드는 두 개의 Function 인터페이스를 받아, 하나의 인터페이스의 결과물을 다른 인터페이스의 입력값으로 전달하는 역할을 한다. 1234Function&lt;Integer, Integer&gt; f = x -&gt; x+1;Function&lt;Integer, Integer&gt; g = x -&gt; x*2;Function&lt;Integer, Integer&gt; h = f.andThen(g);int result = h.apply(1); //return 4 h-3-2. composecompose 메소드는 인수로 주어진 함수를 먼저 하고, 그 결과를 외부 함수의 인수로 제공한다. 이 말이 어렵게 느껴지겠지만 예시로 살펴보자. 1234Function&lt;Integer, Integer&gt; f = x -&gt; x+1;Function&lt;Integer, Integer&gt; g = x -&gt; x*2;Function&lt;Integer, Integer&gt; h = f.compose(g);int result = h.apply(1); //return 3 andThen의 예시에서는 4가 반환됐는데, compose는 3이 반환 됐다. 이 차이를 살펴보자. andThen은 말그대로 f를 하고 g를 해라 라는 의미다. 매우 직관적이다. compose는 g를 하고 f를 하라는 거다. 아까 설명을 함수 스타일로 표현하면 f(g(1))이 되어 (1*2)+1이 되므로 3이 반환된 거다.","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"동적 파라미터화 코드 전달하기","slug":"java/java-basic/modern-java-in-action/modern1","date":"2021-07-30T00:19:44.000Z","updated":"2022-01-22T16:20:00.035Z","comments":true,"path":"2021/07/30/java/java-basic/modern-java-in-action/modern1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/30/java/java-basic/modern-java-in-action/modern1/","excerpt":"","text":"‘녹색 사과를 모두 찾고 싶어요… 아니다! 150그람 이상인 사과를 모두 찾고 싶어요…. 생각해보니 150그람 이상이면서 녹색인 사과를 모두 찾아야 될 것 같네요..’ 이렇게 시시각각 변화는 사용자의 요구 사항을 최소 비용으로 대응하기 위해서는 어떻게 해야할까? a. 동적 파라미터화란…동적 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 말한다. 나중에 실행될 메서드의 인수로 코드 블록을 전달할 수 있다. b. 변화하는 요구사항에 대응하기맨 처음 사과 요구사항을 자꾸 바꿔서 요청하는 예시를 해결해보자! b-1. 첫번째 시도. 녹색 사과 필터링1234567891011enum Color&#123;RED, GREEN&#125;public static List&lt;Apple&gt; filterGreenApple(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple:inventory)&#123; if(GREEN.equals(apple.getColor())&#123; result.add(apple); &#125; &#125; return result;&#125; 이 코드에서 만약 요구사항이 녹색 사과에서 빨간 사과를 수집하도록 바뀐다면 어떨까? 이럴 땐 이 규칙을 기억해야 한다. 거의 비슷한 코드가 반복 존재한다면 그 코드를 추상화한다. b-2. 두번째 시도, 색을 파라미터화123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, Color color)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory)&#123; if(apple.getColor().equals(color))&#123; result.add(apple); &#125; &#125; return result;&#125; 이런 식으로 코드를 짜면, 코드를 반복하여야지 않고 다양한 색에 대한 요구사항을 효율적으로 대응할 수 있을 것이다. 12List&lt;Apple&gt; greenApples = filterApplesByColor(inventory, GREEN);List&lt;Apple&gt; redApples = filterApplesByColor(inventory, RED); 하지만 사용자가 이번엔 색깔이 아닌 다른 요소(무게나 모양 등)로 요구사항을 제시한다면 어떻게 될까? 123456789public static List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple: inventory)&#123; if(apple.getWeight()&gt; weight)&#123; result.add(apple); &#125; &#125; return result;&#125; 이런 식으로 무게에 대한 새로운 메소드를 만들 수 있지만, 결국 색 필터링 코드와 대부분 중복된다.. 이런 중복된 코드는 성능 개선하려 할 때 메서드 전체 구현을 고쳐야 하는 대참사가 발생할 수 있다.. b-3. 세번째 시도, 가능한 모든 속성으로 필터링정말 해서는 안되는 방법이지만 이런 방법도 있긴하다. 123456789101112public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, Color color, int weight, boolean flag)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory)&#123; if((flag &amp;&amp; apple.getColor().equals(color)) ||(!flag&amp;&amp;apple.getWeight()&gt;weight))&#123; result.add(apple); &#125; &#125; return result;&#125;List&lt;Apple&gt; greenApples = filterApples(inventory, GREEN, 0, true);List&lt;Apple&gt; heaveyApples = filterApples(inventory, null, 150, false); 정말 형편없는 코드다.. 도대체 true와 false가 어떤 것을 의미하는 건가? 새로운 조건이 필요하면 어떻게 할 것인가? c. 동적 파라미터화요구 조건들을 어떤 속성에 기초해서 불리언값을 반환하는 형태로 구현할 수 있다. 참 거짓을 반환하는 함수를 프레디케이트 라고 한다. 123456789101112131415public interface ApplePredicate &#123; boolean test (Apple apple);&#125;public class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight()&gt;150; &#125;&#125;public class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return GREEN.equals(apple.getColor()); &#125;&#125; 이와 같은 방식을 전략 디자인 패턴이라고 부르는데, 각 알고리즘(전략이라고 부른다)을 캡슐화하는 알고리즘 패밀리를 정의해둔 다음에, 런타임이 알고리즘을 선택하는 기법이다. 즉 메서드가 다양한 동작(또는 전략)을 받아서 내부적으로 다양한 동작을 수행 할 수 있다. c-1. 네번째 시도, 추상적 조건으로 필터링ApplePredicate 인터페이스를 사용하면 이런 식으로 구현할 수 있다. 123456789public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory) &#123; if(p.test(apple)) &#123; result.add(apple); &#125; &#125; return result;&#125; 훨씬 좋아졌다!! 이를 바탕으로 무게가 150 이상이고 빨간 사과를 모아 달라는 요구조건을 해결해보자! 1234567public class AppleRedAndHeavyPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return RED.equals(apple.getColor())&amp;&amp; apple.getWeight()&gt;150; &#125;&#125;List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); 우리가 전달한 ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정된다!!!! 안타깝게도 메서드는 객체만 인수로 받으므로 test메서드를 ApplePredicate 객체로 감싸서 전달해야 했다. d. 복잡한 과정 간소화위에서 구현한 방식, 즉 프레디케이트로 필터링 할 경우, 조건 마다 여러 클래스를 정의한 다음, 인스턴트화 해야 하므로 번거롭다. 이를 익명 클래스의 람다 표현식으로 해결해보자 d-1. 다섯번째 시도, 익명 클래스 사용익명 클래스는 자바의 지역 클래스와 비슷한 개념이다. 익명 클래스는 클래스 선언과 인스턴스화를 동시에 한다. 익명 클래스를 활용한 ApplePredicate 객체를 생성하는 방식으로 필터링해보자 12345List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123; public boolean test(Apple apple)&#123; return RED.equals(apple.getColor()); &#125;&#125;); filterApples 메서드의 동작을 익명클래스로 직접 파라미터화 했다. 하지만 익명 클래스는 여전히 문제가 많다. 일단 람다에 비해 차지하는 공간이 많고, 이해하기도 어렵다. d-2. 여섯번째 시도, 람다 표현식 사용람다 표현식을 사용하면 굉장히 간단하게 구현할 수 있다. 1List&lt;Apple&gt; result = filterApples(inventory, (Apple apple)-&gt; RED.equals(apple.getColor())); d-3. 일곱번째 시도, 리스트 형식으로 추상화이제 사과 말고 다양한 개체들이 필터링 될 수 있도록 활용해보자 12345678910111213141516public interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T e: list) &#123; if(p.test(e)) &#123; result.add(e); &#125; &#125; return result;&#125;List&lt;Apple&gt; redApples = filter(inventory, (Apple apple)-&gt;RED.equals(apples.getColor());List&lt;Integer&gt; evenNumbers = filter(numbers, (Integer I)-&gt;i%2==0); 람다 표현식으로 인터페이스를 보다 용이하게 구현했다!!!! **e. 실전 예제 **e-1 Comparator로 정렬하기List.sort나 Collections.sort에 java.util.Comparator 객체를 이용해서 sort의 동작을 파라미터화 해보자 123456789101112// java.util.Comparatorpublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;inventory.sort(new Comparator&lt;Apple&gt;() [ public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;);inventory.sort((Apple a1, Apple a2)-&gt;a1.getWeight().compareTO(a2.getWeight()));","categories":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}],"tags":[{"name":"Modern Java in Action","slug":"modern-java-in-action","permalink":"https://yangdongjue5510.github.io/tags/modern-java-in-action/"}],"keywords":[{"name":"Java","slug":"java","permalink":"https://yangdongjue5510.github.io/categories/java/"}]},{"title":"4. 운영체제 구조 - 시스템콜, 커널 모드","slug":"cs/os/os4","date":"2021-07-29T06:22:24.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os4/","excerpt":"","text":"응용 프로그램, 운영체제, 컴퓨터 하드웨어 관계 운영체제는 프로그램이 요청하는 메모리를 허가, 분배 운영체제는 프로그램이 요청하는 CPU시간 제공 운영체제는 프로그램이 요청하는 IO device 사용을 허가 제어 사용자 - 응용 프로그램 - 운영체제 - 하드웨어 이런 식으로 연결된다고 보자! 운영체제는 사용자 인터페이스를 제공한다. 쉘(Shell) 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램. 쉘은 GUI환경과 CLI환경으로 나뉜다. 운영체제는 응용 프로그램을 위해서도 인터페이스를 제공한다 API(aplication programming interface) 프로그램이 운영체제에 뭔가를 요청할 수 있게 프로그램 안에 작성된 인터페이스 일종의 요청서로 이해하자. 함수로 제공된다. 각 언어별 운영체제 기능 호출 인터페이스 함수 시스템 콜 시스템 콜 또는 시스템 호출 인터페이스 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공 API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분. 운영체제 기능 호출 함수 운영체제를 만든다면? 운영체제를 개발한다.(kernel) 시스템 콜을 개발 C API(library) 개발 - 다른언어로도 개발 Shell 프로그램 개발 응용 프로그램 개발 운영체제와 시스템콜시스템 콜의 예시(POSIX API, 윈도우 API) CPU Protection Ringscpu도 권한 모드라는 것을 가지고 있다. 사용자 모드 커널 모드 : 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케하는 모드.이 사진에서 ring 3이 사용자 모드다. 가운데에 있는게 커널이다. 개발자가 만든 프로그램은 맨위에서 작동한다! 시스템콜은 커널 모드로 실행 커널 모드에서만 가능한 기능이 존재 커널 모드로 실행하려면, 반드시 시스템콜 거쳐야함 시스템콜은 운영체제 제공 왜 이렇게 나눴을까 함부로 응용 프로그램이 전체 컴퓨터 시스템을 해치지 못하게 하기 위함. 코드로 이해하기 정리 운영체제는 시스템 콜 제공 프로그래밍 언어 별 운영체제 기능을 활용하기 위한 시스템 콜 기반 API제공 응용 프로그램은 운영체제 기능 필요시 해당 API를 사용해 프로그램 작성 응용 프로그램 실행되서 운영체제 기능이 필요한 API를 호출하면, 시스템콜이 호출되서, 커널모드로 변경후, OS 내부에서 실행","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"3. 시대별로 이해하는 운영체제 핵심 개념","slug":"cs/os/os3","date":"2021-07-29T04:19:36.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os3/","excerpt":"","text":"1950년대ENIAC: 첫번째 컴퓨터.응용 프로그램 돌리기도 바빠 운영체제가 없었음. 응용 컴퓨터가 리소스를 관리. 1960년대 초반 프로그램 종류도 많아지고, 사용자도 늘기 시작. 배치 처리 시스템의 출현(batch processing system) 여러 응용 프로그램을 등록시켜놓으면, 순차적으로 실행시키는 시스템 두 프로그램의 순서를 일직선으로 실행.(하나에 한 프로그램만.) 프로그램을 어떤 순서로 등록하느냐에 따라 응용 프로그램의 실행 시간이 달라진다.(긴 프로그램하고 짧은 프로그램하기 vs 짧은 프로그램하고 긴 프로그램하기 였을 때 짧은 프로그램이 끝날때까지 얼마나 걸리나?) 단점 응답시간이 오래 걸릴 수 있다.(내 앞에 오래 걸리는 프로그램이 실행 될 경우) 실행시간도 오래 걸릴 수 있다.(CPU가 필요없는 상황에도 응용프로그램이 CPU를 점유 할 수 있음) 1960년대 후반 응용 프로그램이 CPU를 사용하는 시간을 쪼개서, 여러개의 응용 프로그램이 동시에 실행하는 기법 등장 시분할 시스템(Time Sharing System) : 다중 사용자 지원, 컴퓨터 응답 시간 최소화 멀티 태스킹(Multi Tasking) : 가능한 CPU를 많이 활용하도록 지원(시간 대비 CPU 사용률을 높이자.) 시분할 시스템컴퓨터 응답시간을 사용자가 요청하고 응답을 받을 때까지 걸린 시간이라고 한다.여러 사용자가 컴퓨터에 접속해 각 응용 프로그램을 실행하려고 할 때, 응답시간을 줄이는게 가장 중요하다.시분할 시스템은 시간을 특정 단위로 쪼개, 단위마다 각 프로그램들이 돌아가며 실행하는 방식이다. 멀티 태스킹단일 CPU에서 여러 응용 프로그램의 병렬 실행을 가능케하는 시스템.보통은 시분할 시스템과 비슷하게 통용되는 경우가 많음. 멀티 프로그래밍 : 최대한 CPU를 많이 활용하도록 하는 시스템어떤 프로그램이 CPU를 사용하는 시간 중 CPU가 아무 일도 안하는 시간은 다른 프로그램을 실행하도록 해주는 기능.(파일 입력을 기다리는 시간이 대표적) 1970년대 제대로 된 운영체제 등장 UNIX OS현대 운영체제의 기본 기술을 모두 포함한 최초의 운영체제 (멀티 태스킹, 시분할 시스템, 멀티 프로그래밍) 여기서 잠깐. 왜 C언어가 운영체제 개발에 필요한가?어셈블리 언어는 CPU와 메모리의 물리적인 주소로 직접 명령을 해서 개발한다. 이러면 각 컴퓨터마다 각각 다시 개발을 해줘야 된다..그런데 C언어는 컴파일러라는 녀석이 C언어를 해당 컴퓨터에 맞도록 어셈블리 언어로 변환해서 실행한다. 다른 컴퓨터에서 다시 작성할 필요가 없어진다. 1980년대 개인용 컴퓨터 시대 1980년대 이전에는 대형 컴퓨터에 여러 명이 접속해 사용(UNIX)1980년대 이후에는 PC시대가 시작. CLI에서 GUI로 전환 시작. CLI(command line interface) &#x3D; 터미널 환경 &#x3D; 키보드, 검은화면GUI(graphical user interface) &#x3D; GUI 환경 &#x3D; 마우스 1990년대 응용 프로그램 시대 (GUI 환경, PC 사용자 증가) 네트워크 기술 발전 - 월드와이드웹(WWW) 인터넷 대중화 오픈 소스 운동 활성화 2000년대 이후 오픈 소스 활성화(리눅스, 아파치, MySQL 등…) 가상 머신(가상으로 컴퓨터가 있는 것처럼 가상의 운영체제를 활용), 대용량 병렬 처리 활성화","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"2. 운영체제와 응용 프로그램의 관계","slug":"cs/os/os2","date":"2021-07-29T04:16:34.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os2/","excerpt":"","text":"응용 프로그램?응용 프로그램은 우리가 흔히 사용하는 엑셀이나 크롬같은 소프트웨어를 말한다.(그렇다고 모든 소프트웨어가 응용 프로그램인건 아니다. 우리가 공부하고 있는 운영체제도 소프트웨어 중 하나다.)즉 응용 프로그램은 소프트웨어 중 운영체제를 제외한 모든 소프트웨어를 의미한다. 운영체제와 응용 프로그램 간의 관계 운영체제는 응용 프로그램을 관리한다.응용프로그램을 실행시킨다.응용 프로그램간의 권한을 관리한다.(관리자 권한으로 실행)응용 프로그램을 사용하는 사용자도 관리한다.(로그인 과정) 응용 프로그램의 잚못된 작동을 저지한다.응용 프로그램이 잘못 동작해서, 프로그램을 정지시킨다.모든 파일 삭제를 막는다.(권한&#x2F;사용자 관리)한 응용프로그램이 지나친 cpu소모를 막는다. 결국 이 둘의 관계는 응용 프로그램을 관리 시스템 자원을 관리 사용자 컴퓨터간의 커뮤니케이션 지원 운영체제는 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고 지원하는 소프트웨어!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"1. 운영체제의 역할은 무엇일까?","slug":"cs/os/os1","date":"2021-07-29T04:16:29.000Z","updated":"2022-01-22T16:20:00.031Z","comments":true,"path":"2021/07/29/cs/os/os1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/29/cs/os/os1/","excerpt":"","text":"운영체제 역할1: 시스템 자원(System Resource) 관리자 operating system 혹은 os라고 부름 시스템 자원 &#x3D; 컴퓨터 하드웨어cpu(중앙처리장치), 메모리(dram, ram)IO devices (monitor, mouse, keyboard, network…)저장매체: SSD, HDD 컴퓨터의 하드웨어는 혼자서 뭘 혼자 하지 못한다. 운영체제가 이를 운영한다. 대표적인 운영체제 windows os, mac os, unixunix는 현대 os의 기술을 최초로 구현한 운영체제. 윈도우즈와 맥 운영체제도 영향을 받았음 unix 계열 osunix 사용법이나 os구조가 유사(리눅스가 대표적.) 운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원운영체제 역할3: 컴퓨터 하드웨어와 프로그램을 제어컴퓨터 하드웨어 뿐만 아니라, 프로그램을 관리한다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"OS","slug":"computer-science/os","permalink":"https://yangdongjue5510.github.io/categories/computer-science/os/"}]},{"title":"7. 힙","slug":"cs/datastructure/ds7","date":"2021-07-28T13:02:01.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds7/","excerpt":"","text":"힙힙을 알기 위해서는 트리에 대한 기본적인 지식이 필요하다. 힙의 특성어떤 특정 값을 찾아내는 기능은 지원하지 않지만,값을 삽입하고, 최대값(최소값)을 찾거나 삭제하는데 큰 강점을 가진 자료구조.만약 최소값을 찾거나 삭제하고 싶으면 힙성질을 반대로 설정하면 된다. 간단한 용어 설명 트리 표현법 표현법 1:level 0 부터 해당 노드 자리에 노드가 있으면 노드이름을 쓰고, 없으면 None이라고 써서 가능한 모든 자리만큼 원소를 갖는 리스트로 표현. 표현법 2:트리의 수직적 관계를 리스트 속 리스트를 활용해 표현하기. [부모노드, [부모노드의 왼쪽 서브트리], [부모노드의 오른쪽 서브트리]]. 이때 빈 노드나 서브트리는 빈 리스트 []로 표현한다. 표현법 3: 노드 클래스 활용각 노드를 노드클래스로 구현해서 객체를 부여해 구현. 힙이란? 힙이란 1차원 배열 중 저장된 값이 힙 조건에 만족하는 배열을 의미. 힙조건힙 조건에는 크게 모양 조건과 값 조건이 있다. 모양 조건 : 리스트(배열)을 이진트리로 해석했을 경우. 마지막 레벨을 제외한 각 레벨엔 빠짐없이 노드가 존재한다. 마지막 레벨의 노드는 왼쪽부터 차례대로 빈틈없이 채워진다. 값 조건루트 노드를 제외한 모든 노드의 값은 부모 노드의 값보다 크지 않아야 한다!!(또는 각 노드의 값은 자신의 자손 노드들의 값보다 같거나 커야 한다.) 인덱스 값 구하기힙 조건을 만족하는 배열(리스트)A의 노드 A[k]가 있을 때, 왼쪽노드 : A[2k+1] 오른쪽노드 : A[2k+2] 부모노드 : A[(k-1)&#x2F;2] 이렇게 왼쪽, 오른쪽, 부모 노드의 인덱스를 구할 때는 O(1)의 복잡도를 가진다. 힙 값 조건을 만족시키도록 만드는 연산힙이 될려면, A[k]가 자신의 자식 노드들과 같거나 커야한다. 이를 위해 A[k]를 자식노드와 비교 하면서 더 큰 자식을 찾으면 서로 swap해줘야 한다.(인덱스로 하면 된다.) 이 과정을 더이상 할 필요가 없을때까지 반복하면 힙의 값 조건을 만족하게 된다. 1234567891011121314151617def heapify_down(self, k, n): while 2*k+1&lt;n: L,R = 2*k+1 , 2*k+2 if L&lt;n and self.A[L] &gt; self.A[k]: m=L else: m = k if R&lt;n and self.A[R] &gt; self.A[m]: m = R if m != k: self.A[k], self.A[m] = self.A[m], self.A[k] k = m else : breakdef make_heap(self): n = len(self.A) for k in range(n-1, -1, -1): self.heapify_down(k, n) heapify_down 연산은 O(힙의 높이)이고, make_heap의 연산은 heapify_down연산을 n번 하는 것이므로 O(n*힙높이)이다. 힙의 높이와 힙 원소 갯수 사이의 관계 힙의 높이를 h라고 하고 원소 갯수 n개라고 했을 때, 레벨 0 :1개 &#x2F; 레벨 1: 2개 &#x2F; 레벨 3: 4개 …..레벨 h-1 : 2^(h-1) &#x2F; 레벨 h : 최소 1개 이다. 즉 1+2+4+8+….2^(h-1)+1 &lt;&#x3D;n 이 되고, (2^h -1) &#x2F; (2-1) + 1 &lt;&#x3D; n 2^h-1+1 &lt;&#x3D; n 2^h&lt;&#x3D;n h &lt;&#x3D; logn 이라는 관계가 성립한다. 이 관계를 토대로 heapify_down 과 make_heap 연산을 보면, heapify_down은 O(log n), make_down은 O(nlog n) 엄밀히 말하면 O(n)이다. 이 된다. 힙 정렬힙 조건을 만족하는 배열을 정렬시키는 방법. 주어진 배열 A가 힙일 경우, 힙의 루트 노드에는 항상 전체의 최대값이 저장되어 있다 루트 노드의 값(현재 최대값) A[0]을 현재 리스트의 가장 마지막 값과 바꾼다. 새로 루트 노드에 온 값은 힙 성질을 만족하지 않을 수 있다. 루트 노드를 heapify_down 을 통해 힙의 위치를 찾아가도록 한다. 위 과정을 (n-1)번 반복하면 (n-1)개가 정렬되어 모든 n이 정렬된다. 123456def heap_sort(self): n = len(self.A) for k in range(len(self.A)-1, -1, -1): self.A[0], self.A[k] = self.A[k], self.A[0] n = n -1 self.heapify_down(0, n) heap_sort의 수행시간은 루트노드와 마지막 리프노드 자리바꾸고 heapify를 (n-1)번 하므로, (n-1)*O(log n) &#x3D; O(nlog n) 힙 삽입일단 삽입할 값을 리프노드로 넣고, 힙 성질에 맞는 위치로 가도록 올려보내는 것. 일단 힙 성질에 맞는 위치로 가는 heapify_up 함수를 만들어 insert함수에 적용시키도록 해보자! 1234567def heapify_up(self, k): while k&gt;0 and self.A[(k-1)//2 ] &lt; self.A[k] : self.A[k], self.A[(k-1)//2] = self.A[(k-1)//2], self.A[k] k = (k-1)//2def insert(self, key): self.A,append(key) self.heapify_up(len(self.A)-1_ insert의 수행시간은 O(h&#x3D;log n) 시간이 걸린다. 최대값을 찾고 삭제하기이전에도 여러번 말했듯이, 힙에서 최대값은 바로 루트노드다!최대값을 찾는다면 그냥 A[0]을 반환하면 된다! 참 쉽다! 근데 최대값을 삭제하는건 좀 까다롭다.최대값을 삭제하고 나서도 힙을 유지하려면 약간의 조정이 필요하기 때문이다. 최대값 삭제일단 최대값을 삭제하려면 루트 노드를 지우고, 맨 마지막 리프노드를 루트 노드 자리에 둔다.그러면 당연히 힙 조건을 벗어나게 되는데, heapify_down 연산을 통해 힙 성질을 만족시킨다! 1234567def delete_max(self): if len(self.A) == 0 : return None key = self.A[0] self.A[0], self.A[len(self.A)-1] = self.A[len(self.A)-1], self.A[0] self.A.pop() heapify_down(0, len(self.A)) return key 최대값 삭제의 경우, 루트노드와 마지막 노드 자리바꾸고 heapify_up하므로 O(h &#x3D; log n) 시간이 걸린다. 수행시간 정리 heapfify_up, heapify_down : O(log n) make_heap : O(n log n) -&gt; O(n) insert : O(log n) delete_max : O(log n) heap_sort : O(n log n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"6. 이진트리","slug":"cs/datastructure/ds6","date":"2021-07-28T11:27:03.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds6/","excerpt":"","text":"이진트리? 자식노드가 최대 2개 뿐인 트리를 이진트리라 한다!! 1234567891011121314class Node: def __init__(self, key, parent=None, left=None, right=None): self.key = key self.parent = parent self.left = left self.right = right def __str__(self): return str(self.key) class Tree: def __init__(self): self.root = None self.size = 0 이진트리의 순회이진트리 노드 key값을 빠짐없이 출력하는 방법! preorder inorder postorder 헤더 노드를 M, 왼쪽 서브트리를 L, 오른쪽 서브트리를 R이라고 가정! 쉽게 생각하면 L, M, R이 삼각형 모양으로 있을 때 우선순위 노드가 있으면 해당 노드를 먼저 탐색하는 방식이다! preorderMLR 순으로 방문하는 방식FBADCEGIH 순으로 방문하게 된다! inorderLMR 순으로 방문하는 방식ABCDEFGHI postorderLRM 순으로 방문하는 방식ACEDBHIGF 코드로 구현하기1234567891011121314151617181920212223242526272829303132class Node: def __init__(self, key, parent=None, left=None, right=None): self.key = key self.parent = parent self.right = right self.left = left def __str__(self): return str(self.key) class Tree: def __init__(self): self.root = None self.size = 0 def preorder(self, v): if v: print(v.key, end=&#x27; - &#x27;) self.preorder(v.left) self.preorder(v.right) &#x27;&#x27;&#x27; inorder는? if v: self.inorder(v.left) print(v.key, end=&#x27; - &#x27;) self.inorder(v.right) postorder는? if v: self.postorder(v.left) self.postorder(v.right) print(v.key, end=&#x27; - &#x27;) 즉 재귀 알고리즘을 활용하여 print문의 위치를 바꿔가면서 구현하는거다!!!&#x27;&#x27;&#x27; 이진탐색트리 BST이진트리 중에 가장 많이 쓰이는 트리!이진트리의 노드를 search할 때 효율적으로 할 수 있게! 특징 각 노드의 왼쪽 서브트리의 key값은 노드의 key값보다 작거나 같아야 한다. 반면 오른쪽 서브트리의 key값은 노드의 key값보다 작거나 같아야 한다. 이런 특징이 탐색이 효율적으로 되게 한다!이진트리의 탐색 연산은 O(h&#x3D;트리 높이)이므로, 만약 이진트리의 강점을 극대화하고 싶으면, 트리의 높이를 최소화 하는 방향으로 설계해야 한다! 코드로 구현 12345678class BST: def __iniit__(self): self.root = None self.size = 0 def __len__(self): return self.size def __iter__(self): return self.root.__iter__() 탐색 함수 search와 삽입 함수 insert탐색 함수와 삽입함수를 구현하기 전에, 해당 노드가 있다면, 해당 노드를 반환하고, 없다면 노드가 삽입될 위치의 부모노드를 반환하는 find_loc 함수를 먼저 구현해보자! 12345678910111213def find_loc(self, key): if self.size == 0: return None p = None v = self.root while v != None: if v.key == key : return v elif v.key &lt; key : p = v v = v.right else : p = v v = v.left return p 이제 find_loc함수를 활용해 search함수를 만들어보자! 123456def search(self, key): v = self.find_loc(key) if v and v.key==key: return v else : return None 노드를 삽입하는 insert함수도 만들 수 있다! 1234567891011def insert(self, key): v = Node(key) if self.size==0 : self.root = v else : p = self.find_loc(key) if p and p.key != key: if p.key &lt; key: p.right = v else : p.left = v v.parent = p self.size += 1 return v 여기서 잠깐 생각해보자. 만약 삽입 연산을 한다고 할 때, 삽입 순서에 따라 트리 모양도 달라질 수 있을까? find_loc, insert, search의 수행시간search, insert 모두 find_loc의 수행시간과 동일하다. (그 외 연산은 모두 상수시간에 이뤄지니까)find_loc은 최악의 경우 트리의 높이 만큼 수행시간이 걸리므로, O(h) 이다. 삭제 함수 delete이진 트리에서는 크게 두가지 방법이 있다. delete by merging delete by copying delete by merging어떤 노드를 지우게 되면 그 노드의 왼쪽 서브트리가 지운 노드의 자리에 오고 지운 노드의 오른쪽 서브트리는 왼쪽 서브트리의 자식 노드가 된다! 이때 삭제할 노드가 루트노드인 경우와 그렇지 않은 경우 두가지로 나뉜다. 삭제할 노드를 x, 왼쪽 자식노드 a, 오른쪽 자식노드 b, x의 왼쪽 서브트리중 가장 큰 노드 m이라 하고 x의 부모노드를 pt라고 하자. 만약 삭제할 노드가 루트노드일 경우 m이 존재 할 경우(if a!&#x3D;None) : b가 m의 오른쪽 자식노드가 되도록 링크 수정, a가 루트노드가 되도록 변경 a &#x3D;&#x3D; None이면 : b가 새로운 루트노드가 됨 만약 삭제할 노드가 루트노드가 아닌 경우 m이 존재 할 경우(if a!&#x3D;None) : b가 m의 오른쪽 자식노드가 되도록 링크 수정, a가 pt의 자식노드가 되도록 변경 a &#x3D;&#x3D; None이면 : b가 pt의 자식노드가 되도록 변경 코드로 구현해보자 12345678910111213141516171819def deleteMerging(self, x) &#123; a, b, pt = x.left, x.right, x.parent if a == None: c = b else: c = m = a while m.right: m = m.right m.right = b if b: b.parent = m if self.root == x : #c가 새로운 루트노드가 된다. if c: c.parent = None self.root = c else : if pt.left == x : pt.left = c else: pt.right = c if c: c.parent = pt self.size -= 1&#125; delete by copying어떤 노드 x를 삭제하려 할 때, 왼쪽 서브 트리를 L, 오른쪽 서브 트리를 R이라고 하자. L에서 가장 큰 노드 y를 찾는다. y의 key 값을 x의 key값으로 카피한다. y의 왼쪽 서브트리가 존재하면, y의 자리로 옮긴다. 코드로 만들어보자 123456789101112131415161718def deleteByCopying(self, x)&#123; L, R = x.left, x.right if L == None : x.key = R.key if R.right: x.right = R.right R = None else : m = L while m.right: pt = m m = m.right x.key = m.key if m.left: pt.right = m.left m.left.parent = pt m = None&#125; delete by merging, delete by copying 의 수행 시간 두 연산 모두 지우려는 노드의 왼쪽 서브트리에서 가장 큰 노드 m을 찾는 연산이 중요. 두 경우 모두 최악의 경우 트리의 높이까지 m을 찾아야 하므로, O(h)이다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"5. 스택과큐","slug":"cs/datastructure/ds5","date":"2021-07-28T11:00:30.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds5/","excerpt":"","text":"a. 스택 Stack차례대로 삽입하고 최근에 저장된 값을 삭제(FILO) push스택에 값 추가pop가장 나중에 push된 값을 스택에서 제거하고 반환top가장 나중에 push된 값을 제거하지 않고 반환__len__스택의 저장된 요소 갯수를 반환isEmpty스택에 요소가 존재하는지 참거짓 1234567891011121314151617181920212223242526272829# stack_queue.py 에 저장class Stack: def __init__(self): self.items = [] # 데이터 저장을 위한 리스트 준비 def push(self, val): self.items.append(val) def pop(self): try: # pop할 아이템이 없으면 return self.items.pop() except IndexError: # indexError 발생 print(&quot;Stack is empty&quot;) def top(self): try: return self.items[-1] except IndexError: print(&quot;Stack is empty&quot;) def __len__(self): # len()로 호출하면 stack의 item 수 반환 return len(self.items) def isEmpty(self): return self.__len__() == 0# for testS = Stack()S.push(10)S.push(2)print(S.top())print(S.pop())print(len(S))print(S.isEmpty()) b. 스택 활용b-1. 괄호짝 맞추기입력 값 : 괄호로 이뤄져 있는 문자열 ex. ()()() 반환 값 : 괄호 짝이 맞는지 참 거짓 ex. True 12345678910111213141516171819202122232425262728293031323334353637383940class Stack: def __init__(self): self.item=[] def push(self, a): self.item.append(a) def pop(self): try: return self.item.pop() except IndexError: print(&#x27;Stack is empty.&#x27;) def top(self): try: return self.item[-1] except IndexError: print(&#x27;Stack is empty.&#x27;) def __len__(self): return len(self.item) def isEmpty(self): return len(self.item)==0 # pseudo codedef parChecker(parSeq): S=Stack() for i in parSeq: if i ==&#x27;(&#x27;: S.push(&#x27;(&#x27;) elif i ==&#x27;)&#x27;: if S.isEmpty(): print(False) return False else : S.pop() if S.isEmpty(): print(True) return True else : print(False) return FalseparSeq=list(input())parChecker(parSeq) b-2. infix 수식을 postfix로 바꾸기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Stack: def __init__(self): self.items = [] def push(self, val): self.items.append(val) def pop(self): try: return self.items.pop() except IndexError: print(&quot;Stack is empty&quot;) def top(self): try: return self.items[-1] except IndexError: print(&quot;Stack is empty&quot;) def __len__(self): return len(self.items) def isEmpty(self): return self.__len__() == 0def infix_to_postfix(infix): opstack = Stack() outstack = [] token_list = infix.split() # 연산자의 우선순위 설정 prec = &#123;&#125; prec[&#x27;(&#x27;] = 0 prec[&#x27;+&#x27;] = 1 prec[&#x27;-&#x27;] = 1 prec[&#x27;*&#x27;] = 2 prec[&#x27;/&#x27;] = 2 prec[&#x27;^&#x27;] = 3 for token in token_list: if token == &#x27;(&#x27;: opstack.push(token) elif token == &#x27;)&#x27;: while True: if opstack.top()==&#x27;(&#x27;: opstack.pop() break else : outstack.append(opstack.pop()) elif token in &#x27;+-/*^&#x27;: while True: if opstack.isEmpty(): opstack.push(token) break elif prec[opstack.top()]&gt;=prec[token]: outstack.append(opstack.pop()) else: opstack.push(token) break else: # operand일 때 outstack.append(token) # opstack 에 남은 모든 연산자를 pop 후 outstack에 append for i in range(opstack.__len__()): outstack.append(opstack.pop()) return &quot; &quot;.join(outstack)infix_expr = input()postfix_expr = infix_to_postfix(infix_expr)print(postfix_expr) b-3. Postfix 계산12345678910111213141516171819202122232425262728293031323334353637383940class Stack: def __init__(self): self.items=[] def push(self, val): return self.items.append(val) def pop(self): try: return self.items.pop() except IndexError: print(&#x27;stack is empty&#x27;) def top(self): try: return self.items[self.items.len()-1] except IndexError: print(&#x27;stack is empty&#x27;) def __len__(self): return self.items.len()def compute_postfix(postfix): opstack = Stack() token_list = postfix.split() for i in token_list: if i in &#x27;+-*/^&#x27;: a=opstack.pop() b=opstack.pop() if i ==&#x27;+&#x27;: opstack.push(a+b) elif i ==&#x27;-&#x27;: opstack.push(b-a) elif i ==&#x27;*&#x27;: opstack.push(a*b) elif i ==&#x27;/&#x27;: opstack.push(b/a) elif i ==&#x27;^&#x27;: opstack.push(b**a) else: opstack.push(int(i)) print(&#x27;%.4f&#x27;%opstack.pop())postfix=input()compute_postfix(postfix) c. 인터뷰 문제1. 스택을 하나 혹은 두개 사용해 push, pop, min 세 연산 모두 O(1) 시간에 수행되도록 하려면? 2. 스택 두 개를 써서 큐를 구현해라.(enqueue, dequeue를 구현하라) a. 큐 Queue가장 최근에 저장된 값 다음에 저장. 반환은 가장 먼저 저장된 값부터. FIFO(First in First out)원칙. enqueue큐의 오른쪽에 삽입(push와 같음)dequeue가장 왼쪽에 저장된 값을 삭제 후 리턴front가장 왼쪽에 저장된 값을 삭제하지 않고 리턴isEmpty큐가 비어져있는지 참거짓len큐의 요소 갯수 반환 12345678910111213141516171819202122class Queue: def __init__(self): self.items=[] self.front_index=0 #다음 dequeue될 값의 인덱스 def enqueue(self, val): self.items.append(val) def dequeue(self): if len(self.items)==0 or self.front_index==len(self.items): print(&quot;Queue is empty&quot;) else : x = self.items[self.front_index] self.front_index +=1 return x def front(self): if len(self.items) ==0 or self.front_index == len(self.items): print(&quot;queue is empty&quot;) else: return self.items[self.front_index] def __len__(self): return len(self.items)-self.front_index def isEmpty(self): return len(self) dequeue를 상수시간에 실행하기 위해선 dequeue가 될 값의 인덱스를 저장하고 관리해야 한다. -&gt; dequeue가 되면, 그 값을 실제로 지우는 것이 아닌 front_index값을 하나 늘려가며 다음 dequeue 될 예정 값의 인덱스를 가르키도록 관리한다. 실제로 dequeue될 때마다 값을 삭제시키면, 모든 값들을 한 칸씩 왼쪽으로 이동하는 시간이 소요되게 된다.O(n) a-1. 큐 활용 : Josephus game12345678910import Queue #큐 클래스 import. 이 부분은 달라질 수 있음def Josephus(n, k): Q=Queue() for v in range(1, n+1): Q.enqueue(v) while len(Q)&gt;1: for i in range(1, k): Q.enqueue(Q.dequeue()) Q.dequeue() #k번째 수 제거 return Q.dequeue() b. Dequeue왼쪽과 오른쪽에서 모두 삽입과 삭제가 가능한 큐 두 가지 버전의 pop과 push 연산을 구현 python collections 모듈에 deque 클래스로 구현되어 있음(덱으로 발음) 오른쪽 push : append &#x2F; 왼쪽 push : appendleft 오른쪽 pop : pop &#x2F; 왼쪽 pop : popleft","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"4. 해쉬테이블","slug":"cs/datastructure/ds4","date":"2021-07-28T11:00:17.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds4/","excerpt":"","text":"a. 해시테이블해시 테이블은 일종의 정보를 저장하는 서랍장. a는 2층에 b는 3층에 c는 1층에 넣어두는 방식…b를 보고 싶으면 어떤 서랍에 넣었는지 알아내서, 3층 서랍에 있는 내용 중에 b와 일치하는 것을 찾는 것. 해시테이블은 삽입, 삭제, 검색 연산을 빨리 처리할 수 있다. 만약 순서대로 정보를 서랍장에 넣었을 경우, 어떤 정보를 찾으려 할 때 일일히 순차적으로 찾아야 된다. 하지만 해시테이블은 그런 식으로 연산하지 않는다. 바로 해시 함수라는 것을 이용하기 때문에 보다 빠른 연산속도를 갖는다. 해시테이블 자료구조에서 가장 핵심은 각 정보들을 어떤 서랍에 넣을지를 결정하는 것!!! 정보를 어떤 서랍장(슬롯)에 넣을지를 결정하는 것이 바로 해시 함수!!!(f()로 표현) 예를 들어, 해시 테이블 H를 int H[10]으로 선언해 사용한다고 하자 해시 함수는 f(K) &#x3D; K % 10로 정의했다고 하자. K &#x3D; 28은 H[f(28)] 슬롯에 저장된다. 즉 H[8]에 저장된다. 근데 K &#x3D; 18도 H[8]에 저장되어야 한다. 근데 이미 H[8]에는 28이 저장되어 있다.이런 경우를 충돌이 발생했다고 한다. 충돌이 발생한 경우, 해당 슬롯에 18도 저장할 공간이 더 있으면 그냥 저장하면 되지만,그렇지 않은 경우 18을 다른 곳에 저장해야한다. 이때 다른 곳을 정하는 방법을 충돌해결방법이라 한다. 결국 해시테이블에서 중요한 건 테이블을 어떤 방식으로 저장할 것인가? : 파이썬에서는 리스트로 저장 해시 함수를 어떻게 만들 것인가? 충돌 해결은 어떻게 할 것이가? 이렇게 세가지가 성능을 좌우한다. b. 해시 함수해시 함수에는 어떤 것들이 있는지 살펴보자. b-1. 완전 해시 함수 충돌없이 일대일 매핑하는 해시 함수 예를 들어 100개의 슬롯을 가지고 있는 H에 50개의 값을 저장한다고 할때, 100^50&#x3D;10^100개의 함수가 만들어질 수 있는데, 완전 해시 함수는 100C50 &#x3D; 10^94이므로, 임의의 함수고 완전 해시 함수일 확률은 10^-6으로 아주 작다… 비현실적이고, 구현하기도 까다롭다. b-2. c-universal 해시 함수서로 다른 두 key 값 x, y에 대해 prob(f(x)&#x3D;&#x3D;f(y)) &#x3D; c&#x2F;size(H)이 성립하는 해시 함수 즉 f(x)와 f(y)가 같을 가능성이 c&#x2F;size(H)인 해시 함수를 c-universal 해시 함수라고 한다. 여기서 c는 0보다 큰 실수 상수이다. 비교적 골고루 매핑하고 완전해시 함수보다 계산하기 쉬워 현실적이다. b-3. 현실에서 자주 쓰이는 해시 함수들 (key값이 수일 경우)m &#x3D; 해시테이블의 크기 mod &#x3D; 나머지를 구하는 연산 Division : f(k) &#x3D; (k mod p) mod m (p &#x3D; 소수)key 값들의 성질이 잘 알려져 있지 않은 경우에 유용 Folding : key 값이 digit를 나눠 연산하는 형식k&#x3D;1254-387-601 이라 할 때, shift folding : 두 digit씩 나눠 모두 더한 뒤 mod m -&gt;(12+54+38+76+01) mod m boundary folding : 여러 digit로 나눈 후 더하는데 짝수번 조각은 거꾸로해서 더함 -&gt;(12+45+38+67+01)mod m Mid-Square : key 값을 적당히 연산 후, 그 결과의 중간 부를 떼어나 주소로 이용 m &#x3D; 1000, k &#x3D; 3121 이면, 3121^2&#x3D;9740641에서 중간에 3digit를 떼어낸 406이 주소가 됨 Extraction : key 값의 각 파트마다 임의의 digit을 떼어내 연결k&#x3D;1254-387-601 일 때 1254의 12, 601에서 1을 떼어내 121을 주소로 함 b-4. 현실에서 자주 쓰이는 해시 함수들 (key값이 문자열일 경우)key[i]는 ascii 코드 값 정도로 하자. Additive hash : key[i]의 단순 합 Rotating hash : &lt;&lt;, &gt;&gt;(비트 쉬프트) 연산과 ^(xor, exclusive or) 연산을 반복 Universal hash #좋은 해쉬 함수란? 충돌이 적어야 한다. 빠르게 계산할 수 있어야 한다. c. 충돌 해결 방법충돌 해결 방법에는 Open addressing과 Chasing 두 가지 방법이 있다. c-1. Open addressing : linear probing예시를 통해 이해해보자! H의 슬롯에는 값 하나만 저장할 수 있다고 가정 해시 함수에 의해 알파벳 다음 수가 저장될 슬롯이라고 가정하자 open addressing은 내가 들어갈 자리가 이미 차 있다면(충돌이 발생했다면) 아래쪽 슬롯으로 순차적으로 탐색하면서 가장 먼저 만난 빈 슬롯에 저장하는 것이다. 만약 마지막 자리까지 차있다면, 맨 처음 슬롯부터 다시 빈 자리를 찾는다. c-1-1. open addressing : linear probing 구현해시 테이블 H의 각 슬롯에는 하나의 아이템을 저장한다고 하자. 아이템은 (key, value) 쌍으로 정의되는데,key는 아이템을 구분하는데 쓰이므로 서로 달라야 하고, value는 해당 아이템의 정보를 의미한다. 123456789class HashOpenAddr: def __init__(self, size=10): self.size = size self.keys = [None]*self.size self.values = [None]*self.size def __iter__(self): for i in range(self.size): yield self.keys[i] c-1-2. 삽입 연산find_slot(key) :key값을 갖는 아이템을 찾아 슬롯 번호를 리턴 key값을 갖는 아이템을 못 찾으면, 해당 아이템이 저장되어야 할 슬롯 번호를 리턴 만약 슬롯이 존재하지도 않고 빈 슬롯도 없으면 FULL 리턴 1234567def find_slot(self, key): i = self.hash_function(key) start = i while self.keys[i] != None and self.keys[i] != key: i = (i+1) % self.size if i == start : return None return i set(key, value) : find_slot(key)를 요긴하게 사용한다!!key 값을 갖는 아이템이 테이블에 있으면 해당 아이템의 value를 매개변수 value로 수정하고 key 리턴 없다면 새 아이템 (key, value) 삽입하고 key 리턴 테이블에 빈 슬롯이 없어 삽입하지 못하고 key 값을 갖는 아이템도 못찾았으면 FULL 리턴 12345678910def set(self, key, value=None): i = self.find_slot(key) if i == None: return None if self.keys[i]!=None: self.values[i]=value else: self.keys[i]=key self.values[i] = value return key c-1-3. 삭제 연산remove(key): 어려우니 천천히 살펴보자 key값을 갖는 아이템을 find_slot(key)를 통해 찾고 i에 저장하자 H[i]에 해당 값이 없다면, 삭제할 아이템이 실제로 존재하지 않음을 의미. None 리턴 H[i]가 존재하면, 이 아이템이 삽입 될 때 다른 아이템이 아래쪽으로 밀렸을 가능성을 생각해야한다 아래쪽으로 밀린 아이템이 있다면, 해당 아이템들을 연쇄적으로 위로 올려야 한다. 일단 H[i]를 지우고, 아래 쪽 H[j]에 있는 아이템들을 H[i]로 이동할지 결정해야 한다. H[j]의 키 값을 해시함수 결과값을 k로 하자. (즉 원래 들어가야했을 자리를 k라고 하자) 이때 k가 i&lt;k&lt;&#x3D;j 면 H[j]를 H[i]로 옮기면 안된다!왜냐면, 원래 위치 k가 j에 있게 된 이유가 i 때문은 아니라는 것을 의미하기 때문이다.즉 i에 밀려 j로 간 게 아니다.(다른 이유로 밀렸을 것이다.) 또한 해시 테이블은 원형이기 때문에, i &gt; j 일 가능성도 있다 그러면 j가 한바퀴를 돌아 j&lt;i&lt;k, k&lt;&#x3D;j&lt;i 이 두 구간도 옮기면 안된다.(i때문에 k에 있어야 할 게 j로 간 것이 아니므로) 이 세가지 경우가 아니라면, H[j]를 H[i]로 옮긴다.(결국 옮기는 경우는 두가지다. k값이 i와 같거나(i 때문에 j로 밀림) k&lt;i&lt;j 이거나 (k에 이미 값이 있어서 내려왔는데 i에도 값이 있어 j로 간 경우)) 그러면 이제 H[j]가 빈 슬롯이 되니 다시 4번으로 돌아가 반복한다. 123456789101112131415161718def remove(self, key): i = self.find_slot(key) j = i if i == None : return None if self.keys[i] == None : return None while True: self.keys[i]=None self.values[i]=None while True: j = (j +1) % self.size if self.keys[j] == None: return key k = self.hash_function(self.keys[j]) if not (i&lt;k&lt;=j or j&lt;i&lt;k or k&lt;=j&lt;i): break self.keys[i] = self.keys[j] self.values[i] = self.values[j] i = j c-1-4. 탐색 연산search(key) :key 값을 갖는 아이템을 찾아 value(혹은 key)값을 리턴 없으면 None 리턴 123456def search(self, key): i = self.find_slot(key) if i != None: if self.keys[i] != None: return self.keys[i] return None c-2. Chaining슬롯에 값 하나만 저장하는게 아니라, 각 슬롯마다 연결리스트를 연결하여 슬롯 당 이론적으로 무한한 갯수 값을 저장하는 방법 1234567891011121314151617181920212223242526class HashChain: def __init__(self, m): self.size = m # 슬롯의 갯수 m self.H = [None] * self.size def hash_function(self, key): return f(key) # return hash value for key def find_slot(self, key): # chaining이므로 빈 슬롯을 찾을 필요없이 해시함수값을 리턴 return self.hash_function(key) def set(self, key, value): i = self.find_slot(key) v = self.H[i].search(key) if v == None: # key 값을 갖는 노드가 없다면 삽입연산 self.H[i].pushFront(key, value) # (key, value) 노드를 head 노드 위치에 삽입! else: # 기존의 key값을 갖는 노드가 있으므로 value값 수정 v.value = value def remove(self, key): i = self.find_slot(key) v = self.H[i].search(key) if v == None return NOTFOUND else: self.H[i].deleteNode(v)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"3. 양방향리스트","slug":"cs/datastructure/ds3","date":"2021-07-28T11:00:09.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds3/","excerpt":"","text":"a. 왜 양방향 연결 리스트가 필요한가?한방향 연결 리스트는 다음 노드를 연결하는 링크만 존재, 이전 노드를 알려면 head부터 다시 탐색을 해야된다… 이런 불필요한 연산을 줄이고자 이전 노드를 연결하는 링크가 있는 양방향 연결 리스트를 구현하고자 한다. 양방향 연결 리스트의 주요 개념은 다음과 같다. 이전 노드로의 링크(prev)를 포함해 이전 노드로 이동 가능 마지막 노드와 첫 노드가 서로 연결된 원형 리스트를 가정 첫 노드(head)는 항성 dummy 노드가 되어야 함(dummy 노드는 리스트의 처음을 구분해주는 마커 기능을 하는 특별한 노드다.) b. 노드 클래스1234567class Node: def __init__(self, key=None): self.key = key self.next = self.prev = self #두개의 링크가 자기 자신에게 향함 def __str__(self): #print(node)했을 경우 출력할 문자열 return str(self.key) c. 양방향 연결 리스트 클래스12345678class DoublyLinkedList: def __init__(self): self.head = Node() self.size = 0 #아래 함수들은 한방향 리스트와 같다. def __iter__(self): def __str__(self): def __len__(self): c-1. splice(a,b,x) 연산 *중요*노드 a부터 노드 b까지를 떼어내 노드 x 뒤에 붙여 넣는 연산 이때, 두 가지 조건이 만족되어야 한다. 조건 1 : a와 b가 동일하거나 a 다음에 b가 나타나야 함 조건 2 : head 노드(dummy)와 x는 a와 b 사이에 포함되면 안됨. 1234567891011121314151617def splice(self, a, b, x): if a == None or b == None or x == None : return ap = a.prev bn = b.next #자르는 연산 ap.next = bn bn.prev = ap #x뒤에 a~b를 삽입 xn = x.next xn.prev = b b.next = xn a.prev = x x.next = a c-2. 탐색 및 기본 연산search(key) : key 값 가지는 노드 리턴, 없으면 None 리턴 isEmpty() : 빈 리스트면 True, 아니면 False first(), last() : 처음과 마지막 노드를 리턴, 빈 리스트면 None 리턴 12345678910111213141516171819202122232425262728def search(self, key): v = self.head while v.next !=self.head: if v.key==key: return v v=v.next return Nonedef isEmpty(self): v = self.head if v.next ==self.head: return True else: return False def first(self): v = self.head if v.next!=self.head: return v.next else: return None def last(self): v = self.head if v.prev != self.head: return v.prev else: return None c-3. 이동과 삽입 연산*splice 함수가 매우 빈번하게 사용된다!!!!* 1234567891011121314151617def moveAfter(self, a, x): #노드 a를 노드 x 뒤로 이동 self.splice(a, a, x) #a를 떼어내어 x뒤로 붙인 것과 같다def moveBefore(self, a, x): #노드 a를 노드 x 앞으로 이동 self.splice(a, a, x.prev)def insertAfter(self, x, key): #key값을 갖는 노드를 x뒤에 삽입 moveAfter(Node(key), x)def insertBefore(self, x, key): #key값을 갖는 노드를 x앞에 삽입 moveBefore(Node(key), x) def pushFront(self, key): # key값을 갖는 노드를 헤드 뒤에 삽입 insertAfter(self.head, key)def pushBack(self, key): # key값을 갖는 노드를 헤드 앞에 삽입 insertBefore(self.head, key) c-4. 삭제 연산remove(x) : 노드 x를 제거 만약 key값만 알고 노드 이름을 모르면 search(key)로 하여 노드 이름을 찾는다. popFront() : head 다음에 있는 노드의 데이터 값 리턴. 빈 리스트면 None popBack() : head 이전에 있는 노드의 데이터 값 리턴. 빈 리스트면 None 12345678910111213141516def remove(self, x): if x == None or x == self.head: return x.prev.next, x.next.prev = x.next, x.prev def popFront(self): if self.isEmpty(): return None key = self.head.next.key self.remove(self.head.next) return key def popBack(self): if self.isEmpty(): return None key = head.prev.key self.remove(head.prev) return key c-5. 연산의 시간 복잡도moveAfter / moveBeforeO(1)pushFront / pushBackO(1)insertAfter / insertBeforeO(1)popFront / popBackO(1)removeO(1)searchO(n) moveAfter(Before) , pushFront(Back), insertAfter(Before)는 splice의 시간복잡도와 같다. O(1)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"2. 배열과리스트","slug":"cs/datastructure/ds2","date":"2021-07-28T10:59:57.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds2/","excerpt":"","text":"a. 배열(array)데이터를 연속적인 메모리 공간에 저장 주소를 통해 매우 빠르게 접근 배열의 시작 주소, 저장된 값의 종류, 인덱스 세가지 정보로 원하는 값의 주소를 계산 가능. 읽기와 쓰기 연산에 O(1)시간이 걸림 고정된 길이를 가지며, 읽기와 쓰기만 지원하는 경우가 많다. b. 리스트 (파이썬)c의 배열에는 실제 데이터가 저장된 형식이지만, python의 리스트에는 데이터가 저장된 주소가 저장된다. 항상 객체의 주소만 저장하기 때문에 셀의 크기를 8바이트(혹은 4바이트)로 고정. 모든 셀의 크기가 같기 때문에 index에 의해 O(1)시간 접근이 가능 읽기&#x2F;쓰기 외에 여러 연산들 지원 a.append(val)맨 뒤에 val 삽입a.pop(i)a[i]값을 지운 후 리턴pop()은 가장 오른쪽 값 지움a.insert(i, val)a[i]=value연산(원래 값들은 한 칸씩 이동)a.remove(val)val을 찾아 제거a.index(val)val이 처음 등장하는 index 리턴a.count(val)val이 몇 번 등장하는지 리턴a[i:j]a[i]...a[j-1]까지 복사해 새 리스트로 반환 리스트는 동적배열(파이썬)append나 insert로 메모리가 부족해지면, 더 큰 메모리를 할당받아 새로운 리스트에 이전 리스트의 값을 모두 이동한다. 반면 pop이나 remove로 메모리가 너무 널널해지면, 더 작은 메모리에 이전 리스트를 할당한다. 따라서 사용자가 배열의 크기를 신경쓰지 않아도 된다.","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]},{"title":"7.피보나치","slug":"cs/algorithm/theory/al7","date":"2021-07-28T10:43:13.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al7/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al7/","excerpt":"","text":"피보나치 수 피보나치 수열이란 F(0) &#x3D; 0, F(1) &#x3D; 1, F(n) &#x3D; F(n-1) + F(n-2)로 정의되는 수열! 구현 방법 피보나치수 정의를 그대로 재귀함수로 구현 간단하지만..O(g^n) 지수 시간이 걸림..(g는 황금비율 1.1618…) 이차원 배열을 재귀적으로 곱하기 (1 1)(F(n-1)) (1 0)(F(n-2)) 이렇게 이차원 배열을 곱하면 (F(n)) (F(n-1)) 을 구할 수 있다. 따라서 곱해준 이차원 배열을 여러번 곱해주면 피보나치 수열의 값을 알 수 있다! 이때 여러번 곱해주는 연산 power(a, n)로 구해주면, O(logn)이다! 123456789101112131415161718192021def fibo_rec(n): if n &lt;= 1: return n return fibo_rec(n-1)+fibo_rec(n-2)def fibo_array(n): F = [0, 1] for i in range(2, n+1): F.append(F[i-1] + F[i-2]) return F[n]def fibo_three(n): f1 = 0 f2 = 1 for i in range(2, n+1): f3 = f1 + f2 f1 = f2 f2 = f3 return f2n = int(input(&quot;n = &quot;))print(fibo_rec(n), fibo_array(n), fibo_three(n))","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"6.Median of Medians 알고리즘","slug":"cs/algorithm/theory/al6","date":"2021-07-28T10:42:57.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al6/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al6/","excerpt":"","text":"MoM(Median of Medians) 알고리즘퀵셀렉트는 세가지 영역으로 나누는데, 피벗보다 큰 쪽으로 너무 몰리면 수행시간이 길어졌었다. MoM 알고리즘은 피벗을 적절하게 고르는 알고리즘이다.피벗보다 작은 값의 집합 A, 피벗보다 큰 집합 B 둘 다 n&#x2F;c보다 작도록 피벗을 설정하는 것이다!! 이런 과정으로 피벗을 고른다고 하면, 재귀 과정에서 집합의 크기가n-&gt;n&#x2F;c-&gt;n&#x2F;c^2-&gt;n&#x2F;c^3….-&gt;n&#x2F;c^k&#x3D;1. 총 logcn 번 하게 된다. 하지만 이런 과정에는 피벗을 설정하는 연산이 필요하다.피벗 고르는데 필요햔 연산을 p라고 하고, 이 연산은 재귀를 거쳐도 동일하게 계산된다. 피벗과 다른 수들과 비교하는 횟수가 필요하게 된다.이 횟수는 재귀를 거치면서n-&gt;n&#x2F;c-&gt;n&#x2F;c^2….이렇게 된다. 결국 p+n + p+n&#x2F;c + p+n&#x2F;c^2 …..&#x3D;logcn*(p+n)이다. 결국 O(nlogn)이다.MoM(L, k): 5개씩 그룹화 각 국릅의 중간값(median) 구하기. 5개에서 중간값 구하는 연산은 6번 비교해야하므로, n&#x2F;5*6 비교해야 된다. 중간 값을 한 집합에 모아 medians라고 하자. m* &#x3D; MoM(medians, len(medians)&#x2F;2). 이때 T(n&#x2F;5) 연산 소요 m*를 pivot으로 삼아 전체 집합을 A,pivot,B로 나눈다. 이때 n번 비교 pivot을 기준으로 내가 찾고자하는 값이 A에 있으면 MoM(A,k), B에 있으면 MoM(B,k) 아니면 return m*한다. 이때 재귀호출에 따라 T(A) or T(B)만큼 연산하는데, A와 B모두 원소 갯수가 n&#x2F;c보다 작기 때문에 둘 다 최대 소요 시간은 T(n&#x2F;c)이 된다. 결국 T(n) &#x3D; 6&#x2F;5*n + T(n&#x2F;5) + n + T(n&#x2F;c) 이때 c를 4&#x2F;3이라고 하면(이 부분은 다소 난해) 점화식은 T(n) &#x3D; T(3*n&#x2F;4)+T(n&#x2F;5)+11*n&#x2F;5가 된다. (휴..)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"5.독특한탐색","slug":"cs/algorithm/theory/al5","date":"2021-07-28T10:42:28.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al5/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al5/","excerpt":"","text":"특수한 선택 문제다음과 같은 요구 조건을 가지느 문제들은 선택(Selection)문제라고 보면 된다. 입력 : n개의 값과 k(1&lt;&#x3D;k&lt;&#x3D;n) 값 출력 : k번째로 작은 입력 값 목표 : 비교 횟수 최소화 상한(upper bound) : 어떤 결과를 찾아내는데 항상 임의 횟수의 연산이면 무조건 찾아낼 수 있다.하한(lower bound) : 어떤 결과를 찾아내는데 임의 횟수의 연산이 반드시 필요한 경우가 존재한다.상한과 하한이 같은 경우가 해당 문제를 해결하는 적절한 알고리즘! k &#x3D; n : 최대값 찾기현재 최대값을 따로 변수로 저장해놓으면서 하나씩 비교해보면 된다. -&gt;항상 n-1번 비교로 가능(상한 upperbound)혹은 이웃한 두쌍이 비교해서 큰 값이 토너먼트 방식으로 비교 -&gt; n-1번 비교로 가능최대값찾기는 무조건 n-1번 연산이 알맞은 알고리즘이다. k&#x3D;1, k&#x3D;n : 최대값, 최솟값 찾기먼저 토너먼트 식으로 최대값을 찾고(n-1번 비교)첫 비교에서 진 요소들(n&#x2F;2개)끼리 다시 최소값 찾는 토너먼트를 실행(n&#x2F;2-1번 비교)총 (3&#x2F;2)n-2번 비교! k&#x3D;1, k&#x3D;2 :최솟값과 두번째로 작은 값찾기먼저 작은 값이 이기는 토너먼트로 최솟값 찾고(n-1번 비교)토너먼트에서 최대값에게 진 값들만 모아서 다시 비교! (라운드 수-1 번&#x3D;logn올림 -1번)(매 라운드마다 패배자가 발생하므로…)총 n-2-log2올림번 비교!","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"4.일반적인 탐색","slug":"cs/algorithm/theory/al4","date":"2021-07-28T10:42:14.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al4/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al4/","excerpt":"","text":"일반적인 선택 문제n개의 값중 k 번째 작은 수 찾기 - QuickSelction 배열 중 임의의 수 p를 고른다.(이 p는 pivot) p보다 작은 값을 A에 따로 모으고, p보다 큰 값을 B에 따로 모으고, p와 같은 값을 M에 따로 모은다. 만약 A의 원소가 k보다 작으면 A의 k번째 작은 값이 전체 데이터의 k번째 작은 값이다. 이제 A에서 k보다 작은값 찾기는 재귀적으로 해결 가능하다. 만약 A와 M의 원소 갯수 합이 k보다 작을 때는 B에서 (k-A-M)번째 작은 값을 구하면 된다. 나머지 경우는 그냥 p를 반환하면 된다. 12345678910111213def quickSelet(L,k): #1. p=L[0] A,B,M=[],[],[] #2. for x in L: if p&gt;x:A.append(x) elif p&lt;x:B.append(x) else: M.append(x) #3-6. if len(A)&gt;k : return quickSelect(A,k) elif len(A)+len(M)&lt;k: return quickSelect(B,k) else: return p Worst case? p를 첫 원소로 했는데 가장 큰 원소가 맨 끝 원소일 때.T(n) &#x3D; T(n-1)+n &#x3D; 1+2+3+…+n &#x3D; n(n+1) &#x2F; 2 -&gt; O(n^2) 평균적인 경우는 O(n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"3.재귀 알고리즘","slug":"cs/algorithm/theory/al3","date":"2021-07-28T10:38:20.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al3/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al3/","excerpt":"","text":"재귀 알고리즘재귀 알고리즘 &#x3D; 알고리즘 내부에서 한번 이상 자신의 함수를 호출sum(n) &#x3D; 1+2+..+nsum(n) &#x3D; sum(n-1)+n 123def sum(n): if n==1 : return 1 return sum(n-1) + n 수행시간T(n) &#x3D; sum(n)의 수행시간이라 할 때T(n) &#x3D; T(n-1)+ c (상수 번의 기본 연산) &#x3D;&gt; 점화식! &#x3D; (T(n-2)+c)+c &#x3D; T(n-1)+2c … &#x3D;T(1)+(n-1)c (바닥조건) &#x3D;c*n 따라서 BigO -&gt; O(n)점화식을 구해 바닥조건까지 전개해가자!! 좀 더 복잡한 예제sum(a,b) &#x3D; a + (a+1) + …. + (b-1) + bsum(3,8) &#x3D; 3+4+5+6+7+8 &#x3D; sum(3,5) + sum(6,8) … 12345def sum(a, b): if a == b : return a if a&gt;b : return 0 m = (a+b)//2 return sum(a,m)+sum(m+1, b) n&#x3D;2^k라고 가정T(n) &#x3D; 2T(n&#x2F;2)+c …. &#x3D;2^k * T(n&#x2F;2^k) + c(1+2+2^2+2^3….+2^(k-1)) T(1)&#x3D;c이고 등비수열 정리하면 &#x3D;2^kc + c(2^k-1) &#x3D;c*2^k + c * 2^r - c &#x3D; 2cn - c &#x3D; O(n) reverse 함수 예제reverse(A) &#x3D; reverse(A[1:])+A[:1]즉 T(n) &#x3D; T(n-1) + c &#x3D;&gt; O(n) reverse(A, start, stop)&#x3D; A[strat]와 A[stop-1] 바꾸고, reverse(A, start-1, stop-1)즉 T(n) &#x3D; T(n-2) + c &#x3D; T(1)+(n&#x2F;2)*c &#x3D;&gt;O(n)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"2.분할정복법","slug":"cs/algorithm/theory/al2","date":"2021-07-28T10:05:36.000Z","updated":"2022-01-22T16:20:00.027Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al2/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al2/","excerpt":"","text":"분할정복법큰 문제를 작은 문제로 분할해 재귀적으로 해결 a와 n 입력받아 a^n 값 구하는 power1(a,n)을 분할 정복법으로 해보자. power1(a, n) &#x3D; power1(a, n-1)*a 이다. 123def power1(a, n): if n==1: return a return a*power1(a, n-1) power1의 걸리는 시간 T(n)은T(n) &#x3D; T(n-1)+c &#x3D; O(n) 다른 방법은 없을까? power2를 보자 123456def power2(a, n): if n==1 : return a if n==0 : return 1 if n%2==0: power2(a, n//2)*power2(a, n//2) else : return power2(a, n//2) * power2(a, n//2)*a power2의 걸리는 시간 T(n)은T(n) &#x3D; 2T(n&#x2F;2)+c&#x3D;O(n) 자세히 보면 power2에는 중복 사용되는 메소드가 있다.이걸 좀 더 개선해보자 12345def power3(a, n): if n==0: return 1 x = power3(a, n//2) if n%2==0: return x*x else return x*x*a T(n) &#x3D; T(n&#x2F;2)+c &#x3D; O(logn)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"1.이진탐색","slug":"cs/algorithm/theory/al1","date":"2021-07-28T10:04:00.000Z","updated":"2022-01-22T16:20:00.026Z","comments":true,"path":"2021/07/28/cs/algorithm/theory/al1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/algorithm/theory/al1/","excerpt":"","text":"이진탐색오름차순으로 정렬된 n개의 숫자가 저장된 배열 A에서 어떤 값 x가 배열에 있는지 없는지 O(log n) 비교에 알 수 있는 탐색법. 현재 탐색 범위가 A[i]…A[j]라면 가운데값(A[(i+j)&#x2F;2]) 비교에 알 수 있는 탐색법. 한 번의 비교로 탐색 범위가 반씩 줄어들어 (log n +1)번 이하의 비교로 x 존재 여부 판별. 주어진 배열을 반으로 나눠서 재귀적으로 해결하는 분할정복 알고리즘 12345678910111213141516def binary_search(A, i, j, x): if i&gt;j: return -1 m = (i+j)//2 if x == A[m]: return m elif x&lt; A[m]: return binary_search(A, i, m-1, x) elif x&gt; A[m]: return binary_search(A, m+1, j, x)A = [2*i for i in range(11)]print(A)x = int(input(&quot;x = &quot;))index = binary_search(A,0,len(A)-1, x)if index == -1: print(&#x27;cannot find&#x27;)else : print(index)","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Algorithm","slug":"computer-science/algorithm","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/"},{"name":"Theory","slug":"computer-science/algorithm/theory","permalink":"https://yangdongjue5510.github.io/categories/computer-science/algorithm/theory/"}]},{"title":"1. 연결리스트","slug":"cs/datastructure/ds1","date":"2021-07-28T06:54:58.000Z","updated":"2022-01-22T16:20:00.028Z","comments":true,"path":"2021/07/28/cs/datastructure/ds1/","link":"","permalink":"https://yangdongjue5510.github.io/2021/07/28/cs/datastructure/ds1/","excerpt":"","text":"a. 연결리스트 기본 개념연결리스트는 노드가 링크에 의해 기차처럼 연결된 순차 자료구조. 노드는 실제 값을 가지고 있는 data 정보와 인접 노드로 향하는 link 정보로 구성된 클래스로 구현한다. 다른 값에 접근하려면 링크에 따라 원하는 노드의 데이터에 접근한다. 다만, 배열처럼 index로 접근할 수 없다. 어떤 값을 찾으려면 처음부터 순차적으로 찾아야한다. 배열과 연결리스트의 차이를 그림으로 파악해보자! b. 한방향 연결리스트노드들이 한 방향으로 연결된 리스트 가장 앞에 있는 노드를 head 노드라고 부르자. 가장 마지막 노드는 다음 노드가 없으므로 마지막 노드의 next 링크는 None이다. b-1. 노드 클래스 구현하기123456789class Node: def __init__(self, key=None, value=None): #노드를 구분하는 key, 필요할 경우 추가 데이터 value self.key = key self.value = value self.next = None def __str__(self): #print(node)인 경우 출력할 문자열 return str(self.key) b-2. 한방향 연결 리스트 클래스 구현하기12345678910111213class SinglyLinkedList: def __init__(self): self.head = None self.size = 0 def __iter__(self): #반복하게 만드는 반복자. yield가 있는 generator v = self.head while v != None: yield v #return과 비슷 v = v.next def __str__(self): return &quot;-&gt;&quot;.join(str(v) for v in self) def __len__(self): return self.size #len(a) = a의 노드 개수 리턴 c. 지원하는 연산 (삽입, 삭제, 탐색 등…)pushFront(key)key값을 갖는 새 노드를 만들어 head 앞에 삽입pushBack(key)key값을 갖는 새 노드를 마지막 노드 뒤에 삽입popFront()첫 노드(head)를 삭제 후 key값을 리턴popBack()마지막 노드를 삭제 후 key값을 리턴search(key)key값을 갖는 노드를 찾아 리턴remove(v)노드 v를 제거 c-1. pushFront vs pushBackpushFront는 현재 head 앞에 새 노드를 생성해 앞에 삽입한다. 12345def pushFront(self, key, value=None): new_node = Node(key, value) new_node.next = self.head self.head = new_node self.size += 1 pushBack은 마지막 노드의 next 링크가 새로운 노드로 연결되도록 해야한다. 만약 마지막 노드가 없다면(즉 리스트가 비었다면) 새 노드가 리스트의 head가 되어야 한다. 12345678910def pushBack(self, key, value=None): new_node = Node(key, value) if self.size == 0: self.head = new_node else : tail = self.head while tail.next != None: #마지막 노드 찾기 tail = tail.next tail.next = new_node self.size += 1 c-2. popFront vs. popBackpopFront는 빈 리스트라서 head를 지울 수 없는 경우와 그렇지 않은 경우로 나눠 구현한다. 12345678910def popFront(self): if self.size == 0 return None else : x = self.head key = x.key self.head=x.next self.size=self.size-1 del x #메모리 상에서 x를 제거 return key popBack은 마지막 노드를 찾고 지우고 그 전 노드의 링크를 수정해야 하므로, 마지막 전 노드를 알아야 한다. (다시 말하면 마지막 노드는 next링크가 None인 노드이다. 마지막 전 노드를 마지막 노드로 하고 싶으면 해당 노드의 next링크를 None으로 해줘야 된다는 의미다.) 연결리스트는 인덱스로 접근이 안되니, 일일히 처음부터 마지막 전 노드까지 찾아가야 한다.(O(n)) 총 세가지로 나눠 구현해야 한다. 빈 리스인 경우 리스트에 노드가 하나만 있는 경우 리스트에 두 개 이상의 노드가 있는 경우 12345678910111213141516def popBack(self): if self.size ==0 return None else : prev, tail = None, self.head while tail.next != None: prev = tail tail = tail.next if prev == None: self.head = None else : prev.next = tail.next key = tail.key del tail self.size -= 1 return key c-3. search(key)key 값을 저장한 노드를 찾아 리턴하거나 없으면 None을 반환하는데, 두가지 방법이 있다. head부터 next 링크를 따라가면서 찾기 1234567def search(self, key): v = self.head while v != None: if v.key == key: return v v = v.next return v​ for 루프를 이용하는 방법(__iter__(self)에 의해 가능) 12345def search(self, key): for v in self: if v.key == key: return v return None​ c-4. remove(v)노드 v를 리스트에서 제거하는 함수. 세가지 경우를 고려해 구현한다. 리스트가 비어있거나, 노드 v가 None인 경우 -&gt; do nothing 노드 v가 head인 경우 -&gt; popFront 호출 그 외의 경우 -&gt; v의 전 노드 w를 찾은 후 w.next &#x3D; v.next로 w의 링크 수정 1234567891011121314151617def remove(self, x): # 노드 x를 제거한 후 True리턴. 제거 실패면 False 리턴 pre=None now=self.head if self.size==0: return False elif v==self.head: popFront() return True else : while now!=x: pre=now now=now.next pre.next=now.next del now self.size-=1 return True","categories":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}],"tags":[],"keywords":[{"name":"Computer Science","slug":"computer-science","permalink":"https://yangdongjue5510.github.io/categories/computer-science/"},{"name":"Data Structure","slug":"computer-science/data-structure","permalink":"https://yangdongjue5510.github.io/categories/computer-science/data-structure/"}]}]}