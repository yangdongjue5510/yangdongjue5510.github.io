<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    

    
    <title>퀴즈로 학습하는 운영체제와 정보기술의 원리 | mudura | 그거 뭐더라</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="운영체제와 정보기술의 원리">
    
    <meta name="description" content="3장   메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?   컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.       운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가 운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코">
<meta property="og:type" content="article">
<meta property="og:title" content="퀴즈로 학습하는 운영체제와 정보기술의 원리">
<meta property="og:url" content="https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/index.html">
<meta property="og:site_name" content="mudura | 그거 뭐더라">
<meta property="og:description" content="3장   메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?   컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.       운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가 운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-01-22T13:39:01.000Z">
<meta property="article:modified_time" content="2023-02-27T12:50:36.252Z">
<meta property="article:author" content="yangdongjue5510">
<meta property="article:tag" content="운영체제와 정보기술의 원리">
<meta name="twitter:card" content="summary">
    

    

    
        <link rel="icon" href="/css/images/favicon.png">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '[object Object]');
</script>
<!-- End Google Analytics -->

    
    
    


<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/rss2.xml" title="mudura | 그거 뭐더라" type="application/rss+xml">
</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1>
                        <a href="/" style="font-size: 100px;color:#fff; text-decoration: none;">mudura</a>
                    </h1>    
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/">Computer Science</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/algorithm/">Algorithm</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/computer-structure/">Computer Structure</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/data-structure/">Data Structure</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/database/">Database</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/infra/">Infra</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/network/">Network</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/computer-science/os/">OS</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/infra/">Infra</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/jpa/">JPA</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/java/design-pattern/">Design Pattern</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/java/java-basic/">Java Basic</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/spring/">Spring</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/spring/boot/">Boot</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/spring/project/">Project</a></li></ul></li></ul>
                                
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" target="_blank" rel="external nofollow noopener noreferrer" href="https://about.me/yangdongjue5510/edit/details">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/computer-science/">Computer Science</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/computer-science/os/">OS</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-cs/os/퀴즈로_학습하는_운영체제와_정보기술의_원리" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        퀴즈로 학습하는 운영체제와 정보기술의 원리
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/" class="article-date">
       <time datetime="2023-01-22T13:39:01.000Z" itemprop="datePublished">2023-01-22</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/" class="article-date">
     <time datetime="2023-02-27T12:50:36.252Z" itemprop="dateModified">2023-02-27</time>
  </a>
</div>


                

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/" rel="tag">운영체제와 정보기술의 원리</a>
    </div>

                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <h1 id="3장"><a href="#3장" class="headerlink" title="3장"></a>3장</h1><details>
  <summary>메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?</summary>
  컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.
</details>


<details>
  <summary>운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가</summary>
운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코드만 메모리에 올리는데, 이 코드를 커널이라고 부른다.  </details>


<details>
  <summary>입출력 장치에서 읽어온 데이터를 임시 저장하는 하드웨어 장치는 무엇이라고 하는가?</summary>
  컨트롤러는 데이터를 데이터를 입출력 장치로 보내거나 가져오기 전에 임시 저장하는 메모리를 로컬 버퍼라고 한다.
</details>


<details>
  <summary>데이터를 읽어오는 명령을 컨트롤러가 완료하여 로컬 버퍼로 읽어오는 작업을 완료한 경우 어떻게 CPU에게 해당 사실을 알리는가? 그 사실을 안 CPU는 어떻게 행동하는가?</summary>
  컨트롤러는 데이터를 모두 읽어온 경우, CPU의 인터럽트 라인에 인터럽트를 추가하여 해당 작업을 완료했음을 알린다. CPU는 매번 명령을 실행하기 전에 자신의 인터럽트 라인을 확인해서 처리해야할 인터럽트가 있는지 확인한다. 인터럽트가 존재하는 경우 인터럽트 벡터를 통해 인터럽트 처리 루틴이 존재하는 주소로 가서 인터럽트에 맞는 처리 로직을 실행한다.
</details>


<details>
  <summary>인터럽트의 종류와 각 종류의 차이점을 설명해보자.</summary>
  인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 입출력 컨트롤러같은 하드웨어가 인터럽트 라인을 설정하고, 소프트웨어 인터럽트는 소프트웨어가 인터럽트 라인을 설정한다.
</details>


<details>
  <summary>소프트웨어 인터럽트의 종류에 대해 설명해보자.</summary>
 소프트웨어 인터럽트는 예외 상황과 시스템콜과 있다. 예외상황은 프로세스가 잘못된 메모리를 접근하려거나 값을 0으로 나누려는 잘못된 연산을 할 때 발생한다. 반면 시스템콜은 사용자 프로그램이 운영체제 코드를 사용해야 할 때 운영체제에게 해당 코드를 실행해주기를 요청하는 방법이다.
</details>


<details>
  <summary>인터럽트를 처리할 때 CPU의 상태를 어떻게 저장되는가?</summary>
  인터럽트를 처리해야 할 때 CPU의 레지스터 값, 하드웨어 상태, 실행 중인 코드 메무리 주소, 실행중인 위치 등을 PCB에 저장하고 CPU의 레지스터를 지운 다음 인터럽트 루틴을 실행한다.
</details>


<details>
  <summary>입출력 방식 두가지에 대해서 설명해보자.</summary>
  입출력은 동기식 입출력, 비동기식 입출력이 있다. 동기식 입출력은 한 프로세스가 CPU를 점유해 진행 중에 입출력을 해야 하는 경우 그 프로세스가 해당 입출력 작업이 완료될 때까지 기다리고 CPU는 해당 프로세스의 점유를 뺏고 다른 프로세스를 진행시키는 방식이다. 이때 입출력 작업 완료를 기다리는 프로세스는 봉쇄 상태가 되어서 CPU 자원을 할당받지 못하게 된다. 반면 비동기식 입출력은 입출력을 해야 하는 경우 해당 입출력이 끝날 때까지 기다리지 않고 해당 프로세스에서 입출력 작업이 완료되지 않아도 수행할 수 있는 작업을 이어서 진행한다.
</details>


<details>
  <summary>동기식 입출력에서 입출력 발생 시 다른 프로세스에게 CPU를 할당했을 때 이 프로세스에서도 입출력이 발생하면 어떤 문제가 발생할 수 있고 이를 어떻게 방지하는가?</summary>
  만약 먼저 실행하던 프로세스에서 입출력이 발생해서 다른 프로세스에게 CPU를 할당했는데 다음 프로세스도 입출력이 발생하면 여러 입출력 요청이 발생할 수 있다. 이 경우 입출력의 동기화가 지켜지지 않는 문제가 발생할 수 있다. 나중에 실행된 프로세스의 입출력 요청을 먼저 수행하고 처음 프로세스의 입출력이 같은 자원에 대한 입출력 요청을 했을 때 처음 프로세스는 예상하지 못한 결과를 얻을 수 있다. 이를 막기 위해 장치 별로 큐를 두어 요청한 순서대로 처리할 수 있게 한다.
</details>


<details>
  <summary>DMA라는 장치의 필요성에 대해 설명해보시오</summary>
  입출력이 완료되어 로컬버퍼에 담긴 내용을 메모리에 올려야 할 때, 컨트롤러가 인터럽트 라인을 세팅해서 CPU가 메모리에 데이터를 적재하도록 한다. 문제는 이런 입출력 처리를 매번 인터럽트를 통해 CPU가 메모리에 적재하도록 하면 너무 여러번 CPU는 인터럽트 처리를 해야된다. DMA는 CPU가 메모리에 로컬버퍼의 데이터를 적재하는 일을 대리한다. 그래서 로컬버퍼 데이터를 메모리에 적재하는 일 때문에 CPU가 인터럽트 당하지 않도록 한다. DMA는 바이트 단위가 아니라 블록이라는 단위로 메모리를 읽어온 후 다 읽어온 경우 CPU에게 인터럽트를 통해 완료를 알린다.
</details>


<details>
  <summary>저장장치 계층 구조에 대해 설명해보자.</summary>
  컴퓨터의 저장장치는 주기억장치와 보조기억장치로 나뉜다. 주기억장치는 메모리를 휘발성이고 일반적으로 RAM을 매체로 사용한다. 보조기억장치는 비휘발성으로 하드디스크나 SSD를 매체로 사용한다. 저장장치 계층 구조는 레지스터 - 캐시 메모리 - 메인 메모리 - 마그네틱 디스크- 광디스크- 마그네틱 테이프 이런 구조로 빠를 수록 비싸고 용량이 적다. 앞 세가지는 주기억장치이고 나머지는 보조기억장치이다.
</details>


<details>
  <summary>보조기억 장치의 목적에 대해 설명해보자. 각 목적의 비교를 해보자</summary>
  보조기억 장치는 비휘발성의 특징을 통해 파일 시스템을 구현하는데 사용된다. 또한 주기억장치인 메모리의 연장 공간인 스왑 영역 역할을 한다. 운영체제는 프로그램 수행에 당장 필요하지 않은 부분은 디스크 스왑 영역에 적재한다. 이렇게 스왑 아웃된 영역은 필요하게 될 때 메모리에 올려서 사용하게 된다. 파일 시스템은 비휘발성을 활용하지만 스왑 영역은 메모리의 연장이므로 휘발성인 특징을 나타낸다.
</details>


<details>
  <summary>캐싱 기법에 대해서 설명하고 왜 효과적인지 설명해라.</summary>
  상대적으로 빠른 저장장치를 이용해 느린 저장장치의 선응을 향상 시키는 총체적 기법을 일컫는다. 느린 저장장치에서 자주 사용되거나 당장 사용되는 정보를 빠른 저장장치에 선별적으로 저장해서 두 저장 장치 사이의 속도를 완충시킨다. 컴퓨터 내의 데이터나 프로그램을 구성하는 부분이 균등하게 사용되지 않고 일부분만 주로 사용하는 특성이 있기 때문에 적은 양의 캐시로도 효과를 볼 수 있다.
</details>


<details>
  <summary>하드웨어 보안이 필요한 이유와 어떻게 달성하는 지 설명해보라</summary>
  여러 프로그램이 실행될 때 다른 프로그램의 메모리 영역에 침범하는 일이 발생할 수 있다. 이런 문제를 막기 위해 운영체제는 커널모드와 사용자모드를 분리해서 사용자 프로그램이 보안에 예민한 부분을 직접 제어하지 못하게 막고 운영체제에게 서비스를 요청하는 방식으로 구현했다. 모드비트를 통해 사용자 프로그램이 어떤 모드인지 검증하는 방식으로 위험한 연산을 하지 못하도록 막는다.
</details>


<details>
  <summary>메모리 보안을 어떻게 달성하는 지 설명해보고 한계를 설명해보라</summary>
  사용자 프로그램이 정해진 메모리 주소 이내에 위치할 수 있도록 기준 레지스터와 한계 레지스터를 정해서 시작주소와 끝 주소를 정해놓는다. 해당 프로그램으로 직접 접근하려는 주소가 기준 레지스터와 한계 레지스터 사이에 없다면 잘못된 접근이라고 판단한다. 다만 이는 하나의 프로그램이 연속적으로 위치하는 단순한 메모리 관리 기법을 사용하는 경우로 한정했을 때 가능하다.
</details>


<details>
  <summary>한 프로그램이 CPU의 자원을 오랫동안 독점하는 상황을 막는 역할을 하는 하드웨어에 대해 설명해보자.</summary>
  타이머라는 하드웨어를 통해 여러 프로그램이 돌아가면서 CPU를 점유하도록 한다. 특정 시간이 지나면 인터럽트를 일으켜서 운영체제가 CPU 제어권을 획득할 수 있도록 하는 역할을 수행한다.
</details>

<h1 id="4장"><a href="#4장" class="headerlink" title="4장"></a>4장</h1><details>
  <summary>CPU에서 프로그램이 실행되려면 메모리에 적재가 되어야 한다. 이때 프로그램 메모리 구조에 대해 설명해보자.</summary>
  프로그램 메모리 구조는 네가지로 나뉜다. 소스 코드가 기계어로 변역된 코드가 저장되는 코드 영역, 프로그램의 전역 변수가 저장되는 데이터 영역, 프로그램에서 동적으로 할당된 메모리에 해당하는 힙 영역, 프로그램의 함수 호출 기록과 함수 내에서 사용한 지역 변수를 저장하는 스택 영역으로 나뉜다.

  <summary>프로그램 내에서 함수 호출과 프로그램에서 인터럽트 발생 시 복귀 주소 저장 방식의 차이를 설명해보자.</summary>
  사용자 프로그램의 함수 호출은 프로그램 메모리 구조 중 스택에 복귀 주소를 저장하고 호출한 함수로 이동해서 함수를 실행한다. 인터럽트 발생 시 복귀 주소는 커널의 메모리 구조 중 데이터 영역 속 PCB에 복귀 주소를 저장한다.
</details>


<details>
  <summary>프로그램 카운터 (PC)의 정의와 왜 필요한 지를 설명해보자.</summary>
  CPU는 명령어를 하나씩 수행하는 역할을 한다. 이때 CPU가 읽어야할 명령어의 주소를 가리키는 것이 프로그램 카운터이다.
</details>


<details>
  <summary>일반명령과 특권명령에 대해 설명해보자.</summary>
  일반 명령은 프로그램 메모리에 적재된 데이터를 읽거나 연산하거나 메모리에 데이터를 쓰는 일반적인 명령을 의미한다. 특권명령은 보안과 관련된 명령과 입출력하거나 타이머와 같은 장치가 관련된 명령을 의미한다.
</details>


<details>
  <summary>메모리에 프로그램을 적재할 때 프로그램의 모든 내용을 적재하지 않는다. 어떤 방식으로 적재하는 지 설명해보자.</summary>
  운영체제는 프로그램에서 당장 필요한 부분만 메모리에 적재한다. 그렇지 않은 코드는 디스크에 스왑 영역에 적재하여 필요한 경우에 메모리에 올려 사용하도록 한다.
</details>


<details>
  <summary>커널 메모리 구조에서 스택 영역이 일반 프로그램 구조의 스택과 다른 특징에 대해 설명해보자.</summary>
  일반 프로그램은 하나의 스택을 가지는 반면 커널 메모리 구조는 각 프로세스마다 스택을 두어서 분리해서 관리한다.
</details>


<details>
  <summary>커널 메모리 구조에서 데어터 영역에는 어떠한 자료구조가 있는지 설명해보자.</summary>
  커널 데이터 영역에는 하드웨어와 프로세스를 관리하는 자료구조를 가지고 있다. 외부 입출력 장치를 통해 입출력하려는 프로세스를 줄세우는 큐가 있고, 각 프로세스의 상태 값을 저장하는 PCB가 있다.
</details>


<details>
  <summary>프로그램에서 함수 호출의 경우와 시스템콜이 발생하는 경우에 대해 프로그램과 커널의 메모리 구조를 중점으로 설명해보자.</summary>
  프로그램에서 함수 호출은 프로그램 메모리의 스택에 복귀 주소를 저장하고 호출된 함수를 처리하고, 시스템콜이 발생하는 경우는 프로그램의 복귀 주소를 커널 메모리의 데이터 영역 속 PCB에 저장해놓고 스택 영역 속 해당 프로세스의 스택에서 실행되는 함수를 기록하고 실행한다.
</details>


<details>
  <summary>인터럽트 처리 중 다른 인터럽트가 발생을 허용하지 않는 이유를 설명해보고 만약 허용한다면 어떤 방식으로 처리하는 지 설명해보자.</summary>
  인터럽트 처리 도중 다른 인터럽트가 발생해서 처리해야 하는 경우, 해당 인터럽트 루틴에서 사용하는 공유 데이터가 있다면 중간에 처리하는 인터럽트 때문에 공유 데이터의 일관성이 깨질 수 있다. 만약 허용한다면 인터럽트마다 우선 순위를 정해서 수행한다.
</details>


<details>
  <summary>일반적인 함수 호출을 다른 함수로 점프하는 반면 시스템콜은 어떻게 다른 코드로 이동하는 지 설명해보자. 그리고 왜 이런 차이가 있는지 설명해보자.</summary>
  시스템콜에서 수행되어야 하는 코드는 프로그램의 메모리가 아닌 커널의 메모리에 있다. 이를 실행하려면 CPU 자원 점유를 운영체제가 해야 한다. 그래서 일반 함수 호출은 CPU 점유를 프로세스가 계속 가지지만 시스템콜은 CPU 점유를 운영체제가 하게 된다. 이 과정에서 인터럽트 라인을 세팅해서 CPU에 인터럽트를 발생시킨다.
</details>


<details>
  <summary>프로그램이 CPU를 할당받았다가 뺏기는 경우를 설명해보라.</summary>
  CPU 할당된 시간이 다 되어서 타이머가 인터럽트를 발생시키거나 프로세스에서 동기식 입출력을 실행할 때 다른 프로그램에게 CPU 자원을 뺏기게 된다.
</details>

<details>
  <summary>프로그램이 실행 중이라는 의미는 해당 프로그램의 코드만 실행되는 것을 의미하진 않는다. 실행 될 수 있는 다른 코드를 설명해고 그런 경우에 어떻게 실행되고 있다고 하는지 설명해보자.</summary>
  프로세스에서 시스템콜을 호출하는 경우 실행되어야 하는 코드는 해당 프로그램의 코드가 아닌 커널의 코드이다. 이럴 때는 여전히 해당 프로그램이 실행되고 있지만 커널 모드로 실행되고 있다고 말한다.
</details>

<h1 id="5장"><a href="#5장" class="headerlink" title="5장"></a>5장</h1><details>
  <summary>프로세스의 문맥이란 무엇일까요?</summary>
  프로세스를 실행하기 위한 정보를 의미한다. 하드웨어, 운영체제, 프로세스 메모리 이렇게 세가지로 나뉜다. 하드웨어는 CPU의 PC나 레지스터 값들, 운영체제는 커널 메모리 데이터 영역의 PCB와 스택 영역의 해당 프로세스 커널 스택, 프로세스 메모리는 코드, 스택, 힙, 데이터 영역을 포함한 프로세스가 실행되기 위해 메모리에 올려져야 하는 내용을 말한다.
</details>

<details>
  <summary>프로세스의 상태를 설명해보세요?</summary>
  프로세스 상태는 크게 6가지로 나뉜다. 
  시작 상태는 프로세스에 필요한 자료구조는 할당받았지만 아직 메모리를 할당받지 못한 상태이다. 
  준비 상태는 프로세스가 CPU 할당만 받으면 작업을 수행할 수 있는 상태를 의미한다.
  실행 상태는 프로세스가 준비 상태에서 CPU 할당을 받아 작업을 실행 중인 상태다.
  봉쇄 상태는 프로세스가 실행 도중 IO 작업 같이 먼저 선행되어야 하는 작업을 해야 해서 CPU를 다음 프로세스에게 넘기고 자신은 IO 작업이 완료될 때까지 대기하는 상태이다.
  중지 상태는 외부 요인 때문에 프로세스가 작업을 진행할 수 없는 상태이다. 대표적으로 중기 스케줄러가 스왑 아웃한 프로세스가 중지 상태이다.
  완료는 프로세스가 작업을 완수했으나 아직 프로세스와 관련된 자료구업가 아직 해제가 안된 상황이다.
</details>

<details>
  <summary>문맥 교환에 대해 설명해보세요</summary>
  타이머 인터럽트나 IO 작업 발생으로 인해 실행 중인 프로세스가 다음 프로세스에게 CPU 자원을 넘겨줄 때 이전 프로세스가 실행되던 문맥을 저장하고, 다음 프로세스가 실행할 수 있는 문맥으로 바꾸는 행동을 문맥 교환이라고 한다.
</details>

<details>
  <summary>입출력을 진행하는 중이라 봉쇄된 프로세스 A와 지금 진행 중인 프로세스 B가 있다. 이때 디스크 컨트롤러가 인터럽트 라인을 설정하여 CPU가 이를 확인하고 인터럽트 처리 루틴을 실행하는 상황이라면 어떤 프로세스가 진행 중이라고 할 수 있을까?</summary>
  이런 경우 아직 B 프로세스가 실행 중이라고 하며, 이때 B 프로세스가 커널 모드로 실행 중이라고 표현한다.
</details>

<details>
  <summary>문맥 교환에는 어떤 일이 벌어지는지 설명해보세요</summary>
  이전에 실행되던 프로세스의 문맥을 PCB에 저장하고 다음 실행될 프로세스의 PCB를 통해 문맥을 하드웨어에 세팅한다.
</details>

<details>
  <summary>문맥 교환과 실행 모드 변경되는 상황의 차이를 설명해보세요</summary>
  문맥 교환은 하드웨어 등 프로세스가 실행되는 문맥을 모두 바꾸는 것이지만, 실행 모드 변경은 여전히 같은 프로세스가 진행되고 있기 때문에 모든 문맥을 바꾸지 않고 PCB에 프로세스 명령어의 복귀 지점만 저장해놓는다.
</details>

<details>
  <summary>운영체제가 하드웨어와 소프트웨어를 관리하기 위한 큐를 커널의 메모리 구조 중 어떤 곳에서 관리할까요?</summary>
  커널의 데이터 영역에서 하드웨어와 소프트웨어를 관리하는 자료구조를 관리한다.
</details>

<details>
  <summary>공유 데이터를 접근한 프로세스가 봉쇄 상태라면 다른 프로세스가 공유 데이터에 접근 할 수 있나요?</summary>
  접근할 수 없다. 봉쇄 상태이더라도 공유 데이터 사용을 반납한 게 아니다. 프로세스가 공유 데이터 사용을 아직 반납하지 않은 상태에서 다른 프로세스가 이를 접근해서 수정하게 되면 데이터 일관성이 깨져서 기존에 사용하던 프로세스가 예상하지 못한 문제를 일으킬 수 있다.
</details>

<details>
  <summary>커널에서 프로세스 관리하는 큐의 종류에는 어떤 것이 있나요?</summary>
  준비 상태인 프로세스를 줄 세운 준비큐,
  입출력 장치 접근 권한을 줄세운 장치큐,
  현재 모든 프로세스를 줄세운 작업큐
</details>

<details>
  <summary>단기, 중기, 장기 스케줄러에 대해 설명해보세요</summary>
  단기 스케줄러는 준비큐의 프로세스 중 어떤 프로세스를 실행할 지 고른다.
  중기 스케줄러는 메모리에 올라간 프로세스가 너무 많아 프로세스 실행이 효율적이지 않을 때 어떤 프로세스를 스왑 아웃할지 고른다. 일반적으로 봉쇄 상태에 있는 프로세스나 준비 상태에 있는 프로세스가 그 대상이 된다.
  장기 스케줄러는 시작 상태인 프로세스 중 어떤 프로세스를 준비 상태로 할 지 고른다. 최근에는 메모리 용량이 넉넉해서 장기 스케줄러가 큰 의미가 없어졌다. 
</details>

<details>
  <summary>부모와 자식 프로세스가 수행되는 모델 두 가지를 설명해보세요.</summary>
  부모와 자식이 서로 동등한 입장으로 CPU 자원을 경쟁하는 경우가 있고, 자식 프로세스가 완료 될 때까지 부모 프로세스는 봉쇄 상태가 되는 경우가 있다.
</details>

<details>
  <summary>프로세스 간 협력 메커니즘인 IPC의 대표적인 방법 두가지를 설명해보세요.</summary>
  공유 메모리 방식은 두 프로세스가 물리적으로 같은 메모리 공간을 참조하는 주소값을 같이 사용하는 방식이다.
  메시지 전달 방식은 두 프로세스가 직간접적으로 연결해서 데이터 전달을 커널에게 의뢰하는 방식이다.
</details>

<h1 id="6장"><a href="#6장" class="headerlink" title="6장"></a>6장</h1><details>
  <summary>기계어 명령를 세가지로 분류하고 각 명령의 특징을 설명해보자.</summary>
  CPU 명령어 : CPU 내부에서 레지스터 값을 제어하는 매우 빠른 명령
  메모리 명령어 : 메모리에 값을 읽거나 쓰는 명령어 CPU 명령어보다는 느리지만 빠른 편이다.
  입출력 명령어 : 하드웨어를 통해 입출력을 하는 명령어. 굉장히 느리다.
</details>

<details>
  <summary>CPU 스케줄링 기법이 필요한 이유는 무엇인가?</summary>
  한정된 CPU 자원을 CPU 버스트가 각기 다른 프로세스들에게 효과적으로 분배하기 위해서 CPU 스케줄링이 필요하다.
</details>

<details>
  <summary>CPU 스케줄러는 어떤 일을 하는가?</summary>
  준비 큐에 있는 프로세스 중 CPU를 할당받고 실행될 프로세스를 선정한다.
</details>

<details>
  <summary>CPU 스케줄러가 작동하는 여러 상황을 설명해보자.</summary>
  타이머 인터럽트가 발생해서 실행 -> 준비 되는 경우
  IO 요청에 의해 실행 -> 봉쇄 되는 경우
  CPU 작업 완료되어 실행 -> 종료 되는 경우
</details>

<details>
  <summary>선점형과 비선점형 CPU 스케줄러를 구분지어 설명해보자.</summary>
  선점형 스케줄러는 특정 프로세스가 실행 중일 때 실행 중인 프로세스보다 우선순위가 더 높은 프로세스가 준비큐에 진입하면 그 프로세스에게 CPU 자원을 넘기는 방식이다.
  비선점형 스케줄러는 그런 경우에도 뺏기지 않는다.
</details>

<details>
  <summary>디스패처에 대해 설명해보자.</summary>
  문맥교환이 일어날 때 PCB의 값을 하드웨어에 세팅해야 하는 일을 하는 운영체제 코드이다.
</details>

<details>
  <summary>스케줄링 성능 평가에 사용되는 다섯 가지 지표를 설명해보자.</summary>
  CPU 이용률 : 주어진 시간동안 CPU가 작업을 처리한 시간 비율
  처리량 : 주어진 시간동안 작업 완료한 프로세스 비율
  소요 시간 : 한 프로세스가 CPU를 기다린 시간과 CPU 할당 받아 실행한 시간의 합
  대기 시간 : 한 프로세스가 CPU 버스트동안 준비큐에서 기다린 시간
  응답 시간 : 한 프로세스가 준비큐에 들어가서 처음 CPU를 할당받은 시간.
</details>

<details>
  <summary>선입선출 스케줄링의 장단점은?</summary>
  먼저 온 프로세스를 완료할 때까지 CPU 자원 점유를 보장해주니 평균 소요시간과 평균 대기시간이 짧은 편이다. 하지만 CPU 버스트가 긴 프로세스가 점유하면 다른 프로세스들이 오랫동안 CPU를 점유하지 못하게 되는 콘보이 현상을 겪을 수 있다.
</details>

<details>
  <summary>최단 작업 우선 스케줄링의 장단점은?</summary>
  CPU 버스트가 짧은 프로세스를 먼저 할당해서 IO 자원을 비교적 효율적으로 활용할 수 있고 선입선출 스케줄러의 콘보이 현상도 방지한다. 
  다만 준비큐에 CPU 버스트가 긴 프로세스가 있을 때 준비큐로 CPU 버스트가 짧은 프로세스가 계속 진입하면 CPU 버스트가 긴 프로세스는 CPU 자원을 점유하지 못하게 되는 기아 현상이 발생할 수 있다.
</details>

<details>
  <summary>우선순위 스케줄링의 장단점은?</summary>
  우선순위 스케줄링도 기아 현상이 발생할 수 있다. 하지만 CPU 할당을 받지 못한 준비 상태의 프로세스들의 우선순위를 동적으로 한단계 올려주는 노화 기법으로 기아 현상을 해결할 수 있다.
</details>

<details>
  <summary>라운드 로빈 스케줄링에서 할당시간을 너무 길게 혹은 너무 짧게 설정하면 생기는 일에 대해 설명해보자.</summary>
  라운드 로빈 스케줄링 할당 시간을 너무 늘리면 사실상 선입선출 스케줄링과 같아진다. 그래서 선입선출 스케줄링의 단점을 그대로 가져오게 된다.
  할당 시간을 너무 짧게 하면 문맥 교환이 그만큼 더 자주 일어나게 되서 오버헤드가 커진다.
</details>

<details>
  <summary>선입선출 스케줄링에 비해 라운드 로빈 스케줄링의 장단점은?</summary>
  라운드 로빈 스케줄링은 선입 선출에 비해 평해 소요시간이 길다는 단점이 있다. 하지만 평균 응답시간이 빠르다는 장점이 있다.
</details>

<details>
  <summary>멀티레벨 큐에 대해 설명해보자.</summary>
  각 프로세스의 특징에 따라 여러 형태의 스케줄링 큐를 운영하는 방식이다. 응답을 빨리 해야되는 프로세스를 할당하는 라운드 로빈 전위 큐와 CPU 버스트가 긴 프로세스를 할당하는 선입 선출 후위 큐를 운영하는 방식으로 구현될 수 있다.
</details>

<details>
  <summary>멀티레벨 피드백 큐에 대해 설명해보자.</summary>
  우선 순위가 다른 여러 큐를 운영하되, 프로세스가 각 큐를 이동할 수 있는 방식이다. 우선순위가 높은 큐에서 할당 받지 못하면 낮은 큐로 이동하는 방식인데, 이때 해당 프로세스의 우선순위를 높이는 노화 방식을 도입할 수 있다.
</details>

<details>
  <summary>스케줄링 알고리즘 평가 방법에 대해 설명해보자.</summary>
  큐잉 모델, 시뮬레이션, 구현 및 실축
</details>

<h1 id="7장"><a href="#7장" class="headerlink" title="7장"></a>7장</h1><details>
  <summary>컴퓨터 시스템의 주소 체계의 32비트, 64비트는 어떤 의미인가?</summary>
  주소 체계는 컴퓨터가 해당 비트만큼 서로 다른 메모리를 구분할 수 있다는 의미이다. 32비트 주소 체계는 2^32가지의 주소를 부여할 수 있다. 컴퓨터는 각 주소마다 1바이트를 부여하므로 32비트 주소 체계는 2^32 바이트 만큼의 주소 공간을 가진다.
</details>

<details>
  <summary>프로세스의 논리적 주소는 무엇인가?</summary>
  프로세스마다 주어지는 독립된 논리적인 주소 공간을 의미한다.  
</details>

<details>
  <summary>주소 바인딩이란 무엇인가</summary>
  각 프로세스의 독립된 논리적인 주소를 실제 물리적인 메모리 주소로 변환하는 과정을 말한다.  
</details>

<details>
  <summary>실행시간 바인딩에 대해 설명해보자.</summary>
  프로세스의 논리적 주소에 매핑된 물리적 주소를 실행시간에서 바뀔 수 있는 바인딩 방법이다. 이 경우 물리적인 주소에 접근할 때마다 실제로 매핑되어 있는지 확인해야 한다. 이때 사용되는 것이 주소 매핑 테이블, 기준 레지스터, 한계 레지스터, MMU이다.  
</details>

<details>
  <summary>MMU 기법에 대해 설명해보자.</summary>
  MMU(메모리 관리 유닛) 기법은 논리적 주소에 기준 레지스터를 더해서 물리적 주소를 찾아내는 기법이다. 이 기법은 기본적으로 프로세스의 물리적 주소 매핑이 연속되어 있다는 점을 전제로 한다. 각 프로세스마다 기준 레지스터가 달라지기 때문에 MMU는 문맥교환마다 새롭게 세팅되어야 한다.
</details>

<details>
  <summary>동적 로딩과 동적 연결에 대해 설명해보자.</summary>
  동적 로딩은 프로세스의 모든 내용을 메모리에 적재하는 것이 아닌 필요한 내용만 적재하는 것을 의미한다. 필요하지 않은 내용은 스왑 영역에 두었다가 호출 시 메모리에 할당하는 방식으로 운영한다. 동적 연결은 여러 프로세스가 사용하는 라이브러리 파일을 하나만 메모리에 적재하고 여러 프로세스가 해당 파일을 공유해서 사용하도록 하는 기법이다.  
</details>

<details>
  <summary>중첩과 동적로딩의 차이를 설명해보자.</summary>
  중첩은 메모리가 부족한 상태에서 큰 메모리 용량을 차지하는 프로세스를 당장 필요한 부분만 메모리에 적재하는 기술이다. 동적 로딩은 동시에 여러 프로세스를 메모리에 적재하기 위해 각 프로세스마다 필요한 부분을 적재하는 방식인 반면 중첩은 부족한 메모리에서 큰 프로세스를 나눠서 실행하기 위한 방법이다.
</details>

<details>
  <summary>연속할당 방식의 두가지 할당 방식에 대해 설명해보고 장단점을 설명해보자.</summary>
  연속할당 방식은 고정 분할 방식과 가변 분할 방식이 있다. 고정 분할 방식은 메모리를 정해진 크기 만큼 균등하게 나눠서 각 조각 마다 프로세스를 할당하는 방식이다. 이 경우 프로세스가 할당되고 남은 부분인 내부 조각이 발생할 수 있다. 또한 각 조각대로 분할하고 남은 외부조각이 남을 수도 있다. 가변 분할 방식은 분할의 형태가 가변적으로 변하는 형태다. 이때 프로세스를 여러 공간 중 어디에 할당해야할 지 결정해야 하는 문제가 생길 수 있고, 가변 분할 방식도 외부조각 문제가 발생할 수 있다.  
</details>

<details>
  <summary>불연속할당 방식에서 페이징 기법에 대해서 설명해보자.</summary>
  페이징 기법은 프로세스 메모리를 일정한 크기의 페이지로 균등하게 나눠서 물리적인 메모리를 균등하게 나눈 프레임에 불연속되게 할당하는 방식이다. 페이징 기법은 프로세스가 자신의 페이지가 어떤 프레임에 할당됐는 지 찾아 갈 수 있도록 페이지 테이블을 가진다.
</details>

<details>
  <summary>페이징 기법의 성능에서 문제와 해결 방법을 제시해라.</summary>
  페이징 기법은 프로세스의 페이지가 실제 물리적인 주소를 찾아야 한다. 이 과정에서 페이지 테이블을 순회하면서 자신의 물리적인 주소를 찾게 되므로 오버헤드를 갖게 된다. 이를 해결하기 위해 TLB라는 캐시를 활용한다. TLB는 병렬로 엔트리를 순회해서 더 빠르게 매핑된 물리 주소를 얻을 수 있다. 다만 TLB는 문맥교환 때 지워진다.
</details>

<details>
  <summary>불연속할당 방식에서 세그먼테이션 기법에 대해서 설명해보자.</summary>
  세그멘테이션 기법은 균등하게 프로세스 메모리를 나눠서 할당하는 것이 아닌 의미에 따라서 분할 하여 할당하는 방식이다. 크기가 가변적이라 외부조각 문제가 생길 수 있는데, 이를 방지하기 위한 페이지드 세그먼테이션 기법이 있다. 먼저 의미 기준으로 메모리를 나누고 나뉜 메모리들을 균등한 페이지로 다시 나눠서 불연속되게 프레임에 할당하는 방식이다. 이 경우 1차로 세그먼트 테이블, 2차로 페이지 테이블을 통해 물리적인 주소를 찾는다.  
</details>


        </div>
        <footer class="article-footer">
            



    <a data-url="https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/" data-id="cldwpodx8004fzfa00zir6rhz" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "yangdongjue5510"
        },
        "headline": "퀴즈로 학습하는 운영체제와 정보기술의 원리",
        "image": "https://yangdongjue5510.github.io",
        "keywords": "운영체제와 정보기술의 원리",
        "genre": "Computer Science OS",
        "datePublished": "2023-01-22",
        "dateCreated": "2023-01-22",
        "dateModified": "2023-02-27",
        "url": "https://yangdongjue5510.github.io/2023/01/22/cs/os/퀴즈로_학습하는_운영체제와_정보기술의_원리/",
        "description": "3장
  메모리 및 입출력 장치를 제어하는 하드웨어 장치는 무엇인가?
  컨트롤러라는 하드웨어 장치가 메모리 및 입출력 장치를 제어한다. 마치 입출력 장치마다 작은 CPU가 있다고 생각하면 편하다.




  운영체제 코드 중 메모리에 올려지는 중요한 코드는 무엇이라고 하는가
운영체제의 모든 코드를 메모리에 올리면 자원 낭비가 생긴다. 운영체제 중 주요 코",
        "wordCount": 2956
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/yangdongjue5510" target="_blank" rel="external nofollow noopener noreferrer">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2023/01/26/kotlinInAction/kotlinInActionCh7/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            연산자 오버로딩과 기타 관례
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2023/01/20/package/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">패키지 설계의 원칙</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/">Computer Science</a><span class="category-list-count">75</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/algorithm/">Algorithm</a><span class="category-list-count">29</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/algorithm/problem-solving/">Problem Solving</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/algorithm/theory/">Theory</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/computer-structure/">Computer Structure</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/data-structure/">Data Structure</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/database/">Database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/infra/">Infra</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/network/">Network</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/os/">OS</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/infra/">Infra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jpa/">JPA</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a><span class="category-list-count">60</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/design-pattern/">Design Pattern</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/java-basic/">Java Basic</a><span class="category-list-count">22</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">Spring</a><span class="category-list-count">44</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spring/boot/">Boot</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/project/">Project</a><span class="category-list-count">23</span></li></ul></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/clean-code/" style="font-size: 11.43px;">Clean Code</a> <a href="/tags/clean-software/" style="font-size: 10px;">Clean Software</a> <a href="/tags/effective-java/" style="font-size: 15.71px;">Effective Java</a> <a href="/tags/kotlin-in-action/" style="font-size: 18.57px;">Kotlin in Action</a> <a href="/tags/modern-java-in-action/" style="font-size: 17.14px;">Modern Java in Action</a> <a href="/tags/software-engineering-at-google/" style="font-size: 10px;">Software Engineering At Google</a> <a href="/tags/greedy/" style="font-size: 10px;">greedy</a> <a href="/tags/reshapi-project/" style="font-size: 10px;">reshapi project</a> <a href="/tags/sable-project/" style="font-size: 10px;">sable project</a> <a href="/tags/troubleshooting/" style="font-size: 12.86px;">troubleShooting</a> <a href="/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/" style="font-size: 14.29px;">오브젝트</a> <a href="/tags/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4/" style="font-size: 20px;">우아한테크코스</a> <a href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9B%90%EB%A6%AC/" style="font-size: 10px;">운영체제와 정보기술의 원리</a> <a href="/tags/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/" style="font-size: 10px;">자바 ORM 표준 JPA 프로그래밍</a> <a href="/tags/%ED%9A%8C%EA%B3%A0/" style="font-size: 10px;">회고</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2023 yangdongjue5510</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank" rel="external nofollow noopener noreferrer">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://yangdongjue5510.github.io/2023/01/22/cs/os/%ED%80%B4%EC%A6%88%EB%A1%9C_%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80_%EC%A0%95%EB%B3%B4%EA%B8%B0%EC%88%A0%EC%9D%98_%EC%9B%90%EB%A6%AC/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
